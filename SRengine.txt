// StressEngine.cpp: implementation of the CStressEngine class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "wg_gps.h"
#include "StressEngine.h"

#include "..\wg_db\DBDoc.h"
#include "..\wg_db\UnitCtrl.h"
#include "..\wg_base\CompFunc.h"

#include "DeformEngine.h"
#include "BDEngine.h"
#include "I_GPSModel.h"
#include "GPSDisplayFilter.h"
#include "GPSPostCtrl.h"
#include "GPSInflGridBase.h"
//XGLRenderer
#include "Func_GPS_Draw.h"
#include "GPostTextOut.h"


#include "..\wg_db\wg_db_AttrCtrl.h"
#include "..\wg_db\wg_db_AttrCtrl2.h"
#include "..\wg_db\wg_db_PostCtrl.h"
#include "..\wg_db\wg_db_StagCtrl.h"
#include "..\wg_db\wg_db_MathFunc.h"
#include "..\wg_db\wg_db_DBLib.h"
#include "..\wg_db\wg_db_CscsInfo.h"
#include "..\wg_db\wg_db_SectUtil.h"
#include "..\wg_db\wg_db_SectDB.h"
#include "..\wg_db\wg_db_ViewCtrl.h"
#include "..\wg_db\IsolatorTool.h"

#ifdef _TOWER
#include "..\wg_db\wg_db_TowerInfo.h"
#endif

#include <float.h>
#include "GPSElemData.h" // Export GPS Data for VTK Test

#include "..\wg_base\wg_base_GTF.h"
#include "..\wg_base\TestEnvMgr.h"

// PMS:3978-CJJEONG-20090430 (Tel : 2124) 
#include "..\wg_db\wg_db_FlagCtrl.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

#define UCS_XY 100000
#define UCS_XZ 100001
#define UCS_YZ 100002

#define DECLARE_GPSMD()  I_GPSModel *gm=(I_GPSModel *)m_pGPSModel
#define DECLARE_DBDOC()  CDBDoc		  *pDoc=((I_GPSModel *)m_pGPSModel)->GetDBDoc()
#define DECLARE_DPTDR()  T_GPS_DISP_OPT_DR *pDR = &(gm->m_DOPT.DR) 
#define DECLARE_DPTRD()  T_GPS_DISP_OPT_RD *pRD = &(gm->m_DOPT.RD)
#define DECLARE_DPTCL()  T_GPS_DISP_OPT_CL *pCL = &(gm->m_DOPT.CL)
#define DECLARE_DPTTX()  T_GPS_DISP_OPT_TX *pTX = &(gm->m_DOPT.TX)

#define GPHS_MAX 7

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CStressEngine::CStressEngine(I_GPSModelBase *pGM)
{
	CEngineBase::CEngineBase();

	m_pGPSModel					= pGM;

	m_mapTStrsData.InitHashTable(HASHSIZEELEM);
	m_mapBStrsData.InitHashTable(HASHSIZEELEM);
	m_mapBVmstData.InitHashTable(HASHSIZEELEM);
	m_mapPlateStrsData.InitHashTable(HASHSIZEELEM);
	m_mapPnStrsData.InitHashTable(HASHSIZEELEM);
	m_mapAxStrsData.InitHashTable(HASHSIZEELEM);
	m_mapPlStrnData.InitHashTable(HASHSIZEELEM);
	m_mapSlStrnData.InitHashTable(HASHSIZEELEM);

	m_mapFreeEdgebyElemKey.InitHashTable(HASHSIZEELEM);
	m_mapFreeFacebyElemKey.InitHashTable(HASHSIZEELEM);
	m_mapSolidStrsData.InitHashTable(HASHSIZEELEM);
	m_mapSFDBMDMax.InitHashTable(HASHSIZEELEM);

//   m_mapLRsultMax_Prn.InitHashTable(HASHSIZEELEM);
//   m_mapLRsultMin_Prn.InitHashTable(HASHSIZEELEM);
// 
//   m_mapURsultMax_Prn.InitHashTable(HASHSIZEELEM);
//   m_mapURsultMin_Prn.InitHashTable(HASHSIZEELEM);
// 
//   m_mapURsultMax_NotPrn.InitHashTable(HASHSIZEELEM);
//   m_mapURsultMin_NotPrn.InitHashTable(HASHSIZEELEM);
// 
//   m_mapLRsultMax_Avg.InitHashTable(HASHSIZEELEM);
//   m_mapLRsultMin_Avg.InitHashTable(HASHSIZEELEM);
//   
//   m_mapURsultMax_Avg.InitHashTable(HASHSIZEELEM);
//   m_mapURsultMin_Avg.InitHashTable(HASHSIZEELEM);

	ResetEngine();

	// MNET:XXXX-CJJEONG-20080422
	m_bVectorPositive = m_bVectorNegative = TRUE;
	//m_nPrdMoving=CProduct::GetMovingType(); 
	m_bInitEngine_All_First = FALSE;
}

CStressEngine::~CStressEngine()
{
	m_BeamKeyList.RemoveAll();
	m_TrussKeyList.RemoveAll();
	m_PlateKeyList.RemoveAll();
	m_SolidKeyList.RemoveAll();
		
	RemoveFreeEdgeData();
	RemoveFreeFaceData();

	

}

// 다른 엔진으로부터 데이터를 Import
void CStressEngine::ImportEngine(CEngineBase* egbase)
{
		if(!egbase)return;

		CEngineBase::ImportEngine(egbase);

		CStressEngine* eg = (CStressEngine*)egbase;

	m_bDeformedShapeContour	= eg->m_bDeformedShapeContour;
	m_MaxAbsValue			      = eg->m_MaxAbsValue;
	m_InflScFc              = eg->m_InflScFc; 
	m_VectorScaleFactor			= eg->m_VectorScaleFactor;
	m_VectorAdjustFactor		= eg->m_VectorAdjustFactor;
	m_bContour							= eg->m_bContour;  
	m_bAverageNodalActiveOnly = eg->m_bAverageNodalActiveOnly;

	m_bLockAdjFactor				= eg->m_bLockAdjFactor;
	
	m_dMaxValue             = eg->m_dMaxValue;
	m_dMinValue             = eg->m_dMinValue;


	m_bTStrsDataSet				= eg->m_bTStrsDataSet;
	m_TStrsComponent			= eg->m_TStrsComponent;
	m_TStrsOutputSection		= eg->m_TStrsOutputSection;

	m_TrussKeyList.RemoveAll();
	m_TrussKeyList.Copy(eg->m_TrussKeyList);
	m_mapTStrsData.RemoveAll();
	T_ELEM_K key; T_STRT_D strt_d;
	POSITION pos =eg->m_mapTStrsData.GetStartPosition();
	while(pos)
	{
		eg->m_mapTStrsData.GetNextAssoc(pos,key,strt_d);
		m_mapTStrsData.SetAt(key,strt_d);
	}

	m_bBStrsDataSet				= eg->m_bBStrsDataSet;
	m_KeyMaxBStrsElem			= eg->m_KeyMaxBStrsElem;
	m_BStrsPart           = eg->m_BStrsPart;
	m_BStrsComponent			= eg->m_BStrsComponent;
	m_BStrsComponentSub   = eg->m_BStrsComponentSub;
	m_BStrsComponentSub2  = eg->m_BStrsComponentSub2;
	m_BStrsOutputSection	= eg->m_BStrsOutputSection;
	m_BStrsComponentType	= eg->m_BStrsComponentType;
	m_BStrsComp7thDof     = eg->m_BStrsComp7thDof;
	m_bBStrsOutputMax			= eg->m_bBStrsOutputMax;
	m_bBStrsOutputAll			= eg->m_bBStrsOutputAll;
	m_bBStrsOutputI				= eg->m_bBStrsOutputI;
	m_bBStrsOutputC				= eg->m_bBStrsOutputC;
	m_bBStrsOutputJ				= eg->m_bBStrsOutputJ;
	m_bBStrsOutputMinMax  = eg->m_bBStrsOutputMinMax ;
	m_nBForcPscPart       = eg->m_nBForcPscPart;

	m_BSfdBmdAdjustFactor	= eg->m_BSfdBmdAdjustFactor;
	m_BSfdBmdScFactor			= eg->m_BSfdBmdScFactor;
	m_bBSfdBmdLineOnly	  = eg->m_bBSfdBmdLineOnly;
	m_bVerticalLineFill   = eg->m_bVerticalLineFill;
	m_bMaxMinDgrm         = eg->m_bMaxMinDgrm;

	m_BeamKeyList.RemoveAll();
	m_BeamKeyList.Copy(eg->m_BeamKeyList);
	m_mapBStrsData.RemoveAll();
	T_STRB_D strb_d;
	pos =eg->m_mapBStrsData.GetStartPosition();
	while(pos)
	{
		eg->m_mapBStrsData.GetNextAssoc(pos,key,strb_d);
		m_mapBStrsData.SetAt(key,strb_d);
	}

	m_mapBStrsDataMin.RemoveAll(); 
	pos =eg->m_mapBStrsDataMin.GetStartPosition();
	while(pos)
	{
		eg->m_mapBStrsDataMin.GetNextAssoc(pos,key,strb_d);
		m_mapBStrsDataMin.SetAt(key,strb_d);
	}

	T_VMST_D VmstD;
	pos =eg->m_mapBVmstData.GetStartPosition();
	while(pos)
	{
		eg->m_mapBVmstData.GetNextAssoc(pos,key,VmstD);
		m_mapBVmstData.SetAt(key,VmstD);
	}

	T_STSS_D StssD;
	m_mapBStssData.RemoveAll();   
	pos =eg->m_mapBStssData.GetStartPosition();
	while(pos)
	{
		eg->m_mapBStssData.GetNextAssoc(pos,key,StssD);
		m_mapBStssData.SetAt(key,StssD);
	}

	m_mapBStssDataMin.RemoveAll();   
	pos =eg->m_mapBStssDataMin.GetStartPosition();
	while(pos)
	{
		eg->m_mapBStssDataMin.GetNextAssoc(pos,key,StssD);
		m_mapBStssDataMin.SetAt(key,StssD);
	}

	T_NLNK_K NlnkK;
	double dValue;
	m_mapIsoStrsData.RemoveAll();
	pos = eg->m_mapIsoStrsData.GetStartPosition();
	while (pos)
	{
		eg->m_mapIsoStrsData.GetNextAssoc(pos, NlnkK, dValue);
		m_mapIsoStrsData.SetAt(NlnkK, dValue);
	}

	m_bPStrsDataSet				= eg->m_bPStrsDataSet;
	m_KeyMaxPStrsElem			= eg->m_KeyMaxPStrsElem;
	m_PStrsVal					= eg->m_PStrsVal;
	m_PStrsSurface				= eg->m_PStrsSurface;
	m_PStrsAve					= eg->m_PStrsAve;
	m_PStrsComponent			= eg->m_PStrsComponent;
	
	m_mapPlateStrsData.RemoveAll();
	T_STRP_DG strp_d;
	pos =eg->m_mapPlateStrsData.GetStartPosition();
	while(pos)
	{
		eg->m_mapPlateStrsData.GetNextAssoc(pos,key,strp_d);
		m_mapPlateStrsData.SetAt(key,strp_d);
	}
	
	T_NODE_K node_k,serial_k;
	pos =eg->m_mapSerialNode.GetStartPosition();
	while(pos)
	{
		eg->m_mapSerialNode.GetNextAssoc(pos,node_k,serial_k);
		m_mapSerialNode.SetAt(node_k,serial_k);
	}	

	m_bPnStrsDataSet		= eg->m_bPnStrsDataSet;
	m_KeyMaxPnStrsElem	= eg->m_KeyMaxPnStrsElem;
	m_PnStrsVal					= eg->m_PnStrsVal;
	m_PnStrsAve					= eg->m_PnStrsAve;
	m_PnStrsComponent		= eg->m_PnStrsComponent;
	m_NUCS              = eg->m_NUCS;
	m_bPrintUCSAxis     = eg->m_bPrintUCSAxis;

	m_PnKeyList.RemoveAll();
	m_PnKeyList.Copy(eg->m_PnKeyList);
	m_mapPnStrsData.RemoveAll();
	T_STPN_D stpn_d;
	pos =eg->m_mapPnStrsData.GetStartPosition();
	while(pos)
	{
		eg->m_mapPnStrsData.GetNextAssoc(pos,key,stpn_d);
		m_mapPnStrsData.SetAt(key,stpn_d);
	}

	m_bAxStrsDataSet			= eg->m_bAxStrsDataSet;
	m_KeyMaxAxStrsElem			= eg->m_KeyMaxAxStrsElem;
	m_AxStrsVal					= eg->m_AxStrsVal;
	m_AxStrsAve					= eg->m_AxStrsAve;
	m_AxStrsComponent			= eg->m_AxStrsComponent;

	m_AxKeyList.RemoveAll();
	m_AxKeyList.Copy(eg->m_AxKeyList);
	m_mapAxStrsData.RemoveAll();
	T_STAX_D stax_d;
	pos =eg->m_mapAxStrsData.GetStartPosition();
	while(pos)
	{
		eg->m_mapAxStrsData.GetNextAssoc(pos,key,stax_d);
		m_mapAxStrsData.SetAt(key,stax_d);
	}

	m_bSStrsDataSet				= eg->m_bSStrsDataSet;
	m_KeyMaxSStrsElem			= eg->m_KeyMaxSStrsElem;
	m_SStrsVal					= eg->m_SStrsVal;
	m_SStrsAve					= eg->m_SStrsAve;
	m_SStrsComponent			= eg->m_SStrsComponent;
	m_bOnCuttingPlane			= eg->m_bOnCuttingPlane;
		
	if(eg->m_bIsFreeEdgeDataSet) // temporary
	{
		RemoveFreeEdgeData();
		MakeFreeEdgeData();
	}
	else
		RemoveFreeEdgeData();
	if(eg->m_bIsFreeFaceDataSet) // temporary
	{
		RemoveFreeFaceData();
		MakeFreeFaceData();
	}
	else
		RemoveFreeFaceData();
		
	m_bIsoSurface = eg->m_bIsoSurface;
	m_SStrsPart = eg->m_SStrsPart;
	
	

	m_SolidKeyList.RemoveAll();
	m_SolidKeyList.Copy(eg->m_SolidKeyList);
	
	m_mapSolidStrsData.RemoveAll();
	T_STRS_D sstrs_d;
	pos =eg->m_mapSolidStrsData.GetStartPosition();
	while(pos)
	{
		eg->m_mapSolidStrsData.GetNextAssoc(pos,key,sstrs_d);
		m_mapSolidStrsData.SetAt(key,sstrs_d);
	}

	m_bPlstrnDataSet		= eg->m_bPlstrnDataSet;
	m_KeyMaxPlstrnElem	= eg->m_KeyMaxPlstrnElem;
	m_PlstrnVal					= eg->m_PlstrnVal;
	m_PlstrnAve					= eg->m_PlstrnAve;
	m_PlstrnComponent		= eg->m_PlstrnComponent;
	m_PlstrnSurface			= eg->m_PlstrnSurface;
	m_nPlstrnValueOpt		= eg->m_nPlstrnValueOpt;
	m_PlstrnType         = eg->m_PlstrnType;

	m_PsKeyList.RemoveAll();
	m_PsKeyList.Copy(eg->m_PsKeyList);

	m_mapPlStrnData.RemoveAll();
	T_PLSTRN_OUTVAL_D PlStrnD;
	pos =eg->m_mapPlStrnData.GetStartPosition();
	while(pos)
	{
		eg->m_mapPlStrnData.GetNextAssoc(pos,key,PlStrnD);
		m_mapPlStrnData.SetAt(key,PlStrnD);
	}
	
	m_bSlstrnDataSet		= eg->m_bSlstrnDataSet;
	m_KeyMaxSlstrnElem	= eg->m_KeyMaxSlstrnElem;
	m_SlstrnVal					= eg->m_SlstrnVal;
	m_SlstrnAve					= eg->m_SlstrnAve;
	m_SlstrnComponent		= eg->m_SlstrnComponent;
	m_bOnCuttingPlane			= eg->m_bOnCuttingPlane;
	m_SlstrnType = eg->m_SlstrnType;

	m_SltlsKeyList.RemoveAll();
	m_SltlsKeyList.Copy(eg->m_SltlsKeyList);

	m_mapSlStrnData.RemoveAll();
	T_SLSTRN_OUTVAL_D SlStrnD;
	pos =eg->m_mapSlStrnData.GetStartPosition();
	while(pos)
	{
		eg->m_mapSlStrnData.GetNextAssoc(pos,key,SlStrnD);
		m_mapSlStrnData.SetAt(key,SlStrnD);
	}

	m_bImpFc = eg->m_bImpFc;
	m_BStrsAdjustFactor = eg->m_BStrsAdjustFactor;

	m_bHingeStatus = eg->m_bHingeStatus; 
	m_bHingeStatusText = eg->m_bHingeStatusText;
	m_bEnvelopeLC	= eg->m_bEnvelopeLC;
	m_Mldt = eg->m_Mldt;

	m_dThisTimeStep   = eg->m_dThisTimeStep;
	m_nThisTimeIndex  = eg->m_nThisTimeIndex;
	m_bThisFunction   = eg->m_bThisFunction;   
	m_nFunctionKey    = eg->m_nFunctionKey;

	// MNET:XXXX-CJJEONG-20080422
	m_bVectorPositive = eg->m_bVectorPositive;
	m_bVectorNegative = eg->m_bVectorNegative;

	m_IsoStrsComponent = eg->m_IsoStrsComponent;
	m_IsoStrsRltComp = eg->m_IsoStrsRltComp;
	m_IsoGBloadcaseK = eg->m_IsoGBloadcaseK;
	m_IsoGBLoadType = eg->m_IsoGBLoadType;
	m_IsoGBloadcaseK2 = eg->m_IsoGBloadcaseK2;
	m_IsoGBLoadType2 = eg->m_IsoGBLoadType2;
	m_IsoGBMaxMin = eg->m_IsoGBMaxMin;
	m_IsoGBMaxMin2 = eg->m_IsoGBMaxMin2;

}

// 데이터를 만든다.
void CStressEngine::InitEngine(CDeformEngine *pDE,int nGPSInstruction)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	if(gm->m_LoadCaseType == D_LOADCASE_PUSHOVER && !m_pDoc->m_pPostCtrl->IsPushOverResultEnable())
	{
		//AfxMessageBox(_LS(IDS_WG_GPS_PUSHOVER_RESULT_UNAVAILABLE));
		return;
	}

	m_bTStrsDataSet = FALSE;
	m_bBStrsDataSet = FALSE;
	m_bPStrsDataSet = FALSE;
	m_bPnStrsDataSet = FALSE;
	m_bAxStrsDataSet = FALSE;
	m_bSStrsDataSet = FALSE;
	RemoveFreeEdgeData();
	RemoveFreeFaceData();
//	if (((CGPSView *) gm->m_pMyView)->m_pRenderView)
//		return;

	gm->SelectLoad();
	
	int nGPSMode = (nGPSInstruction != -1)? nGPSInstruction:gm->m_GPSMode;
	switch (nGPSMode) 
	{
	case GPS_COMMAND_TSTRS:
		MakeTStrsDataList();
		break;
	case GPS_COMMAND_BSTRS:
	case GPS_COMMAND_GIRDERSTRS_DGRM:
	case GPS_COMMAND_BSTRSDGRM:
		MakeBStrsDataList();
		break;
	case GPS_COMMAND_BSTRSDETAIL:
	case GPS_COMMAND_BSTRSDETAILDGRM:
		MakeBStrsDetailDataList();
		break;
	case GPS_COMMAND_BSTRSINC:
		MakeBStssDataList(); 
		break; 
	case GPS_COMMAND_PSTRS:
		MakePStrsDataList();
		break;
	case GPS_COMMAND_PNSTRS:
		MakePnStrsDataList();
		break;
	case GPS_COMMAND_AXSTRS:
		MakeAxStrsDataList();
		break;
	case GPS_COMMAND_SSTRS:
		MakeSStrsDataList();
		break;
	case GPS_COMMAND_IFLBSTRS:
		MakeInflStrsDataList();
		break;
	case GPS_COMMAND_IFSBSTRS:
		MakeInflBStrsDataListS(pDE);
		break;
	case GPS_COMMAND_IFLSSTRS:
		MakeInflStrsDataList();
		break;
	case GPS_COMMAND_IFSSSTRS:
		MakeInflSStrsDataListS(pDE);
		break;
	case GPS_COMMAND_MVLTRCBSTRS:
		if(CDBDoc::GetDocPoint()->m_pPostCtrl->GetInflType() == D_INFLTYPE_LINE)
		{
			MakeMvlTrcStrsDataList_New2(nGPSMode);
		}
		//else MakeMvlTrcBStrsDataListS(pDE);
		break;

	case GPS_COMMAND_IFGBSTRS:
		RemoveInflGrid();
		m_pInflGrid = CGPSInflGridBase::CreateInflGrid(D_INFL_GRID_BSTRS,this);
		if(m_pInflGrid) m_pInflGrid->MakeInfl();
		else            ASSERT(0);
		break;
		
	case GPS_COMMAND_THISBSTRS:
		MakeBStrsTimeHist();
		break; 

	case GPS_COMMAND_PLATE_STRAIN:
		MakePlstrnDataList();
		break;

	case GPS_COMMAND_SOLID_STRAIN:
		MakeSlstrnDataList();
		break;
	case GPS_COMMAND_ISOLATION_STRS:
		MakeIsolationStrsDataList();
		break;
	}
	
	switch(nGPSMode) 
	{
	case GPS_COMMAND_IFLBSTRS:
	case GPS_COMMAND_IFSBSTRS:
	case GPS_COMMAND_MVLTRCBSTRS:
	case GPS_COMMAND_IFLSSTRS:
	case GPS_COMMAND_IFSSSTRS:
	case GPS_COMMAND_IFGBSTRS:
		gm->m_nLgdMaxValKey=0;
		gm->m_nLgdMinValKey=0;
		break;
	}
}

void CStressEngine::InitEngine_All_First()
{
		m_SerialList.RemoveAll();
		m_pDoc->m_pPostCtrl->GetLaneInfo(m_arLaneInfoNew);

		int nNumOfLane = m_arLaneInfoNew.GetSize();
		int nLaneIdx;
		for(int i=0; i<nNumOfLane; i++)
		{
				nLaneIdx = i;
				//nLaneIdx = m_pDoc->m_pPostCtrl->GetSerialLlan(KeyList[i])-1;

				// 해석용 dummy sub lane 제외.      
				if(m_pDoc->m_pPostCtrl->IsDummyLaneForSolver_bySerial(nLaneIdx+1))  continue;
				if(m_pDoc->m_pPostCtrl->IsDummyLaneForSolver_bySerial_op(nLaneIdx+1))   continue;
				m_SerialList.Add(nLaneIdx); 
		}

		DECLARE_GPSMD();
		gm->m_bLoadDataExist = TRUE;

		m_bInitEngine_All_First = TRUE;
}

void CStressEngine::InitEngine_AllForOneElem(CDeformEngine *pDE,int nGPSInstruction)
{
		if (!m_bInitEngine_All_First)
		{
				InitEngine_All_First();
		}

		I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

		if(gm->m_LoadCaseType == D_LOADCASE_PUSHOVER && !m_pDoc->m_pPostCtrl->IsPushOverResultEnable())
		{
				//AfxMessageBox(_LS(IDS_WG_GPS_PUSHOVER_RESULT_UNAVAILABLE));
				return;
		}

		m_bTStrsDataSet = FALSE;
		m_bBStrsDataSet = FALSE;
		m_bPStrsDataSet = FALSE;
		m_bPnStrsDataSet = FALSE;
		m_bAxStrsDataSet = FALSE;
		m_bSStrsDataSet = FALSE;
		RemoveFreeEdgeData();
		RemoveFreeFaceData();

		gm->SelectLoad();

		int nGPSMode = (nGPSInstruction != -1)? nGPSInstruction:gm->m_GPSMode;
		switch (nGPSMode) 
		{
		case GPS_COMMAND_IFLBSTRS:
		case GPS_COMMAND_IFLSSTRS:
				MakeInflStrsDataList_AllForOneElem();
				break;
		case GPS_COMMAND_IFSBSTRS:
				MakeInflBStrsDataListS_AllForOneElem(pDE);
				break;
		case GPS_COMMAND_IFSSSTRS:
				MakeInflSStrsDataListS_AllForOneElem(pDE);
				break;
		default:
				break; 
}

}

////////////////////////////////////////////////////////////////////////////////////////
// Initialization and Utility Routines for Truss Member Stress        /////////////////
////////////////////////////////////////////////////////////////////////////////////////

// 주어진 노드에서의 Truss Stress 값을 구함
double CStressEngine::CalcTStrsValue(T_STRT_D &tstrs_d, int node)
{
	double	ret;

	if (node == I_NODE) {
		ret = tstrs_d.dblStress[0];
	}
	else {
		ret = tstrs_d.dblStress[1];
	}

	return ret;
}

// i/j 노드의 Truss Stress 값 중 큰 것을 구함.
double CStressEngine::GetMaxElemTStrs(T_STRT_D &tstrs_d)
{
	double		max=-DBL_MAX;

	if (tstrs_d.dblStress[0]>tstrs_d.dblStress[1])
		max = tstrs_d.dblStress[0];
	else
		max = tstrs_d.dblStress[1];

	return max;
}

// i/j 노드의 Truss Stress 값 중 작은 것을 구함.
double CStressEngine::GetMinElemTStrs(T_STRT_D &tstrs_d)
{
	double		min=DBL_MAX;

	if (tstrs_d.dblStress[0]>tstrs_d.dblStress[1])
		min = tstrs_d.dblStress[1];
	else
		min = tstrs_d.dblStress[0];

	return min;
}


// Truss Stress 데이터를 만든다.
// 현재 Active Element List에 대해 Loop를 돌며
// 1. DB로 부터 해당 요소의 Truss Stress 데이터를 얻고
// 2. Truss Stress에 대한 최대/최소값을 갱신하고
// 3. Truss Stress값 및 해당 요소번호를 CArray에 저장
BOOL CStressEngine::MakeTStrsDataList()
{
	if (CTestEnvMgr::IsTestEnvST(_LSX(ProfilingSTL), _LSX(yes)))
	{
		M_PROFILE('MakeTStrsDataList()');
	}

	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	
	int			i, elem_num;
	double		max_tstrs=-DBL_MAX, min_tstrs=DBL_MAX, len;
	BOOL		has_content=FALSE;
	T_ELEM_K	elem_key;
	T_ELEM_D	elem_data;
	T_STRT_D	tstrs_d;

	if (!gm->m_bLoadDataSet) {
		return FALSE;
	}

	gm->m_pMyView->BeginWaitCursor();

	m_TrussKeyList.RemoveAll();
	m_mapTStrsData.RemoveAll();
	elem_num = gm->m_EKeyListActive.GetSize();
	for (i=0;i<elem_num;i++) {
		elem_key = gm->m_EKeyListActive[i];
		m_pDoc->m_pAttrCtrl->GetElem(elem_key, elem_data);
		if (!m_pDoc->m_pAttrCtrl->IsTruss(elem_data.eltyp))
			continue;

		switch (gm->m_LoadMinMaxType) {
			case LOADTYPE_NORMAL:
			case LOADTYPE_MAX:
				// 1. DB로 부터 해당 요소의 Truss Force 데이터를 얻고
				if (!m_pDoc->m_pPostCtrl->GetStrtNew(elem_key, &tstrs_d,NULL,NULL)) {
					gm->m_pMyView->EndWaitCursor();
					return FALSE;
				}
				break;
			case LOADTYPE_MIN:
				// 1. DB로 부터 해당 요소의 Truss Force 데이터를 얻고
				if (!m_pDoc->m_pPostCtrl->GetStrtNew(elem_key,NULL, &tstrs_d,NULL)) {
					gm->m_pMyView->EndWaitCursor();
					return FALSE;
				}
				break;
			case LOADTYPE_ALL:
				// 1. DB로 부터 해당 요소의 Truss Force 데이터를 얻고
				if (!m_pDoc->m_pPostCtrl->GetStrtNew(elem_key, NULL, NULL, &tstrs_d)) {
					gm->m_pMyView->EndWaitCursor();
					return FALSE;
				}
				break;
		}
		if(((m_TStrsComponent==TSTRS_COMPONENT_TENS)&&((tstrs_d.dblStress[0]<0.0)&&(tstrs_d.dblStress[1]<0.0))) ||
		   ((m_TStrsComponent==TSTRS_COMPONENT_COMP)&&((tstrs_d.dblStress[0]>0.0)&&(tstrs_d.dblStress[1]>0.0))))
			 continue; 
		
		has_content = TRUE;

		// 2. Truss Stress에 대한 최대/최소값을 갱신하고
		len = GetMaxElemTStrs(tstrs_d);
		if (len > max_tstrs) 
		{
			max_tstrs = len;
			gm->m_nLgdMaxValKey = elem_key;
		}

		len = GetMinElemTStrs(tstrs_d);
		if (len < min_tstrs) 
		{
			min_tstrs = len;
			gm->m_nLgdMinValKey = elem_key;
		}

		// 3. Truss Stress값 및 해당 요소번호를 CArray에 저장
		m_TrussKeyList.Add(elem_key);
		m_mapTStrsData.SetAt(elem_key,tstrs_d);
	}

	if (!has_content) 
	{
		min_tstrs = max_tstrs = 0.0;
		gm->m_nLgdMaxValKey = 0;
		gm->m_nLgdMinValKey = 0;
	}
	
	m_dMaxValue = max_tstrs;
	m_dMinValue = min_tstrs;

	if (m_pContourEngine == NULL)
		m_pContourEngine = new CContourEngine(min_tstrs, max_tstrs);
	else
		m_pContourEngine->MakeRankMap(min_tstrs, max_tstrs);

	gm->m_pMyView->EndWaitCursor();

	m_bTStrsDataSet = TRUE;
	return TRUE;
}

BOOL CStressEngine::GetTStrsRangeDataList(double& dMaxRange, double& dMinRange, CArray<UINT,UINT>& aElemKeyList)
{
	aElemKeyList.RemoveAll();

	if (CTestEnvMgr::IsTestEnvST(_LSX(ProfilingSTL), _LSX(yes)))
	{
		M_PROFILE('GetTStrsRangeDataList()');
	}

	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	int			i, elem_num;
	T_ELEM_K	elem_key;
	T_ELEM_D	elem_data;
	T_STRT_D	tstrs_d;

	gm->m_pMyView->BeginWaitCursor();

	elem_num = gm->m_EKeyListActive.GetSize();
	for (i=0;i<elem_num;i++) {
		elem_key = gm->m_EKeyListActive[i];
		m_pDoc->m_pAttrCtrl->GetElem(elem_key, elem_data);
		if (!m_pDoc->m_pAttrCtrl->IsTruss(elem_data.eltyp))
			continue;

		switch (gm->m_LoadMinMaxType) {
		case LOADTYPE_NORMAL:
		case LOADTYPE_MAX:
			// 1. DB로 부터 해당 요소의 Truss Force 데이터를 얻고
			if (!m_pDoc->m_pPostCtrl->GetStrtNew(elem_key, &tstrs_d,NULL,NULL)) {
				gm->m_pMyView->EndWaitCursor();
				return FALSE;
			}
			break;
		case LOADTYPE_MIN:
			// 1. DB로 부터 해당 요소의 Truss Force 데이터를 얻고
			if (!m_pDoc->m_pPostCtrl->GetStrtNew(elem_key,NULL, &tstrs_d,NULL)) {
				gm->m_pMyView->EndWaitCursor();
				return FALSE;
			}
			break;
		case LOADTYPE_ALL:
			// 1. DB로 부터 해당 요소의 Truss Force 데이터를 얻고
			if (!m_pDoc->m_pPostCtrl->GetStrtNew(elem_key, NULL, NULL, &tstrs_d)) {
				gm->m_pMyView->EndWaitCursor();
				return FALSE;
			}
			break;
		}
		if(((m_TStrsComponent==TSTRS_COMPONENT_TENS)&&((tstrs_d.dblStress[0]<0.0)&&(tstrs_d.dblStress[1]<0.0))) ||
			((m_TStrsComponent==TSTRS_COMPONENT_COMP)&&((tstrs_d.dblStress[0]>0.0)&&(tstrs_d.dblStress[1]>0.0))))
			continue;

		// 2. Truss Stress가 최대/최소 범위안에 들어오는가?
		if(!IsWithinRangeElemTStrs(tstrs_d,dMaxRange,dMinRange)) continue;
		aElemKeyList.Add(elem_key);
	}

	gm->m_pMyView->EndWaitCursor();
	
	return TRUE;
}

BOOL CStressEngine::IsWithinRangeElemTStrs(T_STRT_D &StrtD,double& max_strt,double& min_strt)
{
	double len_max = StrtD.dblStress[1];
	double len_min = StrtD.dblStress[0];

	if(len_min>len_max)
	{
		double len_temp = len_max;
		len_max = len_min;
		len_min = len_temp;
	}

	if (len_min <= min_strt && len_max >= max_strt)
		return TRUE;
	if (len_min >= min_strt && len_min <= max_strt)
		return TRUE;
	if (len_max >= min_strt && len_max <= max_strt)
		return TRUE;

	return FALSE;
}

#if defined(__OLD_OUTPUT_VALUE)
void CStressEngine::OutputTStrsNumbers(CDC *pDC)
{
	I_GPSModel						*gm=(I_GPSModel *) m_pGPSModel;
	
	int								i, j, elem_num, slope;
	T_ELEM_K						ekey;
	T_ELEM_D						edata;
	T_STRT_D						tstrs_d;
	C3DPoint						node3D_i, node3D_j,DrawPoint;
	CPoint							text_p,node_2d_i, node_2d_j;
	TCHAR							fmt_str[10], text_str[256];
	CFont							ft, *old_ft;
	BOOL							fl_bak, is_inverse;

	//POSITION						pos;
	CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray <CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					edge_list;

	if (!m_bTStrsDataSet)
		return;

	if (gm->m_DOPT.TX.m_bNumberOpaque)
		pDC->SetBkMode(OPAQUE);
	else
		pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
	pDC->SetBkColor(gm->m_DOPT.TX.m_NumberBackCol);
	pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);

	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);

	fl_bak = gm->m_DOPT.DR.m_bFrameLine;
	gm->m_DOPT.DR.m_bFrameLine = TRUE;

	if (gm->m_DOPT.TX.m_bNumberSelOnly) {
	}
	else {
	
		//elem_num = gm->m_EKeyListActive.GetSize();
		BOOL bGrpFltMode=gm->m_pGPSCtrl->IsGroupFilterMode();
		if(!bGrpFltMode)elem_num = gm->m_EKeyListActive.GetSize();
		else            elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize(); 

		for (i=0;i<elem_num;i++) {
			//ekey = gm->m_EKeyListActive[i];
			if(!bGrpFltMode)ekey = gm->m_EKeyListActive[i];
			else            ekey = gm->m_pDispFilter->m_aGrpEKey[i]; 

			if(!gm->m_pGPSCtrl->IsActiveElem(ekey))
				continue;

			m_pDoc->m_pAttrCtrl->GetElem(ekey, edata);

			if (!m_pDoc->m_pAttrCtrl->IsTruss(edata.eltyp))
				continue;
#if defined(_TOWER)
			if(m_pDoc->m_pPostCtrl->GetTowerInfo()->IsRedundantElement(ekey)) 
				continue;
#endif

			if(!GetTrussStress(ekey, tstrs_d))continue; 
			if (((m_TStrsComponent==TSTRS_COMPONENT_TENS)&&((tstrs_d.dblStress[0]<0.0)&&(tstrs_d.dblStress[1]<0.0))) ||
				((m_TStrsComponent==TSTRS_COMPONENT_COMP)&&((tstrs_d.dblStress[0]>0.0)&&(tstrs_d.dblStress[1]>0.0))))
				continue;

			if (m_bDeformedShapeContour) {
				gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list);
			}
			else {
				gm->GetShapeElement(ekey, polygon_list, &edge_list);
			}

			POSITION pos = polygon_list[0]->GetHeadPosition();
			node3D_i = polygon_list[0]->GetNext(pos);
			node3D_j = polygon_list[0]->GetNext(pos);
		  if (gm->m_bVirtualMode) {
			  node_2d_i = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_i);
			  node_2d_j = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_j);
		  }
		  else {
			  node_2d_i = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_i);
			  node_2d_j = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_j);
		  }
			
			if((node_2d_i.x >= 0 && node_2d_i.y >= 0 && node_2d_j.x >= 0 && node_2d_j.y >= 0))
			{
		  
				slope = (int) (atan2(node_2d_i.y-node_2d_j.y, node_2d_j.x-node_2d_i.x)*1800.0/3.14159);
			  slope = (slope+3600)%3600;
			  if ((900<slope) && (slope<=2700)) {
				  slope = (slope+1800)%3600;
				  is_inverse = TRUE;
			  }
			  else {
				  is_inverse = FALSE;
			  }

		 	  gm->SetNumberFontOrientation(slope);
			  ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
	  	  old_ft = (CFont *) pDC->SelectObject(&ft);

				if(gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
				{
					double dLimit = (m_dMaxValue-m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;
				  double dTValue;
				
					for(int n=0; n<2; n++)
					{
				    if(n==0) // I단 또는 MAX
						{
							if (m_TStrsOutputSection == TSTRS_OUTPUT_JNODE) continue;
						
							if (m_TStrsOutputSection == TSTRS_OUTPUT_INODE || m_TStrsOutputSection == TSTRS_OUTPUT_ALL) 
							{
								if (is_inverse)
					        pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
				        else
					        pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
								DrawPoint = node3D_i;
								dTValue = CalcTStrsValue(tstrs_d, I_NODE);
							}
							else if (m_TStrsOutputSection == TSTRS_OUTPUT_MAX) 
							{
								pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);
								DrawPoint.x = (node3D_i.x + node3D_j.x)/2.0;
								DrawPoint.y = (node3D_i.y + node3D_j.y)/2.0;
								DrawPoint.z = (node3D_i.z + node3D_j.z)/2.0;
								dTValue = (fabs(CalcTStrsValue(tstrs_d, I_NODE)) >= fabs(CalcTStrsValue(tstrs_d, J_NODE)))? CalcTStrsValue(tstrs_d, I_NODE) : CalcTStrsValue(tstrs_d, J_NODE);
							}
						}
						else // J단
						{			  
							if (m_TStrsOutputSection == TSTRS_OUTPUT_INODE || m_TStrsOutputSection == TSTRS_OUTPUT_MAX ) continue;
				      if (is_inverse)
					      pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
				      else
					      pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
							DrawPoint = node3D_j;
							dTValue = CalcTStrsValue(tstrs_d, J_NODE);
						}
							
						switch(gm->m_DOPT.TX.m_nOutputMinMaxType)
						{
						case 0: // Min & Max
							if((m_dMaxValue-dTValue) <= dLimit)
								 DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,dTValue);
							else if((dTValue-m_dMinValue) <= dLimit)
								 DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,dTValue);
							break;
						case 1: // Abs Max
							if(fabs(m_dMaxValue) >= fabs(m_dMinValue))
							{
								if( fabs(m_dMaxValue)-fabs(dTValue) <= dLimit)
								DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dTValue);
							}
							else
							{
								if( fabs(m_dMinValue)-fabs(dTValue) <= dLimit)
								DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dTValue);
							}
							break;
						case 2: // Max
							if((m_dMaxValue-dTValue) <= dLimit)
								 DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,dTValue);
							break;
						case 3: // Min
							if((dTValue-m_dMinValue) <= dLimit)
								 DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,dTValue);
							break;
						}
					}
				//////////////////////////////////////////////////////////////////////////////////////
				}      
				else      
				{
			    if (m_TStrsOutputSection == TSTRS_OUTPUT_ALL) {
				    
				    if (is_inverse)
					    pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
				    else
					    pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
				    text_p.x = (int) node_2d_i.x;
				    text_p.y = (int) node_2d_i.y;
				    _stprintf(text_str, fmt_str, CalcTStrsValue(tstrs_d, I_NODE));
				    pDC->TextOut(text_p.x, text_p.y, text_str);

				    
				    if (is_inverse)
					    pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
				    else
					    pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
				    text_p.x = (int) node_2d_j.x;
				    text_p.y = (int) node_2d_j.y;
				    _stprintf(text_str, fmt_str, CalcTStrsValue(tstrs_d, J_NODE));
				    pDC->TextOut(text_p.x, text_p.y, text_str);
			    }
			    else if (m_TStrsOutputSection == TSTRS_OUTPUT_MAX) {
				    text_p.x = (int) ((node_2d_i.x+node_2d_j.x)/2.0);
				    text_p.y = (int) ((node_2d_i.y+node_2d_j.y)/2.0);
						double dAbsMax = (fabs(CalcTStrsValue(tstrs_d, I_NODE)) >= fabs(CalcTStrsValue(tstrs_d, J_NODE)))? CalcTStrsValue(tstrs_d, I_NODE) : CalcTStrsValue(tstrs_d, J_NODE);
				    _stprintf(text_str, fmt_str, GetMaxElemTStrs(tstrs_d));
				    pDC->TextOut(text_p.x, text_p.y, text_str);
			    }
			    else if (m_TStrsOutputSection == TSTRS_OUTPUT_INODE) {
				    
				    if (is_inverse)
					    pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
				    else
					    pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
				    text_p.x = (int) node_2d_i.x;
				    text_p.y = (int) node_2d_i.y;
				    _stprintf(text_str, fmt_str, CalcTStrsValue(tstrs_d, I_NODE));
				    pDC->TextOut(text_p.x, text_p.y, text_str);
			    }
			    else if (m_TStrsOutputSection == TSTRS_OUTPUT_JNODE) {
				    
				    if (is_inverse)
					    pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
				    else
					    pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
				    text_p.x = (int) node_2d_j.x;
				    text_p.y = (int) node_2d_j.y;
				    _stprintf(text_str, fmt_str, CalcTStrsValue(tstrs_d, J_NODE));
				    pDC->TextOut(text_p.x, text_p.y, text_str);
			    }
			    else {
				    text_p.x = (int) ((node_2d_i.x+node_2d_j.x)/2.0);
				    text_p.y = (int) ((node_2d_i.y+node_2d_j.y)/2.0);
				    _stprintf(text_str, fmt_str, CalcTStrsValue(tstrs_d, J_NODE));
				    pDC->TextOut(text_p.x, text_p.y, text_str);
			    }
				}

				pDC->SelectObject(old_ft);
	  	  ft.DeleteObject();
			}
			for (j=0;j<polygon_list.GetSize();j++) {
				polygon_list[j]->RemoveAll();
				delete polygon_list[j];
				edge_list[j]->RemoveAll();
				delete edge_list[j];
			}
			polygon_list.RemoveAll();
			edge_list.RemoveAll();

		}
	}
	gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}
#else
void CStressEngine::OutputTStrsNumbers(CDC* pDC)
{
	I_GPSModel* gm = (I_GPSModel*)m_pGPSModel;

	int								i, j, elem_num, slope;
	T_ELEM_K						ekey;
	T_ELEM_D						edata;
	T_STRT_D						tstrs_d;
	C3DPoint						node3D_i, node3D_j, DrawPoint;
	CPoint							text_p, node_2d_i, node_2d_j;
	TCHAR							fmt_str[10], text_str[256];
	CFont							ft, * old_ft;
	BOOL							fl_bak, is_inverse;

	//POSITION						pos;
	CArray <CList <C3DPoint, C3DPoint>*, CList <C3DPoint, C3DPoint>*>		polygon_list;
	CArray <CArray <BOOL, BOOL>*, CArray <BOOL, BOOL>*>					edge_list;

	if (!m_bTStrsDataSet)
		return;

	GPostTextOut TextOutModel;
	TextOutModel.SetDC(pDC);
	TextOutModel.StartTrussStressVal();
	TextOutModel.SettingTrussStress(gm);

	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);

	fl_bak = gm->m_DOPT.DR.m_bFrameLine;
	gm->m_DOPT.DR.m_bFrameLine = TRUE;

	if (gm->m_DOPT.TX.m_bNumberSelOnly) {
	}
	else {

		//elem_num = gm->m_EKeyListActive.GetSize();
		BOOL bGrpFltMode = gm->m_pGPSCtrl->IsGroupFilterMode();
		if (!bGrpFltMode)elem_num = gm->m_EKeyListActive.GetSize();
		else            elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize();

		for (i = 0; i < elem_num; i++) {
			//ekey = gm->m_EKeyListActive[i];
			if (!bGrpFltMode)ekey = gm->m_EKeyListActive[i];
			else            ekey = gm->m_pDispFilter->m_aGrpEKey[i];

			if (!gm->m_pGPSCtrl->IsActiveElem(ekey))
				continue;

			m_pDoc->m_pAttrCtrl->GetElem(ekey, edata);

			if (!m_pDoc->m_pAttrCtrl->IsTruss(edata.eltyp))
				continue;
#if defined(_TOWER)
			if (m_pDoc->m_pPostCtrl->GetTowerInfo()->IsRedundantElement(ekey))
				continue;
#endif

			if (!GetTrussStress(ekey, tstrs_d))continue;
			if (((m_TStrsComponent == TSTRS_COMPONENT_TENS) && ((tstrs_d.dblStress[0] < 0.0) && (tstrs_d.dblStress[1] < 0.0))) ||
				((m_TStrsComponent == TSTRS_COMPONENT_COMP) && ((tstrs_d.dblStress[0] > 0.0) && (tstrs_d.dblStress[1] > 0.0))))
				continue;

			if (m_bDeformedShapeContour) {
				gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list);
			}
			else {
				gm->GetShapeElement(ekey, polygon_list, &edge_list);
			}

			POSITION pos = polygon_list[0]->GetHeadPosition();
			node3D_i = polygon_list[0]->GetNext(pos);
			node3D_j = polygon_list[0]->GetNext(pos);
			if (gm->m_bVirtualMode) {
				node_2d_i = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_i);
				node_2d_j = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_j);
			}
			else {
				node_2d_i = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_i);
				node_2d_j = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_j);
			}

			if ((node_2d_i.x >= 0 && node_2d_i.y >= 0 && node_2d_j.x >= 0 && node_2d_j.y >= 0))
			{

				slope = (int)(atan2(node_2d_i.y - node_2d_j.y, node_2d_j.x - node_2d_i.x) * 1800.0 / 3.14159);
				slope = (slope + 3600) % 3600;
				if ((900 < slope) && (slope <= 2700)) {
					slope = (slope + 1800) % 3600;
					is_inverse = TRUE;
				}
				else {
					is_inverse = FALSE;
				}

				TextOutModel.Font4TrussStress(gm, slope);

				if (gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
				{
					double dLimit = (m_dMaxValue - m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;
					double dTValue;

					for (int n = 0; n < 2; n++)
					{
						if (n == 0) // I단 또는 MAX
						{
							if (m_TStrsOutputSection == TSTRS_OUTPUT_JNODE) continue;

							if (m_TStrsOutputSection == TSTRS_OUTPUT_INODE || m_TStrsOutputSection == TSTRS_OUTPUT_ALL)
							{
								if (is_inverse)
									TextOutModel.AlignTextBot(TA_RIGHT);
								else
									TextOutModel.AlignTextBot(TA_LEFT); 
								DrawPoint = node3D_i;
								dTValue = CalcTStrsValue(tstrs_d, I_NODE);
							}
							else if (m_TStrsOutputSection == TSTRS_OUTPUT_MAX)
							{
								TextOutModel.AlignTextBot(TA_CENTER);
								DrawPoint.x = (node3D_i.x + node3D_j.x) / 2.0;
								DrawPoint.y = (node3D_i.y + node3D_j.y) / 2.0;
								DrawPoint.z = (node3D_i.z + node3D_j.z) / 2.0;
								dTValue = (fabs(CalcTStrsValue(tstrs_d, I_NODE)) >= fabs(CalcTStrsValue(tstrs_d, J_NODE))) ? CalcTStrsValue(tstrs_d, I_NODE) : CalcTStrsValue(tstrs_d, J_NODE);
							}
						}
						else // J단
						{
							if (m_TStrsOutputSection == TSTRS_OUTPUT_INODE || m_TStrsOutputSection == TSTRS_OUTPUT_MAX) continue;
							if (is_inverse)
								TextOutModel.AlignTextBot(TA_LEFT);
							else
								TextOutModel.AlignTextBot(TA_RIGHT);
							DrawPoint = node3D_j;
							dTValue = CalcTStrsValue(tstrs_d, J_NODE);
						}

						switch (gm->m_DOPT.TX.m_nOutputMinMaxType)
						{
						case 0: // Min & Max
							if ((m_dMaxValue - dTValue) <= dLimit)
								DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, dTValue);
							else if ((dTValue - m_dMinValue) <= dLimit)
								DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, dTValue);
							break;
						case 1: // Abs Max
							if (fabs(m_dMaxValue) >= fabs(m_dMinValue))
							{
								if (fabs(m_dMaxValue) - fabs(dTValue) <= dLimit)
									DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, dTValue);
							}
							else
							{
								if (fabs(m_dMinValue) - fabs(dTValue) <= dLimit)
									DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, dTValue);
							}
							break;
						case 2: // Max
							if ((m_dMaxValue - dTValue) <= dLimit)
								DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, dTValue);
							break;
						case 3: // Min
							if ((dTValue - m_dMinValue) <= dLimit)
								DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, dTValue);
							break;
						}
					}
					//////////////////////////////////////////////////////////////////////////////////////
				}
				else
				{
					if (m_TStrsOutputSection == TSTRS_OUTPUT_ALL) {

						if (is_inverse)
							TextOutModel.AlignTextBot(TA_RIGHT);
						else
							TextOutModel.AlignTextBot(TA_LEFT);
						text_p.x = (int)node_2d_i.x;
						text_p.y = (int)node_2d_i.y;
						_stprintf(text_str, fmt_str, CalcTStrsValue(tstrs_d, I_NODE));
						TextOutModel.TextOutTrussStress(text_p.x, text_p.y, text_str);

						if (is_inverse)
							TextOutModel.AlignTextBot(TA_LEFT);
						else
							TextOutModel.AlignTextBot(TA_RIGHT);
						text_p.x = (int)node_2d_j.x;
						text_p.y = (int)node_2d_j.y;
						_stprintf(text_str, fmt_str, CalcTStrsValue(tstrs_d, J_NODE));
						TextOutModel.TextOutTrussStress(text_p.x, text_p.y, text_str);
					}
					else if (m_TStrsOutputSection == TSTRS_OUTPUT_MAX) {
						text_p.x = (int)((node_2d_i.x + node_2d_j.x) / 2.0);
						text_p.y = (int)((node_2d_i.y + node_2d_j.y) / 2.0);
						double dAbsMax = (fabs(CalcTStrsValue(tstrs_d, I_NODE)) >= fabs(CalcTStrsValue(tstrs_d, J_NODE))) ? CalcTStrsValue(tstrs_d, I_NODE) : CalcTStrsValue(tstrs_d, J_NODE);
						_stprintf(text_str, fmt_str, GetMaxElemTStrs(tstrs_d));
						TextOutModel.TextOutTrussStress(text_p.x, text_p.y, text_str);
					}
					else if (m_TStrsOutputSection == TSTRS_OUTPUT_INODE) {

						if (is_inverse)
							TextOutModel.AlignTextBot(TA_RIGHT);
						else
							TextOutModel.AlignTextBot(TA_LEFT);
						text_p.x = (int)node_2d_i.x;
						text_p.y = (int)node_2d_i.y;
						_stprintf(text_str, fmt_str, CalcTStrsValue(tstrs_d, I_NODE));
						TextOutModel.TextOutTrussStress(text_p.x, text_p.y, text_str);
					}
					else if (m_TStrsOutputSection == TSTRS_OUTPUT_JNODE) {

						if (is_inverse)
							TextOutModel.AlignTextBot(TA_LEFT);
						else
							TextOutModel.AlignTextBot(TA_RIGHT);
						text_p.x = (int)node_2d_j.x;
						text_p.y = (int)node_2d_j.y;
						_stprintf(text_str, fmt_str, CalcTStrsValue(tstrs_d, J_NODE));
						TextOutModel.TextOutTrussStress(text_p.x, text_p.y, text_str);
					}
					else {
						text_p.x = (int)((node_2d_i.x + node_2d_j.x) / 2.0);
						text_p.y = (int)((node_2d_i.y + node_2d_j.y) / 2.0);
						_stprintf(text_str, fmt_str, CalcTStrsValue(tstrs_d, J_NODE));
						TextOutModel.TextOutTrussStress(text_p.x, text_p.y, text_str);
					}
				}
				TextOutModel.DeleteFont();
			}
			for (j = 0; j < polygon_list.GetSize(); j++) {
				polygon_list[j]->RemoveAll();
				delete polygon_list[j];
				edge_list[j]->RemoveAll();
				delete edge_list[j];
			}
			polygon_list.RemoveAll();
			edge_list.RemoveAll();

		}
	}
	TextOutModel.EndTrussStressVal();
	gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}
#endif

void CStressEngine::DrawTStrsContour(CDC *pDC)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	T_MIRE_K mkey;

	int			i, elem_num;
	T_ELEM_D	elem_d;
	CPen		elem_pen, *old_pen;
	CArray <int, int>				type_list;
	CArray <GRE_Atom, GRE_Atom&>		atom_list;
	BOOL bEscapePressed = FALSE;

	/*
	if (!gm->m_bContour) {
		gm->GPSDrawOriginal(pDC);
		return;
	}
	*/

	if (m_bDeformedShapeContour) {
		if (gm->m_pDeformEngine == NULL) {
			return;
		}
		type_list.Add(gm->m_MinOTID + OBJECT_TYPE_DEFORMED);
	}
	else {
		type_list.Add(gm->m_MinOTID + OBJECT_TYPE_ORIGINAL);
	}

	//elem_pen.CreatePen(PS_SOLID, gm->m_nLineWidth, m_pContourEngine->m_ElemColor);
	//elem_pen.CreatePen(PS_SOLID, gm->m_LnWd.nElemHddn, m_pContourEngine->m_ElemColor);
	elem_pen.CreatePen(PS_SOLID, gm->m_DOPT.DR.nElemHddn, m_pContourEngine->m_ElemColor);
	old_pen = (CPen *) pDC->SelectObject(&elem_pen);

	gm->m_pGPSCtrl->GetZSortedList(type_list, gm->m_EKeyListVisible_Mirror, atom_list);
	elem_num = atom_list.GetSize();
	for (i=0;i<elem_num;i++) 
	{
		//if(gm->m_pGPSCtrl->WatchEscKeyPress()) bEscapePressed = TRUE;
		if(gm->m_pGPSCtrl->WatchEscKeyPress()) return;
		if (gm->m_pGPSCtrl->IsZoomAllState() ||
			gm->m_pGPSCtrl->IsObjectInClientWindow(atom_list[i].m_OType, atom_list[i].m_OKey)) {
			mkey.keymap = atom_list[i].m_OKey;
			m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d);

			BOOL bRedundant = FALSE;
#if defined(_TOWER)
			bRedundant = m_pDoc->m_pPostCtrl->GetTowerInfo()->IsRedundantElement(mkey.key.elem_k);
#endif

			if(m_pDoc->m_pAttrCtrl->IsTruss(elem_d.eltyp) && (gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey)) && !bEscapePressed && !bRedundant) 
			{
				if(gm->m_bContour)
				{
				  DoTStrsElementContour(pDC, atom_list[i].m_OKey);
					if(m_bHingeStatus)DrawNLHngeStatus(pDC,atom_list[i].m_OKey);
				}
				else
				{
					gm->GPSDrawElement(pDC,atom_list[i].m_OKey);
				}
			}
			else 
			{
				if (m_bDeformedShapeContour)
					gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, atom_list[i].m_OKey);
				else
					gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
			}
		}
	}

	// 변형된 형태에 Undeformed Shape을 같이 그릴 경우.
	if (m_bDeformedShapeContour && gm->m_DOPT.DR.m_bDrawInactive && !bEscapePressed) {
		int	rf_bak=gm->m_DOPT.DR.m_RenderFlag;
		gm->m_DOPT.DR.m_RenderFlag = 2;
		gm->GPSDrawOriginal(pDC, TRUE);
		gm->m_DOPT.DR.m_RenderFlag = rf_bak;
	}

	pDC->SelectObject(old_pen);
	elem_pen.DeleteObject();
}

void CStressEngine::DoTStrsElementContour(CDC *pDC, unsigned int ekey)
{
	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;
	T_MIRE_K mkey;
	mkey.keymap = ekey;
	
	int				i, poly_num, vtx_num;
	T_ELEM_D		elem_d;
	T_STRT_D		tstrs_d;

	CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray <CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					edge_list;
	CArray <CArray <T_NODE_K, T_NODE_K> *, CArray <T_NODE_K, T_NODE_K> *>	VertexNode;

	if ((gm->m_pDeformEngine==NULL) ||
		(m_pContourEngine==NULL) ||
		(!GetTrussStress(mkey.key.elem_k, tstrs_d))) 
	{
		if (m_bDeformedShapeContour)
			gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, ekey);
		else
			gm->GPSDrawInactiveElement(pDC, ekey);
		return;
	}

	// tension 혹은 compression이 일어난 요소만 나타낼 경우
	if (((m_TStrsComponent==TSTRS_COMPONENT_TENS)&&((tstrs_d.dblStress[0]<0.0)&&(tstrs_d.dblStress[1]<0.0))) ||
		((m_TStrsComponent==TSTRS_COMPONENT_COMP)&&((tstrs_d.dblStress[0]>0.0)&&(tstrs_d.dblStress[1]>0.0)))) {
		if (m_bDeformedShapeContour)
			gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, ekey);
		else
			gm->GPSDrawInactiveElement(pDC, ekey);
		return;
	}

	// 요소의 형상정보를 얻음
	m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d);
	if (m_bDeformedShapeContour) {
		gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list, &VertexNode);
	}
	else {
		gm->GetShapeElement(ekey, polygon_list, &edge_list, NULL, &VertexNode);
	}


	T_SECT_D SectD;
	if(gm->m_DOPT.DR.m_bFrameThick)
		m_pDoc->m_pAttrCtrl->GetSect(elem_d.elpro,SectD);

	gm->GPS_XGL_Begin_Elem(mkey.key.elem_k,elem_d);

	poly_num = polygon_list.GetSize();
	for (i=0;i<poly_num;i++) 
	{
		vtx_num = polygon_list[i]->GetCount();

		// Contour를 실시
		if(vtx_num == 2) 
		{
			DoTStrsLineContour(pDC, polygon_list[i], tstrs_d);
		}
		else 
		{
			if(!gm->IsPossibleDrawingPolyFrame(ekey,&elem_d,&SectD,poly_num,polygon_list[i]))continue;
			//if(poly_num>1 &&  gm->m_DOPT.DR.m_bFrameThick && !gm->IsVisibleFace(polygon_list[i],vtx_num))
			// continue;
			DoTStrsPolyContour(pDC, polygon_list[i], edge_list[i], VertexNode[i], elem_d, tstrs_d);
		}
	}
	gm->GPS_XGL_End_Elem();

	FreeMemoryPolyList(&polygon_list,&edge_list,&VertexNode); 
	/*
	for (i=0;i<poly_num;i++) {
		polygon_list[i]->RemoveAll();
		delete polygon_list[i];
		edge_list[i]->RemoveAll();
		delete edge_list[i];
		VertexNode[i]->RemoveAll();
		delete VertexNode[i];
	}
	polygon_list.RemoveAll();
	edge_list.RemoveAll();
	VertexNode.RemoveAll();
	*/
}

void CStressEngine::DoTStrsLineContour(CDC *pDC, CList <C3DPoint, C3DPoint> *Vertex, T_STRT_D &TStrsVal)
{
	I_GPSModel						*gm=(I_GPSModel *) m_pGPSModel;
	double							i_val, j_val;
	POSITION						pos=Vertex->GetHeadPosition();
	C3DPoint						p[2];
	CArray <C3DPoint, C3DPoint>		rvtx_list;
	CArray <double, double>			rval_list;

	p[0] = Vertex->GetNext(pos);
	p[1] = Vertex->GetNext(pos);

	i_val = CalcTStrsValue(TStrsVal, I_NODE);
	j_val = CalcTStrsValue(TStrsVal, J_NODE);
	if (gm->m_AnimEngine.m_bAnimateContour) {
		i_val = m_pContourEngine->GetSubFrameValue(i_val, gm->m_AnimEngine.GetAnimationFactor(TRUE));
		j_val = m_pContourEngine->GetSubFrameValue(j_val, gm->m_AnimEngine.GetAnimationFactor(TRUE));
	}
	if (i_val > j_val) {
		rvtx_list.Add(p[0]);
		rval_list.Add(i_val);
		m_pContourEngine->GetRankVertices(p[0], p[1], i_val, j_val, rvtx_list, rval_list, NULL);
		rvtx_list.Add(p[1]);
		rval_list.Add(j_val);
	}
	else {
		rvtx_list.Add(p[1]);
		rval_list.Add(j_val);
		m_pContourEngine->GetRankVertices(p[1], p[0], j_val, i_val, rvtx_list, rval_list, NULL);
		rvtx_list.Add(p[0]);
		rval_list.Add(i_val);
	}

	//DrawContourLine(pDC, rvtx_list, rval_list);
	//DrawContourLine(pDC, rvtx_list, rval_list,gm->m_nMdLineWidth);
	//DrawContourLine(pDC, rvtx_list, rval_list,gm->m_LnWd.nElemWire);
	DrawContourLine(pDC, rvtx_list, rval_list,gm->m_DOPT.DR.nElemWire);

	rvtx_list.RemoveAll();
	rval_list.RemoveAll();
}

void CStressEngine::DoTStrsPolyContour(CDC *pDC,
									   CList <C3DPoint, C3DPoint> *Vertex,
									   CArray <BOOL, BOOL> *EdgeFlag,
									   CArray <T_NODE_K, T_NODE_K> *VertexNode,
									   T_ELEM_D &ElemData,
									   T_STRT_D &TStrsVal)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	int			i, vertex_num=Vertex->GetCount();
	double		tstrs_val[4];
	BOOL		ef[4];
	C3DPoint	p[4];

	// polygon이 i노드에 있는 것일 경우
	if((VertexNode->GetAt(0)==VertexNode->GetAt(1)) &&
		 (VertexNode->GetAt(0)==VertexNode->GetAt(2)) &&
		 (VertexNode->GetAt(0)==ElemData.elnod[0]))  {
		for (i=0;i<vertex_num;i++) 
		{
			tstrs_val[i] = CalcTStrsValue(TStrsVal, I_NODE);
			if (gm->m_AnimEngine.m_bAnimateContour)
				tstrs_val[i] = m_pContourEngine->GetSubFrameValue(tstrs_val[i], gm->m_AnimEngine.GetAnimationFactor(TRUE));
			ef[i] = EdgeFlag->GetAt(i);
		}
		DoSubPolyContour(pDC, tstrs_val, Vertex, ef, TRUE);
	}
	// polygon이 j노드에 있는 것일 경우
	else if ((VertexNode->GetAt(0)==VertexNode->GetAt(1)) &&
			    (VertexNode->GetAt(0)==VertexNode->GetAt(2)) &&
			    (VertexNode->GetAt(0)==ElemData.elnod[1])) 
	{
		for(i=0;i<vertex_num;i++) 
		{
			tstrs_val[i] = CalcTStrsValue(TStrsVal, J_NODE);
			if (gm->m_AnimEngine.m_bAnimateContour)
				tstrs_val[i] = m_pContourEngine->GetSubFrameValue(tstrs_val[i], gm->m_AnimEngine.GetAnimationFactor(TRUE));
			ef[i] = EdgeFlag->GetAt(i);
		}
		DoSubPolyContour(pDC, tstrs_val, Vertex, ef, TRUE);
	}
	// polygon이 i, j노드에 걸쳐 있는 것일 경우
	else 
	{
		if(vertex_num!=4)return;
		tstrs_val[0] = tstrs_val[1] = CalcTStrsValue(TStrsVal, I_NODE);
		tstrs_val[2] = tstrs_val[3] = CalcTStrsValue(TStrsVal, J_NODE);
		if (gm->m_AnimEngine.m_bAnimateContour) {
			tstrs_val[0] = m_pContourEngine->GetSubFrameValue(tstrs_val[0], gm->m_AnimEngine.GetAnimationFactor(TRUE));
			tstrs_val[1] = m_pContourEngine->GetSubFrameValue(tstrs_val[1], gm->m_AnimEngine.GetAnimationFactor(TRUE));
			tstrs_val[2] = m_pContourEngine->GetSubFrameValue(tstrs_val[2], gm->m_AnimEngine.GetAnimationFactor(TRUE));
			tstrs_val[3] = m_pContourEngine->GetSubFrameValue(tstrs_val[3], gm->m_AnimEngine.GetAnimationFactor(TRUE));
		}
		for (i=0;i<4;i++) {
			ef[i] = EdgeFlag->GetAt(i);
		}
		DoSubPolyContour(pDC, tstrs_val, Vertex, ef, TRUE);
	}
	
	// Fill+Outline의 경우 Contour를 수행하기 전의 Polygon의 Outline을 그림.
	if (gm->m_DOPT.DR.m_RenderFlag == 3 || gm->m_DOPT.DR.m_RenderFlag == 2)
		gm->GPSDrawPolygonEdge(pDC, Vertex, EdgeFlag);
}

////////////////////////////////////////////////////////////////////////////////////////
// Initialization and Utility Routines for Beam Member Stress        ///////////////////
////////////////////////////////////////////////////////////////////////////////////////

void CStressEngine::DoBVmstElementContour(CDC *pDC, unsigned int ekey)
{
	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;
	T_MIRE_K mkey;
	mkey.keymap = ekey;
	
	int				i, poly_num, vtx_num;
	BOOL			is_real=FALSE;
	T_ELEM_D		elem_d;
	T_VMST_D		VmstD;

	CArray<CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray<CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					        edge_list;
	CArray<CArray <T_NODE_K, T_NODE_K> *, CArray <T_NODE_K, T_NODE_K> *>	VertexNode;
	CArray<CArray <double, double> *, CArray <double, double> *>			    PosList;

	if((gm->m_pDeformEngine==NULL) ||
		 (m_pContourEngine==NULL) ||
		 (!GetBeamStressEffective(mkey.key.elem_k, VmstD))) 
	{
		return;
	}

	// 요소의 형상정보를 얻는다.

	m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d);
	if (m_bDeformedShapeContour) 
	{	// 변형된 형상
		is_real = gm->m_pDeformEngine->m_bRealDeform;
		if (is_real) 
		{				// Real Deform
			if (!gm->m_pBeamDiagram)
				gm->m_pBeamDiagram = new CBeamDiagram;
			if (gm->m_pBeamDiagram->MakeBeamDispl(mkey.key.elem_k, gm->m_LoadCombi, 10, 2)) 
			{
				gm->m_pDeformEngine->GetBeamRealDeformedShape(ekey, &polygon_list, &edge_list, &PosList);
			}
			else {
				gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list, &VertexNode);
				is_real = FALSE;
			}
		}
		else 
		{
			gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list, &VertexNode);
		}
	}
	else {
		gm->GetShapeElement(ekey, polygon_list, &edge_list, NULL, &VertexNode);
	}

	T_SECT_D SectD;
	if(gm->m_DOPT.DR.m_bFrameThick)
		m_pDoc->m_pAttrCtrl->GetSect(elem_d.elpro,SectD);

	gm->GPS_XGL_Begin_Elem(mkey.key.elem_k,elem_d);

	poly_num = polygon_list.GetSize();
	for (i=0;i<poly_num;i++) 
	{
		vtx_num = polygon_list[i]->GetCount();
		if (vtx_num == 2) 
		{
			if (m_bDeformedShapeContour && is_real)
				DoBVmstLineContourReal(pDC, polygon_list[i], poly_num, VmstD, PosList[i]);
			else
				DoBVmstLineContour(pDC, polygon_list[i], poly_num, VmstD);
		}
		else 
		{
			if(!gm->IsPossibleDrawingPolyFrame(ekey,&elem_d,&SectD,poly_num,polygon_list[i],is_real))continue;
			if(m_bDeformedShapeContour && is_real)
				DoBVmstPolyContourReal(pDC, polygon_list[i], edge_list[i], VmstD, PosList[i]);
			else
				DoBVmstPolyContour(pDC, polygon_list[i], edge_list[i], VertexNode[i], elem_d, VmstD);
		}
	}

	gm->GPS_XGL_End_Elem();

	for(i=0;i<poly_num;i++) 
	{
		polygon_list[i]->RemoveAll();
		delete polygon_list[i];
		edge_list[i]->RemoveAll();
		delete edge_list[i];
		if(m_bDeformedShapeContour && is_real) 
		{
			PosList[i]->RemoveAll();
			delete PosList[i];
		}
		else 
		{
			VertexNode[i]->RemoveAll();
			delete VertexNode[i];
		}
	}
	polygon_list.RemoveAll();
	edge_list.RemoveAll();
	VertexNode.RemoveAll();
	PosList.RemoveAll();
}

double CStressEngine::GetEffectiveVal(double dblStress[4][56][7], int part, int node, int iPos, int nComp)
{
	double dValue = dblStress[part][node*28+iPos][nComp];

	return dValue;
}

double CStressEngine::CalcBVmstValue(T_VMST_D &BVmstD, int part, int node)
{
	double	len=0.;
	const double  dTol = 1.E-10;

	if(m_BStrsComponentSub2==BSTRSDETAIL_COMP_POSMX)
	{
		if(BVmstD.nPoint4EffectiveSect==0) { ASSERT(0); BVmstD.nPoint4EffectiveSect = 28;}
		// Maximum
		double dMaxVal = GetEffectiveVal(BVmstD.dblStress, part, node, 0, m_BStrsComponentType);
		double dValue  = 0.0;
		for(int i=1; i<BVmstD.nPoint4EffectiveSect; i++)
		{
			dValue = GetEffectiveVal(BVmstD.dblStress, part, node, i, m_BStrsComponentType);
			if(fabs(dMaxVal) < fabs(dValue)) dMaxVal = dValue;
		}
		return dMaxVal;
	}

	if(m_BStrsComponentType<BSTRS_COMPONENT_NORMAL || m_BStrsComponentType>BSTRS_COMPONENT_PRIN2)
	{
		ASSERT(0);
		return len;
	}

	len = GetEffectiveVal(BVmstD.dblStress, part, node, m_BStrsComponentSub2, m_BStrsComponentType);

	return len;
}

double CStressEngine::CalcBVmstValue(T_VMST_D &BVmstD)
{
	double	len=0.0, min, max;

	switch(m_BStrsOutputSection) 
	{
	case BSTRS_OUTPUT_INODE:
		len = CalcBVmstValue(BVmstD, 0, I_NODE);
		break;
	case BSTRS_OUTPUT_JNODE:
		len = CalcBVmstValue(BVmstD, 3, J_NODE);
		break;
	case BSTRS_OUTPUT_CENTER:
		len = CalcBVmstValue(BVmstD, 1, J_NODE);
		break;
	case BSTRS_OUTPUT_MAX:
		min = GetMinElemBVmst(BVmstD);
		max = GetMaxElemBVmst(BVmstD);
		if((-min) > max)len = min;
		else			      len = max;
		break;
	}
	return len;
}

// 주어진 position에서의 Beam Stress 값을 구함
double CStressEngine::CalcBVmstValuePos(T_VMST_D &BVmstD, double pos)
{
	double		len=0.0, vs, vd;

	if (pos == 0.0) {
		len = CalcBVmstValue(BVmstD, 0, I_NODE);
	}
	// 1/4
	else if ((pos > 0.0) && (pos < 0.25)) {
		vs = CalcBVmstValue(BVmstD, 0, I_NODE);
		vd = CalcBVmstValue(BVmstD, 1, I_NODE) - vs;
		len = vs + vd*pos/0.25;
	}
	else if (pos == 0.25) {
		len = CalcBVmstValue(BVmstD, 1, I_NODE);
	}
	// 2/4
	else if ((pos > 0.25) && (pos < 0.5)) {
		vs = CalcBVmstValue(BVmstD, 1, I_NODE);
		vd = CalcBVmstValue(BVmstD, 2, I_NODE) - vs;
		len = vs + vd*(pos-0.25)/0.25;
	}
	else if (pos == 0.5) {
		len = CalcBVmstValue(BVmstD, 2, I_NODE);
	}
	// 3/4
	else if ((pos > 0.5) && (pos < 0.75)) {
		vs = CalcBVmstValue(BVmstD, 2, I_NODE);
		vd = CalcBVmstValue(BVmstD, 3, I_NODE) - vs;
		len = vs + vd*(pos-0.5)/0.25;
	}
	else if (pos == 0.75) {
		len = CalcBVmstValue(BVmstD, 3, I_NODE);
	}
	// 4/4
	else if ((pos > 0.75) && (pos < 1.0)) {
		vs = CalcBVmstValue(BVmstD, 3, I_NODE);
		vd = CalcBVmstValue(BVmstD, 3, J_NODE) - vs;
		len = vs + vd*(pos-0.75)/0.25;
	}
	else if (pos == 1.0) {
		len = CalcBVmstValue(BVmstD, 3, J_NODE);
	}

	return len;
}

double CStressEngine::GetMaxElemBVmst(T_VMST_D &BVmstD)
{
	double len, max=-DBL_MAX;
	for (int i=0;i<4;i++)
	{
		for (int j=0;j<2;j++)
		{
			len = CalcBVmstValue(BVmstD, i, j);
			max = max(max,len);
		}
	}

	return max;
}

double CStressEngine::GetMinElemBVmst(T_VMST_D &BVmstD)
{
	double len, min=DBL_MAX;
	for (int i=0;i<4;i++)
	{
		for (int j=0;j<2;j++)
		{
			len = CalcBVmstValue(BVmstD, i, j);
			min = min(min,len);
		}
	}

	return min;
}

double CStressEngine::CalcBStrsValue(T_STRB_D &bstrs_d, int part, int node)
{
	double	len;
	const double  dTol = 1.E-10;

	switch (m_BStrsComponent) {
		case BSTRS_COMPONENT_FX:
			len = bstrs_d.dblStress[part][node*7+0];
			break;
		case BSTRS_COMPONENT_FY:
			len = bstrs_d.dblStress[part][node*7+1];
			break;
		case BSTRS_COMPONENT_FZ:
			len = bstrs_d.dblStress[part][node*7+2];
			break;
		case BSTRS_COMPONENT_MY:
			{
				double dStress7_3 = bstrs_d.dblStress[part][node*7+3];
				double dStress7_4 = bstrs_d.dblStress[part][node*7+4];
				double dEqualCompare = 0.0;

				len = dStress7_3;
				if(fabs(dStress7_4) > fabs(dStress7_3))
				{
					if (dStress7_4 != 0.0)
					{
						// 두 값이 거의 동일하다면 앞에 것을 일관되게 반환한다.
						// 소수점으로 비교하면 유효숫자의 길이 때문에 무용지물이 되는 경우가 있다. 
						// 예를 들면 123456789.012345 라는 값은 소수점 10번째 자리로 비교해봤자, 실제 의미있는 값은 소수점 5째자리에서 끝나버린다. 
						dEqualCompare = fabs(dStress7_3)/fabs(dStress7_4) -1.0;
						if (fabs(dEqualCompare) > dTol)  len=dStress7_4;
					}
					else   len=dStress7_4;
				}
			}
			break;
		case BSTRS_COMPONENT_MZ:
			{
				double dStress7_5 = bstrs_d.dblStress[part][node*7+5];
				double dStress7_6 = bstrs_d.dblStress[part][node*7+6];
				double dEqualCompare = 0.0;
				
				len = dStress7_5;
				if(fabs(dStress7_6) > fabs(dStress7_5))
				{
					if (dStress7_6 != 0.0)
					{
						// 두 값이 거의 동일하다면 앞에 것을 일관되게 반환한다.
						// 소수점으로 비교하면 유효숫자의 길이 때문에 무용지물이 되는 경우가 있다. 
						// 예를 들면 123456789.012345 라는 값은 소수점 10번째 자리로 비교해봤자, 실제 의미있는 값은 소수점 5째자리에서 끝나버린다. 
						dEqualCompare = fabs(dStress7_5)/fabs(dStress7_6) -1.0;
						if (fabs(dEqualCompare) > dTol)  len=dStress7_6;
					}
					else   len=dStress7_6;
				}
			}
			break;
		case BSTRS_COMPONENT_COMB:
			switch(m_BStrsComponentSub)
			{
			case BSTRS_COMPONENT_CBSUBMX:   len = bstrs_d.dblStress[part][14+node];   break;
			case BSTRS_COMPONENT_CBSUB1:    len = bstrs_d.dblStress[part][16+node];   break; 
			case BSTRS_COMPONENT_CBSUB2:    len = bstrs_d.dblStress[part][18+node];   break; 
			case BSTRS_COMPONENT_CBSUB3:    len = bstrs_d.dblStress[part][20+node];   break; 
			case BSTRS_COMPONENT_CBSUB4:    len = bstrs_d.dblStress[part][22+node];   break; 
			}
			break;
		case BSTRS_COMPONENT_7thDOF:
			switch(m_BStrsComp7thDof)
			{
			case BSTRS_COMPONENT_7th_SAX:
				switch(m_BStrsComponentSub)
				{
				case BSTRS_COMPONENT_CBSUBMX:   len = bstrs_d.GetMaximumStress_Warping(part, node);break;
				case BSTRS_COMPONENT_CBSUB1:    len = bstrs_d.dblStress[part][24+node*20];   break;
				case BSTRS_COMPONENT_CBSUB2:    len = bstrs_d.dblStress[part][25+node*20];   break;
				case BSTRS_COMPONENT_CBSUB3:    len = bstrs_d.dblStress[part][26+node*20];   break;
				case BSTRS_COMPONENT_CBSUB4:    len = bstrs_d.dblStress[part][27+node*20];   break;
				}
			  break;
			case BSTRS_COMPONENT_7th_SSY_MT:
				switch(m_BStrsComponentSub)
				{
				case BSTRS_COMPONENT_CBSUBMX:   len = bstrs_d.GetMaximumStress_Torsional(part, node, BSTRS_COMPONENT_7th_SSY_MT); break;
				case BSTRS_COMPONENT_CBSUB1:    len = bstrs_d.dblStress[part][28+node*20];   break; 
				case BSTRS_COMPONENT_CBSUB2:    len = bstrs_d.dblStress[part][30+node*20];   break; 
				case BSTRS_COMPONENT_CBSUB3:    len = bstrs_d.dblStress[part][32+node*20];   break; 
				case BSTRS_COMPONENT_CBSUB4:    len = bstrs_d.dblStress[part][34+node*20];   break; 
				}
			  break;
			case BSTRS_COMPONENT_7th_SSY_MW:
				switch(m_BStrsComponentSub)
				{
				case BSTRS_COMPONENT_CBSUBMX:   len = bstrs_d.GetMaximumStress_Torsional(part, node, BSTRS_COMPONENT_7th_SSY_MW); break;
				case BSTRS_COMPONENT_CBSUB1:    len = bstrs_d.dblStress[part][36+node*20];   break; 
				case BSTRS_COMPONENT_CBSUB2:    len = bstrs_d.dblStress[part][38+node*20];   break; 
				case BSTRS_COMPONENT_CBSUB3:    len = bstrs_d.dblStress[part][40+node*20];   break; 
				case BSTRS_COMPONENT_CBSUB4:    len = bstrs_d.dblStress[part][42+node*20];   break; 
				}
			  break;
			case BSTRS_COMPONENT_7th_SSZ_MT:
				switch(m_BStrsComponentSub)
				{
				case BSTRS_COMPONENT_CBSUBMX:   len = bstrs_d.GetMaximumStress_Torsional(part, node, BSTRS_COMPONENT_7th_SSZ_MT); break;
				case BSTRS_COMPONENT_CBSUB1:    len = bstrs_d.dblStress[part][29+node*20];   break; 
				case BSTRS_COMPONENT_CBSUB2:    len = bstrs_d.dblStress[part][31+node*20];   break; 
				case BSTRS_COMPONENT_CBSUB3:    len = bstrs_d.dblStress[part][33+node*20];   break; 
				case BSTRS_COMPONENT_CBSUB4:    len = bstrs_d.dblStress[part][35+node*20];   break; 
				}
			  break;
			case BSTRS_COMPONENT_7th_SSZ_MW:
				switch(m_BStrsComponentSub)
				{
				case BSTRS_COMPONENT_CBSUBMX:   len = bstrs_d.GetMaximumStress_Torsional(part, node, BSTRS_COMPONENT_7th_SSZ_MW); break;
				case BSTRS_COMPONENT_CBSUB1:    len = bstrs_d.dblStress[part][37+node*20];   break; 
				case BSTRS_COMPONENT_CBSUB2:    len = bstrs_d.dblStress[part][39+node*20];   break; 
				case BSTRS_COMPONENT_CBSUB3:    len = bstrs_d.dblStress[part][41+node*20];   break; 
				case BSTRS_COMPONENT_CBSUB4:    len = bstrs_d.dblStress[part][43+node*20];   break; 
				}
			  break;
			case BSTRS_COMPONENT_7th_COMB_SSY:
				switch(m_BStrsComponentSub)
				{
				case BSTRS_COMPONENT_CBSUBMX:   len = bstrs_d.GetMaximumCombinedStress_Torsional(part, node, BSTRS_COMPONENT_7th_COMB_SSY);  break;
				case BSTRS_COMPONENT_CBSUB1:    len = bstrs_d.dblStress[part][64+node];   break; 
				case BSTRS_COMPONENT_CBSUB2:    len = bstrs_d.dblStress[part][66+node];   break; 
				case BSTRS_COMPONENT_CBSUB3:    len = bstrs_d.dblStress[part][68+node];   break; 
				case BSTRS_COMPONENT_CBSUB4:    len = bstrs_d.dblStress[part][70+node];   break; 
				}
			  break;
			case BSTRS_COMPONENT_7th_COMB_SSZ:
				switch(m_BStrsComponentSub)
				{
				case BSTRS_COMPONENT_CBSUBMX:   len = bstrs_d.GetMaximumCombinedStress_Torsional(part, node, BSTRS_COMPONENT_7th_COMB_SSZ);  break;
				case BSTRS_COMPONENT_CBSUB1:    len = bstrs_d.dblStress[part][72+node];   break; 
				case BSTRS_COMPONENT_CBSUB2:    len = bstrs_d.dblStress[part][74+node];   break; 
				case BSTRS_COMPONENT_CBSUB3:    len = bstrs_d.dblStress[part][76+node];   break; 
				case BSTRS_COMPONENT_CBSUB4:    len = bstrs_d.dblStress[part][78+node];   break; 
				}
			  break;
			}
			break;
	}

	return len;
}

double CStressEngine::CalcInflBStrsValue(T_STRB_D &bstrs_d, int nComp,int part, int node)
{
	double dVal=0.0;
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	switch(gm->m_GPSInstruction)
	{
	case GPS_COMMAND_IFLBSTRS:
	case GPS_COMMAND_IFSBSTRS:
	case GPS_COMMAND_IFGBSTRS:    
		if(m_BStrsComp7thDof<=BSTRS_COMPONENT_NORMAL)
		{
			switch(nComp) 
			{
			case BSTRS_COMBCOMP_MAX:  dVal = bstrs_d.dblStress[part][14+node];  break;
			case BSTRS_COMBCOMP_CP1:  dVal = bstrs_d.dblStress[part][16+node];  break;
			case BSTRS_COMBCOMP_CP2:  dVal = bstrs_d.dblStress[part][18+node];  break;
			case BSTRS_COMBCOMP_CP3:  dVal = bstrs_d.dblStress[part][20+node];  break;
			case BSTRS_COMBCOMP_CP4:  dVal = bstrs_d.dblStress[part][22+node];  break;
			default :
				ASSERT(FALSE);
				dVal=0.0;
				break; 
			}
		}
		else if(m_BStrsComp7thDof==BSTRS_COMPONENT_SSY)
		{
			switch(nComp) 
			{
			case BSTRS_COMBCOMP_MAX:  dVal = bstrs_d.GetMaximumCombinedStress_Torsional(part, node, BSTRS_COMPONENT_7th_COMB_SSY); break; 
			case BSTRS_COMBCOMP_CP1:  dVal = bstrs_d.dblStress[part][64+node];   break;
			case BSTRS_COMBCOMP_CP2:  dVal = bstrs_d.dblStress[part][66+node];   break;
			case BSTRS_COMBCOMP_CP3:  dVal = bstrs_d.dblStress[part][68+node];   break;
			case BSTRS_COMBCOMP_CP4:  dVal = bstrs_d.dblStress[part][70+node];   break;
			default :
				ASSERT(FALSE);
				dVal=0.0;
				break; 
			}
		}
		else if(m_BStrsComp7thDof==BSTRS_COMPONENT_SSZ)
		{
			switch(nComp) 
			{
			case BSTRS_COMBCOMP_MAX:  dVal = bstrs_d.GetMaximumCombinedStress_Torsional(part, node, BSTRS_COMPONENT_7th_COMB_SSZ); break; 
			case BSTRS_COMBCOMP_CP1:  dVal = bstrs_d.dblStress[part][72+node];   break;
			case BSTRS_COMBCOMP_CP2:  dVal = bstrs_d.dblStress[part][74+node];   break;
			case BSTRS_COMBCOMP_CP3:  dVal = bstrs_d.dblStress[part][76+node];   break;
			case BSTRS_COMBCOMP_CP4:  dVal = bstrs_d.dblStress[part][78+node];   break;
			default :
				ASSERT(FALSE);
				dVal=0.0;
				break; 
			}
		}
		else ASSERT(0);
		break; 
	// Moving Load Tracer에서는 Max Stress가 사라짐
	case GPS_COMMAND_MVLTRCBSTRS:
		if(m_BStrsComp7thDof<=BSTRS_COMPONENT_NORMAL)
		{
			switch(nComp) 
			{
			case BSTRS_COMBCOMP_MAX:  dVal = bstrs_d.dblStress[part][16+node];  break;
			case BSTRS_COMBCOMP_CP1:  dVal = bstrs_d.dblStress[part][18+node];  break;
			case BSTRS_COMBCOMP_CP2:  dVal = bstrs_d.dblStress[part][20+node];  break;
			case BSTRS_COMBCOMP_CP3:  dVal = bstrs_d.dblStress[part][22+node];  break;
			default :
				ASSERT(FALSE);
				dVal=0.0;
				break; 
			}
		}
		else if(m_BStrsComp7thDof==BSTRS_COMPONENT_SSY)
		{
			switch(nComp) 
			{
			case BSTRS_COMBCOMP_MAX:  dVal = bstrs_d.dblStress[part][64+node];   break;
			case BSTRS_COMBCOMP_CP1:  dVal = bstrs_d.dblStress[part][66+node];   break;
			case BSTRS_COMBCOMP_CP2:  dVal = bstrs_d.dblStress[part][68+node];   break;
			case BSTRS_COMBCOMP_CP3:  dVal = bstrs_d.dblStress[part][70+node];   break;
			default :
				ASSERT(FALSE);
				dVal=0.0;
				break; 
			}
		}
		else if(m_BStrsComp7thDof==BSTRS_COMPONENT_SSZ)
		{
			switch(nComp) 
			{
			case BSTRS_COMBCOMP_MAX:  dVal = bstrs_d.dblStress[part][72+node];   break;
			case BSTRS_COMBCOMP_CP1:  dVal = bstrs_d.dblStress[part][74+node];   break;
			case BSTRS_COMBCOMP_CP2:  dVal = bstrs_d.dblStress[part][76+node];   break;
			case BSTRS_COMBCOMP_CP3:  dVal = bstrs_d.dblStress[part][78+node];   break;
			default :
				ASSERT(FALSE);
				dVal=0.0;
				break; 
			}
		}
		else ASSERT(0);
		break; 
	}
	return dVal;
}

double CStressEngine::CalcBStrsValue(T_STRB_D &bstrs_d)
{
	double	len=0.0, min, max;

	switch(m_BStrsOutputSection) 
	{
	case BSTRS_OUTPUT_INODE:
		len = CalcBStrsValue(bstrs_d, 0, I_NODE);
		break;
	case BSTRS_OUTPUT_JNODE:
		len = CalcBStrsValue(bstrs_d, 3, J_NODE);
		break;
	case BSTRS_OUTPUT_CENTER:
		len = CalcBStrsValue(bstrs_d, 1, J_NODE);
		break;
	case BSTRS_OUTPUT_MAX:
		min = GetMinElemBStrs(bstrs_d);
		max = GetMaxElemBStrs(bstrs_d);
		if((-min) > max)len = min;
		else			      len = max;
		break;
	}
	return len;
}

// 주어진 position에서의 Beam Stress 값을 구함
double CStressEngine::CalcBStrsValuePos(T_STRB_D &bstrs_d, double pos)
{
	double		len=0.0, vs, vd;

	if (pos == 0.0) {
		len = CalcBStrsValue(bstrs_d, 0, I_NODE);
	}
	// 1/4
	else if ((pos > 0.0) && (pos < 0.25)) {
		vs = CalcBStrsValue(bstrs_d, 0, I_NODE);
		vd = CalcBStrsValue(bstrs_d, 1, I_NODE) - vs;
		len = vs + vd*pos/0.25;
	}
	else if (pos == 0.25) {
		len = CalcBStrsValue(bstrs_d, 1, I_NODE);
	}
	// 2/4
	else if ((pos > 0.25) && (pos < 0.5)) {
		vs = CalcBStrsValue(bstrs_d, 1, I_NODE);
		vd = CalcBStrsValue(bstrs_d, 2, I_NODE) - vs;
		len = vs + vd*(pos-0.25)/0.25;
	}
	else if (pos == 0.5) {
		len = CalcBStrsValue(bstrs_d, 2, I_NODE);
	}
	// 3/4
	else if ((pos > 0.5) && (pos < 0.75)) {
		vs = CalcBStrsValue(bstrs_d, 2, I_NODE);
		vd = CalcBStrsValue(bstrs_d, 3, I_NODE) - vs;
		len = vs + vd*(pos-0.5)/0.25;
	}
	else if (pos == 0.75) {
		len = CalcBStrsValue(bstrs_d, 3, I_NODE);
	}
	// 4/4
	else if ((pos > 0.75) && (pos < 1.0)) {
		vs = CalcBStrsValue(bstrs_d, 3, I_NODE);
		vd = CalcBStrsValue(bstrs_d, 3, J_NODE) - vs;
		len = vs + vd*(pos-0.75)/0.25;
	}
	else if (pos == 1.0) {
		len = CalcBStrsValue(bstrs_d, 3, J_NODE);
	}

	return len;
}

double CStressEngine::GetMaxElemBStrs(T_STRB_D &bstrs_d)
{
	double		len, max=-DBL_MAX;

	for (int i=0;i<4;i++) {
		for (int j=0;j<2;j++) {
			len = CalcBStrsValue(bstrs_d, i, j);
			if (max < len) {
				max = len;
			}
		}
	}

	return max;
}

double CStressEngine::GetMinElemBStrs(T_STRB_D &bstrs_d)
{
	double		len, min=DBL_MAX;

	for (int i=0;i<4;i++) {
		for (int j=0;j<2;j++) {
			len = CalcBStrsValue(bstrs_d, i, j);
			if (min > len) {
				min = len;
			}
		}
	}

	return min;
}

// Beam Stress 데이터를 만든다.
// 현재 Active Element List에 대해 Loop를 돌며
// 1. DB로 부터 해당 Element의 Beam Stress 데이터를 얻고
// 2. Beam Stress에 대한 최대/최소값을 갱신하고
// 3. Beam Stress값 및 해당 Element번호를 CArray에 저장
BOOL CStressEngine::MakeBStrsDataList()
{
	if (CTestEnvMgr::IsTestEnvST(_LSX(ProfilingSTL), _LSX(yes)))
	{
		M_PROFILE('MakeBStrsDataList()');
	}

	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	
	int			i, elem_num;
	double		max_bstrs=-DBL_MAX, min_bstrs=DBL_MAX;
	BOOL		has_content=FALSE;
	T_ELEM_K	elem_key;
	T_ELEM_D	elem_data;
	T_STRB_D	bstrs_d;
	T_STRB_D	bstrs_dm;

	if(!gm->m_bLoadDataSet)return FALSE;
	int nGPSMode = (gm->m_GPSInstruction != -1)? gm->m_GPSInstruction:gm->m_GPSMode;

	gm->m_pMyView->BeginWaitCursor();

	m_BeamKeyList.RemoveAll();
	m_mapBStrsData.RemoveAll();
	m_mapBStrsDataMin.RemoveAll(); 
	elem_num = gm->m_EKeyListActive.GetSize();
	
	for(i=0;i<elem_num;i++) 
	{
		elem_key = gm->m_EKeyListActive[i];
		m_pDoc->m_pAttrCtrl->GetElem(elem_key, elem_data);
		if (!m_pDoc->m_pAttrCtrl->IsBeam(elem_data.eltyp))continue;
		
		// 1. DB로 부터 해당 Element의 Beam Stress 데이터를 얻고
		if((nGPSMode==GPS_COMMAND_BSTRS || nGPSMode==GPS_COMMAND_BSTRSDGRM) && m_nBForcPscPart>0)
		{
			switch (gm->m_LoadMinMaxType) 
			{
			case LOADTYPE_NORMAL:
			case LOADTYPE_MAX:
				if(!m_pDoc->m_pPostCtrl->GetStrbPartNew(elem_key,m_nBForcPscPart,&bstrs_d,NULL,NULL))
				{ gm->m_pMyView->EndWaitCursor(); continue; }
				break;
			case LOADTYPE_MIN:
				if(!m_pDoc->m_pPostCtrl->GetStrbPartNew(elem_key,m_nBForcPscPart,NULL,&bstrs_d,NULL))
				{ gm->m_pMyView->EndWaitCursor(); continue; }
				break;
			case LOADTYPE_ALL:
				if( gm->m_GPSMode==GPS_COMMAND_GIRDERSTRS_DGRM ||
					( gm->m_GPSMode==GPS_COMMAND_BSTRSDGRM && this->m_bMaxMinDgrm) )// Max/Min동시 표현을 위해서..
				{
					if(!m_pDoc->m_pPostCtrl->GetStrbPartNew(elem_key,m_nBForcPscPart,&bstrs_d,&bstrs_dm,NULL)) 
					{ gm->m_pMyView->EndWaitCursor(); continue; }
					MinMaxElemBStrs(elem_key,bstrs_dm,max_bstrs,min_bstrs);
					m_mapBStrsDataMin.SetAt(elem_key,bstrs_dm);
				}
				else
				{
					if(!m_pDoc->m_pPostCtrl->GetStrbPartNew(elem_key,m_nBForcPscPart,NULL,NULL,&bstrs_d)) 
					{ gm->m_pMyView->EndWaitCursor(); continue; }
				}
				break;
			}
		}
		else
		{
			switch (gm->m_LoadMinMaxType) 
			{
			case LOADTYPE_NORMAL:
			case LOADTYPE_MAX:
				if(!m_pDoc->m_pPostCtrl->GetStrbNew(elem_key, &bstrs_d, NULL,NULL,FALSE)) {
					gm->m_pMyView->EndWaitCursor();
					return FALSE;
				}
				break;
			case LOADTYPE_MIN:
				if(!m_pDoc->m_pPostCtrl->GetStrbNew(elem_key, NULL,&bstrs_d, NULL,FALSE)) {
					gm->m_pMyView->EndWaitCursor();
					return FALSE;
				}
				break;
			case LOADTYPE_ALL:
				if( gm->m_GPSMode==GPS_COMMAND_GIRDERSTRS_DGRM ||
					( gm->m_GPSMode==GPS_COMMAND_BSTRSDGRM && this->m_bMaxMinDgrm) )// Max/Min동시 표현을 위해서..
				{
					if(!m_pDoc->m_pPostCtrl->GetStrbNew(elem_key, &bstrs_d, &bstrs_dm,NULL,FALSE)) 
					{
						gm->m_pMyView->EndWaitCursor();
						return FALSE;
					}
					MinMaxElemBStrs(elem_key,bstrs_dm,max_bstrs,min_bstrs);
					m_mapBStrsDataMin.SetAt(elem_key,bstrs_dm);
				}
				else
				{
					if(!m_pDoc->m_pPostCtrl->GetStrbNew(elem_key, NULL,NULL,&bstrs_d,FALSE)) 
					{
						gm->m_pMyView->EndWaitCursor();
						return FALSE;
					}
				}
				break;
			}
		}

		has_content = TRUE;
		
		// 2. Beam Stress에 대한 최대/최소값을 갱신하고
		MinMaxElemBStrs(elem_key,bstrs_d,max_bstrs,min_bstrs);
		m_BeamKeyList.Add(elem_key);
		m_mapBStrsData.SetAt(elem_key,bstrs_d);
	}

	if (!has_content) 
	{
		min_bstrs = max_bstrs = 0.0;
		gm->m_nLgdMaxValKey = 0; 
		gm->m_nLgdMinValKey = 0; 
	}
	
	// 20100518 KIMJM, differnce가 e-16으로 작게 나옴.
	double dTol = M_InitValueCurUnit(1.E-10, N, MM, D_UNITSYS_BASE_STRESS);
	if (dTol > 1.0e-7) dTol = 1.0e-7;   // dTol가 너무 커지는 경우가 있어서 좀더 줄여줌.. // MNET:XXXX-HSSHIM-20130807
	if( fabs(max_bstrs-min_bstrs) < dTol )
		min_bstrs = max_bstrs;

	m_dMaxValue = max_bstrs;
	m_dMinValue = min_bstrs;

	if(fabs(max_bstrs)<fabs(min_bstrs))InitBSfdBmdAdjustFactor(min_bstrs);
	else		                           InitBSfdBmdAdjustFactor(max_bstrs);

	if (m_pContourEngine == NULL) m_pContourEngine = new CContourEngine(min_bstrs, max_bstrs);
	else		                      m_pContourEngine->MakeRankMap(min_bstrs, max_bstrs);

	gm->m_pMyView->EndWaitCursor();

	m_bBStrsDataSet = TRUE;
	return TRUE;
}

BOOL CStressEngine::GetBStrsRangeDataList(double& dMaxRange, double& dMinRange, CArray<UINT,UINT>& aElemKeyList)
{
	aElemKeyList.RemoveAll();

	if (CTestEnvMgr::IsTestEnvST(_LSX(ProfilingSTL), _LSX(yes)))
	{
		M_PROFILE('MakeBStrsScopeDataList()');
	}

	if (m_pContourEngine == NULL) { ASSERT(0); return FALSE;}

	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
		
	int			i, elem_num;
	T_ELEM_K	elem_key;
	T_ELEM_D	elem_data;
	T_STRB_D	bstrs_d;
	T_STRB_D	bstrs_dm;

	if(!gm->m_bLoadDataSet)return FALSE;
	int nGPSMode = (gm->m_GPSInstruction != -1)? gm->m_GPSInstruction:gm->m_GPSMode;

	gm->m_pMyView->BeginWaitCursor();
	
	elem_num = gm->m_EKeyListActive.GetSize();
	for(i=0;i<elem_num;i++) 
	{
		elem_key = gm->m_EKeyListActive[i];
		m_pDoc->m_pAttrCtrl->GetElem(elem_key, elem_data);
		if (!m_pDoc->m_pAttrCtrl->IsBeam(elem_data.eltyp))continue;

		// 1. DB로 부터 해당 Element의 Beam Stress 데이터를 얻고
		if((nGPSMode==GPS_COMMAND_BSTRS || nGPSMode==GPS_COMMAND_BSTRSDGRM) && m_nBForcPscPart>0)
		{
			switch (gm->m_LoadMinMaxType) 
			{
			case LOADTYPE_NORMAL:
			case LOADTYPE_MAX:
				if(!m_pDoc->m_pPostCtrl->GetStrbPartNew(elem_key,m_nBForcPscPart,&bstrs_d,NULL,NULL))
				{ gm->m_pMyView->EndWaitCursor(); continue; }
				break;
			case LOADTYPE_MIN:
				if(!m_pDoc->m_pPostCtrl->GetStrbPartNew(elem_key,m_nBForcPscPart,NULL,&bstrs_d,NULL))
				{ gm->m_pMyView->EndWaitCursor(); continue; }
				break;
			case LOADTYPE_ALL:
				if( gm->m_GPSMode==GPS_COMMAND_GIRDERSTRS_DGRM ||
					( gm->m_GPSMode==GPS_COMMAND_BSTRSDGRM && this->m_bMaxMinDgrm) )// Max/Min동시 표현을 위해서..
				{
					if(!m_pDoc->m_pPostCtrl->GetStrbPartNew(elem_key,m_nBForcPscPart,&bstrs_d,&bstrs_dm,NULL)) 
					{ gm->m_pMyView->EndWaitCursor(); continue; }
					if(!IsWithinRangeElemBStrs(bstrs_dm,dMaxRange,dMinRange)) continue;
				}
				else
				{
					if(!m_pDoc->m_pPostCtrl->GetStrbPartNew(elem_key,m_nBForcPscPart,NULL,NULL,&bstrs_d)) 
					{ gm->m_pMyView->EndWaitCursor(); continue; }
				}
				break;
			}
		}
		else
		{
			switch (gm->m_LoadMinMaxType) 
			{
			case LOADTYPE_NORMAL:
			case LOADTYPE_MAX:
				if(!m_pDoc->m_pPostCtrl->GetStrbNew(elem_key, &bstrs_d, NULL,NULL,FALSE)) {
					gm->m_pMyView->EndWaitCursor();
					return FALSE;
				}
				break;
			case LOADTYPE_MIN:
				if(!m_pDoc->m_pPostCtrl->GetStrbNew(elem_key, NULL,&bstrs_d, NULL,FALSE)) {
					gm->m_pMyView->EndWaitCursor();
					return FALSE;
				}
				break;
			case LOADTYPE_ALL:
				if( gm->m_GPSMode==GPS_COMMAND_GIRDERSTRS_DGRM ||
					( gm->m_GPSMode==GPS_COMMAND_BSTRSDGRM && this->m_bMaxMinDgrm) )// Max/Min동시 표현을 위해서..
				{
					if(!m_pDoc->m_pPostCtrl->GetStrbNew(elem_key, &bstrs_d, &bstrs_dm,NULL,FALSE)) 
					{
						gm->m_pMyView->EndWaitCursor();
						return FALSE;
					}
					if(!IsWithinRangeElemBStrs(bstrs_dm,dMaxRange,dMinRange)) continue;
				}
				else
				{
					if(!m_pDoc->m_pPostCtrl->GetStrbNew(elem_key, NULL,NULL,&bstrs_d,FALSE)) 
					{
						gm->m_pMyView->EndWaitCursor();
						return FALSE;
					}
				}
				break;
			}
		}
		
		// 2. Beam Stress가 최대/최소 범위안에 들어오는가?
		if(!IsWithinRangeElemBStrs(bstrs_d,dMaxRange,dMinRange)) continue;
		aElemKeyList.Add(elem_key);
	}

	gm->m_pMyView->EndWaitCursor();

	return TRUE;
}

// Beam Stress 데이터를 만든다.
// 현재 Active Element List에 대해 Loop를 돌며
// 1. 솔버로부터 해당 Element의 Beam Stress 데이터를 얻고
// 2. Beam Stress에 대한 최대/최소값을 갱신하고
// 3. Beam Stress값 및 해당 Element번호를 CArray에 저장
BOOL CStressEngine::MakeBStrsDetailDataList()
{
	if (CTestEnvMgr::IsTestEnvST(_LSX(ProfilingSTL), _LSX(yes)))
	{
		M_PROFILE('MakeBStrsDetailDataList()');
	}

	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	int			i, elem_num;
	double		max_BVmst=-DBL_MAX, min_BVmst=DBL_MAX;
	BOOL		has_content=FALSE;
	T_ELEM_K	elem_key;
	T_ELEM_D	elem_data;
	T_VMST_D	BVmst_d;
	T_SECT_D  SectD;

	if(!gm->m_bLoadDataSet)return FALSE;
	int nGPSMode = (gm->m_GPSInstruction != -1)? gm->m_GPSInstruction:gm->m_GPSMode;

	gm->m_pMyView->BeginWaitCursor();

	m_BeamKeyList.RemoveAll();
	m_mapBVmstData.RemoveAll();
	int nPoint4EffectiveSect = 0;
	elem_num = gm->m_EKeyListActive.GetSize();

	T_ACTL_D DataActl;
	if(!m_pDoc->m_pAttrCtrl->GetActl(DataActl))DataActl.Initialize();

	if(DataActl.bCalculateBeamStresses == TRUE)
	{
		for(i=0;i<elem_num;i++) 
		{
			elem_key = gm->m_EKeyListActive[i];
			if (!m_pDoc->m_pAttrCtrl2->IsEffectiveBeam(elem_key)) continue;
			m_pDoc->m_pAttrCtrl->GetElem(elem_key, elem_data);
			if (!m_pDoc->m_pAttrCtrl->GetSect(elem_data.elpro,SectD)) { ASSERT(0); continue; }
			nPoint4EffectiveSect = CSectUtil::GetNPoint4EffectiveSect(SectD);

			if(!m_pDoc->m_pPostCtrl->GetVmstNew(elem_key, &BVmst_d, NULL,NULL))
			{
				gm->m_pMyView->EndWaitCursor();
				return FALSE;
			}

			BVmst_d.nPoint4EffectiveSect = nPoint4EffectiveSect;

			has_content = TRUE;

			// 2. Beam Stress에 대한 최대/최소값을 갱신하고
			MinMaxElemBVmst(elem_key,BVmst_d,max_BVmst,min_BVmst);
			m_BeamKeyList.Add(elem_key);
			m_mapBVmstData.SetAt(elem_key,BVmst_d);
		}
	}

	if (!has_content) 
	{
		min_BVmst = max_BVmst = 0.0;
		gm->m_nLgdMaxValKey = 0; 
		gm->m_nLgdMinValKey = 0; 
	}
	
	double dTol = M_InitValueCurUnit(1.E-10, N, MM, D_UNITSYS_BASE_STRESS);
	if (dTol > 1.0e-7) dTol = 1.0e-7;
	if( fabs(max_BVmst-min_BVmst) < dTol )
		min_BVmst = max_BVmst;

	m_dMaxValue = max_BVmst;
	m_dMinValue = min_BVmst;

	if(fabs(max_BVmst)<fabs(min_BVmst))InitBSfdBmdAdjustFactor(min_BVmst);
	else		                           InitBSfdBmdAdjustFactor(max_BVmst);

	if (m_pContourEngine == NULL) m_pContourEngine = new CContourEngine(min_BVmst, max_BVmst);
	else		                      m_pContourEngine->MakeRankMap(min_BVmst, max_BVmst);

	gm->m_pMyView->EndWaitCursor();

	m_bBStrsDataSet = TRUE;
	return TRUE;
}

BOOL CStressEngine::GetBStrsDetailRangeDataList(double& dMaxRange, double& dMinRange, CArray<UINT,UINT>& aElemKeyList)
{
	aElemKeyList.RemoveAll();

	if (CTestEnvMgr::IsTestEnvST(_LSX(ProfilingSTL), _LSX(yes)))
	{
		M_PROFILE('GetBStrsDetailRangeDataList()');
	}

	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	int			i, elem_num;
	T_ELEM_K	elem_key;
	T_ELEM_D	elem_data;
	T_VMST_D	BVmst_d;
	T_SECT_D  SectD;
	
	int nGPSMode = (gm->m_GPSInstruction != -1)? gm->m_GPSInstruction:gm->m_GPSMode;

	gm->m_pMyView->BeginWaitCursor();

	int nPoint4EffectiveSect = 0;
	elem_num = gm->m_EKeyListActive.GetSize();

	T_ACTL_D DataActl;
	if(!m_pDoc->m_pAttrCtrl->GetActl(DataActl))DataActl.Initialize();

	if(DataActl.bCalculateBeamStresses == TRUE)
	{
		for(i=0;i<elem_num;i++) 
		{
			elem_key = gm->m_EKeyListActive[i];
			if (!m_pDoc->m_pAttrCtrl2->IsEffectiveBeam(elem_key)) continue;
			m_pDoc->m_pAttrCtrl->GetElem(elem_key, elem_data);
			if (!m_pDoc->m_pAttrCtrl->GetSect(elem_data.elpro,SectD)) { ASSERT(0); continue; }
			nPoint4EffectiveSect = CSectUtil::GetNPoint4EffectiveSect(SectD);

			if(!m_pDoc->m_pPostCtrl->GetVmstNew(elem_key, &BVmst_d, NULL,NULL))
			{
				gm->m_pMyView->EndWaitCursor();
				return FALSE;
			}

			BVmst_d.nPoint4EffectiveSect = nPoint4EffectiveSect;

			// 2. Beam Stress가 최대/최소 범위안에 들어오는가?
			if(!IsWithinRangeElemBVmst(elem_key,BVmst_d,dMaxRange,dMinRange)) continue;
			aElemKeyList.Add(elem_key);
		}
	}

	gm->m_pMyView->EndWaitCursor();
	
	return TRUE;
}

void CStressEngine::MinMaxElemBVmst(T_ELEM_K elem_key,T_VMST_D &BVmstD,double& max_vmst,double& min_vmst)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	double len = GetMaxElemBVmst(BVmstD);
	if (len > max_vmst) 
	{
		max_vmst = len;
		gm->m_nLgdMaxValKey=elem_key;
	}
	len = GetMinElemBVmst(BVmstD);
	if (len < min_vmst) 
	{
		min_vmst = len;
		gm->m_nLgdMinValKey=elem_key;
	}
}

BOOL CStressEngine::IsWithinRangeElemBVmst(T_ELEM_K elem_key,T_VMST_D &BVmstD,double& max_vmst,double& min_vmst)
{
	double len_max;
	double len_min;

	for (int i=0;i<4;i++)
	{
		len_max = CalcBVmstValue(BVmstD, i, I_NODE);
		len_min = CalcBVmstValue(BVmstD, i, J_NODE);

		if(len_min>len_max)
		{
			double len_temp = len_max;
			len_max = len_min;
			len_min = len_temp;
		}

		if (len_min <= min_vmst && len_max >= max_vmst)
			return TRUE;
		if (len_min >= min_vmst && len_min <= max_vmst)
			return TRUE;
		if (len_max >= min_vmst && len_max <= max_vmst)
			return TRUE;
	}

	return FALSE;
}

void CStressEngine::MinMaxElemBStrs(T_ELEM_K elem_key,T_STRB_D &StrbD,double& max_strb,double& min_strb)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	
	double len = GetMaxElemBStrs(StrbD);
	if (len > max_strb) 
	{
		max_strb = len;
		m_KeyMaxBStrsElem = elem_key;
		gm->m_nLgdMaxValKey=elem_key;
	}
	len = GetMinElemBStrs(StrbD);
	if (len < min_strb) 
	{
		min_strb = len;
		gm->m_nLgdMinValKey=elem_key;
	}
}

BOOL CStressEngine::IsWithinRangeElemBStrs(T_STRB_D &StrbD,double& max_strb,double& min_strb)
{
	double len_max;
	double len_min;

	for (int i=0;i<4;i++)
	{
		len_max = CalcBStrsValue(StrbD, i, I_NODE);
		len_min = CalcBStrsValue(StrbD, i, J_NODE);

		if(len_min>len_max)
		{
			double len_temp = len_max;
			len_max = len_min;
			len_min = len_temp;
		}

		if (len_min <= min_strb && len_max >= max_strb)
			return TRUE;
		if (len_min >= min_strb && len_min <= max_strb)
			return TRUE;
		if (len_max >= min_strb && len_max <= max_strb)
			return TRUE;
	}

	return FALSE;
}

void CStressEngine::DoBVmstPolyContour(CDC *pDC,CList <C3DPoint, C3DPoint> *Vertex,CArray <BOOL, BOOL> *EdgeFlag,CArray <T_NODE_K, T_NODE_K> *VertexNode,T_ELEM_D &ElemData,T_VMST_D &BVmstD)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	int			i, vertex_num=Vertex->GetCount();
	double		bvmst_val[4], dx1, dy1, dz1, dx2, dy2, dz2;
	BOOL		ef[4];
	POSITION	pos;
	C3DPoint	p[4];
	T_NODE_K  NodeK[4];
	CList <C3DPoint, C3DPoint>	sub_vertex;

	NodeK[0] = VertexNode->GetAt(0);
	NodeK[1] = VertexNode->GetAt(1);
	NodeK[2] = VertexNode->GetAt(2);
	if(vertex_num==4)
		NodeK[3] = VertexNode->GetAt(3);

	// polygon이 i단 쪽에 있을 경우
	if((NodeK[0]==NodeK[1]) &&  (NodeK[0]==NodeK[2]) && (NodeK[0]==ElemData.elnod[0])) 
	{
		for (i=0;i<vertex_num;i++) 
		{
			bvmst_val[i] = CalcBVmstValue(BVmstD, 0, I_NODE);
			if(gm->m_AnimEngine.m_bAnimateContour)
				bvmst_val[i] = m_pContourEngine->GetSubFrameValue(bvmst_val[i], gm->m_AnimEngine.GetAnimationFactor(TRUE));
			ef[i] = EdgeFlag->GetAt(i);
		}
		DoSubPolyContour(pDC, bvmst_val, Vertex, ef, TRUE);
	}
	// polygon이 j단 쪽에 있을 경우
	else if((NodeK[0]==NodeK[1]) && (NodeK[0]==NodeK[2]) && (NodeK[0]==ElemData.elnod[1])) 
	{
		for (i=0;i<vertex_num;i++) 
		{
			bvmst_val[i] = CalcBVmstValue(BVmstD, 3, J_NODE);
			if(gm->m_AnimEngine.m_bAnimateContour)
				bvmst_val[i] = m_pContourEngine->GetSubFrameValue(bvmst_val[i], gm->m_AnimEngine.GetAnimationFactor(TRUE));
			ef[i] = EdgeFlag->GetAt(i);
		}
		DoSubPolyContour(pDC, bvmst_val, Vertex, ef, TRUE);
	}
	// polygon이 i, j단에 걸쳐 있을 경우
	else 
	{
		if(vertex_num!=4)return; 
		if(NodeK[0]==NodeK[1] && NodeK[2]==NodeK[3] )
		{
			pos = Vertex->GetHeadPosition();
			for(i=0;i<4;i++) p[i] = Vertex->GetNext(pos);
		}
		else if(NodeK[0]==NodeK[3] && NodeK[1]==NodeK[2] )
		{
			C3DPoint	tp[4];  
			pos = Vertex->GetHeadPosition();
			for(i=0;i<4;i++) tp[i] = Vertex->GetNext(pos);
			p[0] = tp[0];
			p[1] = tp[3];
			p[2] = tp[2];
			p[3] = tp[1];
		}
		else 
		{
			ASSERT(FALSE); 
			pos = Vertex->GetHeadPosition();
			for(i=0;i<4;i++)p[i] = Vertex->GetNext(pos);
		}

		dx1 = (p[3].x-p[0].x) / 4.0;
		dy1 = (p[3].y-p[0].y) / 4.0;
		dz1 = (p[3].z-p[0].z) / 4.0;

		dx2 = (p[2].x-p[1].x) / 4.0;
		dy2 = (p[2].y-p[1].y) / 4.0;
		dz2 = (p[2].z-p[1].z) / 4.0;

		p[3] = p[0];
		p[2] = p[1];
		for (i=0;i<4;i++) 
		{
			p[0] = p[3];
			p[1] = p[2];
			p[3].x = p[0].x + dx1;
			p[3].y = p[0].y + dy1;
			p[3].z = p[0].z + dz1;
			p[2].x = p[1].x + dx2;
			p[2].y = p[1].y + dy2;
			p[2].z = p[1].z + dz2;
			sub_vertex.AddTail(p[0]);
			sub_vertex.AddTail(p[1]);
			sub_vertex.AddTail(p[2]);
			sub_vertex.AddTail(p[3]);

			bvmst_val[0] = bvmst_val[1] = CalcBVmstValue(BVmstD, i, I_NODE);
			bvmst_val[2] = bvmst_val[3] = CalcBVmstValue(BVmstD, i, J_NODE);
			if (gm->m_AnimEngine.m_bAnimateContour) 
			{
				bvmst_val[0] = m_pContourEngine->GetSubFrameValue(bvmst_val[0], gm->m_AnimEngine.GetAnimationFactor(TRUE));
				bvmst_val[1] = m_pContourEngine->GetSubFrameValue(bvmst_val[1], gm->m_AnimEngine.GetAnimationFactor(TRUE));
				bvmst_val[2] = m_pContourEngine->GetSubFrameValue(bvmst_val[2], gm->m_AnimEngine.GetAnimationFactor(TRUE));
				bvmst_val[3] = m_pContourEngine->GetSubFrameValue(bvmst_val[3], gm->m_AnimEngine.GetAnimationFactor(TRUE));
			}

			if(i == 0)ef[0] = EdgeFlag->GetAt(0);
			else			ef[0] = FALSE;
			ef[1] = EdgeFlag->GetAt(1);
			if(i == 3)ef[2] = EdgeFlag->GetAt(2);
			else      ef[2] = FALSE;
			ef[3] = EdgeFlag->GetAt(3);

			DoSubPolyContour(pDC, bvmst_val, &sub_vertex, ef, TRUE);
			sub_vertex.RemoveAll();
		}
	}

	// Fill+Outline의 경우 Contour를 수행하기 전의 Polygon의 Outline을 그림.
	if(gm->m_DOPT.DR.m_RenderFlag == 3 || gm->m_DOPT.DR.m_RenderFlag == 2)
		gm->GPSDrawPolygonEdge(pDC, Vertex, EdgeFlag);
}

void CStressEngine::DoBVmstPolyContourReal(CDC *pDC,CList <C3DPoint, C3DPoint> *Vertex,CArray <BOOL, BOOL> *EdgeFlag,T_VMST_D &BVmstD,CArray <double, double> *PosList)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	int			  i, vertex_num=Vertex->GetCount();
	double		val[4];
	BOOL		  ef[4];

	if(vertex_num == 3) 
	{

	}
	else if(vertex_num == 4) 
	{
		for(i=0;i<4;i++) 
		{
			val[i] = CalcBVmstValuePos(BVmstD, PosList->GetAt(i));
			val[i] = max(val[i], m_pContourEngine->m_MinRange);
			val[i] = min(val[i], m_pContourEngine->m_MaxRange);
			if(gm->m_AnimEngine.m_bAnimateContour)val[i] = m_pContourEngine->GetSubFrameValue(val[i], gm->m_AnimEngine.GetAnimationFactor(TRUE));
			ef[i] = EdgeFlag->GetAt(i);
		}
		DoSubPolyContour(pDC, val, Vertex, ef, TRUE);
	}

	if(gm->m_DOPT.DR.m_RenderFlag == 3 || gm->m_DOPT.DR.m_RenderFlag == 2)
		gm->GPSDrawPolygonEdge(pDC, Vertex, EdgeFlag);
}

#if defined(__OLD_OUTPUT_VALUE)
void CStressEngine::OutputBVmstNumbers(CDC* pDC)
{
	T_ACTL_D DataActl;
	if (!m_pDoc->m_pAttrCtrl->GetActl(DataActl))DataActl.Initialize();
	if (DataActl.bCalculateBeamStresses == FALSE) return;

	I_GPSModel* gm = (I_GPSModel*)m_pGPSModel;
	int nGPSMode = (gm->m_GPSInstruction != -1) ? gm->m_GPSInstruction : gm->m_GPSMode;

	int				i, j, elem_num, slope;
	T_ELEM_K		ekey;
	T_VMST_D		VmstD;
	T_SECT_D    SectD;
	C3DPoint		node3D_i, node3D_j, DrawPoint;
	CPoint			text_p, node_2d_i, node_2d_j;
	TCHAR			fmt_str[10], text_str[512];
	CFont			ft, * old_ft;
	BOOL			fl_bak, is_inverse;

	POSITION		pos;
	CArray <CList <C3DPoint, C3DPoint>*, CList <C3DPoint, C3DPoint>*>		polygon_list;
	CArray <CArray <BOOL, BOOL>*, CArray <BOOL, BOOL>*>					edge_list;

	if (!m_bBStrsDataSet)
		return;

	if (gm->m_DOPT.TX.m_bNumberOpaque)
		pDC->SetBkMode(OPAQUE);
	else
		pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
	pDC->SetBkColor(gm->m_DOPT.TX.m_NumberBackCol);
	pDC->SetTextAlign(TA_CENTER | TA_BOTTOM);

	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);

	fl_bak = gm->m_DOPT.DR.m_bFrameLine;
	gm->m_DOPT.DR.m_bFrameLine = TRUE;

	if (gm->m_DOPT.TX.m_bNumberSelOnly)
	{
	}
	else
	{
		BOOL bGrpFltMode = gm->m_pGPSCtrl->IsGroupFilterMode();
		if (!bGrpFltMode)elem_num = gm->m_EKeyListActive.GetSize();
		else            elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize();

		for (i = 0; i < elem_num; i++)
		{
			if (!bGrpFltMode)ekey = gm->m_EKeyListActive[i];
			else            ekey = gm->m_pDispFilter->m_aGrpEKey[i];

			if (!gm->m_pGPSCtrl->IsActiveElem(ekey))continue;
			if (!m_pDoc->m_pAttrCtrl2->IsEffectiveBeam(ekey))continue;

			if (m_bDeformedShapeContour)
			{
				gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list);
			}
			else
			{
				gm->GetShapeElement(ekey, polygon_list, &edge_list);
			}

			pos = polygon_list[0]->GetHeadPosition();
			node3D_i = polygon_list[0]->GetNext(pos);
			node3D_j = polygon_list[0]->GetNext(pos);
			if (gm->m_bVirtualMode)
			{
				node_2d_i = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_i);
				node_2d_j = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_j);
			}
			else
			{
				node_2d_i = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_i);
				node_2d_j = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_j);
			}

			if ((node_2d_i.x >= 0 && node_2d_i.y >= 0 && node_2d_j.x >= 0 && node_2d_j.y >= 0))
			{
				slope = (int)(atan2(node_2d_i.y - node_2d_j.y, node_2d_j.x - node_2d_i.x) * 1800.0 / 3.14159);
				slope = (slope + 3600) % 3600;
				if ((900 < slope) && (slope <= 2700))
				{
					slope = (slope + 1800) % 3600;
					is_inverse = TRUE;
				}
				else
				{
					is_inverse = FALSE;
				}

				gm->SetNumberFontOrientation(slope);
				ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
				old_ft = (CFont*)pDC->SelectObject(&ft);

				if (!GetBeamStressEffective(ekey, VmstD)) VmstD.Initialize();

				if (gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
				{
					double dLimit = (m_dMaxValue - m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;
					double dBValue;

					for (int n = 0; n < 3; n++)
					{
						if (n == 0) // I단 
						{
							if (!m_bBStrsOutputI) continue;

							if (is_inverse)
								pDC->SetTextAlign(TA_RIGHT | TA_BOTTOM);
							else
								pDC->SetTextAlign(TA_LEFT | TA_BOTTOM);
							DrawPoint = node3D_i;
							dBValue = CalcBVmstValue(VmstD, 0, I_NODE);

						}
						else if (n == 1)// CNT or MAX
						{
							if (!(m_bBStrsOutputC || m_bBStrsOutputMax)) continue;

							pDC->SetTextAlign(TA_CENTER | TA_BOTTOM);
							DrawPoint.x = (node3D_i.x + node3D_j.x) / 2.0;
							DrawPoint.y = (node3D_i.y + node3D_j.y) / 2.0;
							DrawPoint.z = (node3D_i.z + node3D_j.z) / 2.0;

							if (m_bBStrsOutputMax)
								dBValue = CalcBVmstValue(VmstD);
							else
								dBValue = CalcBVmstValue(VmstD, 1, J_NODE);

						}
						else if (n == 2)// J단 
						{
							if (!m_bBStrsOutputJ) continue;

							if (is_inverse)
								pDC->SetTextAlign(TA_LEFT | TA_BOTTOM);
							else
								pDC->SetTextAlign(TA_RIGHT | TA_BOTTOM);
							DrawPoint = node3D_j;
							dBValue = CalcBVmstValue(VmstD, 3, J_NODE);
						}

						switch (gm->m_DOPT.TX.m_nOutputMinMaxType)
						{
						case 0: // Min & Max
							if ((m_dMaxValue - dBValue) <= dLimit)
								DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, dBValue);
							else if ((dBValue - m_dMinValue) <= dLimit)
								DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, dBValue);
							break;
						case 1: // Abs Max
							if (fabs(m_dMaxValue) >= fabs(m_dMinValue))
							{
								if (fabs(m_dMaxValue) - fabs(dBValue) <= dLimit)
									DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, dBValue);
							}
							else
							{
								if (fabs(m_dMinValue) - fabs(dBValue) <= dLimit)
									DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, dBValue);
							}
							break;
						case 2: // Max
							if ((m_dMaxValue - dBValue) <= dLimit)
								DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, dBValue);
							break;
						case 3: // Min
							if ((dBValue - m_dMinValue) <= dLimit)
								DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, dBValue);
							break;
						}
					}
					//////////////////////////////////////////////////////////////////////////////////////
				}
				else
				{
					if (m_bBStrsOutputI)
					{
						pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorI);
						if (is_inverse)
							pDC->SetTextAlign(TA_RIGHT | TA_BOTTOM);
						else
							pDC->SetTextAlign(TA_LEFT | TA_BOTTOM);
						text_p.x = (int)node_2d_i.x;
						text_p.y = (int)node_2d_i.y;
						_stprintf(text_str, fmt_str, CalcBVmstValue(VmstD, 0, I_NODE));
						pDC->TextOut(text_p.x, text_p.y, text_str);
					}
					if (m_bBStrsOutputJ)
					{
						pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorJ);
						if (is_inverse)
							pDC->SetTextAlign(TA_LEFT | TA_BOTTOM);
						else
							pDC->SetTextAlign(TA_RIGHT | TA_BOTTOM);
						text_p.x = (int)node_2d_j.x;
						text_p.y = (int)node_2d_j.y;
						_stprintf(text_str, fmt_str, CalcBVmstValue(VmstD, 3, J_NODE));
						pDC->TextOut(text_p.x, text_p.y, text_str);
					}
					if (m_bBStrsOutputC)
					{
						pDC->SetTextAlign(TA_CENTER | TA_BOTTOM);
						text_p.x = (int)((node_2d_i.x + node_2d_j.x) / 2.0);
						text_p.y = (int)((node_2d_i.y + node_2d_j.y) / 2.0);
						_stprintf(text_str, fmt_str, CalcBVmstValue(VmstD, 2, I_NODE));
						pDC->TextOut(text_p.x, text_p.y, text_str);
					}
					if (m_bBStrsOutputMax)
					{
						pDC->SetTextAlign(TA_CENTER | TA_BOTTOM);
						text_p.x = (int)((node_2d_i.x + node_2d_j.x) / 2.0);
						text_p.y = (int)((node_2d_i.y + node_2d_j.y) / 2.0);
						_stprintf(text_str, fmt_str, CalcBVmstValue(VmstD));
						pDC->TextOut(text_p.x, text_p.y, text_str);
					}
				}
				pDC->SelectObject(old_ft);
				ft.DeleteObject();
			}

			for (j = 0; j < polygon_list.GetSize(); j++)
			{
				polygon_list[j]->RemoveAll();
				delete polygon_list[j];
				edge_list[j]->RemoveAll();
				delete edge_list[j];
			}
			polygon_list.RemoveAll();
			edge_list.RemoveAll();
		}
	}

	gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}
#else
void CStressEngine::OutputBVmstNumbers(CDC *pDC)
{
	T_ACTL_D DataActl;
	if(!m_pDoc->m_pAttrCtrl->GetActl(DataActl))DataActl.Initialize();
	if(DataActl.bCalculateBeamStresses==FALSE) return;

	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;
	int nGPSMode = (gm->m_GPSInstruction != -1)? gm->m_GPSInstruction:gm->m_GPSMode;

	int				i, j, elem_num, slope;
	T_ELEM_K		ekey;
	T_VMST_D		VmstD;
	T_SECT_D    SectD;
	C3DPoint		node3D_i, node3D_j,DrawPoint;
	CPoint			text_p,node_2d_i, node_2d_j;
	TCHAR			fmt_str[10], text_str[512];
	CFont			ft, *old_ft;
	BOOL			fl_bak, is_inverse;

	POSITION		pos;
	CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray <CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					edge_list;

	if (!m_bBStrsDataSet)
		return;

	GPostTextOut TextOutModel;
	TextOutModel.SetDC(pDC);
	TextOutModel.StartBeamStressEquivVal();
	TextOutModel.SettingBeamStressEquiv(gm);

	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);

	fl_bak = gm->m_DOPT.DR.m_bFrameLine;
	gm->m_DOPT.DR.m_bFrameLine = TRUE;

	if (gm->m_DOPT.TX.m_bNumberSelOnly) 
	{
	}
	else 
	{
		BOOL bGrpFltMode=gm->m_pGPSCtrl->IsGroupFilterMode();
		if(!bGrpFltMode)elem_num = gm->m_EKeyListActive.GetSize();
		else            elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize(); 

		for (i=0;i<elem_num;i++) 
		{
			if(!bGrpFltMode)ekey = gm->m_EKeyListActive[i];
			else            ekey = gm->m_pDispFilter->m_aGrpEKey[i]; 

			if(!gm->m_pGPSCtrl->IsActiveElem(ekey))continue;
			if(!m_pDoc->m_pAttrCtrl2->IsEffectiveBeam(ekey))continue;

			if(m_bDeformedShapeContour) 
			{
				gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list);
			}
			else 
			{
				gm->GetShapeElement(ekey, polygon_list, &edge_list);
			}

			pos = polygon_list[0]->GetHeadPosition();
			node3D_i = polygon_list[0]->GetNext(pos);
			node3D_j = polygon_list[0]->GetNext(pos);
			if(gm->m_bVirtualMode) 
			{
				node_2d_i = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_i);
				node_2d_j = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_j);
			}
			else 
			{
				node_2d_i = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_i);
				node_2d_j = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_j);
			}

			if((node_2d_i.x >= 0 && node_2d_i.y >= 0 && node_2d_j.x >= 0 && node_2d_j.y >= 0))
			{
				slope = (int) (atan2(node_2d_i.y-node_2d_j.y, node_2d_j.x-node_2d_i.x)*1800.0/3.14159);
				slope = (slope+3600) % 3600;
				if ((900<slope) && (slope<=2700)) 
				{
					slope = (slope+1800)%3600;
					is_inverse = TRUE;
				}
				else 
				{
					is_inverse = FALSE;
				}

				TextOutModel.Font4BeamStressEquiv(gm, slope);
	
				if(!GetBeamStressEffective(ekey, VmstD)) VmstD.Initialize();

				if(gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
				{
					double dLimit = (m_dMaxValue-m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;
					double dBValue;

					for(int n=0; n<3; n++)
					{
						if(n==0) // I단 
						{
							if (!m_bBStrsOutputI) continue;

							if (is_inverse)
								TextOutModel.AlignTextBot(TA_RIGHT);
							else
								TextOutModel.AlignTextBot(TA_LEFT);
							DrawPoint = node3D_i;
							dBValue = CalcBVmstValue(VmstD, 0, I_NODE);

						}
						else if(n==1)// CNT or MAX
						{			  
							if (!(m_bBStrsOutputC||m_bBStrsOutputMax)) continue;

							TextOutModel.AlignTextBot(TA_CENTER);
							DrawPoint.x = (node3D_i.x + node3D_j.x)/2.0;
							DrawPoint.y = (node3D_i.y + node3D_j.y)/2.0;
							DrawPoint.z = (node3D_i.z + node3D_j.z)/2.0;

							if (m_bBStrsOutputMax) 
								dBValue = CalcBVmstValue(VmstD);
							else
								dBValue = CalcBVmstValue(VmstD, 1, J_NODE);

						}
						else if(n==2)// J단 
						{			  
							if (!m_bBStrsOutputJ) continue;
							if (is_inverse)
								TextOutModel.AlignTextBot(TA_LEFT);
							else
								TextOutModel.AlignTextBot(TA_RIGHT);
							DrawPoint = node3D_j;
							dBValue = CalcBVmstValue(VmstD, 3, J_NODE);
						}

						switch(gm->m_DOPT.TX.m_nOutputMinMaxType)
						{
						case 0: // Min & Max
							if((m_dMaxValue-dBValue) <= dLimit)
								DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,dBValue);
							else if((dBValue-m_dMinValue) <= dLimit)
								DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,dBValue);
							break;
						case 1: // Abs Max
							if(fabs(m_dMaxValue) >= fabs(m_dMinValue))
							{
								if( fabs(m_dMaxValue)-fabs(dBValue) <= dLimit)
									DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dBValue);
							}
							else
							{
								if( fabs(m_dMinValue)-fabs(dBValue) <= dLimit)
									DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dBValue);
							}
							break;
						case 2: // Max
							if((m_dMaxValue-dBValue) <= dLimit)
								DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,dBValue);
							break;
						case 3: // Min
							if((dBValue-m_dMinValue) <= dLimit)
								DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,dBValue);
							break;
						}
					}
					//////////////////////////////////////////////////////////////////////////////////////
				}      
				else      
				{
					if(m_bBStrsOutputI) 
					{
						text_p.x = (int) node_2d_i.x;
						text_p.y = (int) node_2d_i.y;
						_stprintf(text_str, fmt_str, CalcBVmstValue(VmstD, 0, I_NODE));
						if (is_inverse)
							TextOutModel.TextOutBeamStressEquiv(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorI, TA_RIGHT);
						else
							TextOutModel.TextOutBeamStressEquiv(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorI, TA_LEFT);
					}
					if(m_bBStrsOutputJ) 
					{
						text_p.x = (int) node_2d_j.x;
						text_p.y = (int) node_2d_j.y;
						_stprintf(text_str, fmt_str, CalcBVmstValue(VmstD, 3, J_NODE));
						if (is_inverse)
							TextOutModel.TextOutBeamStressEquiv(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorJ, TA_LEFT);
						else
							TextOutModel.TextOutBeamStressEquiv(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorJ, TA_RIGHT);
					}
					if(m_bBStrsOutputC) 
					{
						text_p.x = (int) ((node_2d_i.x+node_2d_j.x)/2.0);
						text_p.y = (int) ((node_2d_i.y+node_2d_j.y)/2.0);
						_stprintf(text_str, fmt_str, CalcBVmstValue(VmstD, 2, I_NODE));
						TextOutModel.AlignTextBot(TA_CENTER);
						TextOutModel.TextOutBeamStressEquiv(text_p.x, text_p.y, text_str);
					}
					if(m_bBStrsOutputMax) 
					{
						text_p.x = (int) ((node_2d_i.x+node_2d_j.x)/2.0);
						text_p.y = (int) ((node_2d_i.y+node_2d_j.y)/2.0);
						_stprintf(text_str, fmt_str, CalcBVmstValue(VmstD));
						TextOutModel.AlignTextBot(TA_CENTER);
						TextOutModel.TextOutBeamStressEquiv(text_p.x, text_p.y, text_str);	
					}
				}
				TextOutModel.DeleteFont();
			}

			for(j=0;j<polygon_list.GetSize();j++) 
			{
				polygon_list[j]->RemoveAll();
				delete polygon_list[j];
				edge_list[j]->RemoveAll();
				delete edge_list[j];
			}
			polygon_list.RemoveAll();
			edge_list.RemoveAll();
		}
	}
	TextOutModel.EndBeamStressEquivVal();
	gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}
#endif

void CStressEngine::DoBVmstLineContour(CDC *pDC, CList <C3DPoint, C3DPoint> *Vertex, int nPolyNum ,T_VMST_D &BVmstVal)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	int					i;
	double			dx, dy, dz, i_val, j_val;
	POSITION		pos=Vertex->GetHeadPosition();
	C3DPoint		p[5];
	CArray <C3DPoint, C3DPoint>		rvtx_list;
	CArray <double, double>			rval_list;

	p[0] = Vertex->GetNext(pos);
	p[4] = Vertex->GetNext(pos);

	// Line이지만 Polygon의 Outline이다.
	// Composite Section의 Concrete부분 
	if( nPolyNum>1 )
	{
		CPen pen,*pOldPen;
		if(gm->m_DOPT.DR.m_bFrameLine) // wire frame
			pen.CreatePen(PS_SOLID, gm->m_nLineWidth*1.7, gm->m_DOPT.CL.m_InactiveCol);
		else 
			pen.CreatePen(PS_SOLID, gm->m_nLineWidth, gm->m_DOPT.CL.m_InactiveCol);
		pOldPen = pDC->SelectObject(&pen);

		if(gm->m_bVirtualMode)
			gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, p[0], p[4]);
		else 
			gm->m_pGPSCtrl->DrawLine3D(pDC, p[0], p[4]);

		pDC->SelectObject(pOldPen);
		pen.DeleteObject();
		return;  
	}

	dx = (p[4].x-p[0].x) / 4.0;
	dy = (p[4].y-p[0].y) / 4.0;
	dz = (p[4].z-p[0].z) / 4.0;
	for (i=1;i<4;i++) {
		p[i].x = p[0].x + dx*((double) i);
		p[i].y = p[0].y + dy*((double) i);
		p[i].z = p[0].z + dz*((double) i);
	}

	for (i=0;i<4;i++) {
		i_val = CalcBVmstValue(BVmstVal, i, I_NODE);
		j_val = CalcBVmstValue(BVmstVal, i, J_NODE);
		if (gm->m_AnimEngine.m_bAnimateContour) {
			i_val = m_pContourEngine->GetSubFrameValue(i_val, gm->m_AnimEngine.GetAnimationFactor(TRUE));
			j_val = m_pContourEngine->GetSubFrameValue(j_val, gm->m_AnimEngine.GetAnimationFactor(TRUE));
		}
		if (i_val > j_val) {
			rvtx_list.Add(p[i]);
			rval_list.Add(i_val);
			m_pContourEngine->GetRankVertices(p[i], p[i+1], i_val, j_val, rvtx_list, rval_list, NULL);
			rvtx_list.Add(p[i+1]);
			rval_list.Add(j_val);
		}
		else {
			rvtx_list.Add(p[i+1]);
			rval_list.Add(j_val);
			m_pContourEngine->GetRankVertices(p[i+1], p[i], j_val, i_val, rvtx_list, rval_list, NULL);
			rvtx_list.Add(p[i]);
			rval_list.Add(i_val);
		}

		//DrawContourLine(pDC, rvtx_list, rval_list);
		//DrawContourLine(pDC, rvtx_list, rval_list,gm->m_LnWd.nElemWire);
		DrawContourLine(pDC, rvtx_list, rval_list,gm->m_DOPT.DR.nElemWire);

		rvtx_list.RemoveAll();
		rval_list.RemoveAll();
	}
}

void CStressEngine::DoBVmstLineContourReal(CDC *pDC, CList <C3DPoint, C3DPoint> *Vertex, int nPolyNum,T_VMST_D &BVmstVal, CArray <double, double> *PosList)
{
	I_GPSModel  *gm=(I_GPSModel *)m_pGPSModel;
	double			i_val, j_val;
	C3DPoint		i_pos, j_pos;
	POSITION		pos=Vertex->GetHeadPosition();
	CArray <C3DPoint, C3DPoint> rvtx_list;
	CArray <double, double>			rval_list;

	i_pos = Vertex->GetNext(pos);
	j_pos = Vertex->GetNext(pos);
	i_val = CalcBVmstValuePos(BVmstVal, PosList->GetAt(0));
	i_val = max(i_val, m_pContourEngine->m_MinRange);
	i_val = min(i_val, m_pContourEngine->m_MaxRange);
	j_val = CalcBVmstValuePos(BVmstVal, PosList->GetAt(1));
	j_val = max(j_val, m_pContourEngine->m_MinRange);
	j_val = min(j_val, m_pContourEngine->m_MaxRange);

	if(gm->m_AnimEngine.m_bAnimateContour) 
	{
		i_val = m_pContourEngine->GetSubFrameValue(i_val, gm->m_AnimEngine.GetAnimationFactor(TRUE));
		j_val = m_pContourEngine->GetSubFrameValue(j_val, gm->m_AnimEngine.GetAnimationFactor(TRUE));
	}

	if(i_val > j_val) 
	{
		rvtx_list.Add(i_pos);	rval_list.Add(i_val);
		m_pContourEngine->GetRankVertices(i_pos, j_pos, i_val, j_val, rvtx_list, rval_list, NULL);
		rvtx_list.Add(j_pos);	rval_list.Add(j_val);
	}
	else 
	{
		rvtx_list.Add(j_pos);	rval_list.Add(j_val);
		m_pContourEngine->GetRankVertices(j_pos, i_pos, j_val, i_val, rvtx_list, rval_list, NULL);
		rvtx_list.Add(i_pos);	rval_list.Add(i_val);
	}

	// Line이지만 Polygon의 Outline이다.
	// Composite Section의 Concrete부분 
	if(nPolyNum>1 && !gm->m_DOPT.DR.m_bFrameLine)
	{
		C3DPoint pt1,pt2;
		CPen pen,*pOldPen;
		if(gm->m_DOPT.DR.m_bFrameLine) // wire frame
			pen.CreatePen(PS_SOLID, gm->m_nLineWidth*1.7, gm->m_DOPT.CL.m_InactiveCol);
		else 
			pen.CreatePen(PS_SOLID, gm->m_nLineWidth, gm->m_DOPT.CL.m_InactiveCol);
		pOldPen = pDC->SelectObject(&pen);

		for(int i=0; i<rvtx_list.GetSize()-1; i++)
		{
			pt1 = rvtx_list[i];
			pt2 = rvtx_list[i+1];
			if(gm->m_bVirtualMode)
				gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, pt1, pt2);
			else 
				gm->m_pGPSCtrl->DrawLine3D(pDC, pt1, pt2);
		}
		pDC->SelectObject(pOldPen);
		pen.DeleteObject();
		return;   
	}
	DrawContourLine(pDC, rvtx_list, rval_list,gm->m_DOPT.DR.nElemWire);

	rvtx_list.RemoveAll();
	rval_list.RemoveAll();
}

////////////////////////////////////////////////////////////////////////////////////////
// Routines for Drawing Beam Member Stress Contour                 ////////////////////
////////////////////////////////////////////////////////////////////////////////////////

void CStressEngine::DrawBStrsContour(CDC *pDC)
{
	I_GPSModel	*gm=(I_GPSModel *)m_pGPSModel;
	T_MIRE_K mkey;
		
	int			  i, elem_num;
	T_ELEM_D	elem_d;
	CPen		  elem_pen, *old_pen;
	CArray<int, int>				    type_list;
	CArray<GRE_Atom, GRE_Atom&>	atom_list;
	BOOL bEscapePressed = FALSE;

	/*
	if(!gm->m_bContour) 
	{
		gm->GPSDrawOriginal(pDC);
		return;
	}
	*/

	if(m_bDeformedShapeContour) 
	{
		if(gm->m_pDeformEngine == NULL)return;
		type_list.Add(gm->m_MinOTID + OBJECT_TYPE_DEFORMED);
	}
	else 
	{
		type_list.Add(gm->m_MinOTID + OBJECT_TYPE_ORIGINAL);
	}

	elem_pen.CreatePen(PS_SOLID, gm->m_DOPT.DR.nElemHddn, m_pContourEngine->m_ElemColor);
	old_pen = pDC->SelectObject(&elem_pen);

	T_ACTL_D DataActl;
	if(!m_pDoc->m_pAttrCtrl->GetActl(DataActl))DataActl.Initialize();

	gm->m_pGPSCtrl->GetZSortedList(type_list, gm->m_EKeyListVisible_Mirror, atom_list);
	elem_num = atom_list.GetSize();
	for (i=0;i<elem_num;i++) 
	{
		if(gm->m_pGPSCtrl->WatchEscKeyPress()) return;
		if(gm->m_pGPSCtrl->IsZoomAllState() ||
			 gm->m_pGPSCtrl->IsObjectInClientWindow(atom_list[i].m_OType, atom_list[i].m_OKey))
		{
			mkey.keymap = atom_list[i].m_OKey;
			m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d);
			if(gm->m_GPSInstruction==GPS_COMMAND_BSTRSDETAIL)
			{
				if(DataActl.bCalculateBeamStresses == TRUE&&m_pDoc->m_pAttrCtrl2->IsEffectiveBeam(mkey.key.elem_k)&&(gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey)) && !bEscapePressed)
				{
					if(gm->m_bContour)  DoBVmstElementContour(pDC, atom_list[i].m_OKey);
					else                gm->GPSDrawElement(pDC,atom_list[i].m_OKey);
				}
				else
				{
					if(m_bDeformedShapeContour) gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, atom_list[i].m_OKey);
					else					              gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
				}
			}
			else
			{
				if(m_pDoc->m_pAttrCtrl->IsBeam(elem_d.eltyp) && (gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey)) && !bEscapePressed) 
				{
					if(gm->m_bContour)  DoBStrsElementContour(pDC, atom_list[i].m_OKey);
					else                gm->GPSDrawElement(pDC,atom_list[i].m_OKey);
				}
				else 
				{
					if(m_bDeformedShapeContour) gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, atom_list[i].m_OKey);
					else					              gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
				}
			}
		}
	}

	// 변형된 그림에 Undeformed Shape을 같이 그릴 경우.
	// Contour를 그릴 경우는 Hidden이 default
	// 따라서 Undeformed Shape은 무조건 나중에 그린다...
	if(m_bDeformedShapeContour && gm->m_DOPT.DR.m_bDrawInactive  && !bEscapePressed) 
	{
		int	rf_bak=gm->m_DOPT.DR.m_RenderFlag;
		gm->m_DOPT.DR.m_RenderFlag = 2;
		gm->GPSDrawOriginal(pDC, TRUE);
		gm->m_DOPT.DR.m_RenderFlag = rf_bak;
	}
	pDC->SelectObject(old_pen);
	elem_pen.DeleteObject();
}

void CStressEngine::DoBStrsElementContour(CDC *pDC, unsigned int ekey)
{
	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;
	T_MIRE_K mkey;
	mkey.keymap = ekey;
	
	int				i, poly_num, vtx_num;
	BOOL			is_real=FALSE;
	T_ELEM_D		elem_d;
	T_STRB_D		bstrs_d;

	CArray<CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray<CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					        edge_list;
	CArray<CArray <T_NODE_K, T_NODE_K> *, CArray <T_NODE_K, T_NODE_K> *>	VertexNode;
	CArray<CArray <double, double> *, CArray <double, double> *>			    PosList;

	if((gm->m_pDeformEngine==NULL) ||
		 (m_pContourEngine==NULL) ||
		 (!GetBeamStress(mkey.key.elem_k, bstrs_d))) 
	{
		return;
	}

	// 요소의 형상정보를 얻는다.

	m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d);
	if (m_bDeformedShapeContour) 
	{	// 변형된 형상
		is_real = gm->m_pDeformEngine->m_bRealDeform;
		if (is_real) 
		{				// Real Deform
			if (!gm->m_pBeamDiagram)
				gm->m_pBeamDiagram = new CBeamDiagram;
			if (gm->m_pBeamDiagram->MakeBeamDispl(mkey.key.elem_k, gm->m_LoadCombi, 10, 2)) 
			{
				gm->m_pDeformEngine->GetBeamRealDeformedShape(ekey, &polygon_list, &edge_list, &PosList);
			}
			else {
				gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list, &VertexNode);
				is_real = FALSE;
			}
		}
		else 
		{
			gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list, &VertexNode);
		}
	}
	else {
		gm->GetShapeElement(ekey, polygon_list, &edge_list, NULL, &VertexNode);
	}

	T_SECT_D SectD;
	if(gm->m_DOPT.DR.m_bFrameThick)
		m_pDoc->m_pAttrCtrl->GetSect(elem_d.elpro,SectD);

	gm->GPS_XGL_Begin_Elem(mkey.key.elem_k,elem_d);

	poly_num = polygon_list.GetSize();
	for (i=0;i<poly_num;i++) 
	{
		vtx_num = polygon_list[i]->GetCount();
		if (vtx_num == 2) 
		{
			if (m_bDeformedShapeContour && is_real)
				DoBStrsLineContourReal(pDC, polygon_list[i], poly_num, bstrs_d, PosList[i]);
			else
				DoBStrsLineContour(pDC, polygon_list[i], poly_num, bstrs_d);
		}
		else 
		{
			if(!gm->IsPossibleDrawingPolyFrame(ekey,&elem_d,&SectD,poly_num,polygon_list[i],is_real))continue;
			if(m_bDeformedShapeContour && is_real)
				DoBStrsPolyContourReal(pDC, polygon_list[i], edge_list[i], bstrs_d, PosList[i]);
			else
				DoBStrsPolyContour(pDC, polygon_list[i], edge_list[i], VertexNode[i], elem_d, bstrs_d);
		}
	}

	gm->GPS_XGL_End_Elem();

	for(i=0;i<poly_num;i++) 
	{
		polygon_list[i]->RemoveAll();
		delete polygon_list[i];
		edge_list[i]->RemoveAll();
		delete edge_list[i];
		if(m_bDeformedShapeContour && is_real) 
		{
			PosList[i]->RemoveAll();
			delete PosList[i];
		}
		else 
		{
			VertexNode[i]->RemoveAll();
			delete VertexNode[i];
		}
	}
	polygon_list.RemoveAll();
	edge_list.RemoveAll();
	VertexNode.RemoveAll();
	PosList.RemoveAll();
}

void CStressEngine::DoBStrsLineContour(CDC *pDC, CList <C3DPoint, C3DPoint> *Vertex, int nPolyNum ,T_STRB_D &BStrsVal)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	int					i;
	double			dx, dy, dz, i_val, j_val;
	POSITION		pos=Vertex->GetHeadPosition();
	C3DPoint		p[5];
	CArray <C3DPoint, C3DPoint>		rvtx_list;
	CArray <double, double>			rval_list;

	p[0] = Vertex->GetNext(pos);
	p[4] = Vertex->GetNext(pos);

	// Line이지만 Polygon의 Outline이다.
	// Composite Section의 Concrete부분 
	if( nPolyNum>1 )
	{
		CPen pen,*pOldPen;
		if(gm->m_DOPT.DR.m_bFrameLine) // wire frame
		  pen.CreatePen(PS_SOLID, gm->m_nLineWidth*1.7, gm->m_DOPT.CL.m_InactiveCol);
	  else 
		  pen.CreatePen(PS_SOLID, gm->m_nLineWidth, gm->m_DOPT.CL.m_InactiveCol);
		pOldPen = pDC->SelectObject(&pen);

		if(gm->m_bVirtualMode)
			gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, p[0], p[4]);
	  else 
			gm->m_pGPSCtrl->DrawLine3D(pDC, p[0], p[4]);
		
		pDC->SelectObject(pOldPen);
		pen.DeleteObject();
		return;  
	}

	dx = (p[4].x-p[0].x) / 4.0;
	dy = (p[4].y-p[0].y) / 4.0;
	dz = (p[4].z-p[0].z) / 4.0;
	for (i=1;i<4;i++) {
		p[i].x = p[0].x + dx*((double) i);
		p[i].y = p[0].y + dy*((double) i);
		p[i].z = p[0].z + dz*((double) i);
	}

	for (i=0;i<4;i++) {
		i_val = CalcBStrsValue(BStrsVal, i, I_NODE);
		j_val = CalcBStrsValue(BStrsVal, i, J_NODE);
		if (gm->m_AnimEngine.m_bAnimateContour) {
			i_val = m_pContourEngine->GetSubFrameValue(i_val, gm->m_AnimEngine.GetAnimationFactor(TRUE));
			j_val = m_pContourEngine->GetSubFrameValue(j_val, gm->m_AnimEngine.GetAnimationFactor(TRUE));
		}
		if (i_val > j_val) {
			rvtx_list.Add(p[i]);
			rval_list.Add(i_val);
			m_pContourEngine->GetRankVertices(p[i], p[i+1], i_val, j_val, rvtx_list, rval_list, NULL);
			rvtx_list.Add(p[i+1]);
			rval_list.Add(j_val);
		}
		else {
			rvtx_list.Add(p[i+1]);
			rval_list.Add(j_val);
			m_pContourEngine->GetRankVertices(p[i+1], p[i], j_val, i_val, rvtx_list, rval_list, NULL);
			rvtx_list.Add(p[i]);
			rval_list.Add(i_val);
		}

		//DrawContourLine(pDC, rvtx_list, rval_list);
		//DrawContourLine(pDC, rvtx_list, rval_list,gm->m_LnWd.nElemWire);
		DrawContourLine(pDC, rvtx_list, rval_list,gm->m_DOPT.DR.nElemWire);

		rvtx_list.RemoveAll();
		rval_list.RemoveAll();
	}
}

void CStressEngine::DoBStrsLineContourReal(CDC *pDC, CList <C3DPoint, C3DPoint> *Vertex, int nPolyNum,
										                      T_STRB_D &BStrsVal, CArray <double, double> *PosList)
{
	I_GPSModel  *gm=(I_GPSModel *)m_pGPSModel;
	double			i_val, j_val;
	C3DPoint		i_pos, j_pos;
	POSITION		pos=Vertex->GetHeadPosition();
	CArray <C3DPoint, C3DPoint> rvtx_list;
	CArray <double, double>			rval_list;

	i_pos = Vertex->GetNext(pos);
	j_pos = Vertex->GetNext(pos);
	i_val = CalcBStrsValuePos(BStrsVal, PosList->GetAt(0));
	i_val = max(i_val, m_pContourEngine->m_MinRange);
	i_val = min(i_val, m_pContourEngine->m_MaxRange);
	j_val = CalcBStrsValuePos(BStrsVal, PosList->GetAt(1));
	j_val = max(j_val, m_pContourEngine->m_MinRange);
	j_val = min(j_val, m_pContourEngine->m_MaxRange);

	if(gm->m_AnimEngine.m_bAnimateContour) 
	{
		i_val = m_pContourEngine->GetSubFrameValue(i_val, gm->m_AnimEngine.GetAnimationFactor(TRUE));
		j_val = m_pContourEngine->GetSubFrameValue(j_val, gm->m_AnimEngine.GetAnimationFactor(TRUE));
	}

	if(i_val > j_val) 
	{
		rvtx_list.Add(i_pos);	rval_list.Add(i_val);
		m_pContourEngine->GetRankVertices(i_pos, j_pos, i_val, j_val, rvtx_list, rval_list, NULL);
		rvtx_list.Add(j_pos);	rval_list.Add(j_val);
	}
	else 
	{
		rvtx_list.Add(j_pos);	rval_list.Add(j_val);
		m_pContourEngine->GetRankVertices(j_pos, i_pos, j_val, i_val, rvtx_list, rval_list, NULL);
		rvtx_list.Add(i_pos);	rval_list.Add(i_val);
	}

	// Line이지만 Polygon의 Outline이다.
	// Composite Section의 Concrete부분 
	if(nPolyNum>1 && !gm->m_DOPT.DR.m_bFrameLine)
	{
		C3DPoint pt1,pt2;
		CPen pen,*pOldPen;
		if(gm->m_DOPT.DR.m_bFrameLine) // wire frame
		  pen.CreatePen(PS_SOLID, gm->m_nLineWidth*1.7, gm->m_DOPT.CL.m_InactiveCol);
	  else 
		  pen.CreatePen(PS_SOLID, gm->m_nLineWidth, gm->m_DOPT.CL.m_InactiveCol);
		pOldPen = pDC->SelectObject(&pen);

		for(int i=0; i<rvtx_list.GetSize()-1; i++)
		{
			pt1 = rvtx_list[i];
			pt2 = rvtx_list[i+1];
			if(gm->m_bVirtualMode)
				gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, pt1, pt2);
	    else 
				gm->m_pGPSCtrl->DrawLine3D(pDC, pt1, pt2);
		}
		pDC->SelectObject(pOldPen);
		pen.DeleteObject();
		return;   
	}
	DrawContourLine(pDC, rvtx_list, rval_list,gm->m_DOPT.DR.nElemWire);
	
	rvtx_list.RemoveAll();
	rval_list.RemoveAll();
}

void CStressEngine::DoBStrsPolyContour(CDC *pDC,
									   CList <C3DPoint, C3DPoint> *Vertex,
									   CArray <BOOL, BOOL> *EdgeFlag,
									   CArray <T_NODE_K, T_NODE_K> *VertexNode,
									   T_ELEM_D &ElemData,
									   T_STRB_D &BStrsVal)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	int			i, vertex_num=Vertex->GetCount();
	double		bstrs_val[4], dx1, dy1, dz1, dx2, dy2, dz2;
	BOOL		ef[4];
	POSITION	pos;
	C3DPoint	p[4];
	T_NODE_K  NodeK[4];
	CList <C3DPoint, C3DPoint>	sub_vertex;

	NodeK[0] = VertexNode->GetAt(0);
	NodeK[1] = VertexNode->GetAt(1);
	NodeK[2] = VertexNode->GetAt(2);
	if(vertex_num==4)
		NodeK[3] = VertexNode->GetAt(3);

	// polygon이 i단 쪽에 있을 경우
	if((NodeK[0]==NodeK[1]) &&  (NodeK[0]==NodeK[2]) && (NodeK[0]==ElemData.elnod[0])) 
	{
		for (i=0;i<vertex_num;i++) 
		{
			bstrs_val[i] = CalcBStrsValue(BStrsVal, 0, I_NODE);
			if(gm->m_AnimEngine.m_bAnimateContour)
				bstrs_val[i] = m_pContourEngine->GetSubFrameValue(bstrs_val[i], gm->m_AnimEngine.GetAnimationFactor(TRUE));
			ef[i] = EdgeFlag->GetAt(i);
		}
		DoSubPolyContour(pDC, bstrs_val, Vertex, ef, TRUE);
	}
	// polygon이 j단 쪽에 있을 경우
	else if((NodeK[0]==NodeK[1]) && (NodeK[0]==NodeK[2]) && (NodeK[0]==ElemData.elnod[1])) 
	{
		for (i=0;i<vertex_num;i++) 
		{
			bstrs_val[i] = CalcBStrsValue(BStrsVal, 3, J_NODE);
			if(gm->m_AnimEngine.m_bAnimateContour)
				bstrs_val[i] = m_pContourEngine->GetSubFrameValue(bstrs_val[i], gm->m_AnimEngine.GetAnimationFactor(TRUE));
			ef[i] = EdgeFlag->GetAt(i);
		}
		DoSubPolyContour(pDC, bstrs_val, Vertex, ef, TRUE);
	}
	// polygon이 i, j단에 걸쳐 있을 경우
	else 
	{
		if(vertex_num!=4)return; 
		if(NodeK[0]==NodeK[1] && NodeK[2]==NodeK[3] )
		{
	    pos = Vertex->GetHeadPosition();
			for(i=0;i<4;i++) p[i] = Vertex->GetNext(pos);
		}
		else if(NodeK[0]==NodeK[3] && NodeK[1]==NodeK[2] )
		{
			C3DPoint	tp[4];  
			pos = Vertex->GetHeadPosition();
			for(i=0;i<4;i++) tp[i] = Vertex->GetNext(pos);
			p[0] = tp[0];
			p[1] = tp[3];
			p[2] = tp[2];
			p[3] = tp[1];
	  }
		else 
		{
			ASSERT(FALSE); 
			pos = Vertex->GetHeadPosition();
			for(i=0;i<4;i++)p[i] = Vertex->GetNext(pos);
	  }

		dx1 = (p[3].x-p[0].x) / 4.0;
		dy1 = (p[3].y-p[0].y) / 4.0;
		dz1 = (p[3].z-p[0].z) / 4.0;

		dx2 = (p[2].x-p[1].x) / 4.0;
		dy2 = (p[2].y-p[1].y) / 4.0;
		dz2 = (p[2].z-p[1].z) / 4.0;

		p[3] = p[0];
		p[2] = p[1];
		for (i=0;i<4;i++) 
		{
			p[0] = p[3];
			p[1] = p[2];
			p[3].x = p[0].x + dx1;
			p[3].y = p[0].y + dy1;
			p[3].z = p[0].z + dz1;
			p[2].x = p[1].x + dx2;
			p[2].y = p[1].y + dy2;
			p[2].z = p[1].z + dz2;
			sub_vertex.AddTail(p[0]);
			sub_vertex.AddTail(p[1]);
			sub_vertex.AddTail(p[2]);
			sub_vertex.AddTail(p[3]);

			bstrs_val[0] = bstrs_val[1] = CalcBStrsValue(BStrsVal, i, I_NODE);
			bstrs_val[2] = bstrs_val[3] = CalcBStrsValue(BStrsVal, i, J_NODE);
			if (gm->m_AnimEngine.m_bAnimateContour) 
			{
				bstrs_val[0] = m_pContourEngine->GetSubFrameValue(bstrs_val[0], gm->m_AnimEngine.GetAnimationFactor(TRUE));
				bstrs_val[1] = m_pContourEngine->GetSubFrameValue(bstrs_val[1], gm->m_AnimEngine.GetAnimationFactor(TRUE));
				bstrs_val[2] = m_pContourEngine->GetSubFrameValue(bstrs_val[2], gm->m_AnimEngine.GetAnimationFactor(TRUE));
				bstrs_val[3] = m_pContourEngine->GetSubFrameValue(bstrs_val[3], gm->m_AnimEngine.GetAnimationFactor(TRUE));
			}

			if(i == 0)ef[0] = EdgeFlag->GetAt(0);
			else			ef[0] = FALSE;
			ef[1] = EdgeFlag->GetAt(1);
			if(i == 3)ef[2] = EdgeFlag->GetAt(2);
			else      ef[2] = FALSE;
			ef[3] = EdgeFlag->GetAt(3);
			
			DoSubPolyContour(pDC, bstrs_val, &sub_vertex, ef, TRUE);
			sub_vertex.RemoveAll();
		}
	}
	
	// Fill+Outline의 경우 Contour를 수행하기 전의 Polygon의 Outline을 그림.
	if(gm->m_DOPT.DR.m_RenderFlag == 3 || gm->m_DOPT.DR.m_RenderFlag == 2)
		gm->GPSDrawPolygonEdge(pDC, Vertex, EdgeFlag);
}

void CStressEngine::DoBStrsPolyContourReal(CDC *pDC,
									   CList <C3DPoint, C3DPoint> *Vertex,
									   CArray <BOOL, BOOL> *EdgeFlag,
									   T_STRB_D &BStrsVal,
									   CArray <double, double> *PosList)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	int			  i, vertex_num=Vertex->GetCount();
	double		val[4];
	BOOL		  ef[4];

	if(vertex_num == 3) 
	{

	}
	else if(vertex_num == 4) 
	{
		for(i=0;i<4;i++) 
		{
			val[i] = CalcBStrsValuePos(BStrsVal, PosList->GetAt(i));
			val[i] = max(val[i], m_pContourEngine->m_MinRange);
			val[i] = min(val[i], m_pContourEngine->m_MaxRange);
			if(gm->m_AnimEngine.m_bAnimateContour)val[i] = m_pContourEngine->GetSubFrameValue(val[i], gm->m_AnimEngine.GetAnimationFactor(TRUE));
			ef[i] = EdgeFlag->GetAt(i);
		}
		DoSubPolyContour(pDC, val, Vertex, ef, TRUE);
	}

	if(gm->m_DOPT.DR.m_RenderFlag == 3 || gm->m_DOPT.DR.m_RenderFlag == 2)
		gm->GPSDrawPolygonEdge(pDC, Vertex, EdgeFlag);
}

#if defined(__OLD_OUTPUT_VALUE)
void CStressEngine::OutputBStrsNumbers(CDC *pDC)
{
	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;
	int nGPSMode = (gm->m_GPSInstruction != -1)? gm->m_GPSInstruction:gm->m_GPSMode;
	
	int				i, j, elem_num, slope;
	T_ELEM_K		ekey;
	T_ELEM_D		edata;
	T_STRB_D		bstrs_d;
	C3DPoint		node3D_i, node3D_j,DrawPoint;
	CPoint			text_p,node_2d_i, node_2d_j;
	TCHAR			fmt_str[10], text_str[512];
	CFont			ft, *old_ft;
	BOOL			fl_bak, is_inverse;

	POSITION		pos;
	CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray <CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					edge_list;

	if (!m_bBStrsDataSet)
		return;

	if (gm->m_DOPT.TX.m_bNumberOpaque)
		pDC->SetBkMode(OPAQUE);
	else
		pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
	pDC->SetBkColor(gm->m_DOPT.TX.m_NumberBackCol);
	pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);

	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);

	fl_bak = gm->m_DOPT.DR.m_bFrameLine;
	gm->m_DOPT.DR.m_bFrameLine = TRUE;

	if (gm->m_DOPT.TX.m_bNumberSelOnly) 
	{
	}
	else 
	{
		BOOL bGrpFltMode=gm->m_pGPSCtrl->IsGroupFilterMode();
		if(!bGrpFltMode)elem_num = gm->m_EKeyListActive.GetSize();
		else            elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize(); 
		
		for (i=0;i<elem_num;i++) 
		{
			if(!bGrpFltMode)ekey = gm->m_EKeyListActive[i];
			else            ekey = gm->m_pDispFilter->m_aGrpEKey[i]; 

			if(!gm->m_pGPSCtrl->IsActiveElem(ekey))
				continue;

			m_pDoc->m_pAttrCtrl->GetElem(ekey, edata);

			if(!m_pDoc->m_pAttrCtrl->IsBeam(edata.eltyp))continue;

			if((nGPSMode==GPS_COMMAND_BSTRS || nGPSMode==GPS_COMMAND_BSTRSDGRM) && m_nBForcPscPart>0)
			{
				if(m_nBForcPscPart>m_pDoc->m_pPostCtrl->GetCscsInfo()->GetNumMaxSectionPart(ekey))
					continue;
			}

			if(m_bDeformedShapeContour) 
			{
				gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list);
			}
			else 
			{
				gm->GetShapeElement(ekey, polygon_list, &edge_list);
			}

			pos = polygon_list[0]->GetHeadPosition();
			node3D_i = polygon_list[0]->GetNext(pos);
			node3D_j = polygon_list[0]->GetNext(pos);
		  if(gm->m_bVirtualMode) 
			{
			  node_2d_i = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_i);
			  node_2d_j = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_j);
		  }
		  else 
			{
			  node_2d_i = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_i);
			  node_2d_j = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_j);
		  }
			
			if((node_2d_i.x >= 0 && node_2d_i.y >= 0 && node_2d_j.x >= 0 && node_2d_j.y >= 0))
			{
		    slope = (int) (atan2(node_2d_i.y-node_2d_j.y, node_2d_j.x-node_2d_i.x)*1800.0/3.14159);
			  slope = (slope+3600) % 3600;
			  if ((900<slope) && (slope<=2700)) 
				{
				  slope = (slope+1800)%3600;
				  is_inverse = TRUE;
			  }
			  else 
				{
				  is_inverse = FALSE;
			  }

			  gm->SetNumberFontOrientation(slope);
			  ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
			  old_ft = (CFont *) pDC->SelectObject(&ft);

			  if(!GetBeamStress(ekey, bstrs_d)) bstrs_d.Initialize();

				if(gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
				{
					double dLimit = (m_dMaxValue-m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;
				  double dBValue;
				
					for(int n=0; n<3; n++)
					{
				    if(n==0) // I단 
						{
							if (!m_bBStrsOutputI) continue;
						
							if (is_inverse)
					      pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
				      else
					      pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
							DrawPoint = node3D_i;
							dBValue = CalcBStrsValue(bstrs_d, 0, I_NODE);
						
						}
						else if(n==1)// CNT or MAX
						{			  
							if (!(m_bBStrsOutputC||m_bBStrsOutputMax)) continue;
						
							pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);
							DrawPoint.x = (node3D_i.x + node3D_j.x)/2.0;
							DrawPoint.y = (node3D_i.y + node3D_j.y)/2.0;
							DrawPoint.z = (node3D_i.z + node3D_j.z)/2.0;
						
							if (m_bBStrsOutputMax) 
								dBValue = CalcBStrsValue(bstrs_d);
							else
								dBValue = CalcBStrsValue(bstrs_d, 1, J_NODE);
						
						}
						else if(n==2)// J단 
						{			  
							if (!m_bBStrsOutputJ) continue;

				      if (is_inverse)
					      pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
				      else
					      pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
							DrawPoint = node3D_j;
							dBValue = CalcBStrsValue(bstrs_d, 3, J_NODE);
						}
							
						switch(gm->m_DOPT.TX.m_nOutputMinMaxType)
						{
						case 0: // Min & Max
							if((m_dMaxValue-dBValue) <= dLimit)
								 DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,dBValue);
							else if((dBValue-m_dMinValue) <= dLimit)
								 DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,dBValue);
							break;
						case 1: // Abs Max
							if(fabs(m_dMaxValue) >= fabs(m_dMinValue))
							{
								if( fabs(m_dMaxValue)-fabs(dBValue) <= dLimit)
								DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dBValue);
							}
							else
							{
								if( fabs(m_dMinValue)-fabs(dBValue) <= dLimit)
								DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dBValue);
							}
							break;
						case 2: // Max
							if((m_dMaxValue-dBValue) <= dLimit)
								 DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,dBValue);
							break;
						case 3: // Min
							if((dBValue-m_dMinValue) <= dLimit)
								 DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,dBValue);
							break;
						}
					}
				//////////////////////////////////////////////////////////////////////////////////////
				}      
				else      
				{
			    if(m_bBStrsOutputI) 
					{
				    pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorI);
				    if (is_inverse)
					    pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
				    else
					    pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
				    text_p.x = (int) node_2d_i.x;
				    text_p.y = (int) node_2d_i.y;
				    _stprintf(text_str, fmt_str, CalcBStrsValue(bstrs_d, 0, I_NODE));
				    pDC->TextOut(text_p.x, text_p.y, text_str);
			    }
			    if(m_bBStrsOutputJ) 
					{
				    pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorJ);
				    if (is_inverse)
					    pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
				    else
					    pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
				    text_p.x = (int) node_2d_j.x;
				    text_p.y = (int) node_2d_j.y;
				    _stprintf(text_str, fmt_str, CalcBStrsValue(bstrs_d, 3, J_NODE));
				    pDC->TextOut(text_p.x, text_p.y, text_str);
			    }
			    if(m_bBStrsOutputC) 
					{
						pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);
				    text_p.x = (int) ((node_2d_i.x+node_2d_j.x)/2.0);
				    text_p.y = (int) ((node_2d_i.y+node_2d_j.y)/2.0);
				    _stprintf(text_str, fmt_str, CalcBStrsValue(bstrs_d, 1, J_NODE));
				    pDC->TextOut(text_p.x, text_p.y, text_str);
			    }
					if(m_bBStrsOutputMax) 
					{
						pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);
				    text_p.x = (int) ((node_2d_i.x+node_2d_j.x)/2.0);
				    text_p.y = (int) ((node_2d_i.y+node_2d_j.y)/2.0);
				    _stprintf(text_str, fmt_str, CalcBStrsValue(bstrs_d));
				    pDC->TextOut(text_p.x, text_p.y, text_str);
			    }
				}
			  pDC->SelectObject(old_ft);
			  ft.DeleteObject();
			}

			for(j=0;j<polygon_list.GetSize();j++) 
			{
				polygon_list[j]->RemoveAll();
				delete polygon_list[j];
				edge_list[j]->RemoveAll();
				delete edge_list[j];
			}
			polygon_list.RemoveAll();
			edge_list.RemoveAll();
		}
	}

	gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}
#else
void CStressEngine::OutputBStrsNumbers(CDC* pDC)
{
	I_GPSModel* gm = (I_GPSModel*)m_pGPSModel;
	int nGPSMode = (gm->m_GPSInstruction != -1) ? gm->m_GPSInstruction : gm->m_GPSMode;

	int				i, j, elem_num, slope;
	T_ELEM_K		ekey;
	T_ELEM_D		edata;
	T_STRB_D		bstrs_d;
	C3DPoint		node3D_i, node3D_j, DrawPoint;
	CPoint			text_p, node_2d_i, node_2d_j;
	TCHAR			fmt_str[10], text_str[512];
	CFont			ft, * old_ft;
	BOOL			fl_bak, is_inverse;

	POSITION		pos;
	CArray <CList <C3DPoint, C3DPoint>*, CList <C3DPoint, C3DPoint>*>		polygon_list;
	CArray <CArray <BOOL, BOOL>*, CArray <BOOL, BOOL>*>					edge_list;

	if (!m_bBStrsDataSet)
		return;

	GPostTextOut TextOutModel;
	TextOutModel.SetDC(pDC);
	TextOutModel.StartBeamStressVal();
	TextOutModel.SettingBeamStress(gm);

	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);

	fl_bak = gm->m_DOPT.DR.m_bFrameLine;
	gm->m_DOPT.DR.m_bFrameLine = TRUE;

	if (gm->m_DOPT.TX.m_bNumberSelOnly)
	{
	}
	else
	{
		BOOL bGrpFltMode = gm->m_pGPSCtrl->IsGroupFilterMode();
		if (!bGrpFltMode)elem_num = gm->m_EKeyListActive.GetSize();
		else            elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize();

		for (i = 0; i < elem_num; i++)
		{
			if (!bGrpFltMode)ekey = gm->m_EKeyListActive[i];
			else            ekey = gm->m_pDispFilter->m_aGrpEKey[i];

			if (!gm->m_pGPSCtrl->IsActiveElem(ekey))
				continue;

			m_pDoc->m_pAttrCtrl->GetElem(ekey, edata);

			if (!m_pDoc->m_pAttrCtrl->IsBeam(edata.eltyp))continue;

			if ((nGPSMode == GPS_COMMAND_BSTRS || nGPSMode == GPS_COMMAND_BSTRSDGRM) && m_nBForcPscPart > 0)
			{
				if (m_nBForcPscPart > m_pDoc->m_pPostCtrl->GetCscsInfo()->GetNumMaxSectionPart(ekey))
					continue;
			}

			if (m_bDeformedShapeContour)
			{
				gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list);
			}
			else
			{
				gm->GetShapeElement(ekey, polygon_list, &edge_list);
			}

			pos = polygon_list[0]->GetHeadPosition();
			node3D_i = polygon_list[0]->GetNext(pos);
			node3D_j = polygon_list[0]->GetNext(pos);
			if (gm->m_bVirtualMode)
			{
				node_2d_i = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_i);
				node_2d_j = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_j);
			}
			else
			{
				node_2d_i = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_i);
				node_2d_j = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_j);
			}

			if ((node_2d_i.x >= 0 && node_2d_i.y >= 0 && node_2d_j.x >= 0 && node_2d_j.y >= 0))
			{
				slope = (int)(atan2(node_2d_i.y - node_2d_j.y, node_2d_j.x - node_2d_i.x) * 1800.0 / 3.14159);
				slope = (slope + 3600) % 3600;
				if ((900 < slope) && (slope <= 2700))
				{
					slope = (slope + 1800) % 3600;
					is_inverse = TRUE;
				}
				else
				{
					is_inverse = FALSE;
				}

				TextOutModel.Font4BeamStress(gm, slope);
		
				if (!GetBeamStress(ekey, bstrs_d)) bstrs_d.Initialize();

				if (gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
				{
					double dLimit = (m_dMaxValue - m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;
					double dBValue;

					for (int n = 0; n < 3; n++)
					{
						if (n == 0) // I단 
						{
							if (!m_bBStrsOutputI) continue;

							if (is_inverse)
								TextOutModel.AlignTextBot(TA_RIGHT);
							else
								TextOutModel.AlignTextBot(TA_LEFT);
							DrawPoint = node3D_i;
							dBValue = CalcBStrsValue(bstrs_d, 0, I_NODE);

						}
						else if (n == 1)// CNT or MAX
						{
							if (!(m_bBStrsOutputC || m_bBStrsOutputMax)) continue;

							TextOutModel.AlignTextBot(TA_CENTER);
							DrawPoint.x = (node3D_i.x + node3D_j.x) / 2.0;
							DrawPoint.y = (node3D_i.y + node3D_j.y) / 2.0;
							DrawPoint.z = (node3D_i.z + node3D_j.z) / 2.0;

							if (m_bBStrsOutputMax)
								dBValue = CalcBStrsValue(bstrs_d);
							else
								dBValue = CalcBStrsValue(bstrs_d, 1, J_NODE);

						}
						else if (n == 2)// J단 
						{
							if (!m_bBStrsOutputJ) continue;

							if (is_inverse)
								TextOutModel.AlignTextBot(TA_LEFT);
							else
								TextOutModel.AlignTextBot(TA_RIGHT);
							DrawPoint = node3D_j;
							dBValue = CalcBStrsValue(bstrs_d, 3, J_NODE);
						}

						switch (gm->m_DOPT.TX.m_nOutputMinMaxType)
						{
						case 0: // Min & Max
							if ((m_dMaxValue - dBValue) <= dLimit)
								DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, dBValue);
							else if ((dBValue - m_dMinValue) <= dLimit)
								DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, dBValue);
							break;
						case 1: // Abs Max
							if (fabs(m_dMaxValue) >= fabs(m_dMinValue))
							{
								if (fabs(m_dMaxValue) - fabs(dBValue) <= dLimit)
									DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, dBValue);
							}
							else
							{
								if (fabs(m_dMinValue) - fabs(dBValue) <= dLimit)
									DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, dBValue);
							}
							break;
						case 2: // Max
							if ((m_dMaxValue - dBValue) <= dLimit)
								DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, dBValue);
							break;
						case 3: // Min
							if ((dBValue - m_dMinValue) <= dLimit)
								DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, dBValue);
							break;
						}
					}
					//////////////////////////////////////////////////////////////////////////////////////
				}
				else
				{
					if (m_bBStrsOutputI)
					{
						text_p.x = (int)node_2d_i.x;
						text_p.y = (int)node_2d_i.y;
						_stprintf(text_str, fmt_str, CalcBStrsValue(bstrs_d, 0, I_NODE));
						if (is_inverse)
							TextOutModel.TextOutBeamStress(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorI, TA_RIGHT);
						else
							TextOutModel.TextOutBeamStress(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorI, TA_LEFT);
					}
					if (m_bBStrsOutputJ)
					{
						text_p.x = (int)node_2d_j.x;
						text_p.y = (int)node_2d_j.y;
						_stprintf(text_str, fmt_str, CalcBStrsValue(bstrs_d, 3, J_NODE));
						if (is_inverse)
							TextOutModel.TextOutBeamStress(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorJ, TA_LEFT);
						else
							TextOutModel.TextOutBeamStress(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorJ, TA_RIGHT);
					}
					if (m_bBStrsOutputC)
					{
						text_p.x = (int)((node_2d_i.x + node_2d_j.x) / 2.0);
						text_p.y = (int)((node_2d_i.y + node_2d_j.y) / 2.0);
						_stprintf(text_str, fmt_str, CalcBStrsValue(bstrs_d, 1, J_NODE));
						TextOutModel.AlignTextBot(TA_CENTER);
						TextOutModel.TextOutBeamStress(text_p.x, text_p.y, text_str);
					}
					if (m_bBStrsOutputMax)
					{
						text_p.x = (int)((node_2d_i.x + node_2d_j.x) / 2.0);
						text_p.y = (int)((node_2d_i.y + node_2d_j.y) / 2.0);
						_stprintf(text_str, fmt_str, CalcBStrsValue(bstrs_d));
						TextOutModel.AlignTextBot(TA_CENTER);
						TextOutModel.TextOutBeamStress(text_p.x, text_p.y, text_str);
					}
				}
				TextOutModel.DeleteFont();
			}

			for (j = 0; j < polygon_list.GetSize(); j++)
			{
				polygon_list[j]->RemoveAll();
				delete polygon_list[j];
				edge_list[j]->RemoveAll();
				delete edge_list[j];
			}
			polygon_list.RemoveAll();
			edge_list.RemoveAll();
		}
	}
	TextOutModel.EndBeamStressVal();
	gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}
#endif

////////////////////////////////////////////////////////////////////////////////////////
// Inclined Beam Stress에 관한 Contouring
////////////////////////////////////////////////////////////////////////////////////////
BOOL CStressEngine::MakeBStssDataList()
{
	if (CTestEnvMgr::IsTestEnvST(_LSX(ProfilingSTL), _LSX(yes)))
	{
		M_PROFILE('MakeBStssDataList()');
	}

	DECLARE_GPSMD();
	
	int			i;
	double	max_bstss=-DBL_MAX, min_bstss=DBL_MAX;
	BOOL		has_content=FALSE;
	T_ELEM_K	elem_key;
	T_ELEM_D	elem_data;
	T_STSS_D	bstss_d;
	
	m_bPositionMax = TRUE; 
	if(!gm->m_bLoadDataSet)return FALSE;
	
	gm->m_pMyView->BeginWaitCursor();

	m_BeamKeyList.RemoveAll();
	m_mapBStssData.RemoveAll();
	m_mapBStssDataMin.RemoveAll();

	T_RPSC_D RpscD;
	CArray<UINT,UINT> arStssBeam; 
	for(i=0; i<gm->m_EKeyListActive.GetSize(); i++)
	{
		elem_key = gm->m_EKeyListActive[i];
		m_pDoc->m_pAttrCtrl->GetElem(elem_key, elem_data);
		if(!m_pDoc->m_pAttrCtrl->IsBeam(elem_data.eltyp))continue;
		//if(!m_pDoc->m_pAttrCtrl->GetRpsc(elem_data.elpro,RpscD))continue;
		if(!CDBLib::IsPscDgnFor1st(elem_key,FALSE))continue;
		arStssBeam.Add(elem_key);
	}
		
	for(i=0;i<arStssBeam.GetSize();i++) 
	{
		elem_key = arStssBeam[i];
		//m_pDoc->m_pAttrCtrl->GetElem(elem_key, elem_data);
		//if (!m_pDoc->m_pAttrCtrl->IsBeam(elem_data.eltyp))continue;
		
		switch (gm->m_LoadMinMaxType) 
		{
		case LOADTYPE_NORMAL:
		case LOADTYPE_MAX:
			if(!m_pDoc->m_pPostCtrl->GetStssNew(elem_key, &bstss_d, NULL,NULL,1))continue; 
			if(m_BStrsOutputSection==BSTRSINC_COMP_MAXMIN) // Max/Min Position
			{
				m_bPositionMax = FALSE;  // Min Position
				MinMaxElemBStss(elem_key,bstss_d,max_bstss,min_bstss);
				m_mapBStssDataMin.SetAt(elem_key,bstss_d);
				has_content = TRUE;
			}
			break;
		case LOADTYPE_MIN:
			if(!m_pDoc->m_pPostCtrl->GetStssNew(elem_key, NULL,&bstss_d, NULL,1))continue; 
			if(m_BStrsOutputSection==BSTRSINC_COMP_MAXMIN) // Max/Min Position
			{
				m_bPositionMax = FALSE;  // Min Position
				MinMaxElemBStss(elem_key,bstss_d,max_bstss,min_bstss);
				m_mapBStssDataMin.SetAt(elem_key,bstss_d);
				has_content = TRUE;
			}
			break;
		case LOADTYPE_ALL:
			if(gm->m_GPSMode==GPS_COMMAND_BSTRSINC && this->m_bMaxMinDgrm) 
			{
				if(m_BStrsOutputSection==BSTRSINC_COMP_MAXMIN) // Max/Min Position
				{
					m_bPositionMax = FALSE;  // Min Position
				}
				T_STSS_D bstss_d_min;
				if(!m_pDoc->m_pPostCtrl->GetStssNew(elem_key, &bstss_d,&bstss_d_min,NULL,1))continue;  
				MinMaxElemBStss(elem_key,bstss_d_min,max_bstss,min_bstss);
				m_mapBStssDataMin.SetAt(elem_key,bstss_d_min);
				has_content = TRUE;
			}
			else
			{
				if(!m_pDoc->m_pPostCtrl->GetStssNew(elem_key, NULL,NULL,&bstss_d,1))continue;  
				if(m_BStrsOutputSection==BSTRSINC_COMP_MAXMIN) // Max/Min Position
				{
					m_bPositionMax = FALSE;   // Min Position
					MinMaxElemBStss(elem_key,bstss_d,max_bstss,min_bstss);
				  m_mapBStssDataMin.SetAt(elem_key,bstss_d);
					has_content = TRUE;
				}
			}
			break;
		}
		has_content = TRUE;

		m_bPositionMax = TRUE; // Max Position
		MinMaxElemBStss(elem_key,bstss_d,max_bstss,min_bstss);
		// 3. Beam Stress값 및 해당 Element번호를 CArray에 저장
		m_BeamKeyList.Add(elem_key);
		m_mapBStssData.SetAt(elem_key,bstss_d);
	}

	if(!has_content) 
	{
		min_bstss = max_bstss = 0.0;
		gm->m_nLgdMaxValKey   = 0; 
		gm->m_nLgdMinValKey   = 0; 
	}
	m_dMaxValue = max_bstss;
	m_dMinValue = min_bstss;

	if(fabs(max_bstss)<fabs(min_bstss))InitBSfdBmdAdjustFactor(min_bstss);
	else		                           InitBSfdBmdAdjustFactor(max_bstss);

	if(m_pContourEngine==NULL)
		m_pContourEngine = new CContourEngine(min_bstss, max_bstss);
	else
		m_pContourEngine->MakeRankMap(min_bstss, max_bstss);

	gm->m_pMyView->EndWaitCursor();
	m_bBStrsDataSet = TRUE;
	return TRUE;
}

void CStressEngine::MinMaxElemBStss(T_ELEM_K elem_key,T_STSS_D StssD,double& max_stss,double& min_stss)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	
	double len = GetMaxElemBStss(StssD);
	if (len > max_stss) 
	{
		max_stss = len;
		gm->m_nLgdMaxValKey=elem_key;
	}
	len = GetMinElemBStss(StssD);
	if (len < min_stss) 
	{
		min_stss = len;
		gm->m_nLgdMinValKey=elem_key;
	}
}


void CStressEngine::InitBSfdBmdAdjustFactor(double max_bforc)
{
	C3DPoint	min_p, max_p;
	double		max_l;

	if(m_bLockAdjFactor)return;
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	gm->GetRangeModel(&min_p,&max_p);
	max_l = max(max(max_p.x-min_p.x, max_p.y-min_p.y), max_p.z-min_p.z);
	m_dMaxModelLength = max_l;
	
	if(max_bforc > -1e-15 && max_bforc < 1e-15)max_bforc = 1.0f;
	// 최대값이 전체모델의 1/20의 크기로 나오도록...
	m_BSfdBmdAdjustFactor = max_l / (fabs(max_bforc)*20.0);
}


double CStressEngine::GetMaxElemBStss(T_STSS_D &StssD)
{
	double  len, mxval=-DBL_MAX;
	for(int i=0;i<=4;i++) 
	{
	  len   = CalcBStssValue(StssD,i);
		mxval = max(mxval,len);
	}
	return mxval;  
}

double CStressEngine::GetMinElemBStss(T_STSS_D &StssD)
{
	double  len, mnval=DBL_MAX;
	for(int i=0;i<=4;i++) 
	{
	  len   = CalcBStssValue(StssD, i);
		mnval = min(mnval,len);
	}
	return mnval;  
}

double CStressEngine::GetAbsMaxElemBStss(T_STSS_D &StssD)
{
	double  drtval = 0.0;
	double  absmax = 0.0;
	double  len;
	for(int i=0;i<5;i++) 
	{
	  len    = CalcBStssValue(StssD, i);

		if(absmax < fabs(len))
		{
		  absmax = fabs(len);
			drtval = len;
		}
	}
	return drtval;  
}

double CStressEngine::GetStressVal(double dblStress[5][16][19], int part, int iPos, int nBStrsComponent, int nBStrsComp_sub)
{
	double dValue = 0.0;

	if(nBStrsComponent == BSTRSINC_COMP_SIGISST)         // PS1과 동일 
		dValue = dblStress[part][iPos][10];
	else if(nBStrsComponent == BSTRSINC_COMP_SIG1MAX)    // PS1
		dValue = dblStress[part][iPos][10];        
	else if(nBStrsComponent == BSTRSINC_COMP_SIG2MIN)    // PS2
		dValue = dblStress[part][iPos][11];
	else if (nBStrsComponent == BSTRSINC_COMP_7thDOF)
	{
				 if (nBStrsComp_sub == BSTRS_COMPONENT_7th_SAX     )   dValue = dblStress[part][iPos][13-1];      // 13.warping normal stress
		else if (nBStrsComp_sub == BSTRS_COMPONENT_7th_SSY_MT  )   dValue = dblStress[part][iPos][14-1];      // 14.pure torsion xy
		else if (nBStrsComp_sub == BSTRS_COMPONENT_7th_SSY_MW  )   dValue = dblStress[part][iPos][15-1];      // 15.warping torsion xy
		else if (nBStrsComp_sub == BSTRS_COMPONENT_7th_SSZ_MT  )   dValue = dblStress[part][iPos][16-1];      // 16.pure torsion xz
		else if (nBStrsComp_sub == BSTRS_COMPONENT_7th_SSZ_MW  )   dValue = dblStress[part][iPos][17-1];      // 17.warping torsion xz
		else if (nBStrsComp_sub == BSTRS_COMPONENT_7th_COMB_SSY)   dValue = dblStress[part][iPos][18-1];      // 18.summation shear xy
		else if (nBStrsComp_sub == BSTRS_COMPONENT_7th_COMB_SSZ)   dValue = dblStress[part][iPos][19-1];      // 19.summation shear xz
		else { ASSERT(0); }
	}
	else
		dValue = dblStress[part][iPos][nBStrsComponent];

	return dValue;
}

double CStressEngine::CalcBStssValue(T_STSS_D &StssD, int part)
{
	int nPosNum=10;
	if (CSectDB::IsEnable7thDOF()) nPosNum = 16;

	// Maximum/Minimum
	if(m_BStrsOutputSection==BSTRSINC_COMP_MAXMIN)
	{
		double dMaxVal = -DBL_MAX;
		double dMinVal =  DBL_MAX;
		double dValue  = 0.0;
		for(int i=0; i<nPosNum; i++) 
		{
			dValue = GetStressVal(StssD.dblStress, part,i,m_BStrsComponent, m_BStrsComp7thDof);

			if(m_bPositionMax)
			{
				if (dMaxVal < dValue) dMaxVal = dValue;
			}
			else
			{
				 if (dMinVal > dValue) dMinVal = dValue;
			}
		}
		if(m_bPositionMax)  return dMaxVal;
		else                return dMinVal;
	}
	// Maximum
	else if(m_BStrsOutputSection==BSTRSINC_COMP_MAX)
	{
		double dMaxVal = -DBL_MAX;
		double dValue  = 0.0;
		for(int i=0; i<nPosNum; i++)
		{
			dValue = GetStressVal(StssD.dblStress, part,i,m_BStrsComponent, m_BStrsComp7thDof);

			if (dMaxVal < dValue) dMaxVal = dValue;
		}
		return dMaxVal;
	}
	// Minimum
	else if(m_BStrsOutputSection==BSTRSINC_COMP_MIN)
	{
		double dMinVal = DBL_MAX;
		double dValue  = 0.0;
		for(int i=0; i<nPosNum; i++)
		{
			dValue = GetStressVal(StssD.dblStress, part,i,m_BStrsComponent, m_BStrsComp7thDof);

			if (dMinVal > dValue) dMinVal = dValue;
		}
		return dMinVal;
	}
	// Abs Max
	else if(m_BStrsOutputSection==BSTRSINC_COMP_ABSMAX)
	{
		double dAbsMaxVal = 0.0;
		double dValue     = 0.0;
		for(int i=0; i<nPosNum; i++)
		{
			dValue = GetStressVal(StssD.dblStress, part,i,m_BStrsComponent, m_BStrsComp7thDof);

			if (dAbsMaxVal < fabs(dValue)) dAbsMaxVal = fabs(dValue);
		}
		return dAbsMaxVal;
	}
	
	double dValue;
	dValue = GetStressVal(StssD.dblStress, part,m_BStrsOutputSection,m_BStrsComponent, m_BStrsComp7thDof);
	
	return dValue; 
}

void	 CStressEngine::DrawBStssContour(CDC *pDC)
{
	I_GPSModel	*gm=(I_GPSModel *)m_pGPSModel;
	T_MIRE_K mkey;
		
	int			  i, elem_num;
	T_ELEM_D	elem_d;
	CPen		  elem_pen, *old_pen;
	CArray<int, int>				    type_list;
	CArray<GRE_Atom, GRE_Atom&>	atom_list;
	BOOL bEscapePressed = FALSE;

	//if(!gm->m_bContour){ gm->GPSDrawOriginal(pDC);  return; }
	
	if(m_bDeformedShapeContour) 
	{
		if(gm->m_pDeformEngine == NULL)return;
		type_list.Add(gm->m_MinOTID + OBJECT_TYPE_DEFORMED);
	}
	else 
	{
		type_list.Add(gm->m_MinOTID + OBJECT_TYPE_ORIGINAL);
	}

	elem_pen.CreatePen(PS_SOLID, gm->m_DOPT.DR.nElemHddn, m_pContourEngine->m_ElemColor);
	old_pen = pDC->SelectObject(&elem_pen);

	gm->m_pGPSCtrl->GetZSortedList(type_list, gm->m_EKeyListVisible_Mirror, atom_list);
	elem_num = atom_list.GetSize();

	T_STSS_D StssD;
	for (i=0;i<elem_num;i++) 
	{
		if(gm->m_pGPSCtrl->WatchEscKeyPress()) return;
		if(gm->m_pGPSCtrl->IsZoomAllState() ||
			 gm->m_pGPSCtrl->IsObjectInClientWindow(atom_list[i].m_OType, atom_list[i].m_OKey)) 
		{
		  mkey.keymap = atom_list[i].m_OKey;
			m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d);
			BOOL bExist = GetBeamStressInc(mkey.key.elem_k, StssD);

			if(m_pDoc->m_pAttrCtrl->IsBeam(elem_d.eltyp) && 
				 (gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey)) && 
				 !bEscapePressed && bExist) 
			{
				if(gm->m_bContour)
				  DoBStssElementContour(pDC, atom_list[i].m_OKey);
				else
					gm->GPSDrawElement(pDC, atom_list[i].m_OKey);
			}
			else 
			{
				if(m_bDeformedShapeContour) gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, atom_list[i].m_OKey);
				else					              gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
			}
		}
	}

	// 변형된 그림에 Undeformed Shape을 같이 그릴 경우.
	// Contour를 그릴 경우는 Hidden이 default
	// 따라서 Undeformed Shape은 무조건 나중에 그린다...
	if(m_bDeformedShapeContour && gm->m_DOPT.DR.m_bDrawInactive  && !bEscapePressed) 
	{
		int	rf_bak=gm->m_DOPT.DR.m_RenderFlag;
		gm->m_DOPT.DR.m_RenderFlag = 2;
		gm->GPSDrawOriginal(pDC, TRUE);
		gm->m_DOPT.DR.m_RenderFlag = rf_bak;
	}
	pDC->SelectObject(old_pen);
	elem_pen.DeleteObject();
}

void	 CStressEngine::DrawBVmstDiagram(CDC *pDC)
{
	ASSERT(0);
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	T_MIRE_K  mkey;

	int			i, nElem;
	T_ELEM_D	elem_d;
	CArray <int, int>				type_list;
	CArray <GRE_Atom, GRE_Atom&>		atom_list;
	BOOL bEscapePressed = FALSE;
	m_mapSFDBMDMax.RemoveAll();

	CDC	*pdc=gm->m_pMyView->GetDC();
	m_dUnitLength = fabs(gm->m_pGPSCtrl->GetWorldLength(((double) pdc->GetDeviceCaps(LOGPIXELSX))/5.0));

	gm->m_pMyView->ReleaseDC(pdc);

	m_arSfdBmdOutPut.RemoveAll();
	m_arSfdBmdOutPutM.RemoveAll();  

	// SFD/BMD 이외의 그림은 Hidden을 끄고 그린다.
	BOOL fl_bak=gm->m_DOPT.DR.m_bFrameLine;
	gm->m_DOPT.DR.m_bFrameLine = TRUE;

	if(m_bDeformedShapeContour) 
	{
		if(gm->m_pDeformEngine == NULL) 
		{
			gm->m_DOPT.DR.m_bFrameLine = fl_bak;
			return;
		}
		type_list.Add(gm->m_MinOTID + OBJECT_TYPE_DEFORMED);

		// 변형된 모델에 Undeformed 모델을 같이 그릴 경우
		// Undeformed Shape이 Deformed Shape을 가려서 혼란스럽거나(Fill Mode일 경우)
		// 혹은 Deformed Shape에 가려져서 보이지 않게 되는 것을 피하기 위하여(Fill Mode가 아닐 경우)
		// Fill Mode가 아닐 경우에는 Undeformed Shape을 먼저 그리고
		// 그렇지 않을 경우엔 나중에 그린다.
		if(gm->m_DOPT.DR.m_bDrawInactive && m_bBSfdBmdLineOnly) 
		{
			int	rf_bak=gm->m_DOPT.DR.m_RenderFlag;
			gm->m_DOPT.DR.m_RenderFlag = 2;
			gm->GPSDrawOriginal(pDC, TRUE);
			gm->m_DOPT.DR.m_RenderFlag = rf_bak;
		}
	}
	else 
	{
		type_list.Add(gm->m_MinOTID + OBJECT_TYPE_ORIGINAL);
	}

	gm->m_pGPSCtrl->GetZSortedList(type_list, gm->m_EKeyListVisible_Mirror, atom_list);
	nElem = atom_list.GetSize();
	for (i=0;i<nElem ;i++) 
	{
		if(gm->m_pGPSCtrl->WatchEscKeyPress()) return;
		if(gm->m_pGPSCtrl->IsZoomAllState() ||
			gm->m_pGPSCtrl->IsObjectInClientWindow(atom_list[i].m_OType, atom_list[i].m_OKey)) 
		{
			mkey.keymap = atom_list[i].m_OKey;
			if(!m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d))continue;
			if(gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey) && !bEscapePressed)
			{
				BOOL bBeam  = m_pDoc->m_pAttrCtrl->IsBeam(elem_d.eltyp);
				if(m_bDeformedShapeContour)
				{
					if(bBeam) gm->m_pDeformEngine->DrawDeformedElement(pDC, atom_list[i].m_OKey);
					else			gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, atom_list[i].m_OKey);
				}
				else
				{
					if(bBeam) gm->GPSDrawElement(pDC, atom_list[i].m_OKey);
					else		  gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
				}
				gm->GPS_XGL_Begin_Diagram(mkey.key.elem_k);
				if(bBeam)DoBVmstDiagram(pDC, atom_list[i].m_OKey);
				gm->GPS_XGL_End_Elem();
			}
			else
			{
				if(m_bDeformedShapeContour)
					gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, atom_list[i].m_OKey);
				else
					gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
			}
		}
	}
	BOOL bOutNum=gm->m_DOPT.TX.m_bOutputNumber;

	if(bOutNum)
	{
		// Beam/Truss의 결과값 출력 
		BOOL bGrpFltMode=gm->m_pGPSCtrl->IsGroupFilterMode();
		for(i=0; i<m_arBStrsOutPut.GetSize(); i++)
		{
			if(bGrpFltMode)if(!gm->m_pDispFilter->IsExistEKey(m_arBStrsOutPut[i].EKey))continue;
			OutputBVmstDgrmNumber(pDC, m_arBStrsOutPut[i].EKey, m_arBStrsOutPut[i].VmstD, m_arBStrsOutPut[i].Pos, m_arBStrsOutPut[i].nComp, m_arBStrsOutPut[i].dMinMaxVal);
		}
		for(i=0; i<m_arBStrsOutPutM.GetSize(); i++)
		{
			if(bGrpFltMode)if(!gm->m_pDispFilter->IsExistEKey(m_arBStrsOutPutM[i].EKey))continue;
			OutputBVmstDgrmNumber(pDC, m_arBStrsOutPutM[i].EKey, m_arBStrsOutPutM[i].VmstD, m_arBStrsOutPutM[i].Pos, m_arBStrsOutPutM[i].nComp,m_arBStrsOutPutM[i].dMinMaxVal);
		}
	}
	m_arBStrsOutPut.RemoveAll();
	m_arBStrsOutPutM.RemoveAll(); 


	// 변형된 모델에 Undeformed 모델을 같이 그릴 경우
	if (m_bDeformedShapeContour && gm->m_DOPT.DR.m_bDrawInactive && !m_bBSfdBmdLineOnly && !bEscapePressed) 
	{
		int	rf_bak=gm->m_DOPT.DR.m_RenderFlag;
		gm->m_DOPT.DR.m_RenderFlag = 2;
		gm->GPSDrawOriginal(pDC, TRUE);
		gm->m_DOPT.DR.m_RenderFlag = rf_bak;
	}
	gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}

void	 CStressEngine::DrawBStrsDiagram(CDC *pDC)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	T_MIRE_K  mkey;

	int			i, nElem;
	T_ELEM_D	elem_d;
	CArray <int, int>				type_list;
	CArray <GRE_Atom, GRE_Atom&>		atom_list;
	BOOL bEscapePressed = FALSE;
	m_mapSFDBMDMax.RemoveAll();
	
	CDC	*pdc=gm->m_pMyView->GetDC();
	m_dUnitLength = fabs(gm->m_pGPSCtrl->GetWorldLength(((double) pdc->GetDeviceCaps(LOGPIXELSX))/5.0));
	
	gm->m_pMyView->ReleaseDC(pdc);

	m_arSfdBmdOutPut.RemoveAll();
	m_arSfdBmdOutPutM.RemoveAll();  

	// SFD/BMD 이외의 그림은 Hidden을 끄고 그린다.
	BOOL fl_bak=gm->m_DOPT.DR.m_bFrameLine;
	gm->m_DOPT.DR.m_bFrameLine = TRUE;

	if(m_bDeformedShapeContour) 
	{
		if(gm->m_pDeformEngine == NULL) 
		{
			gm->m_DOPT.DR.m_bFrameLine = fl_bak;
			return;
		}
		type_list.Add(gm->m_MinOTID + OBJECT_TYPE_DEFORMED);

		// 변형된 모델에 Undeformed 모델을 같이 그릴 경우
		// Undeformed Shape이 Deformed Shape을 가려서 혼란스럽거나(Fill Mode일 경우)
		// 혹은 Deformed Shape에 가려져서 보이지 않게 되는 것을 피하기 위하여(Fill Mode가 아닐 경우)
		// Fill Mode가 아닐 경우에는 Undeformed Shape을 먼저 그리고
		// 그렇지 않을 경우엔 나중에 그린다.
		if(gm->m_DOPT.DR.m_bDrawInactive && m_bBSfdBmdLineOnly) 
		{
			int	rf_bak=gm->m_DOPT.DR.m_RenderFlag;
			gm->m_DOPT.DR.m_RenderFlag = 2;
			gm->GPSDrawOriginal(pDC, TRUE);
			gm->m_DOPT.DR.m_RenderFlag = rf_bak;
		}
	}
	else 
	{
		type_list.Add(gm->m_MinOTID + OBJECT_TYPE_ORIGINAL);
	}

	gm->m_pGPSCtrl->GetZSortedList(type_list, gm->m_EKeyListVisible_Mirror, atom_list);
	nElem = atom_list.GetSize();
	for (i=0;i<nElem ;i++) 
	{
		if(gm->m_pGPSCtrl->WatchEscKeyPress()) return;
		if(gm->m_pGPSCtrl->IsZoomAllState() ||
			 gm->m_pGPSCtrl->IsObjectInClientWindow(atom_list[i].m_OType, atom_list[i].m_OKey)) 
		{
			mkey.keymap = atom_list[i].m_OKey;
			if(!m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d))continue;
			if(gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey) && !bEscapePressed)
			{
				BOOL bBeam  = m_pDoc->m_pAttrCtrl->IsBeam(elem_d.eltyp);
				if(m_bDeformedShapeContour)
				{
				  if(bBeam) gm->m_pDeformEngine->DrawDeformedElement(pDC, atom_list[i].m_OKey);
					else			gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, atom_list[i].m_OKey);
				}
			  else
				{
				  if(bBeam) gm->GPSDrawElement(pDC, atom_list[i].m_OKey);
					else		  gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
				}
				gm->GPS_XGL_Begin_Diagram(mkey.key.elem_k);
			  if(bBeam)DoBStrsDiagram(pDC, atom_list[i].m_OKey);
				gm->GPS_XGL_End_Elem();
			}
			else
			{
				if(m_bDeformedShapeContour)
					gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, atom_list[i].m_OKey);
				else
					gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
			}
		}
	}
	BOOL bOutNum=gm->m_DOPT.TX.m_bOutputNumber;

	if(bOutNum)
	{
		// Beam/Truss의 결과값 출력 
		BOOL bGrpFltMode=gm->m_pGPSCtrl->IsGroupFilterMode();
		for(i=0; i<m_arBStrsOutPut.GetSize(); i++)
		{
			if(bGrpFltMode)if(!gm->m_pDispFilter->IsExistEKey(m_arBStrsOutPut[i].EKey))continue;
			OutputBStrsDgrmNumber(pDC, m_arBStrsOutPut[i].EKey, m_arBStrsOutPut[i].StrbD, m_arBStrsOutPut[i].Pos, m_arBStrsOutPut[i].nComp, m_arBStrsOutPut[i].dMinMaxVal);
		}
		for(i=0; i<m_arBStrsOutPutM.GetSize(); i++)
		{
			if(bGrpFltMode)if(!gm->m_pDispFilter->IsExistEKey(m_arBStrsOutPutM[i].EKey))continue;
			OutputBStrsDgrmNumber(pDC, m_arBStrsOutPutM[i].EKey, m_arBStrsOutPutM[i].StrbD, m_arBStrsOutPutM[i].Pos, m_arBStrsOutPutM[i].nComp,m_arBStrsOutPutM[i].dMinMaxVal);
		}
	}
	m_arBStrsOutPut.RemoveAll();
	m_arBStrsOutPutM.RemoveAll(); 


	// 변형된 모델에 Undeformed 모델을 같이 그릴 경우
	if (m_bDeformedShapeContour && gm->m_DOPT.DR.m_bDrawInactive && !m_bBSfdBmdLineOnly && !bEscapePressed) 
	{
		int	rf_bak=gm->m_DOPT.DR.m_RenderFlag;
		gm->m_DOPT.DR.m_RenderFlag = 2;
		gm->GPSDrawOriginal(pDC, TRUE);
		gm->m_DOPT.DR.m_RenderFlag = rf_bak;
	}
	gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}


void	 CStressEngine::DrawBStssDiagram(CDC *pDC)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	T_MIRE_K  mkey;

	int			i, nElem;
	T_ELEM_D	elem_d;
	CArray <int, int>				type_list;
	CArray <GRE_Atom, GRE_Atom&>		atom_list;
	BOOL bEscapePressed = FALSE;
	m_mapSFDBMDMax.RemoveAll();
	
	CDC	*pdc=gm->m_pMyView->GetDC();
	m_dUnitLength = fabs(gm->m_pGPSCtrl->GetWorldLength(((double) pdc->GetDeviceCaps(LOGPIXELSX))/5.0));
	
	gm->m_pMyView->ReleaseDC(pdc);

	m_arSfdBmdOutPut.RemoveAll();
	m_arSfdBmdOutPutM.RemoveAll();  

	// SFD/BMD 이외의 그림은 Hidden을 끄고 그린다.
	BOOL fl_bak=gm->m_DOPT.DR.m_bFrameLine;
	gm->m_DOPT.DR.m_bFrameLine = TRUE;

	if(m_bDeformedShapeContour) 
	{
		if(gm->m_pDeformEngine == NULL) 
		{
			gm->m_DOPT.DR.m_bFrameLine = fl_bak;
			return;
		}
		type_list.Add(gm->m_MinOTID + OBJECT_TYPE_DEFORMED);

		// 변형된 모델에 Undeformed 모델을 같이 그릴 경우
		// Undeformed Shape이 Deformed Shape을 가려서 혼란스럽거나(Fill Mode일 경우)
		// 혹은 Deformed Shape에 가려져서 보이지 않게 되는 것을 피하기 위하여(Fill Mode가 아닐 경우)
		// Fill Mode가 아닐 경우에는 Undeformed Shape을 먼저 그리고
		// 그렇지 않을 경우엔 나중에 그린다.
		if(gm->m_DOPT.DR.m_bDrawInactive && m_bBSfdBmdLineOnly) 
		{
			int	rf_bak=gm->m_DOPT.DR.m_RenderFlag;
			gm->m_DOPT.DR.m_RenderFlag = 2;
			gm->GPSDrawOriginal(pDC, TRUE);
			gm->m_DOPT.DR.m_RenderFlag = rf_bak;
		}
	}
	else 
	{
		type_list.Add(gm->m_MinOTID + OBJECT_TYPE_ORIGINAL);
	}

	gm->m_pGPSCtrl->GetZSortedList(type_list, gm->m_EKeyListVisible_Mirror, atom_list);
	nElem = atom_list.GetSize();
	for (i=0;i<nElem ;i++) 
	{
		if(gm->m_pGPSCtrl->WatchEscKeyPress()) return;
		if(gm->m_pGPSCtrl->IsZoomAllState() ||
			 gm->m_pGPSCtrl->IsObjectInClientWindow(atom_list[i].m_OType, atom_list[i].m_OKey)) 
		{
			mkey.keymap = atom_list[i].m_OKey;
			if(!m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d))continue;
			if(gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey) && !bEscapePressed)
			{
				BOOL bBeam  = m_pDoc->m_pAttrCtrl->IsBeam(elem_d.eltyp);
				if(m_bDeformedShapeContour)
				{
				  if(bBeam) gm->m_pDeformEngine->DrawDeformedElement(pDC, atom_list[i].m_OKey);
					else			gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, atom_list[i].m_OKey);
				}
			  else
				{
				  if(bBeam) gm->GPSDrawElement(pDC, atom_list[i].m_OKey);
					else		  gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
				}
				gm->GPS_XGL_Begin_Diagram(mkey.key.elem_k);
			  if(bBeam)DoBStssDiagram(pDC, atom_list[i].m_OKey);
				gm->GPS_XGL_End_Elem();
			}
			else
			{
				if(m_bDeformedShapeContour)
					gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, atom_list[i].m_OKey);
				else
					gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
			}
		}
	}
	BOOL bOutNum=gm->m_DOPT.TX.m_bOutputNumber;

	if(bOutNum)
	{
		// Beam/Truss의 결과값 출력 
		BOOL bGrpFltMode=gm->m_pGPSCtrl->IsGroupFilterMode();
		for(i=0; i<m_arSfdBmdOutPut.GetSize(); i++)
		{
			m_bPositionMax = TRUE; 
			if(bGrpFltMode)if(!gm->m_pDispFilter->IsExistEKey(m_arSfdBmdOutPut[i].EKey))continue;
			OutputSfdBmdNumber(pDC, m_arSfdBmdOutPut[i].EKey, m_arSfdBmdOutPut[i].StssD, m_arSfdBmdOutPut[i].Pos, m_arSfdBmdOutPut[i].nComp, m_arSfdBmdOutPut[i].dMinMaxVal);
		}
		for(i=0; i<m_arSfdBmdOutPutM.GetSize(); i++)
		{
			m_bPositionMax = FALSE; 
			if(bGrpFltMode)if(!gm->m_pDispFilter->IsExistEKey(m_arSfdBmdOutPutM[i].EKey))continue;
			OutputSfdBmdNumber(pDC, m_arSfdBmdOutPutM[i].EKey, m_arSfdBmdOutPutM[i].StssD, m_arSfdBmdOutPutM[i].Pos, m_arSfdBmdOutPut[i].nComp, m_arSfdBmdOutPutM[i].dMinMaxVal);
		}
	}
	m_arSfdBmdOutPut.RemoveAll();
	m_arSfdBmdOutPutM.RemoveAll(); 


	// 변형된 모델에 Undeformed 모델을 같이 그릴 경우
	if (m_bDeformedShapeContour && gm->m_DOPT.DR.m_bDrawInactive && !m_bBSfdBmdLineOnly && !bEscapePressed) 
	{
		int	rf_bak=gm->m_DOPT.DR.m_RenderFlag;
		gm->m_DOPT.DR.m_RenderFlag = 2;
		gm->GPSDrawOriginal(pDC, TRUE);
		gm->m_DOPT.DR.m_RenderFlag = rf_bak;
	}
	gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}

void CStressEngine::DoBVmstDiagram(CDC *pDC, unsigned int ekey)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	T_MIRE_K mkey;
	mkey.keymap = ekey;

	if(IsMinMaxDiagram()) { ASSERT(0); return; }

	int		    poly_num;
	double		local_vector[3][3];
	double    dMnMxVal[2];

	POSITION	pos;
	C3DPoint	node_i, node_j;
	C3DPoint	pnt[2], *txt_pnt, *txt_pntm;
	CArray<BOOL, BOOL>				ef_list;
	CArray<BOOL, BOOL>				rect_flag;
	CArray<double, double &>	val_list;
	CArray<C3DPoint,C3DPoint&>vtx_list;
	CArray<CList<C3DPoint,C3DPoint> *, CList <C3DPoint, C3DPoint> *>polygon_list;

	if((gm->m_pDeformEngine==NULL) || (m_pContourEngine==NULL))return;

	T_VMST_D VmstD;
	if(!GetBeamStressEffective(mkey.key.elem_k, VmstD))return;

	m_pDoc->calcFrameLocalVector(mkey.key.elem_k, local_vector);

	if(m_bDeformedShapeContour)
		gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, NULL, NULL);
	else
		gm->GetShapeElement(ekey, polygon_list, NULL, NULL, NULL);

	poly_num = polygon_list.GetSize();
	if((poly_num!=1) || (polygon_list[0]->GetCount()!=2))return;

	if(gm->m_DOPT.TX.m_bOutputNumber) 
	{
		txt_pnt   = new C3DPoint[4];
		txt_pntm  = new C3DPoint[4];
	}
	else 
	{
		txt_pnt   = NULL;
		txt_pntm  = NULL;
	}

	pos = polygon_list[0]->GetHeadPosition();
	pnt[0] = polygon_list[0]->GetNext(pos);
	pnt[1] = polygon_list[0]->GetNext(pos);

	GetOffsetedPoint(mkey.key.elem_k,pnt[0],pnt[1],node_i,node_j,m_BStrsComponent);
	BVmstDgrmPolygon(VmstD, local_vector, node_i, node_j, vtx_list, val_list, ef_list, rect_flag, txt_pnt, mkey.key.elem_k, dMnMxVal);
	if(txt_pnt)AddBVmstDgrmOutputData(mkey.key.elem_k,txt_pnt,VmstD,dMnMxVal,this->m_BStrsComponent,0);

	DoBSfdBmdContour(pDC, vtx_list, val_list, ef_list, rect_flag);

	vtx_list.RemoveAll();
	val_list.RemoveAll();
	ef_list.RemoveAll();
	rect_flag.RemoveAll();

	FreeMemoryPolyList(&polygon_list); 

	if(txt_pnt) delete []txt_pnt;
	if(txt_pntm)delete []txt_pntm;
}

void CStressEngine::DoBStrsDiagram(CDC *pDC, unsigned int ekey)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	T_MIRE_K mkey;
	mkey.keymap = ekey;
	
	int		    poly_num;
	double		local_vector[3][3];
	double    dMnMxVal[2];
			
	POSITION	pos;
	C3DPoint	node_i, node_j;
	C3DPoint	pnt[2], *txt_pnt, *txt_pntm;
	CArray<BOOL, BOOL>				ef_list;
	CArray<BOOL, BOOL>				rect_flag;
	CArray<double, double &>	val_list;
	CArray<C3DPoint,C3DPoint&>vtx_list;
	CArray<CList<C3DPoint,C3DPoint> *, CList <C3DPoint, C3DPoint> *>polygon_list;

	if((gm->m_pDeformEngine==NULL) || (m_pContourEngine==NULL))return;
	
	T_STRB_D StrbD,StrbDMin;

	if(IsMinMaxDiagram()) 
	{
		if(!GetBeamStress(mkey.key.elem_k, StrbD) || !GetBeamStressMin(mkey.key.elem_k, StrbDMin))return;
	}
	else 
	{
		if(!GetBeamStress(mkey.key.elem_k, StrbD))return;
	}
	
	m_pDoc->calcFrameLocalVector(mkey.key.elem_k, local_vector);

	if(m_bDeformedShapeContour)
		gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, NULL, NULL);
	else
		gm->GetShapeElement(ekey, polygon_list, NULL, NULL, NULL);
	
	poly_num = polygon_list.GetSize();
	if((poly_num!=1) || (polygon_list[0]->GetCount()!=2))return;
	
	if(gm->m_DOPT.TX.m_bOutputNumber) 
	{
		txt_pnt   = new C3DPoint[4];
		txt_pntm  = new C3DPoint[4];
	}
	else 
	{
		txt_pnt   = NULL;
		txt_pntm  = NULL;
	}

	pos = polygon_list[0]->GetHeadPosition();
	pnt[0] = polygon_list[0]->GetNext(pos);
	pnt[1] = polygon_list[0]->GetNext(pos);

	GetOffsetedPoint(mkey.key.elem_k,pnt[0],pnt[1],node_i,node_j,m_BStrsComponent);
	BStrsDgrmPolygon(StrbD, local_vector, node_i, node_j, vtx_list, val_list, ef_list, rect_flag, txt_pnt, mkey.key.elem_k, dMnMxVal);
	if(txt_pnt)AddBStrsDgrmOutputData(mkey.key.elem_k,txt_pnt,StrbD,dMnMxVal,this->m_BStrsComponent,0);
	
	if(IsMinMaxDiagram())
	{
		BStrsDgrmPolygon(StrbDMin, local_vector, node_i, node_j, vtx_list, val_list, ef_list, rect_flag, txt_pntm, mkey.key.elem_k, dMnMxVal);
		if(txt_pntm)AddBStrsDgrmOutputData(mkey.key.elem_k,txt_pntm,StrbDMin,dMnMxVal,this->m_BStrsComponent,1);
	}
	DoBSfdBmdContour(pDC, vtx_list, val_list, ef_list, rect_flag);

	vtx_list.RemoveAll();
	val_list.RemoveAll();
	ef_list.RemoveAll();
	rect_flag.RemoveAll();

	FreeMemoryPolyList(&polygon_list); 
	
	if(txt_pnt) delete []txt_pnt;
	if(txt_pntm)delete []txt_pntm;
}

void CStressEngine::DoBStssDiagram(CDC *pDC, unsigned int ekey)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	T_MIRE_K mkey;
	mkey.keymap = ekey;
	
	int		    poly_num;
	double		local_vector[3][3];
	double    dMnMxVal[2];
			
	POSITION	pos;
	//C3DPoint	node_i, node_j;
	C3DPoint	pnt[2], *txt_pnt, *txt_pntm;
	CArray<BOOL, BOOL>				ef_list;
	CArray<BOOL, BOOL>				rect_flag;
	CArray<double, double &>	val_list;
	CArray<C3DPoint,C3DPoint&>vtx_list;
	CArray<CList<C3DPoint,C3DPoint> *, CList <C3DPoint, C3DPoint> *>polygon_list;

	if((gm->m_pDeformEngine==NULL) || (m_pContourEngine==NULL))return;
	
	T_STSS_D StssD,StssDMin;

	if(IsMinMaxDiagram()) 
	{
		if(!GetBeamStressInc(mkey.key.elem_k, StssD) || !GetBeamStressIncMin(mkey.key.elem_k, StssDMin))return;
	}
	else 
	{
		if(!GetBeamStressInc(mkey.key.elem_k, StssD))return;
	}
	
	m_pDoc->calcFrameLocalVector(mkey.key.elem_k, local_vector);

	if(m_bDeformedShapeContour)
		gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, NULL, NULL);
	else
		gm->GetShapeElement(ekey, polygon_list, NULL, NULL, NULL);
	
	poly_num = polygon_list.GetSize();
	if((poly_num!=1) || (polygon_list[0]->GetCount()!=2))return;
	
	if(gm->m_DOPT.TX.m_bOutputNumber) 
	{
		txt_pnt   = new C3DPoint[4];
		txt_pntm  = new C3DPoint[4];
	}
	else 
	{
		txt_pnt   = NULL;
		txt_pntm  = NULL;
	}

	pos = polygon_list[0]->GetHeadPosition();
	pnt[0] = polygon_list[0]->GetNext(pos);
	pnt[1] = polygon_list[0]->GetNext(pos);

	CArray<T_STSS_OUTVAL_D,T_STSS_OUTVAL_D&> arOutVal; 
	T_STSS_OUTVAL_D OutVal;

	m_bPositionMax = TRUE; // Max Load Case의 Max Position  
	//GetOffsetedPoint(mkey.key.elem_k,pnt[0],pnt[1],node_i,node_j,m_BStrsComponent); // MQC-3747 20101210 KIMJM
	BSfdBmdMakePolygon(StssD, local_vector, pnt[0], pnt[1], vtx_list, val_list, ef_list, rect_flag, txt_pnt, mkey.key.elem_k, dMnMxVal);
	if(txt_pnt)AddBSfdBmdOutputData(mkey.key.elem_k,txt_pnt,StssD,dMnMxVal,this->m_BStrsComponent,0);
	
	if(IsMinMaxDiagram())
	{
		m_bPositionMax = FALSE; // Max Load Case의 Max Position
		BSfdBmdMakePolygon(StssDMin, local_vector, pnt[0], pnt[1], vtx_list, val_list, ef_list, rect_flag, txt_pntm, mkey.key.elem_k, dMnMxVal);
		if(txt_pntm)AddBSfdBmdOutputData(mkey.key.elem_k,txt_pntm,StssDMin,dMnMxVal,this->m_BStrsComponent,1);
	}
	DoBSfdBmdContour(pDC, vtx_list, val_list, ef_list, rect_flag);

	vtx_list.RemoveAll();
	val_list.RemoveAll();
	ef_list.RemoveAll();
	rect_flag.RemoveAll();

	FreeMemoryPolyList(&polygon_list); 
	
	if(txt_pnt) delete []txt_pnt;
	if(txt_pntm)delete []txt_pntm;
}

void CStressEngine::DoBSfdBmdContour(CDC *pDC,
									CArray <C3DPoint, C3DPoint &> &vtx_list,
									CArray <double, double &> &val_list,
									CArray <BOOL, BOOL> &ef_list,
									CArray <BOOL, BOOL> &rect_flag)
{
	I_GPSModel					*gm=(I_GPSModel *) m_pGPSModel;
	int							i, j, k, l, m, poly_num=rect_flag.GetSize();
	C3DPoint					vtx_array[4];
	double						val_array[4];
	BOOL						ef_array[4];
	CArray <int, int>			vnum_list;
	CArray <VtxInfo, VtxInfo>	vinfo_list;

	k = 0;
	l = 0;
	m = 0;
	for(i=0;i<poly_num;i++) 
	{
		if(rect_flag[i]) 
		{
			for(j=0;j<4;j++) 
			{
				val_array[j] = val_list[k++];
				vtx_array[j] = vtx_list[l++];
				ef_array[j] = ef_list[m++];
			}
			m_pContourEngine->SfdBmdFramePoly(vtx_array, val_array, ef_array, 4, vnum_list, vinfo_list,m_bVerticalLineFill);
		}
		else 
		{
			for(j=0;j<3;j++) 
			{
				val_array[j] = val_list[k++];
				vtx_array[j] = vtx_list[l++];
				ef_array[j] = ef_list[m++];
			}
			m_pContourEngine->SfdBmdFramePoly(vtx_array, val_array, ef_array, 3, vnum_list, vinfo_list,m_bVerticalLineFill);
		}
	}

	if (gm->m_bGradient) 
	{
		DrawContourListGrad(pDC, vnum_list, vinfo_list);
	}
	else 
	{
		DrawContourList(pDC, vnum_list, vinfo_list);
	}

	vnum_list.RemoveAll();
	vinfo_list.RemoveAll();
}

void CStressEngine::AddBSfdBmdOutputData(T_ELEM_K ElemK,C3DPoint *pTxtPt,T_STSS_D &StrbD,
																					double *pMnMxVal,int nComp,int nType)
{
	T_STSS_OUTVAL_D OutVal;
	if(GetBSfdBmdOutputData(OutVal,ElemK,pTxtPt,StrbD,pMnMxVal,nComp))
	{
		if(nType == 0) m_arSfdBmdOutPut.Add(OutVal);
		else           m_arSfdBmdOutPutM.Add(OutVal);
	}
}

void CStressEngine::AddBVmstDgrmOutputData(T_ELEM_K ElemK,C3DPoint *pTxtPt,T_VMST_D &VmstD,
																					 double *pMnMxVal,int nComp,int nType)
{
	T_SFDBMD_OUTVAL_D OutVal;
	if(GetBVmstDgrmOutputData(OutVal,ElemK,pTxtPt,VmstD,pMnMxVal,nComp))
	{
		if(nType == 0) m_arBStrsOutPut.Add(OutVal);
		else           m_arBStrsOutPutM.Add(OutVal);
	}
}

void CStressEngine::AddBStrsDgrmOutputData(T_ELEM_K ElemK,C3DPoint *pTxtPt,T_STRB_D &StrbD,
																					double *pMnMxVal,int nComp,int nType)
{
	T_SFDBMD_OUTVAL_D OutVal;
	if(GetBStrsDgrmOutputData(OutVal,ElemK,pTxtPt,StrbD,pMnMxVal,nComp))
	{
		if(nType == 0) m_arBStrsOutPut.Add(OutVal);
		else           m_arBStrsOutPutM.Add(OutVal);
	}
}


void CStressEngine::DrawContourList(CDC *pDC, CArray <int, int> &vnum_list, CArray <VtxInfo, VtxInfo> &vtx_list)
{
	DECLARE_GPSMD();

	// SFD/BMD용 DrawContourList
	int		i, j, k, poly_num=vnum_list.GetSize();
	BOOL	is_bsfdbmd=FALSE;
	CPen	edge_pen, *old_pen,*old_pen2;
	CClientDC	 ClientDC(((I_GPSModel*)m_pGPSModel)->m_pMyView);
	CList<C3DPoint,C3DPoint>	vlist;

	if(!m_pContourEngine)return;
	
	if(gm->m_GPSInstruction==GPS_COMMAND_BSTRSINC) is_bsfdbmd = TRUE;
	if(gm->m_GPSInstruction==GPS_COMMAND_BSTRSDGRM) is_bsfdbmd = TRUE;
	if(gm->m_GPSInstruction==GPS_COMMAND_BSTRSDETAILDGRM) is_bsfdbmd = TRUE;
	
	if(!is_bsfdbmd || !(is_bsfdbmd && m_bBSfdBmdLineOnly) ) 
	{
		if((is_bsfdbmd) && !gm->m_bContour)
			DrawSFDBMDContourList_mono(pDC,vnum_list,vtx_list);
		else
			CEngineBase::DrawContourList(pDC,vnum_list,vtx_list);
	}
	else  
	{
		k = 0;
		for(i=0;i<poly_num;i++) 
		{  
			if((gm->m_DOPT.m_PrintMode == 0) && pDC->IsPrinting()) // B&W Mode
				edge_pen.CreatePen(PS_SOLID, gm->m_nLineWidth, RGB(60,60,60));
			else if(!gm->m_bContour)
				edge_pen.CreatePen(PS_SOLID, gm->m_nLineWidth, gm->m_DOPT.CL.m_BeamDiagramColor);
			else // Color Mode
				edge_pen.CreatePen(PS_SOLID, gm->m_nLineWidth, m_pContourEngine->GetValueColor(vtx_list[k].val));

			old_pen = (CPen *) pDC->SelectObject(&edge_pen);
			if(!gm->m_bVirtualMode && !gm->m_bAnimation)
				old_pen2 = (CPen *) ClientDC.SelectObject(&edge_pen);
			
			for(j=0;j<vnum_list[i];j++) 
			{
				if(vtx_list[k+j].ef) 
				{
					if (gm->m_bVirtualMode)
						gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, vtx_list[k+(j%vnum_list[i])].vtx, vtx_list[k+((j+1)%vnum_list[i])].vtx);
					else
					{
						if(!gm->m_bAnimation)
							gm->m_pGPSCtrl->DrawLine3DOnClientWindow(&ClientDC, vtx_list[k+(j%vnum_list[i])].vtx, vtx_list[k+((j+1)%vnum_list[i])].vtx);
						gm->m_pGPSCtrl->DrawLine3D(pDC, vtx_list[k+(j%vnum_list[i])].vtx, vtx_list[k+((j+1)%vnum_list[i])].vtx);
					}
				}
			}
			k += vnum_list[i];
			pDC->SelectObject(old_pen);
			if(!gm->m_bVirtualMode && !gm->m_bAnimation)
				ClientDC.SelectObject(old_pen2);
			edge_pen.DeleteObject();
		}
	}
}

void CStressEngine::DrawContourListGrad(CDC *pDC, CArray <int, int> &vnum_list, CArray <VtxInfo, VtxInfo> &vtx_list)
{
	int							i, j, k=0, poly_num=vnum_list.GetSize();
	I_GPSModel					*gm=(I_GPSModel *) m_pGPSModel;
	BOOL						is_bsfdbmd=FALSE, is_wsfdbmd=FALSE,is_esfdbmd=FALSE,is_thsfdbmd=FALSE;
	CPoint						p1, p2;
	CPen						edge_pen, *old_pen,*old_pen2;
	CClientDC		ClientDC(((I_GPSModel*)m_pGPSModel)->m_pMyView);

	CArray<CPoint, CPoint &>		vtx_output;
	CArray<C3DPoint, C3DPoint &>vtx_input;
	CArray<COLORREF, COLORREF &>col_input, col_output;

	if(m_pContourEngine == NULL)return;
	
	if(gm->m_GPSInstruction==GPS_COMMAND_BSTRSINC) is_bsfdbmd = TRUE;
	if(gm->m_GPSInstruction==GPS_COMMAND_BSTRSDGRM) is_bsfdbmd = TRUE;
	if(gm->m_GPSInstruction==GPS_COMMAND_BSTRSDETAILDGRM) is_bsfdbmd = TRUE;

	if(!(is_bsfdbmd) || !(is_bsfdbmd && m_bBSfdBmdLineOnly) ) 
	{
		if( (is_bsfdbmd) && !gm->m_bContour)
			DrawSFDBMDContourList_mono(pDC,vnum_list,vtx_list);
		else
			CEngineBase::DrawContourListGrad(pDC,vnum_list,vtx_list);
	}
	else
	{
		k = 0;
		for (i=0;i<poly_num;i++) 
		{
			if((gm->m_DOPT.m_PrintMode == 0) && pDC->IsPrinting()) // B&W Mode
				edge_pen.CreatePen(PS_SOLID, gm->m_nLineWidth, RGB(60,60,60));
			else if(!gm->m_bContour)
				edge_pen.CreatePen(PS_SOLID, gm->m_nLineWidth, gm->m_DOPT.CL.m_BeamDiagramColor);
			else // Color Mode
				edge_pen.CreatePen(PS_SOLID, gm->m_nLineWidth, m_pContourEngine->GetValueColor(vtx_list[k].val));

			old_pen = (CPen *) pDC->SelectObject(&edge_pen);
			if(!gm->m_bVirtualMode && !gm->m_bAnimation)
				old_pen2 = (CPen *) ClientDC.SelectObject(&edge_pen);

			
			for (j=0;j<vnum_list[i];j++) {
				if (vtx_list[k+j].ef) {
					if (gm->m_bVirtualMode) {
						gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, vtx_list[k+(j%vnum_list[i])].vtx, vtx_list[k+((j+1)%vnum_list[i])].vtx);
					}
					else {
						if(!gm->m_bAnimation)
							gm->m_pGPSCtrl->DrawLine3DOnClientWindow(&ClientDC, vtx_list[k+(j%vnum_list[i])].vtx, vtx_list[k+((j+1)%vnum_list[i])].vtx);
						gm->m_pGPSCtrl->DrawLine3D(pDC, vtx_list[k+(j%vnum_list[i])].vtx, vtx_list[k+((j+1)%vnum_list[i])].vtx);
					}
				}
			}
			k += vnum_list[i];
			pDC->SelectObject(old_pen);
			if(!gm->m_bVirtualMode && !gm->m_bAnimation)
				ClientDC.SelectObject(old_pen2);

			edge_pen.DeleteObject();
		}
	}
	
}

void CStressEngine::DrawSFDBMDContourList_mono(CDC *pDC, CArray <int, int> &vnum_list, CArray <VtxInfo, VtxInfo> &vtx_list)								
{
	int							i, j, k, poly_num=vnum_list.GetSize();
	I_GPSModel					*gm=(I_GPSModel *) m_pGPSModel;
	CList <C3DPoint, C3DPoint>	vlist;

	CClientDC		ClientDC(((I_GPSModel*)m_pGPSModel)->m_pMyView);
	
	if (m_pContourEngine == NULL) {
		return;
	}

	k = 0;

	for (i=0;i<poly_num;i++) {
		for (j=0;j<vnum_list[i];j++) {
			vlist.AddTail(vtx_list[k+j].vtx);
		}

		//COLORREF color =gm->m_BeamDiagramColor;
		COLORREF color =gm->m_DOPT.CL.m_BeamDiagramColor;
		
		if (gm->m_bVirtualMode)
			gm->m_pGPSCtrl->DrawPolygon3DFillOnClientWindow(pDC, vlist, color);
		else
		{
			if (!gm->m_bAnimation)
				gm->m_pGPSCtrl->DrawPolygon3DFillOnClientWindow(&ClientDC, vlist, color);
			gm->m_pGPSCtrl->DrawPolygon3DFill(pDC, vlist, color);
		}
		vlist.RemoveAll();
		k += vnum_list[i];
	}

}

BOOL CStressEngine::GetBSfdBmdOutputData(T_STSS_OUTVAL_D &OutVal,T_ELEM_K ElemK,C3DPoint *pTxtPt,T_STSS_D &StssD,double *pMnMxVal,int nComp)
{
	I_GPSModel  *gm=(I_GPSModel *)m_pGPSModel;
	if(!gm->m_DOPT.TX.m_bOutputNumber)return FALSE; 
	OutVal.Pos[0] = pTxtPt[0];
	OutVal.Pos[1] = pTxtPt[1];
	OutVal.Pos[2] = pTxtPt[2];
	OutVal.Pos[3] = pTxtPt[3];
	OutVal.EKey   = ElemK;
	OutVal.StssD  = StssD;
	OutVal.nComp  = nComp;
	OutVal.dMinMaxVal[0] = pMnMxVal[0];
	OutVal.dMinMaxVal[1] = pMnMxVal[1];
	return TRUE; 
}

BOOL CStressEngine::GetBVmstDgrmOutputData(T_SFDBMD_OUTVAL_D &OutVal,T_ELEM_K ElemK,C3DPoint *pTxtPt,T_VMST_D &VmstD,double *pMnMxVal,int nComp)
{
	I_GPSModel  *gm=(I_GPSModel *)m_pGPSModel;
	if(!gm->m_DOPT.TX.m_bOutputNumber)return FALSE; 
	OutVal.Pos[0] = pTxtPt[0];
	OutVal.Pos[1] = pTxtPt[1];
	OutVal.Pos[2] = pTxtPt[2];
	OutVal.Pos[3] = pTxtPt[3];
	OutVal.EKey   = ElemK;
	OutVal.VmstD  = VmstD;
	OutVal.nComp  = nComp;
	OutVal.dMinMaxVal[0] = pMnMxVal[0];
	OutVal.dMinMaxVal[1] = pMnMxVal[1];
	return TRUE; 
}

BOOL CStressEngine::GetBStrsDgrmOutputData(T_SFDBMD_OUTVAL_D &OutVal,T_ELEM_K ElemK,C3DPoint *pTxtPt,T_STRB_D &StrbD,double *pMnMxVal,int nComp)
{
	I_GPSModel  *gm=(I_GPSModel *)m_pGPSModel;
	if(!gm->m_DOPT.TX.m_bOutputNumber)return FALSE; 
	OutVal.Pos[0] = pTxtPt[0];
	OutVal.Pos[1] = pTxtPt[1];
	OutVal.Pos[2] = pTxtPt[2];
	OutVal.Pos[3] = pTxtPt[3];
	OutVal.EKey   = ElemK;
	OutVal.StrbD  = StrbD;
	OutVal.nComp  = nComp;
	OutVal.dMinMaxVal[0] = pMnMxVal[0];
	OutVal.dMinMaxVal[1] = pMnMxVal[1];
	return TRUE; 
}

BOOL CStressEngine::IsMinMaxDiagram()
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	// Max,Min Position의 경우 무조건 Min/Max가 모두 있음 
	if(gm->m_GPSInstruction == GPS_COMMAND_BSTRSINC && 
		 m_BStrsOutputSection==BSTRSINC_COMP_MAXMIN )
		 return TRUE; 
					
	return gm->m_LoadMinMaxType == LOADTYPE_ALL && m_bMaxMinDgrm;
}

void CStressEngine::BSfdBmdMakePolygon(T_STSS_D &StssD, double local_vector[][3],
									  C3DPoint &node_i, C3DPoint &node_j,
									  CArray<C3DPoint, C3DPoint &> &vtx_list,
									  CArray<double, double &> &val_list,
									  CArray<BOOL, BOOL> &ef_list,
									  CArray<BOOL, BOOL> &rect_flag,
									  C3DPoint *txt_pnt,T_ELEM_K ElemKey,double *pMnMxVal )
{
	if(pMnMxVal){ pMnMxVal[0]=0;  pMnMxVal[1]=0;}
	
	DECLARE_GPSMD();    
	
	int			i, j, sl_num;
	double	val_i, val_j;
	double  dVal[2];
	double  ulen, udist, uval, ldist, vdist;
	double  sub_ival, sub_jval, sub_mval;
	double  dMaxVal=-DBL_MAX,dMinVal=DBL_MAX;
	double  dAbsMax=0;
	
	C3DPoint	ps, pss, pe, pee;
	C3DPoint  sub_ps, sub_pss, sub_pe, sub_pee, sub_pm;

	CDC	*pdc=gm->m_pMyView->GetDC();
	ulen = fabs(gm->m_pGPSCtrl->GetWorldLength(((double) pdc->GetDeviceCaps(LOGPIXELSX))/6.0));
	gm->m_pMyView->ReleaseDC(pdc);

	// SFD,BMD Inverse 
	double SFDvector[3];
	int nSFDSign = ((gm->m_DOPT.DR.m_bInverseBMD == TRUE) || (gm->m_DOPT.DR.m_bInverseSFD == TRUE)) ? -1: 1;
	
	pe = node_i;

	double dTol = M_InitValueCurUnit(1.E-10, N, MM, D_UNITSYS_BASE_STRESS);
	double dLengthTol = M_InitValueCurUnit(1.E-10, N, MM, D_UNITSYS_BASE_LENGTH);

	double prv_j_val;
	double pst_i_val;
	for(i=0;i<4;i++) 
	{
		dVal[0] = val_i = CalcBStssValue(StssD, i);
		dVal[1] = val_j = CalcBStssValue(StssD, i+1);
		if(i==0)prv_j_val = val_i;
		else    prv_j_val = CalcBStssValue(StssD,i-1);

		if(i==3)pst_i_val = val_j;
		else    pst_i_val = CalcBStssValue(StssD,i+1);
		
		if (gm->m_AnimEngine.m_bAnimateContour) 
		{
			val_i = val_i*fabs(gm->m_AnimEngine.GetAnimationFactor(TRUE));
			val_j = val_j*fabs(gm->m_AnimEngine.GetAnimationFactor(TRUE));
		}

		ps = pe;
		CUtilFuncs::GetInnerLinePoint((double) (i+1), 4.0-((double) (i+1)), node_i, node_j, pe);
		for(j=0; j<3; j++) SFDvector[j] = local_vector[2][j]*nSFDSign;
		CUtilFuncs::GetVectorDirectionPoint(SFDvector, val_i, m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, ps, pss);
		CUtilFuncs::GetVectorDirectionPoint(SFDvector, val_j, m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, pe, pee);
		
		if(txt_pnt) 
		{
			// Min/Max
			if(m_bBStrsOutputMinMax)
			{
				if(CCompFunc::CompRealTol(dVal[0], dMaxVal, dTol)== 1) { txt_pnt[1] = pss; dMaxVal=dVal[0]; }
				if(CCompFunc::CompRealTol(dVal[1], dMaxVal, dTol)== 1) { txt_pnt[1] = pee; dMaxVal=dVal[1]; }
				if(CCompFunc::CompRealTol(dVal[0], dMaxVal, dTol)==-1) { txt_pnt[0] = pss; dMinVal=dVal[0]; }
				if(CCompFunc::CompRealTol(dVal[1], dMaxVal, dTol)==-1) { txt_pnt[0] = pee; dMinVal=dVal[1]; }
			}
			// Abs Max
			else if(m_bBStrsOutputMax)
			{
				if(CCompFunc::CompRealTol(fabs(dVal[0]), fabs(dAbsMax), dTol)== 1) { dAbsMax=dVal[0]; }
				if(CCompFunc::CompRealTol(fabs(dVal[1]), fabs(dAbsMax), dTol)== 1) { dAbsMax=dVal[1]; }
				switch(i) 
				{
			  case 0: txt_pnt[0] = pss; break;
			  case 2: txt_pnt[1] = pss; break;
			  case 3: txt_pnt[2] = pee; break;
			  }
			}
			else
			{
			  switch(i) 
				{
			  case 0: txt_pnt[0] = pss; break;
			  case 2: txt_pnt[1] = pss; break;
			  case 3: txt_pnt[2] = pee; break;
			  }
			}
		}

		ldist = sqrt( (pe.x-ps.x)*(pe.x-ps.x) +
					        (pe.y-ps.y)*(pe.y-ps.y) +
					        (pe.z-ps.z)*(pe.z-ps.z) );
		if(CCompFunc::CompRealTol(ldist, 0., dLengthTol)==0) ldist = 0.0;
		if(ldist==0.0) { ASSERT(0); return; }

		sl_num = (int) (ldist/ulen);
		if(((double) sl_num)*ulen == ldist)sl_num--;
		if(sl_num==-1) continue; 
		udist = ldist/((double) (sl_num+1));
		if(CCompFunc::CompRealTol(udist, 0., dLengthTol)==0) udist = 0.0;

		vdist = val_j - val_i;
		if(CCompFunc::CompRealTol(vdist, 0., dTol)==0) vdist = 0.0;
		uval = vdist*udist/ldist;

		sub_jval = val_i;
		sub_pe = ps;
		sub_pee = pss;
		for(j=0;j<=sl_num;j++) 
		{
			sub_ival  = sub_jval;
			sub_ps    = sub_pe;
			sub_pss   = sub_pee;
			if(j == sl_num) 
			{
				sub_jval = val_j;
				sub_pe = pe;
				sub_pee = pee;
			}
			else 
			{
				sub_jval = val_i + uval*(j+1);
				CUtilFuncs::GetInnerLinePoint(fabs(udist*(j+1)), fabs(fabs(ldist)-fabs(udist*(j+1))), ps, pe, sub_pe);
				CUtilFuncs::GetInnerLinePoint(fabs(udist*(j+1)), fabs(fabs(ldist)-fabs(udist*(j+1))), pss, pee, sub_pee);
			}
			BOOL bIsStart     = (i==0 && j==0)?       TRUE:FALSE;
			BOOL bIsEnd       = (i==3 && j==sl_num)?  TRUE:FALSE;
			BOOL bAnyFill = m_bVerticalLineFill; // No Fill Option일 경우만 FALSE이다.
			if(m_bBSfdBmdLineOnly == FALSE && m_bVerticalLineFill == TRUE && gm->m_bGradient) bAnyFill = FALSE; // Gradient Fill시 외곽선을 없앤다.

			// x/4지점에서 값이 변하는 경우 Check
			BOOL bIsValModifySubStart=FALSE;
			BOOL bIsValModifySubEnd=FALSE;
			
			if(i!=0 && j==0)
			{
				//if(sub_ival*prv_j_val < 0)  bIsValModifySubStart=TRUE;
				if(CCompFunc::CompRealTol(sub_ival*prv_j_val, 0., dTol)==-1) bIsValModifySubStart=TRUE;
				else                                                        bIsValModifySubStart=FALSE;
			}
			if(i!=3 && j==sl_num)
			{
				//if(sub_jval*pst_i_val < 0)  bIsValModifySubEnd=TRUE;
				if(CCompFunc::CompRealTol(sub_jval*pst_i_val, 0., dTol)==-1) bIsValModifySubEnd=TRUE;
				else                                                        bIsValModifySubEnd=FALSE;
			}
			
			//if((sub_ival==0) && (sub_jval==0)) 
			if(CCompFunc::CompRealTol(sub_ival, 0., dTol)== 0 && CCompFunc::CompRealTol(sub_jval, 0., dTol)== 0)
			{
				continue;
			}
			//else if(sub_ival == 0) 
			else if(CCompFunc::CompRealTol(sub_ival, 0., dTol)== 0)
			{
				ef_list.Add(TRUE);	vtx_list.Add(sub_ps);	val_list.Add(sub_ival);
				ef_list.Add(bAnyFill || bIsEnd);	vtx_list.Add(sub_pee);	val_list.Add(sub_jval);
				ef_list.Add(FALSE);	vtx_list.Add(sub_pe);	val_list.Add(sub_jval);
				rect_flag.Add(FALSE);
			}
			//else if(sub_jval == 0) 
			else if(CCompFunc::CompRealTol(sub_jval, 0., dTol)== 0)
			{
				ef_list.Add(bAnyFill || bIsStart);	vtx_list.Add(sub_ps);	val_list.Add(sub_ival);
				ef_list.Add(TRUE);	vtx_list.Add(sub_pss);	val_list.Add(sub_ival);
				ef_list.Add(FALSE);	vtx_list.Add(sub_pe);	val_list.Add(sub_jval);
				rect_flag.Add(FALSE);
			}
			//else if((sub_ival*sub_jval) < 0) 
			else if(CCompFunc::CompRealTol(sub_ival*sub_jval, 0., dTol)==-1)
			{
				sub_mval = 0.0;
				CUtilFuncs::GetInnerLinePoint(fabs(sub_ival), fabs(sub_jval), sub_ps, sub_pe, sub_pm);
				ef_list.Add(bAnyFill || bIsStart);	vtx_list.Add(sub_ps);	val_list.Add(sub_ival);
				ef_list.Add(TRUE);	vtx_list.Add(sub_pss);	val_list.Add(sub_ival);
				ef_list.Add(FALSE);	vtx_list.Add(sub_pm);	val_list.Add(sub_mval);
				rect_flag.Add(FALSE);
				ef_list.Add(TRUE);	vtx_list.Add(sub_pm);	val_list.Add(sub_mval);
				ef_list.Add(bAnyFill || bIsEnd);	vtx_list.Add(sub_pee);	val_list.Add(sub_jval);
				ef_list.Add(FALSE);	vtx_list.Add(sub_pe);	val_list.Add(sub_jval);
				rect_flag.Add(FALSE);
			}
			else 
			{
				ef_list.Add(bAnyFill || bIsStart || bIsValModifySubStart);	vtx_list.Add(sub_ps);	val_list.Add(sub_ival);
				ef_list.Add(TRUE);	vtx_list.Add(sub_pss);	val_list.Add(sub_ival);
				ef_list.Add(bAnyFill || bIsEnd || bIsValModifySubEnd);	    vtx_list.Add(sub_pee);	val_list.Add(sub_jval);
				ef_list.Add(FALSE);	vtx_list.Add(sub_pe);	val_list.Add(sub_jval);
				rect_flag.Add(TRUE);
			}
		}
	}

	if(pMnMxVal)
	{
		if(m_bBStrsOutputMinMax)
		{
			pMnMxVal[0] = dMinVal;
			pMnMxVal[1] = dMaxVal;
		}
		if(m_bBStrsOutputMax)
		{
			pMnMxVal[0] = 0.0;
			pMnMxVal[1] = dAbsMax;
		}
	}
}

void CStressEngine::BVmstDgrmPolygon(T_VMST_D &BVmstD, double local_vector[][3],C3DPoint &node_i, C3DPoint &node_j,CArray<C3DPoint, C3DPoint &> &vtx_list,
																		 CArray<double, double &> &val_list,CArray<BOOL, BOOL> &ef_list,CArray<BOOL, BOOL> &rect_flag,C3DPoint *txt_pnt,T_ELEM_K ElemKey,double *pMnMxVal )
{
	if(pMnMxVal){ pMnMxVal[0]=0;  pMnMxVal[1]=0;}

	DECLARE_GPSMD();    

	int			i, j, sl_num;
	double	val_i, val_j;
	double  dVal[2];
	double  ulen, udist, uval, ldist, vdist;
	double  sub_ival, sub_jval, sub_mval;
	double  dMaxVal=-DBL_MAX,dMinVal=DBL_MAX;
	double  dAbsMax=0;

	C3DPoint	ps, pss, pe, pee;
	C3DPoint  sub_ps, sub_pss, sub_pe, sub_pee, sub_pm;

	CDC	*pdc=gm->m_pMyView->GetDC();
	ulen = fabs(gm->m_pGPSCtrl->GetWorldLength(((double) pdc->GetDeviceCaps(LOGPIXELSX))/6.0));
	gm->m_pMyView->ReleaseDC(pdc);

	// SFD,BMD Inverse 
	double BMDvector[3];
	int nBMDSign = (gm->m_DOPT.DR.m_bInverseBMD == TRUE)? -1:1;
	int nSFDSign = (gm->m_DOPT.DR.m_bInverseSFD == TRUE)? -1:1;

	pe = node_i;

	double prv_j_val;
	double pst_i_val;
	for(i=0;i<4;i++) 
	{
		dVal[0] = val_i = CalcBVmstValue(BVmstD, i, I_NODE);
		dVal[1] = val_j = CalcBVmstValue(BVmstD, i, J_NODE);
		if(i==0)prv_j_val = val_i;
		else    prv_j_val = CalcBVmstValue(BVmstD,i-1, J_NODE);

		if(i==3)pst_i_val = val_j;
		else    pst_i_val = CalcBVmstValue(BVmstD,i+1, I_NODE);

		if (gm->m_AnimEngine.m_bAnimateContour) 
		{
			val_i = val_i*fabs(gm->m_AnimEngine.GetAnimationFactor(TRUE));
			val_j = val_j*fabs(gm->m_AnimEngine.GetAnimationFactor(TRUE));
		}

		ps = pe;
		CUtilFuncs::GetInnerLinePoint((double) (i+1), 4.0-((double) (i+1)), node_i, node_j, pe);

		for(j=0; j<3; j++)
			BMDvector[j] = local_vector[2][j]*nBMDSign;
		CUtilFuncs::GetVectorDirectionPoint(BMDvector, val_i, m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, ps, pss);
		CUtilFuncs::GetVectorDirectionPoint(BMDvector, val_j, m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, pe, pee);

		if(txt_pnt) 
		{
			// Min/Max
			if(m_bBStrsOutputMinMax)
			{
				if(dVal[0]>dMaxVal){ txt_pnt[1] = pss; dMaxVal=dVal[0]; }
				if(dVal[1]>dMaxVal){ txt_pnt[1] = pee; dMaxVal=dVal[1]; }
				if(dVal[0]<dMinVal){ txt_pnt[0] = pss; dMinVal=dVal[0]; }
				if(dVal[1]<dMinVal){ txt_pnt[0] = pee; dMinVal=dVal[1]; }
			}
			// Abs Max
			else if(m_bBStrsOutputMax)
			{
				if(fabs(dVal[0])>fabs(dAbsMax)){ dAbsMax=dVal[0]; }
				if(fabs(dVal[1])>fabs(dAbsMax)){ dAbsMax=dVal[1]; }
				switch(i) 
				{
				case 0: txt_pnt[0] = pss; break;
				case 2: txt_pnt[1] = pss; break;
				case 3: txt_pnt[2] = pee; break;
				}
			}
			else
			{
				switch(i) 
				{
				case 0: txt_pnt[0] = pss; break;
				case 2: txt_pnt[1] = pss; break;
				case 3: txt_pnt[2] = pee; break;
				}
			}
		}

		ldist = sqrt( (pe.x-ps.x)*(pe.x-ps.x) +
			(pe.y-ps.y)*(pe.y-ps.y) +
			(pe.z-ps.z)*(pe.z-ps.z) );
		sl_num = (int) (ldist/ulen);
		if(((double) sl_num)*ulen == ldist)sl_num--;
		if(sl_num==-1) continue; 
		udist = ldist/((double) (sl_num+1));

		vdist = val_j - val_i;
		uval = vdist*udist/ldist;

		sub_jval = val_i;
		sub_pe = ps;
		sub_pee = pss;
		for(j=0;j<=sl_num;j++) 
		{
			sub_ival  = sub_jval;
			sub_ps    = sub_pe;
			sub_pss   = sub_pee;
			if(j == sl_num) 
			{
				sub_jval = val_j;
				sub_pe = pe;
				sub_pee = pee;
			}
			else 
			{
				sub_jval = val_i + uval*(j+1);
				CUtilFuncs::GetInnerLinePoint(fabs(udist*(j+1)), fabs(fabs(ldist)-fabs(udist*(j+1))), ps, pe, sub_pe);
				CUtilFuncs::GetInnerLinePoint(fabs(udist*(j+1)), fabs(fabs(ldist)-fabs(udist*(j+1))), pss, pee, sub_pee);
			}
			BOOL bIsStart     = (i==0 && j==0)?       TRUE:FALSE;
			BOOL bIsEnd       = (i==3 && j==sl_num)?  TRUE:FALSE;
			BOOL bAnyFill = m_bVerticalLineFill; // No Fill Option일 경우만 FALSE이다.
			if(m_bBSfdBmdLineOnly == FALSE && m_bVerticalLineFill == TRUE && gm->m_bGradient) bAnyFill = FALSE; // Gradient Fill시 외곽선을 없앤다.

			// x/4지점에서 값이 변하는 경우 Check
			BOOL bIsValModifySubStart=FALSE;
			BOOL bIsValModifySubEnd=FALSE;

			if(i!=0 && j==0)
			{
				if(sub_ival*prv_j_val < 0)  bIsValModifySubStart=TRUE;
				else                        bIsValModifySubStart=FALSE;
			}
			if(i!=3 && j==sl_num)
			{
				if(sub_jval*pst_i_val < 0)  bIsValModifySubEnd=TRUE;
				else                        bIsValModifySubEnd=FALSE;
			}

			if((sub_ival==0) && (sub_jval==0)) 
			{
				continue;
			}
			else if(sub_ival == 0) 
			{
				ef_list.Add(TRUE);	vtx_list.Add(sub_ps);	val_list.Add(sub_ival);
				ef_list.Add(bAnyFill || bIsEnd);	vtx_list.Add(sub_pee);	val_list.Add(sub_jval);
				ef_list.Add(FALSE);	vtx_list.Add(sub_pe);	val_list.Add(sub_jval);
				rect_flag.Add(FALSE);
			}
			else if(sub_jval == 0) 
			{
				ef_list.Add(bAnyFill || bIsStart);	vtx_list.Add(sub_ps);	val_list.Add(sub_ival);
				ef_list.Add(TRUE);	vtx_list.Add(sub_pss);	val_list.Add(sub_ival);
				ef_list.Add(FALSE);	vtx_list.Add(sub_pe);	val_list.Add(sub_jval);
				rect_flag.Add(FALSE);
			}
			else if((sub_ival*sub_jval) < 0) 
			{
				sub_mval = 0.0;
				CUtilFuncs::GetInnerLinePoint(fabs(sub_ival), fabs(sub_jval), sub_ps, sub_pe, sub_pm);
				ef_list.Add(bAnyFill || bIsStart);	vtx_list.Add(sub_ps);	val_list.Add(sub_ival);
				ef_list.Add(TRUE);	vtx_list.Add(sub_pss);	val_list.Add(sub_ival);
				ef_list.Add(FALSE);	vtx_list.Add(sub_pm);	val_list.Add(sub_mval);
				rect_flag.Add(FALSE);
				ef_list.Add(TRUE);	vtx_list.Add(sub_pm);	val_list.Add(sub_mval);
				ef_list.Add(bAnyFill || bIsEnd);	vtx_list.Add(sub_pee);	val_list.Add(sub_jval);
				ef_list.Add(FALSE);	vtx_list.Add(sub_pe);	val_list.Add(sub_jval);
				rect_flag.Add(FALSE);
			}
			else 
			{
				ef_list.Add(bAnyFill || bIsStart || bIsValModifySubStart);	vtx_list.Add(sub_ps);	val_list.Add(sub_ival);
				ef_list.Add(TRUE);	vtx_list.Add(sub_pss);	val_list.Add(sub_ival);
				ef_list.Add(bAnyFill || bIsEnd || bIsValModifySubEnd);	    vtx_list.Add(sub_pee);	val_list.Add(sub_jval);
				ef_list.Add(FALSE);	vtx_list.Add(sub_pe);	val_list.Add(sub_jval);
				rect_flag.Add(TRUE);
			}
		}
	}

	if(pMnMxVal)
	{
		if(m_bBStrsOutputMinMax)
		{
			pMnMxVal[0] = dMinVal;
			pMnMxVal[1] = dMaxVal;
		}
		if(m_bBStrsOutputMax)
		{
			pMnMxVal[0] = 0.0;
			pMnMxVal[1] = dAbsMax;
		}
	}
}

void CStressEngine::BStrsDgrmPolygon(T_STRB_D &StrbD, double local_vector[][3],
									  C3DPoint &node_i, C3DPoint &node_j,
									  CArray<C3DPoint, C3DPoint &> &vtx_list,
									  CArray<double, double &> &val_list,
									  CArray<BOOL, BOOL> &ef_list,
									  CArray<BOOL, BOOL> &rect_flag,
									  C3DPoint *txt_pnt,T_ELEM_K ElemKey,double *pMnMxVal )
{
	if(pMnMxVal){ pMnMxVal[0]=0;  pMnMxVal[1]=0;}
	
	DECLARE_GPSMD();    
	
	int			i, j, sl_num;
	double	val_i, val_j;
	double  dVal[2];
	double  ulen, udist, uval, ldist, vdist;
	double  sub_ival, sub_jval, sub_mval;
	double  dMaxVal=-DBL_MAX,dMinVal=DBL_MAX;
	double  dAbsMax=0;
	
	C3DPoint	ps, pss, pe, pee;
	C3DPoint  sub_ps, sub_pss, sub_pe, sub_pee, sub_pm;

	CDC	*pdc=gm->m_pMyView->GetDC();
	ulen = fabs(gm->m_pGPSCtrl->GetWorldLength(((double) pdc->GetDeviceCaps(LOGPIXELSX))/6.0));
	gm->m_pMyView->ReleaseDC(pdc);

	// SFD,BMD Inverse 
	double SFDvector[3],BMDvector[3];
	int nBMDSign = (gm->m_DOPT.DR.m_bInverseBMD == TRUE)? -1:1;
	int nSFDSign = (gm->m_DOPT.DR.m_bInverseSFD == TRUE)? -1:1;
	
	pe = node_i;

	double prv_j_val;
	double pst_i_val;
	for(i=0;i<4;i++) 
	{
		dVal[0] = val_i = CalcBStrsValue(StrbD, i, I_NODE);
		dVal[1] = val_j = CalcBStrsValue(StrbD, i, J_NODE);
		if(i==0)prv_j_val = val_i;
		else    prv_j_val = CalcBStrsValue(StrbD,i-1, J_NODE);

		if(i==3)pst_i_val = val_j;
		else    pst_i_val = CalcBStrsValue(StrbD,i+1, I_NODE);
		
		if (gm->m_AnimEngine.m_bAnimateContour) 
		{
			val_i = val_i*fabs(gm->m_AnimEngine.GetAnimationFactor(TRUE));
			val_j = val_j*fabs(gm->m_AnimEngine.GetAnimationFactor(TRUE));
		}

		ps = pe;
		CUtilFuncs::GetInnerLinePoint((double) (i+1), 4.0-((double) (i+1)), node_i, node_j, pe);

		switch(m_BStrsComponent) 
		{
		case BSTRS_COMPONENT_FY:
			for(j=0; j<3; j++)
				SFDvector[j] = local_vector[1][j]*nSFDSign;
			CUtilFuncs::GetVectorDirectionPoint(SFDvector, val_i, m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, ps, pss);
			CUtilFuncs::GetVectorDirectionPoint(SFDvector, val_j, m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, pe, pee);
			break;
		case BSTRS_COMPONENT_FZ:
		case BSTRS_COMPONENT_FX:
			for(j=0; j<3; j++)
				SFDvector[j] = local_vector[2][j]*nSFDSign;
			CUtilFuncs::GetVectorDirectionPoint(SFDvector, val_i, m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, ps, pss);
			CUtilFuncs::GetVectorDirectionPoint(SFDvector, val_j, m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, pe, pee);
			break;
		case BSTRS_COMPONENT_MZ:
		  for(j=0; j<3; j++)
				BMDvector[j] = local_vector[2][j]*nBMDSign;
			CUtilFuncs::GetVectorDirectionPoint(BMDvector, val_i, m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, ps, pss);
			CUtilFuncs::GetVectorDirectionPoint(BMDvector, val_j, m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, pe, pee);
			break;
		case BSTRS_COMPONENT_MY:
			for(j=0; j<3; j++)
				BMDvector[j] = local_vector[1][j]*nBMDSign;
			CUtilFuncs::GetVectorDirectionPoint(BMDvector, val_i, m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, ps, pss);
			CUtilFuncs::GetVectorDirectionPoint(BMDvector, val_j, m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, pe, pee);
			break; 
		case BSTRS_COMPONENT_COMB:
		case BSTRS_COMPONENT_7thDOF:
			for(j=0; j<3; j++)
				BMDvector[j] = local_vector[2][j]*nBMDSign;
			CUtilFuncs::GetVectorDirectionPoint(BMDvector, val_i, m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, ps, pss);
			CUtilFuncs::GetVectorDirectionPoint(BMDvector, val_j, m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, pe, pee);
			break;
		default:
			return;
		}

		
		if(txt_pnt) 
		{
			// Min/Max
			if(m_bBStrsOutputMinMax)
			{
				if(dVal[0]>dMaxVal){ txt_pnt[1] = pss; dMaxVal=dVal[0]; }
				if(dVal[1]>dMaxVal){ txt_pnt[1] = pee; dMaxVal=dVal[1]; }
				if(dVal[0]<dMinVal){ txt_pnt[0] = pss; dMinVal=dVal[0]; }
				if(dVal[1]<dMinVal){ txt_pnt[0] = pee; dMinVal=dVal[1]; }
			}
			// Abs Max
			else if(m_bBStrsOutputMax)
			{
				if(fabs(dVal[0])>fabs(dAbsMax)){ dAbsMax=dVal[0]; }
				if(fabs(dVal[1])>fabs(dAbsMax)){ dAbsMax=dVal[1]; }
				switch(i) 
				{
			  case 0: txt_pnt[0] = pss; break;
			  case 2: txt_pnt[1] = pss; break;
			  case 3: txt_pnt[2] = pee; break;
			  }
			}
			else
			{
			  switch(i) 
				{
			  case 0: txt_pnt[0] = pss; break;
			  case 2: txt_pnt[1] = pss; break;
			  case 3: txt_pnt[2] = pee; break;
			  }
			}
		}

		ldist = sqrt( (pe.x-ps.x)*(pe.x-ps.x) +
					        (pe.y-ps.y)*(pe.y-ps.y) +
					        (pe.z-ps.z)*(pe.z-ps.z) );
		sl_num = (int) (ldist/ulen);
		if(((double) sl_num)*ulen == ldist)sl_num--;
		if(sl_num==-1) continue; 
		udist = ldist/((double) (sl_num+1));

		vdist = val_j - val_i;
		uval = vdist*udist/ldist;

		sub_jval = val_i;
		sub_pe = ps;
		sub_pee = pss;
		for(j=0;j<=sl_num;j++) 
		{
			sub_ival  = sub_jval;
			sub_ps    = sub_pe;
			sub_pss   = sub_pee;
			if(j == sl_num) 
			{
				sub_jval = val_j;
				sub_pe = pe;
				sub_pee = pee;
			}
			else 
			{
				sub_jval = val_i + uval*(j+1);
				CUtilFuncs::GetInnerLinePoint(fabs(udist*(j+1)), fabs(fabs(ldist)-fabs(udist*(j+1))), ps, pe, sub_pe);
				CUtilFuncs::GetInnerLinePoint(fabs(udist*(j+1)), fabs(fabs(ldist)-fabs(udist*(j+1))), pss, pee, sub_pee);
			}
			BOOL bIsStart     = (i==0 && j==0)?       TRUE:FALSE;
			BOOL bIsEnd       = (i==3 && j==sl_num)?  TRUE:FALSE;
			BOOL bAnyFill = m_bVerticalLineFill; // No Fill Option일 경우만 FALSE이다.
			if(m_bBSfdBmdLineOnly == FALSE && m_bVerticalLineFill == TRUE && gm->m_bGradient) bAnyFill = FALSE; // Gradient Fill시 외곽선을 없앤다.

			// x/4지점에서 값이 변하는 경우 Check
			BOOL bIsValModifySubStart=FALSE;
			BOOL bIsValModifySubEnd=FALSE;
			
			if(i!=0 && j==0)
			{
				if(sub_ival*prv_j_val < 0)  bIsValModifySubStart=TRUE;
				else                        bIsValModifySubStart=FALSE;
			}
			if(i!=3 && j==sl_num)
			{
				if(sub_jval*pst_i_val < 0)  bIsValModifySubEnd=TRUE;
				else                        bIsValModifySubEnd=FALSE;
			}
			
			if((sub_ival==0) && (sub_jval==0)) 
			{
				continue;
			}
			else if(sub_ival == 0) 
			{
				ef_list.Add(TRUE);	vtx_list.Add(sub_ps);	val_list.Add(sub_ival);
				ef_list.Add(bAnyFill || bIsEnd);	vtx_list.Add(sub_pee);	val_list.Add(sub_jval);
				ef_list.Add(FALSE);	vtx_list.Add(sub_pe);	val_list.Add(sub_jval);
				rect_flag.Add(FALSE);
			}
			else if(sub_jval == 0) 
			{
				ef_list.Add(bAnyFill || bIsStart);	vtx_list.Add(sub_ps);	val_list.Add(sub_ival);
				ef_list.Add(TRUE);	vtx_list.Add(sub_pss);	val_list.Add(sub_ival);
				ef_list.Add(FALSE);	vtx_list.Add(sub_pe);	val_list.Add(sub_jval);
				rect_flag.Add(FALSE);
			}
			else if((sub_ival*sub_jval) < 0) 
			{
				sub_mval = 0.0;
				CUtilFuncs::GetInnerLinePoint(fabs(sub_ival), fabs(sub_jval), sub_ps, sub_pe, sub_pm);
				ef_list.Add(bAnyFill || bIsStart);	vtx_list.Add(sub_ps);	val_list.Add(sub_ival);
				ef_list.Add(TRUE);	vtx_list.Add(sub_pss);	val_list.Add(sub_ival);
				ef_list.Add(FALSE);	vtx_list.Add(sub_pm);	val_list.Add(sub_mval);
				rect_flag.Add(FALSE);
				ef_list.Add(TRUE);	vtx_list.Add(sub_pm);	val_list.Add(sub_mval);
				ef_list.Add(bAnyFill || bIsEnd);	vtx_list.Add(sub_pee);	val_list.Add(sub_jval);
				ef_list.Add(FALSE);	vtx_list.Add(sub_pe);	val_list.Add(sub_jval);
				rect_flag.Add(FALSE);
			}
			else 
			{
				ef_list.Add(bAnyFill || bIsStart || bIsValModifySubStart);	vtx_list.Add(sub_ps);	val_list.Add(sub_ival);
				ef_list.Add(TRUE);	vtx_list.Add(sub_pss);	val_list.Add(sub_ival);
				ef_list.Add(bAnyFill || bIsEnd || bIsValModifySubEnd);	    vtx_list.Add(sub_pee);	val_list.Add(sub_jval);
				ef_list.Add(FALSE);	vtx_list.Add(sub_pe);	val_list.Add(sub_jval);
				rect_flag.Add(TRUE);
			}
		}
	}

	if(pMnMxVal)
	{
		if(m_bBStrsOutputMinMax)
		{
			pMnMxVal[0] = dMinVal;
			pMnMxVal[1] = dMaxVal;
		}
		if(m_bBStrsOutputMax)
		{
			pMnMxVal[0] = 0.0;
			pMnMxVal[1] = dAbsMax;
		}
	}
}


#if defined(__OLD_OUTPUT_VALUE)
void CStressEngine::OutputSfdBmdNumber(CDC* pDC, T_ELEM_K ekey, T_STSS_D StssD,
	C3DPoint* txt_pnt, int nComp, double* pMnMxVal)
{
	DECLARE_GPSMD();
	DECLARE_DPTTX();
	DECLARE_DPTDR();

	int			  j, slope;
	TCHAR			fmt_str[10], text_str[512];
	BOOL			fl_bak, is_inverse;
	C3DPoint	node3D_i, node3D_j, DrawPoint;
	CPoint		text_p, node_2d_i, node_2d_j;
	CFont			ft, * old_ft;
	T_ELEM_D	edata;

	POSITION	pos;
	CArray<GPS_3DPT_LISTP, GPS_3DPT_LISTP>  polygon_list;
	CArray<GPS_BOOL_ARRYP, GPS_BOOL_ARRYP>	edge_list;

	if (pTX->m_bNumberOpaque)pDC->SetBkMode(OPAQUE);
	else		                pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(pTX->m_NumberTextColorC);
	pDC->SetBkColor(pTX->m_NumberBackCol);
	pDC->SetTextAlign(TA_CENTER | TA_BOTTOM);

	if (pTX->m_bNumberExponent)_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else		                  _stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);

	m_pDoc->m_pAttrCtrl->GetElem(ekey, edata);
	if (!m_pDoc->m_pAttrCtrl->IsBeam(edata.eltyp))return;

	fl_bak = pDR->m_bFrameLine;
	gm->m_DOPT.DR.m_bFrameLine = TRUE;

	if (m_bDeformedShapeContour)
		gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list);
	else
		gm->GetShapeElement(ekey, polygon_list, &edge_list);

	CRect	rct;
	gm->m_pMyView->GetClientRect(&rct);

	pos = polygon_list[0]->GetHeadPosition();
	node3D_i = polygon_list[0]->GetNext(pos);
	node3D_j = polygon_list[0]->GetNext(pos);

	//XGLRenderer
	BOOL bSaveTextOutput = FALSE;
	if (gm->m_pGPSCtrl->IsGLRenderer() && gm->m_pGPSCtrl->IsXGRMode() &&
		!gm->m_pGPSCtrl->IsMakeEMFMode())
	{
		bSaveTextOutput = TRUE;
	}

	if (gm->m_bVirtualMode)
	{
		node_2d_i = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_i);
		node_2d_j = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_j);
	}
	else
	{
		node_2d_i = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_i);
		node_2d_j = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_j);
	}
	//XGLRenderer 
	if (bSaveTextOutput == FALSE) //저장 모드에서는 현재 화면 상태와 관계된 Filtering처리를 하지 않는다. 
	{
		if (node_2d_i.x < 0 || node_2d_i.y < 0) return;
		if (node_2d_j.x < 0 || node_2d_j.y < 0) return;
	}

	slope = (int)(atan2(node_2d_i.y - node_2d_j.y, node_2d_j.x - node_2d_i.x) * 1800.0 / 3.14159);
	slope = (slope + 3600) % 3600;
	if ((900 < slope) && (slope <= 2700))
	{
		slope = (slope + 1800) % 3600;
		is_inverse = TRUE;
	}
	else
	{
		is_inverse = FALSE;
	}

	gm->SetNumberFontOrientation(slope);
	ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
	old_ft = (CFont*)pDC->SelectObject(&ft);

	if (pTX->m_bOutputMinMaxValueOnly)
	{
		double dLimit = (m_dMaxValue - m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;
		double dBValue;

		for (int n = 0; n < 3; n++)
		{
			if (m_bBStrsOutputMinMax)
			{
				// Min
				if (n == 0)
				{
					pDC->SetTextAlign(TA_CENTER | TA_TOP);
					DrawPoint = txt_pnt[0];
					dBValue = pMnMxVal[0];
				}
				else if (n == 1)
				{
					pDC->SetTextAlign(TA_CENTER | TA_BOTTOM);
					DrawPoint = txt_pnt[1];
					dBValue = pMnMxVal[1];
				}
				else continue;
			}
			// Abs Max
			else if (m_bBStrsOutputMax)
			{
				if (n == 0)
				{
					DrawPoint = txt_pnt[1];  // Center Point 
					dBValue = pMnMxVal[1]; // Abs Max값 
				}
				else continue;
			}
			else if (n == 0) // I단 
			{
				if (!m_bBStrsOutputI) continue;

				if (is_inverse) pDC->SetTextAlign(TA_RIGHT | TA_BOTTOM);
				else					 pDC->SetTextAlign(TA_LEFT | TA_BOTTOM);
				DrawPoint = txt_pnt[0];
				//dBValue = CalcBForcValue(bforc_d, 0, I_NODE);
				dBValue = this->CalcBStssValue(StssD, 0);

			}
			else if (n == 1)// CNT or MAX
			{
				if (!(m_bBStrsOutputC || m_bBStrsOutputMax)) continue;

				pDC->SetTextAlign(TA_CENTER | TA_BOTTOM);
				DrawPoint = txt_pnt[1];

				if (m_bBStrsOutputMax)
				{
					dBValue = pMnMxVal[1];
				}
				else
				{
					dBValue = this->CalcBStssValue(StssD, 4);
				}

			}
			else if (n == 2)// J단 
			{
				if (!m_bBStrsOutputJ) continue;
				if (is_inverse)pDC->SetTextAlign(TA_LEFT | TA_BOTTOM);
				else					pDC->SetTextAlign(TA_RIGHT | TA_BOTTOM);
				DrawPoint = txt_pnt[2];
				//dBValue = CalcBForcValue(bforc_d, 3, J_NODE);
				dBValue = this->CalcBStssValue(StssD, 2);
			}

			switch (gm->m_DOPT.TX.m_nOutputMinMaxType)
			{
			case 0: // Min & Max
				if (bSaveTextOutput)
				{
					double Pos6[6];
					Pos6[0] = node3D_i.x; Pos6[1] = node3D_i.y; Pos6[2] = node3D_i.z;
					Pos6[3] = node3D_j.x; Pos6[4] = node3D_j.y; Pos6[5] = node3D_j.z;
					if ((m_dMaxValue - dBValue) <= dLimit)
						gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(DrawPoint.x), Pos6, 0, dBValue);
					else if ((dBValue - m_dMinValue) <= dLimit)
						gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(DrawPoint.x), Pos6, 1, dBValue);
				}
				else
				{
					if ((m_dMaxValue - dBValue) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, dBValue);
					else if ((dBValue - m_dMinValue) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, dBValue);
				}
				break;
			case 1: // Abs Max
				if (bSaveTextOutput)
				{
					double Pos6[6];
					Pos6[0] = node3D_i.x; Pos6[1] = node3D_i.y; Pos6[2] = node3D_i.z;
					Pos6[3] = node3D_j.x; Pos6[4] = node3D_j.y; Pos6[5] = node3D_j.z;
					if (fabs(m_dMaxValue) >= fabs(m_dMinValue))
					{
						if (fabs(m_dMaxValue) - fabs(dBValue) <= dLimit)
							gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(DrawPoint.x), Pos6, 2, dBValue);
					}
					else
					{
						if (fabs(m_dMinValue) - fabs(dBValue) <= dLimit)
							gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(DrawPoint.x), Pos6, 2, dBValue);
					}
				}
				else
				{
					if (fabs(m_dMaxValue) >= fabs(m_dMinValue))
					{
						if (fabs(m_dMaxValue) - fabs(dBValue) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, dBValue);
					}
					else
					{
						if (fabs(m_dMinValue) - fabs(dBValue) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, dBValue);
					}
				}
				break;
			case 2: // Max
				if (bSaveTextOutput)
				{
					double Pos6[6];
					Pos6[0] = node3D_i.x; Pos6[1] = node3D_i.y; Pos6[2] = node3D_i.z;
					Pos6[3] = node3D_j.x; Pos6[4] = node3D_j.y; Pos6[5] = node3D_j.z;
					if ((m_dMaxValue - dBValue) <= dLimit)
						gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(DrawPoint.x), Pos6, 0, dBValue);
				}
				else
				{
					if ((m_dMaxValue - dBValue) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, dBValue);
				}
				break;
			case 3: // Min
				if (bSaveTextOutput)
				{
					double Pos6[6];
					Pos6[0] = node3D_i.x; Pos6[1] = node3D_i.y; Pos6[2] = node3D_i.z;
					Pos6[3] = node3D_j.x; Pos6[4] = node3D_j.y; Pos6[5] = node3D_j.z;
					if ((dBValue - m_dMinValue) <= dLimit)
						gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(DrawPoint.x), Pos6, 1, dBValue);
				}
				else
				{
					if ((dBValue - m_dMinValue) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, dBValue);
				}
				break;
			}
		}
		//////////////////////////////////////////////////////////////////////////////////////
	}
	else
	{
		// Min/Max
		if (m_bBStrsOutputMinMax)
		{
			if (bSaveTextOutput)
			{
				double Pos6[6];
				Pos6[0] = node3D_i.x; Pos6[1] = node3D_i.y; Pos6[2] = node3D_i.z;
				Pos6[3] = node3D_j.x; Pos6[4] = node3D_j.y; Pos6[5] = node3D_j.z;
				gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[0].x), Pos6, 3, pMnMxVal[0]);
				gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[1].x), Pos6, 4, pMnMxVal[1]);
			}
			else
			{
				// Min Val
				pDC->SetTextAlign(TA_CENTER | TA_TOP);
				if (gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[0]);
				else                  text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[0]);
				_stprintf(text_str, fmt_str, pMnMxVal[0]);
				if (text_p.x >= 0 && text_p.y >= 0)pDC->TextOut(text_p.x, text_p.y, text_str);

				// Max Val
				pDC->SetTextAlign(TA_CENTER | TA_BOTTOM);
				if (gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[1]);
				else                  text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[1]);
				_stprintf(text_str, fmt_str, pMnMxVal[1]);
				if (text_p.x >= 0 && text_p.y >= 0)pDC->TextOut(text_p.x, text_p.y, text_str);
			}
		}
		// Abs Max
		else if (m_bBStrsOutputMax)
		{
			if (bSaveTextOutput)
			{
				double Pos6[6];
				Pos6[0] = node3D_i.x; Pos6[1] = node3D_i.y; Pos6[2] = node3D_i.z;
				Pos6[3] = node3D_j.x; Pos6[4] = node3D_j.y; Pos6[5] = node3D_j.z;
				gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[1].x), Pos6, 5, pMnMxVal[1]);
			}
			else
			{
				if (gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[1]);
				else                  text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[1]);
				_stprintf(text_str, fmt_str, pMnMxVal[1]);
				if (text_p.x >= 0 && text_p.y >= 0) pDC->TextOut(text_p.x, text_p.y, text_str);
			}
		}
		else
		{
			if (bSaveTextOutput)
			{
				double Pos6[6];
				Pos6[0] = node3D_i.x; Pos6[1] = node3D_i.y; Pos6[2] = node3D_i.z;
				Pos6[3] = node3D_j.x; Pos6[4] = node3D_j.y; Pos6[5] = node3D_j.z;
				if (m_bBStrsOutputI)
				{
					gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[0].x), Pos6, 6, CalcBStssValue(StssD, 0));
				}
				if (m_bBStrsOutputJ)
				{
					gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[2].x), Pos6, 7, CalcBStssValue(StssD, 4));
				}
				if (m_bBStrsOutputC)
				{
					gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[1].x), Pos6, 8, CalcBStssValue(StssD, 2));
				}
			}
			else
			{
				if (m_bBStrsOutputI)
				{
					pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorI);
					if (is_inverse)pDC->SetTextAlign(TA_RIGHT | TA_BOTTOM);
					else				  pDC->SetTextAlign(TA_LEFT | TA_BOTTOM);
					if (gm->m_bVirtualMode) text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[0]);
					else                    text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[0]);
					_stprintf(text_str, fmt_str, CalcBStssValue(StssD, 0));
					if (text_p.x >= 0 && text_p.y >= 0)pDC->TextOut(text_p.x, text_p.y, text_str);
				}
				if (m_bBStrsOutputJ)
				{
					pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorJ);
					if (is_inverse)pDC->SetTextAlign(TA_LEFT | TA_BOTTOM);
					else				  pDC->SetTextAlign(TA_RIGHT | TA_BOTTOM);
					if (gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[2]);
					else                   text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[2]);
					_stprintf(text_str, fmt_str, CalcBStssValue(StssD, 4));
					if (text_p.x >= 0 && text_p.y >= 0) pDC->TextOut(text_p.x, text_p.y, text_str);
				}
				if (m_bBStrsOutputC)
				{
					pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
					pDC->SetTextAlign(TA_CENTER | TA_BOTTOM);
					if (gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[1]);
					else 				          text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[1]);
					_stprintf(text_str, fmt_str, CalcBStssValue(StssD, 2));
					if (text_p.x >= 0 && text_p.y >= 0) pDC->TextOut(text_p.x, text_p.y, text_str);
				}
			}
		}
	}

	pDC->SelectObject(old_ft);
	ft.DeleteObject();

	for (j = 0; j < polygon_list.GetSize(); j++)
	{
		polygon_list[j]->RemoveAll();
		delete polygon_list[j];
		edge_list[j]->RemoveAll();
		delete edge_list[j];
	}
	polygon_list.RemoveAll();
	edge_list.RemoveAll();

	gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}
#else
void CStressEngine::OutputSfdBmdNumber(CDC *pDC, T_ELEM_K ekey, T_STSS_D StssD, 
																			C3DPoint *txt_pnt,int nComp,double *pMnMxVal)
{
	DECLARE_GPSMD();
	DECLARE_DPTTX();
	DECLARE_DPTDR();

	int			  j, slope;
	TCHAR			fmt_str[10], text_str[512];
	BOOL			fl_bak, is_inverse;
	C3DPoint	node3D_i, node3D_j,DrawPoint;
	CPoint		text_p,node_2d_i, node_2d_j;
	CFont			ft, *old_ft;
	T_ELEM_D	edata;

	POSITION	pos;
	CArray<GPS_3DPT_LISTP, GPS_3DPT_LISTP>  polygon_list;
	CArray<GPS_BOOL_ARRYP, GPS_BOOL_ARRYP>	edge_list;

	GPostTextOut TextOutModel;
	TextOutModel.SetDC(pDC);
	TextOutModel.StartBeamStressPSCVal();
	TextOutModel.SettingBeamStressPSC(gm);

	if(pTX->m_bNumberExponent)_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else		                  _stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);

	m_pDoc->m_pAttrCtrl->GetElem(ekey, edata);
	if(!m_pDoc->m_pAttrCtrl->IsBeam(edata.eltyp) )return;

	fl_bak = pDR->m_bFrameLine;
	gm->m_DOPT.DR.m_bFrameLine = TRUE;

	if(m_bDeformedShapeContour)
		gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list);
	else
		gm->GetShapeElement(ekey, polygon_list, &edge_list);
	
	CRect	rct;
	gm->m_pMyView->GetClientRect(&rct);

	pos = polygon_list[0]->GetHeadPosition();
	node3D_i = polygon_list[0]->GetNext(pos);
	node3D_j = polygon_list[0]->GetNext(pos);

	//XGLRenderer
	BOOL bSaveTextOutput = FALSE;
	if(gm->m_pGPSCtrl->IsGLRenderer() && gm->m_pGPSCtrl->IsXGRMode()  && 
		 !gm->m_pGPSCtrl->IsMakeEMFMode() )
	{
		 bSaveTextOutput = TRUE;
	}
	
	if(gm->m_bVirtualMode) 
	{
		node_2d_i = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_i);
		node_2d_j = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_j);
	}
	else 
	{
		node_2d_i = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_i);
		node_2d_j = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_j);
	}
	//XGLRenderer 
	if(bSaveTextOutput == FALSE) //저장 모드에서는 현재 화면 상태와 관계된 Filtering처리를 하지 않는다. 
	{
	if(node_2d_i.x < 0 ||node_2d_i.y < 0 ) return;
	if(node_2d_j.x < 0 ||node_2d_j.y < 0 ) return;
	}

	slope = (int) (atan2(node_2d_i.y-node_2d_j.y, node_2d_j.x-node_2d_i.x)*1800.0/3.14159);
	slope = (slope+3600)%3600;
	if ((900<slope) && (slope<=2700)) 
	{
		slope = (slope+1800)%3600;
		is_inverse = TRUE;
	}
	else 
	{
		is_inverse = FALSE;
	}

	TextOutModel.Font4BeamStressPSC(gm, slope);

	if(pTX->m_bOutputMinMaxValueOnly)
	{
		double dLimit = (m_dMaxValue-m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;
		double dBValue;
		
		for(int n=0; n<3; n++)
		{
			if(m_bBStrsOutputMinMax)
			{
				// Min
				if(n==0)
				{
					TextOutModel.AlignTextTop(TA_CENTER);
					DrawPoint = txt_pnt[0];  
					dBValue   = pMnMxVal[0];
				}
				else if(n==1)
				{
					TextOutModel.AlignTextBot(TA_CENTER);
					DrawPoint = txt_pnt[1];  
					dBValue   = pMnMxVal[1];
				}
				else continue; 
			}
			// Abs Max
	    else if(m_bBStrsOutputMax) 
			{
				if(n==0)
				{
		      DrawPoint = txt_pnt[1];  // Center Point 
					dBValue   = pMnMxVal[1]; // Abs Max값 
				}
				else continue; 
	    }
			else if(n==0) // I단 
			{
				if (!m_bBStrsOutputI) continue;
				
				if(is_inverse)
					TextOutModel.AlignTextBot(TA_RIGHT);
				else					 
					TextOutModel.AlignTextBot(TA_LEFT);
				DrawPoint = txt_pnt[0];
				//dBValue = CalcBForcValue(bforc_d, 0, I_NODE);
				dBValue = this->CalcBStssValue(StssD, 0);
				
			}
			else if(n==1)// CNT or MAX
			{			  
				if (!(m_bBStrsOutputC||m_bBStrsOutputMax)) continue;
				TextOutModel.AlignTextBot(TA_CENTER);
				DrawPoint= txt_pnt[1];
				
				if (m_bBStrsOutputMax) 
				{
					dBValue = pMnMxVal[1];
				}
				else
				{
					dBValue = this->CalcBStssValue(StssD, 4);
				}
				
			}
			else if(n==2)// J단 
			{			  
				if(!m_bBStrsOutputJ) continue;
				if(is_inverse)
					TextOutModel.AlignTextBot(TA_LEFT);
				else					
					TextOutModel.AlignTextBot(TA_RIGHT);
				DrawPoint = txt_pnt[2];
				//dBValue = CalcBForcValue(bforc_d, 3, J_NODE);
				dBValue = this->CalcBStssValue(StssD, 2);
			}
					
			switch(gm->m_DOPT.TX.m_nOutputMinMaxType)
			{
			case 0: // Min & Max
				if(bSaveTextOutput)
				{
					double Pos6[6];
					Pos6[0] = node3D_i.x;Pos6[1] = node3D_i.y;Pos6[2] = node3D_i.z;
					Pos6[3] = node3D_j.x;Pos6[4] = node3D_j.y;Pos6[5] = node3D_j.z;
					if((m_dMaxValue-dBValue) <= dLimit)
						gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(DrawPoint.x),Pos6, 0,dBValue);
					else if((dBValue-m_dMinValue) <= dLimit)
						gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(DrawPoint.x),Pos6, 1,dBValue);
				}
				else
				{
				if((m_dMaxValue-dBValue) <= dLimit)
					 DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,dBValue);
				else if((dBValue-m_dMinValue) <= dLimit)
					 DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,dBValue);
				}
				break;
			case 1: // Abs Max
				if(bSaveTextOutput)
				{
					double Pos6[6];
					Pos6[0] = node3D_i.x;Pos6[1] = node3D_i.y;Pos6[2] = node3D_i.z;
					Pos6[3] = node3D_j.x;Pos6[4] = node3D_j.y;Pos6[5] = node3D_j.z;
					if(fabs(m_dMaxValue) >= fabs(m_dMinValue))
					{
						if( fabs(m_dMaxValue)-fabs(dBValue) <= dLimit)
						gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(DrawPoint.x),Pos6, 2,dBValue);
					}
					else
					{
						if( fabs(m_dMinValue)-fabs(dBValue) <= dLimit)
						gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(DrawPoint.x),Pos6, 2,dBValue);
					}
				}
				else
				{
				if(fabs(m_dMaxValue) >= fabs(m_dMinValue))
				{
					if( fabs(m_dMaxValue)-fabs(dBValue) <= dLimit)
					DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dBValue);
				}
				else
				{
					if( fabs(m_dMinValue)-fabs(dBValue) <= dLimit)
					DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dBValue);
				}
				}
				break;
			case 2: // Max
				if(bSaveTextOutput)
				{
					double Pos6[6];
					Pos6[0] = node3D_i.x;Pos6[1] = node3D_i.y;Pos6[2] = node3D_i.z;
					Pos6[3] = node3D_j.x;Pos6[4] = node3D_j.y;Pos6[5] = node3D_j.z;
					if((m_dMaxValue-dBValue) <= dLimit)
						gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(DrawPoint.x),Pos6, 0,dBValue);
				}
				else
				{
				if((m_dMaxValue-dBValue) <= dLimit)
					 DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,dBValue);
				}
				break;
			case 3: // Min
				if(bSaveTextOutput)
				{
					double Pos6[6];
					Pos6[0] = node3D_i.x;Pos6[1] = node3D_i.y;Pos6[2] = node3D_i.z;
					Pos6[3] = node3D_j.x;Pos6[4] = node3D_j.y;Pos6[5] = node3D_j.z;
					if((dBValue-m_dMinValue) <= dLimit)
						gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(DrawPoint.x),Pos6, 1,dBValue);
				}
				else
				{
				if((dBValue-m_dMinValue) <= dLimit)
					 DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,dBValue);
				}
				break;
			}
		}
	//////////////////////////////////////////////////////////////////////////////////////
	}      
	else      
	{
		// Min/Max
		if(m_bBStrsOutputMinMax)      
		{
			if(bSaveTextOutput)
			{
				double Pos6[6];
				Pos6[0] = node3D_i.x;Pos6[1] = node3D_i.y;Pos6[2] = node3D_i.z;
				Pos6[3] = node3D_j.x;Pos6[4] = node3D_j.y;Pos6[5] = node3D_j.z;
				gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[0].x),Pos6, 3, pMnMxVal[0]);
				gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[1].x),Pos6, 4, pMnMxVal[1]);
			}
			else
			{
				// Min Val
				if (gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[0]);
				else                  text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[0]);
				_stprintf(text_str, fmt_str, pMnMxVal[0]);
				TextOutModel.AlignTextTop(TA_CENTER);
				if (text_p.x >= 0 && text_p.y >= 0)
					TextOutModel.TextOutBeamStressPSC(text_p.x, text_p.y, text_str);

				// Max Val
				if (gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[1]);
				else                  text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[1]);
				_stprintf(text_str, fmt_str, pMnMxVal[1]);
				TextOutModel.AlignTextBot(TA_CENTER);
				if (text_p.x >= 0 && text_p.y >= 0)
					TextOutModel.TextOutBeamStressPSC(text_p.x, text_p.y, text_str);
			}
		}
		// Abs Max
	  else if(m_bBStrsOutputMax) 
		{
			 if(bSaveTextOutput)
			{
				double Pos6[6];
				Pos6[0] = node3D_i.x;Pos6[1] = node3D_i.y;Pos6[2] = node3D_i.z;
				Pos6[3] = node3D_j.x;Pos6[4] = node3D_j.y;Pos6[5] = node3D_j.z;
				gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[1].x),Pos6, 5, pMnMxVal[1]);
			}
			else
			{
				if(gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[1]);
				else                  text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[1]);
				_stprintf(text_str, fmt_str, pMnMxVal[1]);
				if (text_p.x >= 0 && text_p.y >= 0)
					TextOutModel.TextOutBeamStressPSC(text_p.x, text_p.y, text_str);
			}
	  }
	  else 
		{
			if(bSaveTextOutput) 
			{
				double Pos6[6];
				Pos6[0] = node3D_i.x;Pos6[1] = node3D_i.y;Pos6[2] = node3D_i.z;
				Pos6[3] = node3D_j.x;Pos6[4] = node3D_j.y;Pos6[5] = node3D_j.z;
				if(m_bBStrsOutputI) 
				{
					gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[0].x),Pos6, 6, CalcBStssValue(StssD, 0));
		    }
		    if (m_bBStrsOutputJ) 
				{
					gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[2].x),Pos6, 7, CalcBStssValue(StssD, 4));
		    }
		    if(m_bBStrsOutputC) 
				{
					gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[1].x),Pos6, 8, CalcBStssValue(StssD, 2));
		    }
			}
			else
			{
			  if(m_bBStrsOutputI) 
			  {
					if (gm->m_bVirtualMode) text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[0]);
					else                    text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[0]);
					_stprintf(text_str, fmt_str, CalcBStssValue(StssD, 0));
					if (text_p.x >= 0 && text_p.y >= 0)
					{
						if (is_inverse)
						{
							TextOutModel.TextOutBeamStressPSC(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorI, TA_RIGHT);
						}
						else
						{
							TextOutModel.TextOutBeamStressPSC(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorI, TA_LEFT);
						}
					}
			  }
			  if (m_bBStrsOutputJ) 
			  {
					if (gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[2]);
					else                   text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[2]);
					_stprintf(text_str, fmt_str, CalcBStssValue(StssD, 4));
					if (text_p.x >= 0 && text_p.y >= 0)
					{
						if (is_inverse)
						{
							TextOutModel.TextOutBeamStressPSC(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorJ, TA_LEFT);
						}
						else
						{
							TextOutModel.TextOutBeamStressPSC(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorJ, TA_RIGHT);
						}
					}
			  }
			  if (m_bBStrsOutputC)
			  {
				  if (gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[1]);
				  else 				          text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[1]);
				  _stprintf(text_str, fmt_str, CalcBStssValue(StssD, 2));
				  if (text_p.x >= 0 && text_p.y >= 0)
				  {
					  TextOutModel.TextOutBeamStressPSC(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorC, TA_CENTER);
				  }
			  }
			}
		  }
	}
	TextOutModel.DeleteFont();
	TextOutModel.EndBeamStressPSCVal();
	for(j=0;j<polygon_list.GetSize();j++) 
	{
		polygon_list[j]->RemoveAll();
		delete polygon_list[j];
		edge_list[j]->RemoveAll();
		delete edge_list[j];
	}
	polygon_list.RemoveAll();
	edge_list.RemoveAll();

	gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}
#endif

void CStressEngine::OutputBVmstDgrmNumber(CDC *pDC, T_ELEM_K ekey, T_VMST_D &VmstD, 
																					C3DPoint *txt_pnt,int nComp,double *pMnMxVal)
{
	DECLARE_GPSMD();
	DECLARE_DPTTX();
	DECLARE_DPTDR();

	int			  j, slope;
	TCHAR			fmt_str[10], text_str[512];
	BOOL			fl_bak, is_inverse;
	C3DPoint	node3D_i, node3D_j,DrawPoint;
	CPoint		text_p,node_2d_i, node_2d_j;
	CFont			ft, *old_ft;
	T_ELEM_D	edata;

	POSITION	pos;
	CArray<GPS_3DPT_LISTP, GPS_3DPT_LISTP>  polygon_list;
	CArray<GPS_BOOL_ARRYP, GPS_BOOL_ARRYP>	edge_list;

	if(pTX->m_bNumberOpaque)pDC->SetBkMode(OPAQUE);
	else		                pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(pTX->m_NumberTextColorC);
	pDC->SetBkColor(pTX->m_NumberBackCol);
	pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);

	if(pTX->m_bNumberExponent)_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else		                  _stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);

	m_pDoc->m_pAttrCtrl->GetElem(ekey, edata);
	if(!m_pDoc->m_pAttrCtrl->IsBeam(edata.eltyp) )return;

	fl_bak = pDR->m_bFrameLine;
	gm->m_DOPT.DR.m_bFrameLine = TRUE;

	if(m_bDeformedShapeContour)
		gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list);
	else
		gm->GetShapeElement(ekey, polygon_list, &edge_list);

	CRect	rct;
	gm->m_pMyView->GetClientRect(&rct);

	pos = polygon_list[0]->GetHeadPosition();
	node3D_i = polygon_list[0]->GetNext(pos);
	node3D_j = polygon_list[0]->GetNext(pos);

	//XGLRenderer
	BOOL bSaveTextOutput = FALSE;
	if(gm->m_pGPSCtrl->IsGLRenderer() && gm->m_pGPSCtrl->IsXGRMode() && 
		!gm->m_pGPSCtrl->IsMakeEMFMode() )
	{
		bSaveTextOutput = TRUE;
	}

	if(gm->m_bVirtualMode) 
	{
		node_2d_i = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_i);
		node_2d_j = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_j);
	}
	else 
	{
		node_2d_i = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_i);
		node_2d_j = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_j);
	}

	//XGLRenderer 
	if(bSaveTextOutput == FALSE) //저장 모드에서는 현재 화면 상태와 관계된 Filtering처리를 하지 않는다. 
	{
		if(node_2d_i.x < 0 ||node_2d_i.y < 0 ) return;
		if(node_2d_j.x < 0 ||node_2d_j.y < 0 ) return;
	}

	slope = (int) (atan2(node_2d_i.y-node_2d_j.y, node_2d_j.x-node_2d_i.x)*1800.0/3.14159);
	slope = (slope+3600)%3600;
	if ((900<slope) && (slope<=2700)) 
	{
		slope = (slope+1800)%3600;
		is_inverse = TRUE;
	}
	else 
	{
		is_inverse = FALSE;
	}

	gm->SetNumberFontOrientation(slope);
	ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
	old_ft = (CFont *) pDC->SelectObject(&ft);

	if(pTX->m_bOutputMinMaxValueOnly)
	{
		double dLimit = (m_dMaxValue-m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;
		double dBValue;

		for(int n=0; n<3; n++)
		{
			if(m_bBStrsOutputMinMax)
			{
				// Min
				if(n==0)
				{
					pDC->SetTextAlign(TA_CENTER|TA_TOP);
					DrawPoint = txt_pnt[0];  
					dBValue   = pMnMxVal[0];
				}
				// Max
				else if(n==1)
				{
					pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);
					DrawPoint = txt_pnt[1];  
					dBValue   = pMnMxVal[1];
				}
				else continue; 
			}
			// Abs Max
			else if(m_bBStrsOutputMax) 
			{
				if(n==0)
				{
					DrawPoint = txt_pnt[1];  
					dBValue   = pMnMxVal[1];
				}
				else continue; 
			}
			else if(n==0) // I단 
			{
				if (!m_bBStrsOutputI) continue;

				if(is_inverse) pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
				else					 pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
				DrawPoint = txt_pnt[0];
				dBValue = CalcBVmstValue(VmstD, 0, I_NODE);
			}
			else if(n==1)// CNT or MAX
			{			  
				if (!(m_bBStrsOutputC||m_bBStrsOutputMax)) continue;

				pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);
				DrawPoint= txt_pnt[1];

				if (m_bBStrsOutputMax) 
				{
					dBValue = pMnMxVal[1];
				}
				else
				{
					dBValue = CalcBVmstValue(VmstD, 1, J_NODE);
				}
			}
			else if(n==2)// J단 
			{			  
				if(!m_bBStrsOutputJ) continue;
				if(is_inverse)pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
				else					pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
				DrawPoint = txt_pnt[2];
				dBValue = CalcBVmstValue(VmstD, 3, J_NODE);
			}

			switch(gm->m_DOPT.TX.m_nOutputMinMaxType)
			{
			case 0: // Min & Max
				if(bSaveTextOutput)
				{
					double Pos6[6];
					Pos6[0] = node3D_i.x;Pos6[1] = node3D_i.y;Pos6[2] = node3D_i.z;
					Pos6[3] = node3D_j.x;Pos6[4] = node3D_j.y;Pos6[5] = node3D_j.z;
					if((m_dMaxValue-dBValue) <= dLimit)
						gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(DrawPoint.x),Pos6, 0,dBValue);
					else if((dBValue-m_dMinValue) <= dLimit)
						gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(DrawPoint.x),Pos6, 1,dBValue);
				}
				else
				{
					if((m_dMaxValue-dBValue) <= dLimit)
						DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,dBValue);
					else if((dBValue-m_dMinValue) <= dLimit)
						DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,dBValue);
				}
				break;
			case 1: // Abs Max
				if(bSaveTextOutput)
				{
					double Pos6[6];
					Pos6[0] = node3D_i.x;Pos6[1] = node3D_i.y;Pos6[2] = node3D_i.z;
					Pos6[3] = node3D_j.x;Pos6[4] = node3D_j.y;Pos6[5] = node3D_j.z;
					if( fabs(m_dMaxValue) >= fabs(m_dMinValue))
					{
						if( fabs(m_dMaxValue)-fabs(dBValue) <= dLimit)
							gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(DrawPoint.x),Pos6, 2,dBValue);
					}
					else
					{
						if( fabs(m_dMinValue)-fabs(dBValue) <= dLimit)
							gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(DrawPoint.x),Pos6, 2,dBValue);
					}
				}
				else
				{
					if(fabs(m_dMaxValue) >= fabs(m_dMinValue))
					{
						if( fabs(m_dMaxValue)-fabs(dBValue) <= dLimit)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dBValue);
					}
					else
					{
						if( fabs(m_dMinValue)-fabs(dBValue) <= dLimit)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dBValue);
					}
				}
				break;
			case 2: // Max
				if(bSaveTextOutput)
				{
					double Pos6[6];
					Pos6[0] = node3D_i.x;Pos6[1] = node3D_i.y;Pos6[2] = node3D_i.z;
					Pos6[3] = node3D_j.x;Pos6[4] = node3D_j.y;Pos6[5] = node3D_j.z;
					if((m_dMaxValue-dBValue) <= dLimit)
						gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(DrawPoint.x),Pos6, 0,dBValue);
				}
				else
				{
					if((m_dMaxValue-dBValue) <= dLimit)
						DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,dBValue);
				}
				break;
			case 3: // Min
				if(bSaveTextOutput)
				{
					double Pos6[6];
					Pos6[0] = node3D_i.x;Pos6[1] = node3D_i.y;Pos6[2] = node3D_i.z;
					Pos6[3] = node3D_j.x;Pos6[4] = node3D_j.y;Pos6[5] = node3D_j.z;
					if((dBValue-m_dMinValue) <= dLimit)
						gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(DrawPoint.x),Pos6, 1,dBValue);
				}
				else
				{
					if((dBValue-m_dMinValue) <= dLimit)
						DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,dBValue);
				}
				break;
			}
		}
		//////////////////////////////////////////////////////////////////////////////////////
	}      
	else      
	{
		// Min/Max
		if(m_bBStrsOutputMinMax)      
		{
			if(bSaveTextOutput)
			{
				double Pos6[6];
				Pos6[0] = node3D_i.x;Pos6[1] = node3D_i.y;Pos6[2] = node3D_i.z;
				Pos6[3] = node3D_j.x;Pos6[4] = node3D_j.y;Pos6[5] = node3D_j.z;
				gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[0].x),Pos6, 3, pMnMxVal[0]);
				gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[1].x),Pos6, 4, pMnMxVal[1]);
			}
			else
			{
				// Min Val
				pDC->SetTextAlign(TA_CENTER|TA_TOP);
				if(gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[0]);
				else                  text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[0]);
				_stprintf(text_str, fmt_str, pMnMxVal[0]);
				if(text_p.x >= 0 && text_p.y>=0)pDC->TextOut(text_p.x, text_p.y, text_str);  

				// Max Val
				pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);
				if(gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[1]);
				else                  text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[1]);
				_stprintf(text_str, fmt_str, pMnMxVal[1]);
				if(text_p.x >= 0 && text_p.y>=0)pDC->TextOut(text_p.x, text_p.y, text_str);  
			}
		}
		// Abs Max
		else if(m_bBStrsOutputMax) 
		{
			if(bSaveTextOutput)
			{
				double Pos6[6];
				Pos6[0] = node3D_i.x;Pos6[1] = node3D_i.y;Pos6[2] = node3D_i.z;
				Pos6[3] = node3D_j.x;Pos6[4] = node3D_j.y;Pos6[5] = node3D_j.z;
				gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[1].x),Pos6, 5, pMnMxVal[1]);
			}
			else
			{
				if(gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[1]);
				else                  text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[1]);
				_stprintf(text_str, fmt_str, pMnMxVal[1]);
				if(text_p.x >= 0 && text_p.y>=0) pDC->TextOut(text_p.x, text_p.y, text_str);
			}
		}
		else 
		{
			if(bSaveTextOutput) 
			{
				double Pos6[6];
				Pos6[0] = node3D_i.x;Pos6[1] = node3D_i.y;Pos6[2] = node3D_i.z;
				Pos6[3] = node3D_j.x;Pos6[4] = node3D_j.y;Pos6[5] = node3D_j.z;
				if(m_bBStrsOutputI) 
				{
					gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[0].x),Pos6, 6, CalcBVmstValue(VmstD, 0, I_NODE));
				}
				if (m_bBStrsOutputJ) 
				{
					gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[2].x),Pos6, 7, CalcBVmstValue(VmstD, 3, J_NODE));
				}
				if(m_bBStrsOutputC) 
				{
					gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[1].x),Pos6, 8, CalcBVmstValue(VmstD, 1, J_NODE));
				}
			}
			else
			{
				if(m_bBStrsOutputI) 
				{
					pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorI);
					if(is_inverse)pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
					else				  pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
					if (gm->m_bVirtualMode) text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[0]);
					else                    text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[0]);
					_stprintf(text_str, fmt_str, CalcBVmstValue(VmstD, 0, I_NODE));
					if(text_p.x >= 0 && text_p.y>=0)pDC->TextOut(text_p.x, text_p.y, text_str);
				}
				if (m_bBStrsOutputJ) 
				{
					pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorJ);
					if(is_inverse)pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
					else				  pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
					if (gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[2]);
					else                   text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[2]);
					_stprintf(text_str, fmt_str, CalcBVmstValue(VmstD, 3, J_NODE));
					if(text_p.x >= 0 && text_p.y>=0) pDC->TextOut(text_p.x, text_p.y, text_str);
				}
				if(m_bBStrsOutputC) 
				{
					pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
					pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);
					if(gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[1]);
					else 				          text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[1]);
					_stprintf(text_str, fmt_str, CalcBVmstValue(VmstD, 1, J_NODE));
					if(text_p.x >= 0 && text_p.y>=0) pDC->TextOut(text_p.x, text_p.y, text_str);
				}
			}
		}
	}

	pDC->SelectObject(old_ft);
	ft.DeleteObject();

	for(j=0;j<polygon_list.GetSize();j++) 
	{
		polygon_list[j]->RemoveAll();
		delete polygon_list[j];
		edge_list[j]->RemoveAll();
		delete edge_list[j];
	}
	polygon_list.RemoveAll();
	edge_list.RemoveAll();

	gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}
#if defined(__OLD_OUTPUT_VALUE)
void CStressEngine::OutputBStrsDgrmNumber(CDC* pDC, T_ELEM_K ekey, T_STRB_D& StrbD,
	C3DPoint* txt_pnt, int nComp, double* pMnMxVal)
{
	DECLARE_GPSMD();
	DECLARE_DPTTX();
	DECLARE_DPTDR();

	int			  j, slope;
	TCHAR			fmt_str[10], text_str[512];
	BOOL			fl_bak, is_inverse;
	C3DPoint	node3D_i, node3D_j, DrawPoint;
	CPoint		text_p, node_2d_i, node_2d_j;
	CFont			ft, * old_ft;
	T_ELEM_D	edata;

	POSITION	pos;
	CArray<GPS_3DPT_LISTP, GPS_3DPT_LISTP>  polygon_list;
	CArray<GPS_BOOL_ARRYP, GPS_BOOL_ARRYP>	edge_list;

	if (pTX->m_bNumberOpaque)pDC->SetBkMode(OPAQUE);
	else		                pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(pTX->m_NumberTextColorC);
	pDC->SetBkColor(pTX->m_NumberBackCol);
	pDC->SetTextAlign(TA_CENTER | TA_BOTTOM);

	if (pTX->m_bNumberExponent)_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else		                  _stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);

	m_pDoc->m_pAttrCtrl->GetElem(ekey, edata);
	if (!m_pDoc->m_pAttrCtrl->IsBeam(edata.eltyp))return;

	fl_bak = pDR->m_bFrameLine;
	gm->m_DOPT.DR.m_bFrameLine = TRUE;

	if (m_bDeformedShapeContour)
		gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list);
	else
		gm->GetShapeElement(ekey, polygon_list, &edge_list);

	CRect	rct;
	gm->m_pMyView->GetClientRect(&rct);

	pos = polygon_list[0]->GetHeadPosition();
	node3D_i = polygon_list[0]->GetNext(pos);
	node3D_j = polygon_list[0]->GetNext(pos);

	//XGLRenderer
	BOOL bSaveTextOutput = FALSE;
	if (gm->m_pGPSCtrl->IsGLRenderer() && gm->m_pGPSCtrl->IsXGRMode() &&
		!gm->m_pGPSCtrl->IsMakeEMFMode())
	{
		bSaveTextOutput = TRUE;
	}

	if (gm->m_bVirtualMode)
	{
		node_2d_i = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_i);
		node_2d_j = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_j);
	}
	else
	{
		node_2d_i = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_i);
		node_2d_j = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_j);
	}

	//XGLRenderer 
	if (bSaveTextOutput == FALSE) //저장 모드에서는 현재 화면 상태와 관계된 Filtering처리를 하지 않는다. 
	{
		if (node_2d_i.x < 0 || node_2d_i.y < 0) return;
		if (node_2d_j.x < 0 || node_2d_j.y < 0) return;
	}

	slope = (int)(atan2(node_2d_i.y - node_2d_j.y, node_2d_j.x - node_2d_i.x) * 1800.0 / 3.14159);
	slope = (slope + 3600) % 3600;
	if ((900 < slope) && (slope <= 2700))
	{
		slope = (slope + 1800) % 3600;
		is_inverse = TRUE;
	}
	else
	{
		is_inverse = FALSE;
	}

	gm->SetNumberFontOrientation(slope);
	ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
	old_ft = (CFont*)pDC->SelectObject(&ft);

	if (pTX->m_bOutputMinMaxValueOnly)
	{
		double dLimit = (m_dMaxValue - m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;
		double dBValue;

		for (int n = 0; n < 3; n++)
		{
			if (m_bBStrsOutputMinMax)
			{
				// Min
				if (n == 0)
				{
					pDC->SetTextAlign(TA_CENTER | TA_TOP);
					DrawPoint = txt_pnt[0];
					dBValue = pMnMxVal[0];
				}
				// Max
				else if (n == 1)
				{
					pDC->SetTextAlign(TA_CENTER | TA_BOTTOM);
					DrawPoint = txt_pnt[1];
					dBValue = pMnMxVal[1];
				}
				else continue;
			}
			// Abs Max
			else if (m_bBStrsOutputMax)
			{
				if (n == 0)
				{
					DrawPoint = txt_pnt[1];
					dBValue = pMnMxVal[1];
				}
				else continue;
			}
			else if (n == 0) // I단 
			{
				if (!m_bBStrsOutputI) continue;

				if (is_inverse) pDC->SetTextAlign(TA_RIGHT | TA_BOTTOM);
				else					 pDC->SetTextAlign(TA_LEFT | TA_BOTTOM);
				DrawPoint = txt_pnt[0];
				dBValue = CalcBStrsValue(StrbD, 0, I_NODE);
				//dBValue = this->CalcBStrsValue(StrbD, 0);

			}
			else if (n == 1)// CNT or MAX
			{
				if (!(m_bBStrsOutputC || m_bBStrsOutputMax)) continue;

				pDC->SetTextAlign(TA_CENTER | TA_BOTTOM);
				DrawPoint = txt_pnt[1];

				if (m_bBStrsOutputMax)
				{
					dBValue = pMnMxVal[1];
				}
				else
				{
					dBValue = CalcBStrsValue(StrbD, 1, J_NODE);
					//dBValue = this->CalcBStssValue(StssD, 4);
				}

			}
			else if (n == 2)// J단 
			{
				if (!m_bBStrsOutputJ) continue;
				if (is_inverse)pDC->SetTextAlign(TA_LEFT | TA_BOTTOM);
				else					pDC->SetTextAlign(TA_RIGHT | TA_BOTTOM);
				DrawPoint = txt_pnt[2];
				//dBValue = CalcBForcValue(bforc_d, 3, J_NODE);
				//this->CalcBStssValue(StssD, 2);
				dBValue = CalcBStrsValue(StrbD, 3, J_NODE);
			}

			switch (gm->m_DOPT.TX.m_nOutputMinMaxType)
			{
			case 0: // Min & Max
				if (bSaveTextOutput)
				{
					double Pos6[6];
					Pos6[0] = node3D_i.x; Pos6[1] = node3D_i.y; Pos6[2] = node3D_i.z;
					Pos6[3] = node3D_j.x; Pos6[4] = node3D_j.y; Pos6[5] = node3D_j.z;
					if ((m_dMaxValue - dBValue) <= dLimit)
						gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(DrawPoint.x), Pos6, 0, dBValue);
					else if ((dBValue - m_dMinValue) <= dLimit)
						gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(DrawPoint.x), Pos6, 1, dBValue);
				}
				else
				{
					if ((m_dMaxValue - dBValue) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, dBValue);
					else if ((dBValue - m_dMinValue) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, dBValue);
				}
				break;
			case 1: // Abs Max
				if (bSaveTextOutput)
				{
					double Pos6[6];
					Pos6[0] = node3D_i.x; Pos6[1] = node3D_i.y; Pos6[2] = node3D_i.z;
					Pos6[3] = node3D_j.x; Pos6[4] = node3D_j.y; Pos6[5] = node3D_j.z;
					if (fabs(m_dMaxValue) >= fabs(m_dMinValue))
					{
						if (fabs(m_dMaxValue) - fabs(dBValue) <= dLimit)
							gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(DrawPoint.x), Pos6, 2, dBValue);
					}
					else
					{
						if (fabs(m_dMinValue) - fabs(dBValue) <= dLimit)
							gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(DrawPoint.x), Pos6, 2, dBValue);
					}
				}
				else
				{
					if (fabs(m_dMaxValue) >= fabs(m_dMinValue))
					{
						if (fabs(m_dMaxValue) - fabs(dBValue) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, dBValue);
					}
					else
					{
						if (fabs(m_dMinValue) - fabs(dBValue) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, dBValue);
					}
				}
				break;
			case 2: // Max
				if (bSaveTextOutput)
				{
					double Pos6[6];
					Pos6[0] = node3D_i.x; Pos6[1] = node3D_i.y; Pos6[2] = node3D_i.z;
					Pos6[3] = node3D_j.x; Pos6[4] = node3D_j.y; Pos6[5] = node3D_j.z;
					if ((m_dMaxValue - dBValue) <= dLimit)
						gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(DrawPoint.x), Pos6, 0, dBValue);
				}
				else
				{
					if ((m_dMaxValue - dBValue) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, dBValue);
				}
				break;
			case 3: // Min
				if (bSaveTextOutput)
				{
					double Pos6[6];
					Pos6[0] = node3D_i.x; Pos6[1] = node3D_i.y; Pos6[2] = node3D_i.z;
					Pos6[3] = node3D_j.x; Pos6[4] = node3D_j.y; Pos6[5] = node3D_j.z;
					if ((dBValue - m_dMinValue) <= dLimit)
						gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(DrawPoint.x), Pos6, 1, dBValue);
				}
				else
				{
					if ((dBValue - m_dMinValue) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, dBValue);
				}
				break;
			}
		}
		//////////////////////////////////////////////////////////////////////////////////////
	}
	else
	{
		// Min/Max
		if (m_bBStrsOutputMinMax)
		{
			if (bSaveTextOutput)
			{
				double Pos6[6];
				Pos6[0] = node3D_i.x; Pos6[1] = node3D_i.y; Pos6[2] = node3D_i.z;
				Pos6[3] = node3D_j.x; Pos6[4] = node3D_j.y; Pos6[5] = node3D_j.z;
				gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[0].x), Pos6, 3, pMnMxVal[0]);
				gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[1].x), Pos6, 4, pMnMxVal[1]);
			}
			else
			{
				// Min Val
				pDC->SetTextAlign(TA_CENTER | TA_TOP);
				if (gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[0]);
				else                  text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[0]);
				_stprintf(text_str, fmt_str, pMnMxVal[0]);
				if (text_p.x >= 0 && text_p.y >= 0)pDC->TextOut(text_p.x, text_p.y, text_str);

				// Max Val
				pDC->SetTextAlign(TA_CENTER | TA_BOTTOM);
				if (gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[1]);
				else                  text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[1]);
				_stprintf(text_str, fmt_str, pMnMxVal[1]);
				if (text_p.x >= 0 && text_p.y >= 0)pDC->TextOut(text_p.x, text_p.y, text_str);
			}
		}
		// Abs Max
		else if (m_bBStrsOutputMax)
		{
			if (bSaveTextOutput)
			{
				double Pos6[6];
				Pos6[0] = node3D_i.x; Pos6[1] = node3D_i.y; Pos6[2] = node3D_i.z;
				Pos6[3] = node3D_j.x; Pos6[4] = node3D_j.y; Pos6[5] = node3D_j.z;
				gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[1].x), Pos6, 5, pMnMxVal[1]);
			}
			else
			{
				if (gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[1]);
				else                  text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[1]);
				_stprintf(text_str, fmt_str, pMnMxVal[1]);
				if (text_p.x >= 0 && text_p.y >= 0) pDC->TextOut(text_p.x, text_p.y, text_str);
			}
		}
		else
		{
			if (bSaveTextOutput)
			{
				double Pos6[6];
				Pos6[0] = node3D_i.x; Pos6[1] = node3D_i.y; Pos6[2] = node3D_i.z;
				Pos6[3] = node3D_j.x; Pos6[4] = node3D_j.y; Pos6[5] = node3D_j.z;
				if (m_bBStrsOutputI)
				{
					gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[0].x), Pos6, 6, CalcBStrsValue(StrbD, 0, I_NODE));
				}
				if (m_bBStrsOutputJ)
				{
					gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[2].x), Pos6, 7, CalcBStrsValue(StrbD, 3, J_NODE));
				}
				if (m_bBStrsOutputC)
				{
					gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[1].x), Pos6, 8, CalcBStrsValue(StrbD, 1, J_NODE));
				}
			}
			else
			{
				if (m_bBStrsOutputI)
				{
					pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorI);
					if (is_inverse)pDC->SetTextAlign(TA_RIGHT | TA_BOTTOM);
					else				  pDC->SetTextAlign(TA_LEFT | TA_BOTTOM);
					if (gm->m_bVirtualMode) text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[0]);
					else                    text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[0]);
					_stprintf(text_str, fmt_str, CalcBStrsValue(StrbD, 0, I_NODE));
					if (text_p.x >= 0 && text_p.y >= 0)pDC->TextOut(text_p.x, text_p.y, text_str);
				}
				if (m_bBStrsOutputJ)
				{
					pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorJ);
					if (is_inverse)pDC->SetTextAlign(TA_LEFT | TA_BOTTOM);
					else				  pDC->SetTextAlign(TA_RIGHT | TA_BOTTOM);
					if (gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[2]);
					else                   text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[2]);
					_stprintf(text_str, fmt_str, CalcBStrsValue(StrbD, 3, J_NODE));
					if (text_p.x >= 0 && text_p.y >= 0) pDC->TextOut(text_p.x, text_p.y, text_str);
				}
				if (m_bBStrsOutputC)
				{
					pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
					pDC->SetTextAlign(TA_CENTER | TA_BOTTOM);
					if (gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[1]);
					else 				          text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[1]);
					_stprintf(text_str, fmt_str, CalcBStrsValue(StrbD, 1, J_NODE));
					if (text_p.x >= 0 && text_p.y >= 0) pDC->TextOut(text_p.x, text_p.y, text_str);
				}
			}
		}
	}

	pDC->SelectObject(old_ft);
	ft.DeleteObject();

	for (j = 0; j < polygon_list.GetSize(); j++)
	{
		polygon_list[j]->RemoveAll();
		delete polygon_list[j];
		edge_list[j]->RemoveAll();
		delete edge_list[j];
	}
	polygon_list.RemoveAll();
	edge_list.RemoveAll();

	gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}
#else
void CStressEngine::OutputBStrsDgrmNumber(CDC *pDC, T_ELEM_K ekey, T_STRB_D &StrbD, 
																			C3DPoint *txt_pnt,int nComp,double *pMnMxVal)
{
	DECLARE_GPSMD();
	DECLARE_DPTTX();
	DECLARE_DPTDR();

	int			  j, slope;
	TCHAR			fmt_str[10], text_str[512];
	BOOL			fl_bak, is_inverse;
	C3DPoint	node3D_i, node3D_j,DrawPoint;
	CPoint		text_p,node_2d_i, node_2d_j;
	CFont			ft, *old_ft;
	T_ELEM_D	edata;

	POSITION	pos;
	CArray<GPS_3DPT_LISTP, GPS_3DPT_LISTP>  polygon_list;
	CArray<GPS_BOOL_ARRYP, GPS_BOOL_ARRYP>	edge_list;

	GPostTextOut TextOutModel;
	TextOutModel.SetDC(pDC);
	TextOutModel.StartBeamStressDgrmVal();
	TextOutModel.SettingBeamStressDgrm(gm);

	if(pTX->m_bNumberExponent)_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else		                  _stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);

	m_pDoc->m_pAttrCtrl->GetElem(ekey, edata);
	if(!m_pDoc->m_pAttrCtrl->IsBeam(edata.eltyp) )return;

	fl_bak = pDR->m_bFrameLine;
	gm->m_DOPT.DR.m_bFrameLine = TRUE;

	if(m_bDeformedShapeContour)
		gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list);
	else
		gm->GetShapeElement(ekey, polygon_list, &edge_list);
	
	CRect	rct;
	gm->m_pMyView->GetClientRect(&rct);

	pos = polygon_list[0]->GetHeadPosition();
	node3D_i = polygon_list[0]->GetNext(pos);
	node3D_j = polygon_list[0]->GetNext(pos);

	 //XGLRenderer
	BOOL bSaveTextOutput = FALSE;
	if(gm->m_pGPSCtrl->IsGLRenderer() && gm->m_pGPSCtrl->IsXGRMode() && 
		 !gm->m_pGPSCtrl->IsMakeEMFMode() )
	{
		 bSaveTextOutput = TRUE;
	}

	if(gm->m_bVirtualMode) 
	{
		node_2d_i = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_i);
		node_2d_j = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_j);
	}
	else 
	{
		node_2d_i = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_i);
		node_2d_j = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_j);
	}

	 //XGLRenderer 
	if(bSaveTextOutput == FALSE) //저장 모드에서는 현재 화면 상태와 관계된 Filtering처리를 하지 않는다. 
	{
	if(node_2d_i.x < 0 ||node_2d_i.y < 0 ) return;
	if(node_2d_j.x < 0 ||node_2d_j.y < 0 ) return;
	}

	slope = (int) (atan2(node_2d_i.y-node_2d_j.y, node_2d_j.x-node_2d_i.x)*1800.0/3.14159);
	slope = (slope+3600)%3600;
	if ((900<slope) && (slope<=2700)) 
	{
		slope = (slope+1800)%3600;
		is_inverse = TRUE;
	}
	else 
	{
		is_inverse = FALSE;
	}

	TextOutModel.Font4BeamStressDgrm(gm, slope);

	if(pTX->m_bOutputMinMaxValueOnly)
	{
		double dLimit = (m_dMaxValue-m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;
		double dBValue;
		
		for(int n=0; n<3; n++)
		{
			if(m_bBStrsOutputMinMax)
			{
				// Min
				if(n==0)
				{
					TextOutModel.AlignTextTop(TA_CENTER);
					DrawPoint = txt_pnt[0];  
					dBValue   = pMnMxVal[0];
				}
				// Max
				else if(n==1)
				{
					TextOutModel.AlignTextBot(TA_CENTER);
					DrawPoint = txt_pnt[1];  
					dBValue   = pMnMxVal[1];
				}
				else continue; 
			}
			// Abs Max
	    else if(m_bBStrsOutputMax) 
			{
				if(n==0)
				{
		      DrawPoint = txt_pnt[1];  
					dBValue   = pMnMxVal[1];
				}
				else continue; 
	    }
			else if(n==0) // I단 
			{
				if (!m_bBStrsOutputI) continue;
				
				if (is_inverse)
					TextOutModel.AlignTextBot(TA_RIGHT);
				else
					TextOutModel.AlignTextBot(TA_LEFT);
				DrawPoint = txt_pnt[0];
				dBValue = CalcBStrsValue(StrbD, 0, I_NODE);
				//dBValue = this->CalcBStrsValue(StrbD, 0);
				
			}
			else if(n==1)// CNT or MAX
			{			  
				if (!(m_bBStrsOutputC||m_bBStrsOutputMax)) continue;
				TextOutModel.AlignTextBot(TA_CENTER);
				DrawPoint= txt_pnt[1];
				
				if (m_bBStrsOutputMax) 
				{
					dBValue = pMnMxVal[1];
				}
				else
				{
					dBValue = CalcBStrsValue(StrbD, 1, J_NODE);
					//dBValue = this->CalcBStssValue(StssD, 4);
				}
				
			}
			else if(n==2)// J단 
			{			  
				if(!m_bBStrsOutputJ) continue;
				if(is_inverse)
					TextOutModel.AlignTextBot(TA_LEFT);
				else
					TextOutModel.AlignTextBot(TA_RIGHT);
				DrawPoint = txt_pnt[2];
				//dBValue = CalcBForcValue(bforc_d, 3, J_NODE);
				//this->CalcBStssValue(StssD, 2);
				dBValue = CalcBStrsValue(StrbD, 3, J_NODE);
			}
					
			switch(gm->m_DOPT.TX.m_nOutputMinMaxType)
			{
			case 0: // Min & Max
				if(bSaveTextOutput)
				{
					double Pos6[6];
					Pos6[0] = node3D_i.x;Pos6[1] = node3D_i.y;Pos6[2] = node3D_i.z;
					Pos6[3] = node3D_j.x;Pos6[4] = node3D_j.y;Pos6[5] = node3D_j.z;
					if((m_dMaxValue-dBValue) <= dLimit)
						gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(DrawPoint.x),Pos6, 0,dBValue);
					else if((dBValue-m_dMinValue) <= dLimit)
						gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(DrawPoint.x),Pos6, 1,dBValue);
				}
				else
				{
				if((m_dMaxValue-dBValue) <= dLimit)
					 DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,dBValue);
				else if((dBValue-m_dMinValue) <= dLimit)
					 DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,dBValue);
				}
				break;
			case 1: // Abs Max
				 if(bSaveTextOutput)
				{
					double Pos6[6];
					Pos6[0] = node3D_i.x;Pos6[1] = node3D_i.y;Pos6[2] = node3D_i.z;
					Pos6[3] = node3D_j.x;Pos6[4] = node3D_j.y;Pos6[5] = node3D_j.z;
					if( fabs(m_dMaxValue) >= fabs(m_dMinValue))
					{
						if( fabs(m_dMaxValue)-fabs(dBValue) <= dLimit)
						gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(DrawPoint.x),Pos6, 2,dBValue);
					}
					else
					{
						if( fabs(m_dMinValue)-fabs(dBValue) <= dLimit)
						gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(DrawPoint.x),Pos6, 2,dBValue);
					}
				}
				else
				{
				if(fabs(m_dMaxValue) >= fabs(m_dMinValue))
				{
					if( fabs(m_dMaxValue)-fabs(dBValue) <= dLimit)
					DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dBValue);
				}
				else
				{
					if( fabs(m_dMinValue)-fabs(dBValue) <= dLimit)
					DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dBValue);
				}
				}
				break;
			case 2: // Max
				if(bSaveTextOutput)
				{
					double Pos6[6];
					Pos6[0] = node3D_i.x;Pos6[1] = node3D_i.y;Pos6[2] = node3D_i.z;
					Pos6[3] = node3D_j.x;Pos6[4] = node3D_j.y;Pos6[5] = node3D_j.z;
					if((m_dMaxValue-dBValue) <= dLimit)
						gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(DrawPoint.x),Pos6, 0,dBValue);
				}
				else
				{
				if((m_dMaxValue-dBValue) <= dLimit)
					 DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,dBValue);
				}
				break;
			case 3: // Min
				if(bSaveTextOutput)
				{
					double Pos6[6];
					Pos6[0] = node3D_i.x;Pos6[1] = node3D_i.y;Pos6[2] = node3D_i.z;
					Pos6[3] = node3D_j.x;Pos6[4] = node3D_j.y;Pos6[5] = node3D_j.z;
					if((dBValue-m_dMinValue) <= dLimit)
						gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(DrawPoint.x),Pos6, 1,dBValue);
				}
				else
				{
				if((dBValue-m_dMinValue) <= dLimit)
					 DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,dBValue);
				}
				break;
			}
		}
	//////////////////////////////////////////////////////////////////////////////////////
	}      
	else      
	{
		// Min/Max
		if(m_bBStrsOutputMinMax)      
		{
			if(bSaveTextOutput)
			{
				double Pos6[6];
				Pos6[0] = node3D_i.x;Pos6[1] = node3D_i.y;Pos6[2] = node3D_i.z;
				Pos6[3] = node3D_j.x;Pos6[4] = node3D_j.y;Pos6[5] = node3D_j.z;
				gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[0].x),Pos6, 3, pMnMxVal[0]);
				gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[1].x),Pos6, 4, pMnMxVal[1]);
			}
			else
			{
				// Min Val
				TextOutModel.AlignTextTop(TA_CENTER);
			
				if(gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[0]);
				else                  text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[0]);
				_stprintf(text_str, fmt_str, pMnMxVal[0]);
				if(text_p.x >= 0 && text_p.y>=0)
					TextOutModel.TextOutBeamStressDgrm(text_p.x, text_p.y, text_str);
					
				// Max Val
				TextOutModel.AlignTextBot(TA_CENTER);
				if(gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[1]);
				else                  text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[1]);
				_stprintf(text_str, fmt_str, pMnMxVal[1]);
				if(text_p.x >= 0 && text_p.y>=0)
					TextOutModel.TextOutBeamStressDgrm(text_p.x, text_p.y, text_str);
			}
		}
		// Abs Max
	  else if(m_bBStrsOutputMax) 
		{
			if(bSaveTextOutput)
			{
				double Pos6[6];
				Pos6[0] = node3D_i.x;Pos6[1] = node3D_i.y;Pos6[2] = node3D_i.z;
				Pos6[3] = node3D_j.x;Pos6[4] = node3D_j.y;Pos6[5] = node3D_j.z;
				gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[1].x),Pos6, 5, pMnMxVal[1]);
			}
			else
			{
				if(gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[1]);
				else                  text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[1]);
				_stprintf(text_str, fmt_str, pMnMxVal[1]);
				if(text_p.x >= 0 && text_p.y>=0)
					TextOutModel.TextOutBeamStressDgrm(text_p.x, text_p.y, text_str);
			}
	  }
	  else 
		{
			if(bSaveTextOutput) 
			{
				double Pos6[6];
				Pos6[0] = node3D_i.x;Pos6[1] = node3D_i.y;Pos6[2] = node3D_i.z;
				Pos6[3] = node3D_j.x;Pos6[4] = node3D_j.y;Pos6[5] = node3D_j.z;
				if(m_bBStrsOutputI) 
				{
					gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[0].x),Pos6, 6, CalcBStrsValue(StrbD, 0, I_NODE));
		    }
		    if (m_bBStrsOutputJ) 
				{
					gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[2].x),Pos6, 7, CalcBStrsValue(StrbD, 3, J_NODE));
		    }
		    if(m_bBStrsOutputC) 
				{
					gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[1].x),Pos6, 8, CalcBStrsValue(StrbD, 1, J_NODE));
		    }
			}
			else
			{
			  if(m_bBStrsOutputI) 
				{
					if (gm->m_bVirtualMode) text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[0]);
					else                    text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[0]);
					_stprintf(text_str, fmt_str, CalcBStrsValue(StrbD, 0, I_NODE));
					if (text_p.x >= 0 && text_p.y >= 0)
					{
						if (is_inverse)
							TextOutModel.TextOutBeamStressDgrm(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorI, TA_RIGHT);
						else
							TextOutModel.TextOutBeamStressDgrm(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorI, TA_LEFT);
					}
			  }
			  if (m_bBStrsOutputJ) 
				{
					if (gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[2]);
					else                   text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[2]);
					_stprintf(text_str, fmt_str, CalcBStrsValue(StrbD, 3, J_NODE));
				
					if (text_p.x >= 0 && text_p.y >= 0)
					{
						if (is_inverse)
							TextOutModel.TextOutBeamStressDgrm(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorJ, TA_LEFT);
						else
							TextOutModel.TextOutBeamStressDgrm(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorJ, TA_RIGHT);
					}
			  }
			  if (m_bBStrsOutputC)
			  {
				  if (gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[1]);
				  else 				          text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[1]);
				  _stprintf(text_str, fmt_str, CalcBStrsValue(StrbD, 1, J_NODE));
				  if (text_p.x >= 0 && text_p.y >= 0)
				  {
					  TextOutModel.TextOutBeamStressDgrm(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorC, TA_CENTER);  
				  }
			  }
			}
	  }
	}

	TextOutModel.DeleteFont();
	TextOutModel.EndBeamStressDgrmVal();
	for(j=0;j<polygon_list.GetSize();j++) 
	{
		polygon_list[j]->RemoveAll();
		delete polygon_list[j];
		edge_list[j]->RemoveAll();
		delete edge_list[j];
	}
	polygon_list.RemoveAll();
	edge_list.RemoveAll();

	gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}
#endif


void	 CStressEngine::OutputBStssNumbers(CDC *pDC)
{
	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;
	
	int				  i, j, elem_num, slope;
	T_ELEM_K		ekey;
	T_ELEM_D		edata;
	T_STSS_D		bstss_d;
	C3DPoint		node3D_i, node3D_j,DrawPoint;
	CPoint			text_p,node_2d_i, node_2d_j;
	TCHAR			  fmt_str[10], text_str[512];
	CFont			  ft, *old_ft;
	BOOL			  fl_bak, is_inverse;

	POSITION		pos;
	CArray<CArray<BOOL,BOOL>*,CArray<BOOL,BOOL>*> edge_list;
	CArray<CList<C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>polygon_list;
	

	if(!m_bBStrsDataSet)return;

	if(gm->m_DOPT.TX.m_bNumberOpaque)
		pDC->SetBkMode(OPAQUE);
	else
		pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
	pDC->SetBkColor(gm->m_DOPT.TX.m_NumberBackCol);
	pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);

	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);

	fl_bak = gm->m_DOPT.DR.m_bFrameLine;
	gm->m_DOPT.DR.m_bFrameLine = TRUE;

	if (gm->m_DOPT.TX.m_bNumberSelOnly) 
	{
	}
	else 
	{
		BOOL bGrpFltMode=gm->m_pGPSCtrl->IsGroupFilterMode();
		if(!bGrpFltMode)elem_num = gm->m_EKeyListActive.GetSize();
		else            elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize(); 

		for (i=0;i<elem_num;i++) 
		{
			if(!bGrpFltMode)ekey = gm->m_EKeyListActive[i];
			else            ekey = gm->m_pDispFilter->m_aGrpEKey[i]; 
			
			if(!gm->m_pGPSCtrl->IsActiveElem(ekey))
				continue; 

			m_pDoc->m_pAttrCtrl->GetElem(ekey, edata);

			if(!m_pDoc->m_pAttrCtrl->IsBeam(edata.eltyp))continue;
			bstss_d.Initialize();
			if(!GetBeamStressInc(ekey, bstss_d))continue; 

			if(m_bDeformedShapeContour) 
			{
				gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list);
			}
			else 
			{
				gm->GetShapeElement(ekey, polygon_list, &edge_list);
			}

			pos = polygon_list[0]->GetHeadPosition();
			node3D_i = polygon_list[0]->GetNext(pos);
			node3D_j = polygon_list[0]->GetNext(pos);
		  if(gm->m_bVirtualMode) 
			{
			  node_2d_i = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_i);
			  node_2d_j = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_j);
		  }
		  else 
			{
			  node_2d_i = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_i);
			  node_2d_j = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_j);
		  }
			
			if((node_2d_i.x >= 0 && node_2d_i.y >= 0 && node_2d_j.x >= 0 && node_2d_j.y >= 0))
			{
		    slope = (int) (atan2(node_2d_i.y-node_2d_j.y, node_2d_j.x-node_2d_i.x)*1800.0/3.14159);
			  slope = (slope+3600) % 3600;
			  if ((900<slope) && (slope<=2700)) 
				{
				  slope = (slope+1800)%3600;
				  is_inverse = TRUE;
			  }
			  else 
				{
				  is_inverse = FALSE;
			  }

			  gm->SetNumberFontOrientation(slope);
			  ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
			  old_ft = (CFont *) pDC->SelectObject(&ft);

				if(gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
				{
					double dLimit = (m_dMaxValue-m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;
				  double dBValue;
				
					for(int n=0; n<3; n++)
					{
				    if(n==0) // I단 
						{
							if(!m_bBStrsOutputI) continue;
						
							if(is_inverse)pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
				      else					pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
							DrawPoint = node3D_i;
							dBValue = CalcBStssValue(bstss_d, 0);
						}
						else if(n==1)// CNT or MAX
						{			  
							if(!(m_bBStrsOutputC||m_bBStrsOutputMax)) continue;
						
							pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);
							DrawPoint.x = (node3D_i.x + node3D_j.x)/2.0;
							DrawPoint.y = (node3D_i.y + node3D_j.y)/2.0;
							DrawPoint.z = (node3D_i.z + node3D_j.z)/2.0;
						
							if(m_bBStrsOutputMax) dBValue = GetAbsMaxElemBStss(bstss_d);
							else                  dBValue = CalcBStssValue(bstss_d,2);
						
						}
						else if(n==2)// J단 
						{			  
							if (!m_bBStrsOutputJ) continue;

				      if (is_inverse) pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
				      else					  pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
							DrawPoint = node3D_j;
							dBValue = CalcBStssValue(bstss_d, 4);
						}
							
						switch(gm->m_DOPT.TX.m_nOutputMinMaxType)
						{
						case 0: // Min & Max
							if((m_dMaxValue-dBValue) <= dLimit)
								 DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,dBValue);
							else if((dBValue-m_dMinValue) <= dLimit)
								 DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,dBValue);
							break;
						case 1: // Abs Max
							if(fabs(m_dMaxValue) >= fabs(m_dMinValue))
							{
								if( fabs(m_dMaxValue)-fabs(dBValue) <= dLimit)
									DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dBValue);
							}
							else
							{
								if( fabs(m_dMinValue)-fabs(dBValue) <= dLimit)
									DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dBValue);
							}
							break;
						case 2: // Max
							if((m_dMaxValue-dBValue) <= dLimit)
								DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,dBValue);
							break;
						case 3: // Min
							if((dBValue-m_dMinValue) <= dLimit)
								DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,dBValue);
							break;
						}
					}
				//////////////////////////////////////////////////////////////////////////////////////
				}      
				else      
				{
			    if(m_bBStrsOutputI) 
					{
				    pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorI);
				    if(is_inverse)pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
				    else					pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
				    text_p.x = (int) node_2d_i.x;
				    text_p.y = (int) node_2d_i.y;
				    _stprintf(text_str, fmt_str, CalcBStssValue(bstss_d, 0));
				    pDC->TextOut(text_p.x, text_p.y, text_str);
			    }
			    if(m_bBStrsOutputJ) 
					{
				    pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorJ);
				    if (is_inverse)pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
				    else					 pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
				    text_p.x = (int) node_2d_j.x;
				    text_p.y = (int) node_2d_j.y;
				    _stprintf(text_str, fmt_str, CalcBStssValue(bstss_d, 4));
				    pDC->TextOut(text_p.x, text_p.y, text_str);
			    }
			    if(m_bBStrsOutputC) 
					{
						pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);
				    text_p.x = (int) ((node_2d_i.x+node_2d_j.x)/2.0);
				    text_p.y = (int) ((node_2d_i.y+node_2d_j.y)/2.0);
				    _stprintf(text_str, fmt_str, CalcBStssValue(bstss_d, 2));
				    pDC->TextOut(text_p.x, text_p.y, text_str);
			    }
					if(m_bBStrsOutputMax) 
					{
						pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);
				    text_p.x = (int) ((node_2d_i.x+node_2d_j.x)/2.0);
				    text_p.y = (int) ((node_2d_i.y+node_2d_j.y)/2.0);
				    _stprintf(text_str, fmt_str, GetAbsMaxElemBStss(bstss_d));
				    pDC->TextOut(text_p.x, text_p.y, text_str);
			    }
				}
			  pDC->SelectObject(old_ft);
			  ft.DeleteObject();
			}

			for(j=0;j<polygon_list.GetSize();j++) 
			{
				polygon_list[j]->RemoveAll();
				delete polygon_list[j];
				edge_list[j]->RemoveAll();
				delete edge_list[j];
			}
			polygon_list.RemoveAll();
			edge_list.RemoveAll();
		}
	}

	gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}

void	 CStressEngine::DoBStssElementContour(CDC *pDC, unsigned int ekey)
{
	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;
	T_MIRE_K mkey;
	mkey.keymap = ekey;
	
	int				i, poly_num, vtx_num;
	BOOL			is_real=FALSE;
	T_ELEM_D		elem_d;
	T_STSS_D		bstss_d;

	CArray<CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray<CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					        edge_list;
	CArray<CArray <T_NODE_K, T_NODE_K> *, CArray <T_NODE_K, T_NODE_K> *>	VertexNode;
	CArray<CArray <double, double> *, CArray <double, double> *>			    PosList;

	if((gm->m_pDeformEngine==NULL) ||
		 (m_pContourEngine==NULL) ||
		 (!GetBeamStressInc(mkey.key.elem_k, bstss_d))) 
	{
		return;
	}

	// 요소의 형상정보를 얻는다.

	m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d);
	if (m_bDeformedShapeContour) 
	{	// 변형된 형상
		is_real = gm->m_pDeformEngine->m_bRealDeform;
		if (is_real) 
		{				// Real Deform
			if (!gm->m_pBeamDiagram)
				gm->m_pBeamDiagram = new CBeamDiagram;
			if (gm->m_pBeamDiagram->MakeBeamDispl(mkey.key.elem_k, gm->m_LoadCombi, 10, 2)) 
			{
				gm->m_pDeformEngine->GetBeamRealDeformedShape(ekey, &polygon_list, &edge_list, &PosList);
			}
			else {
				gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list, &VertexNode);
				is_real = FALSE;
			}
		}
		else 
		{
			gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list, &VertexNode);
		}
	}
	else 
	{
		gm->GetShapeElement(ekey, polygon_list, &edge_list, NULL, &VertexNode);
	}

	T_SECT_D SectD;
	if(gm->m_DOPT.DR.m_bFrameThick)
		m_pDoc->m_pAttrCtrl->GetSect(elem_d.elpro,SectD);

	gm->GPS_XGL_Begin_Elem(mkey.key.elem_k,elem_d);

	poly_num = polygon_list.GetSize();
	for (i=0;i<poly_num;i++) 
	{
		vtx_num = polygon_list[i]->GetCount();
		if (vtx_num == 2) 
		{
			if(m_bDeformedShapeContour && is_real)
				DoBStssLineContourReal(pDC, polygon_list[i], poly_num, bstss_d, PosList[i]);
			else
				DoBStssLineContour(pDC, polygon_list[i], poly_num, bstss_d);
		}
		else 
		{
			if(!gm->IsPossibleDrawingPolyFrame(ekey,&elem_d,&SectD,poly_num,polygon_list[i],is_real))continue;
			if(m_bDeformedShapeContour && is_real)
				DoBStssPolyContourReal(pDC, polygon_list[i], edge_list[i], bstss_d, PosList[i]);
			else
				DoBStssPolyContour(pDC, polygon_list[i], edge_list[i], VertexNode[i], elem_d, bstss_d);
		}
	}
	
	gm->GPS_XGL_End_Elem();

	for(i=0;i<poly_num;i++) 
	{
		polygon_list[i]->RemoveAll();
		delete polygon_list[i];
		edge_list[i]->RemoveAll();
		delete edge_list[i];
		if(m_bDeformedShapeContour && is_real) 
		{
			PosList[i]->RemoveAll();
			delete PosList[i];
		}
		else 
		{
			VertexNode[i]->RemoveAll();
			delete VertexNode[i];
		}
	}
	polygon_list.RemoveAll();
	edge_list.RemoveAll();
	VertexNode.RemoveAll();
	PosList.RemoveAll();
} 

void	 CStressEngine::DoBStssLineContour(CDC *pDC, CList<C3DPoint, C3DPoint> *Vertex, int nPolyNum ,T_STSS_D &BStssVal)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	int					i;
	double			dx, dy, dz, i_val, j_val;
	POSITION		pos=Vertex->GetHeadPosition();
	C3DPoint		p[5];
	CArray <C3DPoint, C3DPoint>		rvtx_list;
	CArray <double, double>			rval_list;

	p[0] = Vertex->GetNext(pos);
	p[4] = Vertex->GetNext(pos);

	// Line이지만 Polygon의 Outline이다.
	// Composite Section의 Concrete부분 
	if( nPolyNum>1 )
	{
		CPen pen,*pOldPen;
		if(gm->m_DOPT.DR.m_bFrameLine) pen.CreatePen(PS_SOLID, gm->m_nLineWidth*1.7, gm->m_DOPT.CL.m_InactiveCol);
	  else 		                       pen.CreatePen(PS_SOLID, gm->m_nLineWidth, gm->m_DOPT.CL.m_InactiveCol);
		pOldPen = pDC->SelectObject(&pen);

		if(gm->m_bVirtualMode)gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, p[0], p[4]);
	  else                  gm->m_pGPSCtrl->DrawLine3D(pDC, p[0], p[4]);
		
		pDC->SelectObject(pOldPen);
		pen.DeleteObject();
		return;  
	}

	dx = (p[4].x-p[0].x) / 4.0;
	dy = (p[4].y-p[0].y) / 4.0;
	dz = (p[4].z-p[0].z) / 4.0;
	for(i=1;i<4;i++) 
	{
		p[i].x = p[0].x + dx*((double) i);
		p[i].y = p[0].y + dy*((double) i);
		p[i].z = p[0].z + dz*((double) i);
	}

	for (i=0;i<4;i++) 
	{
		i_val = CalcBStssValue(BStssVal, i);
		j_val = CalcBStssValue(BStssVal, i+1);
		if(gm->m_AnimEngine.m_bAnimateContour) 
		{
			i_val = m_pContourEngine->GetSubFrameValue(i_val, gm->m_AnimEngine.GetAnimationFactor(TRUE));
			j_val = m_pContourEngine->GetSubFrameValue(j_val, gm->m_AnimEngine.GetAnimationFactor(TRUE));
		}
		
		if(i_val > j_val) 
		{
			rvtx_list.Add(p[i]);
			rval_list.Add(i_val);
			m_pContourEngine->GetRankVertices(p[i], p[i+1], i_val, j_val, rvtx_list, rval_list, NULL);
			rvtx_list.Add(p[i+1]);
			rval_list.Add(j_val);
		}
		else 
		{
			rvtx_list.Add(p[i+1]);
			rval_list.Add(j_val);
			m_pContourEngine->GetRankVertices(p[i+1], p[i], j_val, i_val, rvtx_list, rval_list, NULL);
			rvtx_list.Add(p[i]);
			rval_list.Add(i_val);
		}
		DrawContourLine(pDC, rvtx_list, rval_list,gm->m_DOPT.DR.nElemWire);

		rvtx_list.RemoveAll();
		rval_list.RemoveAll();
	}
}

void	 CStressEngine::DoBStssLineContourReal(CDC *pDC, CList <C3DPoint, C3DPoint> *Vertex,int nPolyNum,
																 T_STSS_D &BStssVal, CArray <double, double> *PosList)
{
	/*
	I_GPSModel  *gm=(I_GPSModel *)m_pGPSModel;
	double			i_val, j_val;
	C3DPoint		i_pos, j_pos;
	POSITION		pos=Vertex->GetHeadPosition();
	CArray <C3DPoint, C3DPoint> rvtx_list;
	CArray <double, double>			rval_list;

	i_pos = Vertex->GetNext(pos);
	j_pos = Vertex->GetNext(pos);
	i_val = CalcBStrsValuePos(BStrsVal, PosList->GetAt(0));
	i_val = max(i_val, m_pContourEngine->m_MinRange);
	i_val = min(i_val, m_pContourEngine->m_MaxRange);
	j_val = CalcBStrsValuePos(BStrsVal, PosList->GetAt(1));
	j_val = max(j_val, m_pContourEngine->m_MinRange);
	j_val = min(j_val, m_pContourEngine->m_MaxRange);

	if(gm->m_AnimEngine.m_bAnimateContour) 
	{
		i_val = m_pContourEngine->GetSubFrameValue(i_val, gm->m_AnimEngine.GetAnimationFactor(TRUE));
		j_val = m_pContourEngine->GetSubFrameValue(j_val, gm->m_AnimEngine.GetAnimationFactor(TRUE));
	}

	if(i_val > j_val) 
	{
		rvtx_list.Add(i_pos);	rval_list.Add(i_val);
		m_pContourEngine->GetRankVertices(i_pos, j_pos, i_val, j_val, rvtx_list, rval_list, NULL);
		rvtx_list.Add(j_pos);	rval_list.Add(j_val);
	}
	else 
	{
		rvtx_list.Add(j_pos);	rval_list.Add(j_val);
		m_pContourEngine->GetRankVertices(j_pos, i_pos, j_val, i_val, rvtx_list, rval_list, NULL);
		rvtx_list.Add(i_pos);	rval_list.Add(i_val);
	}

	// Line이지만 Polygon의 Outline이다.
	// Composite Section의 Concrete부분 
	if(nPolyNum>1 && !gm->m_DOPT.DR.m_bFrameLine)
	{
		C3DPoint pt1,pt2;
		CPen pen,*pOldPen;
		if(gm->m_DOPT.DR.m_bFrameLine) // wire frame
		  pen.CreatePen(PS_SOLID, gm->m_nLineWidth*1.7, gm->m_DOPT.CL.m_InactiveCol);
	  else 
		  pen.CreatePen(PS_SOLID, gm->m_nLineWidth, gm->m_DOPT.CL.m_InactiveCol);
		pOldPen = pDC->SelectObject(&pen);

		for(int i=0; i<rvtx_list.GetSize()-1; i++)
		{
			pt1 = rvtx_list[i];
			pt2 = rvtx_list[i+1];
			if(gm->m_bVirtualMode)
				gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, pt1, pt2);
	    else 
				gm->m_pGPSCtrl->DrawLine3D(pDC, pt1, pt2);
		}
		pDC->SelectObject(pOldPen);
		pen.DeleteObject();
		return;   
	}
	DrawContourLine(pDC, rvtx_list, rval_list,gm->m_DOPT.DR.nElemWire);
	rvtx_list.RemoveAll();
	rval_list.RemoveAll();  
	*/
}

void	 CStressEngine::DoBStssPolyContour(CDC *pDC,CList <C3DPoint, C3DPoint> *Vertex,CArray <BOOL, BOOL> *EdgeFlag,
									              CArray <T_NODE_K, T_NODE_K> *VertexNode,T_ELEM_D &ElemData,T_STSS_D &BStssVal)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	int			i, vertex_num=Vertex->GetCount();
	double		bstrs_val[4], dx1, dy1, dz1, dx2, dy2, dz2;
	BOOL		ef[4];
	POSITION	pos;
	C3DPoint	p[4];
	T_NODE_K  NodeK[4];
	CList <C3DPoint, C3DPoint>	sub_vertex;

	NodeK[0] = VertexNode->GetAt(0);
	NodeK[1] = VertexNode->GetAt(1);
	NodeK[2] = VertexNode->GetAt(2);
	if(vertex_num==4)
		NodeK[3] = VertexNode->GetAt(3);

	// polygon이 i단 쪽에 있을 경우
	if((NodeK[0]==NodeK[1]) &&  (NodeK[0]==NodeK[2]) && (NodeK[0]==ElemData.elnod[0])) 
	{
		for (i=0;i<vertex_num;i++) 
		{
			bstrs_val[i] = CalcBStssValue(BStssVal, 0);
			if(gm->m_AnimEngine.m_bAnimateContour)
				bstrs_val[i] = m_pContourEngine->GetSubFrameValue(bstrs_val[i], gm->m_AnimEngine.GetAnimationFactor(TRUE));
			ef[i] = EdgeFlag->GetAt(i);
		}
		DoSubPolyContour(pDC, bstrs_val, Vertex, ef, TRUE);
	}
	// polygon이 j단 쪽에 있을 경우
	else if((NodeK[0]==NodeK[1]) && (NodeK[0]==NodeK[2]) && (NodeK[0]==ElemData.elnod[1])) 
	{
		for (i=0;i<vertex_num;i++) 
		{
			bstrs_val[i] = CalcBStssValue(BStssVal, 3);
			if(gm->m_AnimEngine.m_bAnimateContour)
				bstrs_val[i] = m_pContourEngine->GetSubFrameValue(bstrs_val[i], gm->m_AnimEngine.GetAnimationFactor(TRUE));
			ef[i] = EdgeFlag->GetAt(i);
		}
		DoSubPolyContour(pDC, bstrs_val, Vertex, ef, TRUE);
	}
	// polygon이 i, j단에 걸쳐 있을 경우
	else 
	{
		if(vertex_num!=4)return; 
		if(NodeK[0]==NodeK[1] && NodeK[2]==NodeK[3] )
		{
	    pos = Vertex->GetHeadPosition();
			for(i=0;i<4;i++) p[i] = Vertex->GetNext(pos);
		}
		else if(NodeK[0]==NodeK[3] && NodeK[1]==NodeK[2] )
		{
			C3DPoint	tp[4];  
			pos = Vertex->GetHeadPosition();
			for(i=0;i<4;i++) tp[i] = Vertex->GetNext(pos);
			p[0] = tp[0];
			p[1] = tp[3];
			p[2] = tp[2];
			p[3] = tp[1];
	  }
		else 
		{
			ASSERT(FALSE); 
			pos = Vertex->GetHeadPosition();
			for(i=0;i<4;i++)p[i] = Vertex->GetNext(pos);
	  }

		dx1 = (p[3].x-p[0].x) / 4.0;
		dy1 = (p[3].y-p[0].y) / 4.0;
		dz1 = (p[3].z-p[0].z) / 4.0;

		dx2 = (p[2].x-p[1].x) / 4.0;
		dy2 = (p[2].y-p[1].y) / 4.0;
		dz2 = (p[2].z-p[1].z) / 4.0;

		p[3] = p[0];
		p[2] = p[1];
		for (i=0;i<4;i++) 
		{
			p[0] = p[3];
			p[1] = p[2];
			p[3].x = p[0].x + dx1;
			p[3].y = p[0].y + dy1;
			p[3].z = p[0].z + dz1;
			p[2].x = p[1].x + dx2;
			p[2].y = p[1].y + dy2;
			p[2].z = p[1].z + dz2;
			sub_vertex.AddTail(p[0]);
			sub_vertex.AddTail(p[1]);
			sub_vertex.AddTail(p[2]);
			sub_vertex.AddTail(p[3]);

			bstrs_val[0] = bstrs_val[1] = CalcBStssValue(BStssVal, i);
			//bstrs_val[2] = bstrs_val[3] = CalcBStrsValue(BStrsVal, i, J_NODE);
			bstrs_val[2] = bstrs_val[3] = CalcBStssValue(BStssVal, i+1);
			if (gm->m_AnimEngine.m_bAnimateContour) 
			{
				bstrs_val[0] = m_pContourEngine->GetSubFrameValue(bstrs_val[0], gm->m_AnimEngine.GetAnimationFactor(TRUE));
				bstrs_val[1] = m_pContourEngine->GetSubFrameValue(bstrs_val[1], gm->m_AnimEngine.GetAnimationFactor(TRUE));
				bstrs_val[2] = m_pContourEngine->GetSubFrameValue(bstrs_val[2], gm->m_AnimEngine.GetAnimationFactor(TRUE));
				bstrs_val[3] = m_pContourEngine->GetSubFrameValue(bstrs_val[3], gm->m_AnimEngine.GetAnimationFactor(TRUE));
			}

			if(i == 0)ef[0] = EdgeFlag->GetAt(0);
			else			ef[0] = FALSE;
			ef[1] = EdgeFlag->GetAt(1);
			if(i == 3)ef[2] = EdgeFlag->GetAt(2);
			else      ef[2] = FALSE;
			ef[3] = EdgeFlag->GetAt(3);
			
			DoSubPolyContour(pDC, bstrs_val, &sub_vertex, ef, TRUE);
			sub_vertex.RemoveAll();
		}
	}
	
	// Fill+Outline의 경우 Contour를 수행하기 전의 Polygon의 Outline을 그림.
	if(gm->m_DOPT.DR.m_RenderFlag == 3 || gm->m_DOPT.DR.m_RenderFlag == 2)
		gm->GPSDrawPolygonEdge(pDC, Vertex, EdgeFlag);   
}

void	 CStressEngine::DoBStssPolyContourReal(CDC *pDC,CList <C3DPoint, C3DPoint> *Vertex,CArray <BOOL, BOOL> *EdgeFlag,
									              T_STSS_D &BStrsVal,CArray <double, double> *PosList)
{
	
}

////////////////////////////////////////////////////////////////////////////////////////
// Initialization and Utility Routines for Plane/Plate Member Stress  /////////////////
////////////////////////////////////////////////////////////////////////////////////////


double CStressEngine::CalcPStrsValue(T_STRP_DG &pstrs_d, int node, int nSurface)
{
	double	len;
	int nOffset = 10 * nSurface;
	switch (m_PStrsComponent) 
	{
	case PSTRS_COMPONENT_SIGXX:
		len = pstrs_d.dblStress[node][0+nOffset];
		break;
	case PSTRS_COMPONENT_SIGYY:
		len = pstrs_d.dblStress[node][1+nOffset];
		break;
	case PSTRS_COMPONENT_SIGZZ:
		len = pstrs_d.dblStress[node][2+nOffset];
		break;
	case PSTRS_COMPONENT_SIGXY:
		len = pstrs_d.dblStress[node][3+nOffset];
		break;
	case PSTRS_COMPONENT_SIGYZ:
		len = pstrs_d.dblStress[node][4+nOffset];
		break;
	case PSTRS_COMPONENT_SIGXZ:
		len = pstrs_d.dblStress[node][5+nOffset];
		break;
	case PSTRS_COMPONENT_SIGMAX:
		len = pstrs_d.dblStress[node][6+nOffset];
		break;
	case PSTRS_COMPONENT_SIGMIN:
		len = pstrs_d.dblStress[node][7+nOffset];
		break;
	case PSTRS_COMPONENT_SIGEFF:
		len = pstrs_d.dblStress[node][9+nOffset];
		break;
	case PSTRS_COMPONENT_MAXSHEAR:
		len = pstrs_d.dblStress[node][40+nSurface] ;
		break;
		///////////////////////////////////////////////////////////////////////////////////////
		// 2008.5.2 Chang-Jin, Jeong TEL : 2124 
		// 기존의 코드에서는 Local에서 T_STRP_DG를 T_STRP_DL의 형태로 만들어 사용했으므로 
		// Index를 T_STRP_DL의 Index로 사용하였으나 주응력계산에서 로컬에 대한 주응력의 각도계산이
		// 누락되어 DG를 DL로 컨버트 후 주응력을 계산한 후 다시 DG에 넣어주므로 Index의 수정이 불가피하게 되었음. 
		// SigX, SigY 는 DG와 DL이 동일하나 Local SinXY는 달라서 Index가 2 --> 3으로 변경
		// Vector 의 경우는 직접 접근하여 계산 하므로 여기서는 수정하지 않고 ASSERT(0); 를 걸어놓음..    
		///////////////////////////////////////////////////////////////////////////////////////
	case PSTRS_COMPONENT_SIGX:
		len = pstrs_d.dblStress[node][0+nOffset];
		break;
	case PSTRS_COMPONENT_SIGY:
		len = pstrs_d.dblStress[node][1+nOffset];
		break;
	case PSTRS_COMPONENT_LOCSIGXY:
		// MNET:XXXX-CJJEONG-20080502
		//len = pstrs_d.dblStress[node][2+nOffset];
		len = pstrs_d.dblStress[node][3+nOffset];
		break;
	case PSTRS_COMPONENT_VECTOR:
		ASSERT(0);
		len = pstrs_d.dblStress[node][3+nOffset];
		break;
	}

	return len;
}

void CStressEngine::SetPStrsComponent(T_STRP_DG &pstrs_d, int node, double strs_val,int nSurface)
{

	int nOffset = 10 * nSurface;
	switch (m_PStrsComponent) {
		case PSTRS_COMPONENT_SIGXX:
			pstrs_d.dblStress[node][0+nOffset] = strs_val;
			break;
		case PSTRS_COMPONENT_SIGYY:
			pstrs_d.dblStress[node][1+nOffset] = strs_val;
			break;
		case PSTRS_COMPONENT_SIGZZ:
			pstrs_d.dblStress[node][2+nOffset] = strs_val;
			break;
		case PSTRS_COMPONENT_SIGXY:
			pstrs_d.dblStress[node][3+nOffset] = strs_val;
			break;
		case PSTRS_COMPONENT_SIGYZ:
			pstrs_d.dblStress[node][4+nOffset] = strs_val;
			break;
		case PSTRS_COMPONENT_SIGXZ:
			pstrs_d.dblStress[node][5+nOffset] = strs_val;
			break;
		case PSTRS_COMPONENT_SIGMAX:
			pstrs_d.dblStress[node][6+nOffset] = strs_val;
			break;
		case PSTRS_COMPONENT_SIGMIN:
			pstrs_d.dblStress[node][7+nOffset] = strs_val;
			break;
		case PSTRS_COMPONENT_SIGEFF:
			pstrs_d.dblStress[node][9+nOffset] = strs_val;
			break;
		case PSTRS_COMPONENT_MAXSHEAR:
			pstrs_d.dblStress[node][40+nSurface] = strs_val; // top,bottom
			break;
		case PSTRS_COMPONENT_SIGX:
			pstrs_d.dblStress[node][0+nOffset] = strs_val;
			break;
		case PSTRS_COMPONENT_SIGY:
			pstrs_d.dblStress[node][1+nOffset] = strs_val;
			break;
		case PSTRS_COMPONENT_LOCSIGXY:
			pstrs_d.dblStress[node][2+nOffset] = strs_val;
			break;
	}
}

double CStressEngine::GetMaxElemPStrs(T_STRP_DG &pstrs_d, int node_num, BOOL bCenter, BOOL bPlate_both, BOOL bAbsMax)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

    double len = 0.0;
    double max = -DBL_MAX;
        
	if(m_PStrsComponent == PSTRS_COMPONENT_VECTOR) 
	{ 
		if(!bCenter)
		{
			for(int i=0; i<5; i++)
			{
				if (max < pstrs_d.dblStress[i][6]) 
				{
					max = pstrs_d.dblStress[i][6];
				}
				if (max < pstrs_d.dblStress[i][7])
				{
					max = pstrs_d.dblStress[i][7];
				}
			}
		}
		else
		{
			if (max < pstrs_d.dblStress[0][6]) 
			{
				max = pstrs_d.dblStress[0][6];
			}
			if (max < pstrs_d.dblStress[0][7])
			{
				max = pstrs_d.dblStress[0][7];
			}
		}
	}
	else 
	{
		if(bCenter)
		{
			len = CalcPStrsValue(pstrs_d, 0, PSTRS_SURFACE_TOP);
			if (max < len) 
			{
				max = len;
			}
		}
		else
		{
			for (int i=0;i<node_num;i++) 
			{
				len = CalcPStrsValue(pstrs_d, i+1, PSTRS_SURFACE_TOP);
				if (max < len) 
				{
					max = len;
				}
			}
		}
	}

	if(bPlate_both) // plate both surface 일 때 bottom 
	{
		if (m_PStrsComponent == PSTRS_COMPONENT_VECTOR)
		{
			if(!bCenter)
			{
				for(int i=0; i<5; i++)
				{
					if (max < pstrs_d.dblStress[i][16])
					{
						max = pstrs_d.dblStress[i][16];
					}
					if (max < pstrs_d.dblStress[i][17])
					{
						max = pstrs_d.dblStress[i][17];
					}
				}
			}
			else
			{
				if (max < pstrs_d.dblStress[0][16])
				{
					max = pstrs_d.dblStress[0][16];
				}
				if (max < pstrs_d.dblStress[0][17])
				{
					max = pstrs_d.dblStress[0][17];
				}
			}
		}
		else
		{
			if(bCenter)
			{
				len = CalcPStrsValue(pstrs_d, 0, PSTRS_SURFACE_BOTTOM);
				if (max < len)
				{
					max = len;
				}
			}
			else
			{
				for (int i=0;i<node_num;i++)
				{
					len = CalcPStrsValue(pstrs_d, i+1, PSTRS_SURFACE_BOTTOM);
					if (max < len)
					{
						max = len;
					}
				}
			}
		}
	}

    if ( bAbsMax )
    {
        // [GEN-4274] ABS max 옵션을 선택한 경우, 절대값이 큰 쪽을 업데이트. (부호는 유지)
        // 위에서 top을 setting 해 두었으므로, 여기서 bottom과 비교하여 업데이트합니다.
        if ( m_PStrsComponent == PSTRS_COMPONENT_VECTOR )
        {
            auto L_Update = [&pstrs_d, &max] (int nIdx)
            {
                if ( max < fabs(pstrs_d.dblStress[nIdx][16]) ) /// 16 : P1b (principal max stress at bottom)
                {
                    max = pstrs_d.dblStress[nIdx][16];
                }
                if ( max < fabs(pstrs_d.dblStress[nIdx][17]) ) /// 17 : P2b (principal min stress at bottom)
                {
                    max = pstrs_d.dblStress[nIdx][17];
                }                
            };

            if ( !bCenter )
            {
                for ( int i=0; i<5; i++ )
                {
                    L_Update(i);
                }
            }
            else
            {
                L_Update(0);
            }
        }
        else
        {
            auto L_Update = [this, &pstrs_d, &max] (int nIdx)
            {
                const double len = CalcPStrsValue(pstrs_d, nIdx, PSTRS_SURFACE_BOTTOM);
                if ( max < fabs(len) )
                {
                    max = len;
                }                
            };

            if ( bCenter )
            {
                L_Update(0);
            }
            else
            {
                for ( int i=0; i<node_num; i++ )
                {
                    L_Update(i+1);
                }
            }
        }
    }

	return max;
}

double CStressEngine::GetMinElemPStrs(T_STRP_DG &pstrs_d, int node_num, BOOL bCenter, BOOL bPlate_both, BOOL bAbsMax)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
    double len = 0.0;
    double min = DBL_MAX;

	if (m_PStrsComponent == PSTRS_COMPONENT_VECTOR)
	{
		if(!bCenter)
		{
			for(int i=0; i<5; i++)
			{
				if (min > pstrs_d.dblStress[i][6])
				{
					min = pstrs_d.dblStress[i][6];
				}
				if (min > pstrs_d.dblStress[i][7])
				{
					min = pstrs_d.dblStress[i][7];
				}
			}
		}
		else
		{
			if (min > pstrs_d.dblStress[0][6])
			{
				min = pstrs_d.dblStress[0][6];
			}
			if (min > pstrs_d.dblStress[0][7])
			{
				min = pstrs_d.dblStress[0][7];
			}
		}
	}
	else
	{
		if(bCenter)
		{
			len = CalcPStrsValue(pstrs_d, 0, PSTRS_SURFACE_TOP);
			if (min > len)
			{
				min = len;
			}
		}
		else
		{
			for (int i=0;i<node_num;i++)
			{
				len = CalcPStrsValue(pstrs_d, i+1, PSTRS_SURFACE_TOP);
				if (min > len)
				{
					min = len;
				}
			}
		}		
	}

	if(bPlate_both) // plate both surface 일 때 bottom 
	{  
		if (m_PStrsComponent == PSTRS_COMPONENT_VECTOR)
		{
			if(!bCenter)
			{
				for(int i=0; i<5; i++)
				{
					if (min > pstrs_d.dblStress[i][16])
					{
						min = pstrs_d.dblStress[i][16];
					}
					if (min > pstrs_d.dblStress[i][17])
					{
						min = pstrs_d.dblStress[i][17];
					}
				}
			}
			else
			{
				if (min > pstrs_d.dblStress[0][16])
				{
					min = pstrs_d.dblStress[0][16];
				}
				if (min > pstrs_d.dblStress[0][17])
				{
					min = pstrs_d.dblStress[0][17];
				}
			}
		}
		else
		{
			if(bCenter)
			{
				len = CalcPStrsValue(pstrs_d, 0, PSTRS_SURFACE_BOTTOM);
				if (min > len)
				{
					min = len;
				}
			}
			else
			{
				for (int i=0;i<node_num;i++)
				{
					len = CalcPStrsValue(pstrs_d, i+1, PSTRS_SURFACE_BOTTOM);
					if (min > len)
					{
						min = len;
					}
				}
			}
		}
	}

    if ( bAbsMax )
    {
        // [GEN-4274] ABS max 옵션을 선택한 경우, 절대값이 큰 쪽을 업데이트. (부호는 유지)
        // 위에서 top을 setting 해 두었으므로, 여기서 bottom과 비교하여 업데이트합니다.
        if ( m_PStrsComponent == PSTRS_COMPONENT_VECTOR )
        {
            auto L_Update =[&pstrs_d, &min](int nIdx)
            {
                if ( min > fabs(pstrs_d.dblStress[nIdx][16]) )
                {
                    min = pstrs_d.dblStress[nIdx][16];
                }
                if ( min > fabs(pstrs_d.dblStress[nIdx][17]) )
                {
                    min = pstrs_d.dblStress[nIdx][17];
                }
            };

            if ( !bCenter )
            {
                for ( int i=0; i<5; i++ )
                {
                    L_Update(i);
                }
            }
            else
            {
                L_Update(0);
            }
        }
        else
        {
            auto L_Update = [this, &pstrs_d, &min] (int nIdx)
            {
                const double len = CalcPStrsValue(pstrs_d, nIdx, PSTRS_SURFACE_BOTTOM);
                if ( min > fabs(len) )
                {
                    min = len;
                }                
            };

            if ( bCenter )
            {
                L_Update(0);
            }
            else
            {
                for ( int i=0; i<node_num; i++ )
                {
                    L_Update(i+1);
                }
            }
        }
    }

	return min;
}

BOOL CStressEngine::IsWithinRangeElemPStrs(T_STRP_DG &StrpD, int node_num, BOOL bPlate_both, BOOL bAbsMax, double& max_strp, double& min_strp)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	double len_max = GetMaxElemPStrs(StrpD, node_num, gm->m_bElemCenter, bPlate_both, bAbsMax);
	double len_min = GetMinElemPStrs(StrpD, node_num, gm->m_bElemCenter, bPlate_both, bAbsMax);

	if (len_min <= min_strp && len_max >= max_strp)
		return TRUE;
	if (len_min >= min_strp && len_min <= max_strp)
		return TRUE;
	if (len_max >= min_strp && len_max <= max_strp)
		return TRUE;

	return FALSE;
}

int CStressEngine::GetSurface( T_ELEM_D &edata, int node_num,CArray <T_NODE_K, T_NODE_K> *Vertex)
{
	if(Vertex->GetAt(1) == Vertex->GetAt(2)) return 2; // Side Surface

	if(edata.elnod[node_num-1] == Vertex->GetAt(node_num-1)) return 0; // top Surface

	// MQC:2783-HSSHIM-20090812
	// mirror로 보여주는 경우의 예외처리 
	if (node_num == 4)
	{
		ASSERT(Vertex->GetSize() == 4);
		// mirror된 경우 top(0->1->2->3)이 1->0->3->2로 바뀌게 된다.
		if (edata.elnod[1] == Vertex->GetAt(0) && 
				edata.elnod[2] == Vertex->GetAt(3) )
			return 0;  // top Surface
	}

	return 1; // bottom surface;
}

BOOL CStressEngine::IsViewPStrsSurfaceAbsMax()
{
    return (m_PStrsSurface == PSTRS_SURFACE_ABSMAX) ? TRUE : FALSE;
}

BOOL CStressEngine::IsViewPStrsSurfacePlateBoth(int nElemType)
{
    if ( m_pDoc->m_pAttrCtrl->IsPlate(nElemType) && m_PStrsSurface == PSTRS_SURFACE_TOPBOT )
    {
        return TRUE;
    }        
    return FALSE;
}

// Plane/Plate Key List 중 현재 Active인 것들의 List를 구한다.
void CStressEngine::GetActivePlaneList()
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	
	int			i, elem_num;
	
	T_ELEM_K	elem_key;
	T_ELEM_D  elem_data;	
	m_PlateKeyList.RemoveAll();
	elem_num = gm->m_EKeyListActive.GetSize(); 
	
	for (i=0;i<elem_num;i++) 
	{
		elem_key = gm->m_EKeyListActive[i];
		
		m_pDoc->m_pAttrCtrl->GetElem(elem_key, elem_data);
		if (m_pDoc->m_pAttrCtrl->IsPlate(elem_data.eltyp)|| m_pDoc->m_pAttrCtrl->IsPlstrs(elem_data.eltyp))
			m_PlateKeyList.Add(elem_key);
	}
}

void CStressEngine::InitVectorAdjustFactor(double dMaxAbsValue)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	C3DPoint	min_pm, max_pm, min_pe, max_pe;
	double		max_lm, max_le, max_l;

	if(m_bLockAdjFactor)
		return;

	if (!m_pDoc->m_pAttrCtrl->ExistElem(m_KeyMaxPStrsElem)) {
		m_VectorAdjustFactor = 1.0;
		return;
	}

	// 전체 모델의 Range와 최대값이 발생한 요소의 Range를 동시에 고려한다.

/*	m_pDoc->calcRangeModel(min_pm.x, min_pm.y, min_pm.z,
								   max_pm.x, max_pm.y, max_pm.z,
								   NULL, NULL, TRUE, NULL, TRUE,
								   gm->m_bFrameThick||gm->m_bPlaneThick);*/
		
	gm->GetRangeModel(&min_pm,&max_pm);
	max_lm = max(max(max_pm.x-min_pm.x, max_pm.y-min_pm.y), max_pm.z-min_pm.z);

	gm->GetRangeElement(m_KeyMaxPStrsElem, &min_pe, &max_pe);
	max_le = max(max(max_pe.x-min_pe.x, max_pe.y-min_pe.y), max_pe.z-min_pe.z);

	if (dMaxAbsValue > -1e-15 && dMaxAbsValue < 1e-15)
		dMaxAbsValue = 1.0f;

	if ((max_le*0.35) < (max_lm/40.0)) {
		max_l = max_lm/40.0;
	}
	else {
		max_l = max_le*0.35;
	}

	m_VectorAdjustFactor = max_l / dMaxAbsValue;
}

// Plane/Plate Stress 데이터를 만든다.
// 전체 Element List에 대해 Loop를 돌며
// 1. DB로 부터 해당 Element의 Stress 데이터를 얻고
// 2. Stress값 및 해당 Element번호 등을 CArray에 저장
// 3. 필요시 각 노드별로 인접한 요소의 Stress의 값의 평균값을 구한다.
// 4. Plane/Plate Key List 중 현재 Active인 것들의 List를 구한다.
// 5. 현재 Active Plane/Plate Key List에 대해 Loop를 돌며 최대/최소값을 갱신한다.
BOOL CStressEngine::MakePStrsDataList()
{
	if (CTestEnvMgr::IsTestEnvST(_LSX(ProfilingSTL), _LSX(yes)))
	{
		M_PROFILE('MakePStrsDataList()');
	}

	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	if(!gm->m_bLoadDataSet)	return FALSE;
	
	int			  i, elem_num, nie;
	double		max_pstrs=-DBL_MAX, min_pstrs=DBL_MAX, len;
	BOOL		  has_content=FALSE;
	T_ELEM_K	elem_key;
	T_ELEM_D	elem_data;
	T_STRP_DG	strp_dg;
	T_STRP_DG	strp_max,strp_min;
	BOOL      bPlate_both;
	BOOL   bWithSign = m_pDoc->m_pPostCtrl->GetSignFlag();


	gm->m_pMyView->BeginWaitCursor();

	m_PlateKeyList.RemoveAll();
	m_mapPlateStrsData.RemoveAll();
	m_mapNodesInElem.RemoveAll();

//   m_mapLRsultMax_Prn.RemoveAll();
//   m_mapLRsultMin_Prn.RemoveAll();
//   m_mapURsultMax_Prn.RemoveAll();
//   m_mapURsultMin_Prn.RemoveAll();
//   m_mapURsultMax_NotPrn.RemoveAll();
//   m_mapURsultMin_NotPrn.RemoveAll();
//   m_mapLRsultMax_Avg.RemoveAll();
//   m_mapLRsultMin_Avg.RemoveAll();
//   m_mapURsultMax_Avg.RemoveAll();
//   m_mapURsultMin_Avg.RemoveAll();

	// Get the Original LoadCombination Data
	T_LCOM_D  LcomOrg=m_pDoc->m_pPostCtrl->GetLoadComb();

	if(m_bAverageNodalActiveOnly || (m_PStrsAve !=PSTRS_VALUE_AVENODAL))
	  elem_num = gm->m_EKeyListActive.GetSize(); // Active된 요소에 대해서만 Average Nodal을 계산.
	else
		elem_num = gm->m_EKeyList.GetSize(); // Average Nodal이 가능하도록...전체 요소를 취한다.

	if(m_PStrsAve == PSTRS_VALUE_AVENODAL) MakeSerialNodeMap();

	m_mapStrpData.clear();
	m_mapAvgStrpData.clear();

	CMap<T_ELEM_K,T_ELEM_K,T_STRP_DG,T_STRP_DG&> mapPstrsDataMax,mapPstrsDataMin;
	mapPstrsDataMax.InitHashTable(HASHSIZEELEM);
	mapPstrsDataMin.InitHashTable(HASHSIZEELEM);
	MakePstrsDataListLcom(LcomOrg,elem_num,1.0,mapPstrsDataMax,mapPstrsDataMin);
        
	for(i=0;i<m_PlateKeyList.GetSize();i++) 
	{
		elem_key = m_PlateKeyList[i];
		mapPstrsDataMax.Lookup(elem_key, strp_max);
		mapPstrsDataMin.Lookup(elem_key, strp_min);
		
		switch (gm->m_LoadMinMaxType) 
		{
		case LOADTYPE_NORMAL:
		case LOADTYPE_MAX:
			m_mapPlateStrsData.SetAt(elem_key,strp_max);
			break;
		case LOADTYPE_MIN:
			m_mapPlateStrsData.SetAt(elem_key,strp_min);
			break;
		case LOADTYPE_ALL:
			if(bWithSign)
				strp_max.AbsMaxwithSign(strp_min);
			else
				strp_max.AbsMax(strp_min);
			m_mapPlateStrsData.SetAt(elem_key,strp_max);
			break;
		}

		// [2008-02-21] KIM, GEUN YOUNG (Tel: 2042, gykim@midasit.com)          // start  
		//mapPstrsDataMax.RemoveKey(elem_key);
		//mapPstrsDataMin.RemoveKey(elem_key);
		////////////////////////////////////////////////////////////////////////// end
	}
	
	// Back to the Original LoadCombination Data
	m_pDoc->m_pPostCtrl->ChangeLoadComb(LcomOrg);

	// AverageNodalData를 얻기 위해 전체 리스트를 대상으로 값을 얻어놓은후 
	// 4. Plane/Plate Key List 중 현재 Active인 것들의 List를 재 구성한다.
	if(!(m_bAverageNodalActiveOnly || (m_PStrsAve !=PSTRS_VALUE_AVENODAL)))
		GetActivePlaneList();

	// 5. 현재 Active Plane/Plate Key List에 대해 Loop를 돌며 최대/최소값을 갱신한다.
	elem_num = m_PlateKeyList.GetSize();
	if(elem_num) has_content = TRUE;
	m_MaxAbsValue = -DBL_MAX;

    const BOOL bAbsMax = IsViewPStrsSurfaceAbsMax();
	
	for(i=0;i<elem_num;i++) 
	{
		m_mapPlateStrsData.Lookup(m_PlateKeyList[i], strp_dg);
		m_mapNodesInElem.Lookup(m_PlateKeyList[i],nie);
		m_pDoc->m_pAttrCtrl->GetElem(m_PlateKeyList[i], elem_data);
		
        bPlate_both = IsViewPStrsSurfacePlateBoth(elem_data.eltyp);
		
		len = GetMaxElemPStrs(strp_dg, nie, gm->m_bElemCenter, bPlate_both, bAbsMax);
		if (m_PStrsComponent != PSTRS_COMPONENT_VECTOR || (m_bVectorPositive && m_bVectorNegative))
		{
			if (len > max_pstrs) 
			{
				max_pstrs = len;
				gm->m_nLgdMaxValKey = m_PlateKeyList[i];
			}
		}
		else if ((m_bVectorPositive && len>0.0) || (m_bVectorNegative && len<0.0))
		{
			if (len > max_pstrs) 
			{
				max_pstrs = len;
				gm->m_nLgdMaxValKey = m_PlateKeyList[i];
			}
			if (len < min_pstrs) 
			{
				min_pstrs = len;
				gm->m_nLgdMinValKey = m_PlateKeyList[i];
			}
		}
		if (fabs(len) > m_MaxAbsValue) 
		{
			m_MaxAbsValue = fabs(len);
			m_KeyMaxPStrsElem = m_PlateKeyList[i];
		}
		
		len = GetMinElemPStrs(strp_dg, nie, gm->m_bElemCenter, bPlate_both, bAbsMax);
		if (m_PStrsComponent != PSTRS_COMPONENT_VECTOR || (m_bVectorPositive && m_bVectorNegative))
		{
			if (len < min_pstrs) 
			{
				min_pstrs = len;
				gm->m_nLgdMinValKey = m_PlateKeyList[i];
			}
		}
		else if ((m_bVectorPositive && len>0.0) || (m_bVectorNegative  && len<0.0))
		{
			if (len > max_pstrs) 
			{
				max_pstrs = len;
				gm->m_nLgdMaxValKey = m_PlateKeyList[i];
			}
			if (len < min_pstrs) 
			{
				min_pstrs = len;
				gm->m_nLgdMinValKey = m_PlateKeyList[i];
			}
		}
		if (fabs(len) > m_MaxAbsValue) 
		{
			m_MaxAbsValue = fabs(len);
			m_KeyMaxPStrsElem = m_PlateKeyList[i];
		}
	}

	if (fabs(max_pstrs+DBL_MAX)<1.e-10) max_pstrs=0.;
	if (fabs(min_pstrs-DBL_MAX)<1.e-10) min_pstrs=0.;
		
	if (!has_content) 
	{
		min_pstrs = max_pstrs = 0.0;
		gm->m_nLgdMaxValKey = 0;
		gm->m_nLgdMinValKey = 0;
	}
	
	m_dMaxValue = max_pstrs;
	m_dMinValue = min_pstrs;

	if (m_pContourEngine == NULL)
		m_pContourEngine = new CContourEngine(m_dMinValue, m_dMaxValue);
	else
		m_pContourEngine->MakeRankMap(m_dMinValue, m_dMaxValue);

	m_mapNodesInElem.RemoveAll();

	if (m_bOnCuttingLine)
			MakeCuttingLineData();

	gm->m_pMyView->EndWaitCursor();

	m_bPStrsDataSet = TRUE;
	return TRUE;
}

BOOL CStressEngine::GetPStrsRangeDataList(double& dMaxRange, double& dMinRange, CArray<UINT,UINT>& aElemKeyList)
{
	aElemKeyList.RemoveAll();

	if (CTestEnvMgr::IsTestEnvST(_LSX(ProfilingSTL), _LSX(yes)))
	{
		M_PROFILE('GetPStrsRangeDataList()');
	}

	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	int			  i, nie;
	T_ELEM_K	elem_key;
	T_ELEM_D	elem_data;
	T_STRP_DG	strp_dg;
	BOOL		bPlate_both;
	BOOL		bWithSign = m_pDoc->m_pPostCtrl->GetSignFlag();
    const BOOL bAbsMax = IsViewPStrsSurfaceAbsMax();

	gm->m_pMyView->BeginWaitCursor();
	
	int elem_num = m_PlateKeyList.GetSize();
	for(i=0;i<elem_num;i++) 
	{
		elem_key = m_PlateKeyList[i];
		if(!m_mapPlateStrsData.Lookup(elem_key, strp_dg)) continue;

		elem_data.Initialize();
		m_pDoc->m_pAttrCtrl->GetElem(elem_key, elem_data);
		nie = m_pDoc->m_pAttrCtrl->GetNumNode(elem_data.eltyp, elem_data.elnod);

        bPlate_both = IsViewPStrsSurfacePlateBoth(elem_data.eltyp);
		
		if(!IsWithinRangeElemPStrs(strp_dg,nie,bPlate_both,bAbsMax,dMaxRange,dMinRange)) continue;

		aElemKeyList.Add(elem_key);
	}

	gm->m_pMyView->EndWaitCursor();
	
	return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////
// Routines for Drawing Plane/Plate Member Stress Contour          ////////////////////
////////////////////////////////////////////////////////////////////////////////////////

void CStressEngine::DrawPStrsContour(CDC *pDC)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	
	int			i, elem_num;
	BOOL		fl_bak=gm->m_DOPT.DR.m_bFrameLine;
	T_ELEM_D	elem_d;
	CPen		elem_pen, *old_pen;
	CArray <int, int>				type_list;
	CArray <GRE_Atom, GRE_Atom&>		atom_list;
	BOOL bEscapePressed = FALSE;
	T_MIRE_K mkey;

	if (!gm->m_bContour && !m_bOnCuttingLine ) { 
		gm->GPSDrawOriginal(pDC);
		return;
	}

	if (m_PStrsComponent == PSTRS_COMPONENT_VECTOR)
		InitVectorAdjustFactor(m_MaxAbsValue);

	if (m_bDeformedShapeContour) {
		if (gm->m_pDeformEngine == NULL) {
			return;
		}
		type_list.Add(gm->m_MinOTID + OBJECT_TYPE_DEFORMED);

		// 변형된 그림에 Undeformed Shape을 같이 그릴 경우.
		if (gm->m_DOPT.DR.m_bDrawInactive && (m_PStrsComponent==PSTRS_COMPONENT_VECTOR)) {
			gm->m_DOPT.DR.m_bFrameLine = TRUE;
			gm->GPSDrawOriginal(pDC, TRUE);
		}
	}
	else {
		type_list.Add(gm->m_MinOTID + OBJECT_TYPE_ORIGINAL);
	}

	//elem_pen.CreatePen(PS_SOLID, gm->m_nLineWidth, m_pContourEngine->m_ElemColor);
	//elem_pen.CreatePen(PS_SOLID, gm->m_LnWd.nElemHddn, m_pContourEngine->m_ElemColor);
	elem_pen.CreatePen(PS_SOLID, gm->m_DOPT.DR.nElemHddn, m_pContourEngine->m_ElemColor);
	old_pen = (CPen *) pDC->SelectObject(&elem_pen);

	gm->m_pGPSCtrl->GetZSortedList(type_list, gm->m_EKeyListVisible_Mirror, atom_list);
	elem_num = atom_list.GetSize();
	
	for (i=0;i<elem_num;i++) 
	{
		//if(gm->m_pGPSCtrl->WatchEscKeyPress()) bEscapePressed = TRUE;
		if(gm->m_pGPSCtrl->WatchEscKeyPress()) return;
		if (gm->m_pGPSCtrl->IsZoomAllState() ||
			gm->m_pGPSCtrl->IsObjectInClientWindow(atom_list[i].m_OType, atom_list[i].m_OKey)) {
			mkey.keymap = atom_list[i].m_OKey;
			m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d);
			if ( (m_pDoc->m_pAttrCtrl->IsPlate(elem_d.eltyp) || m_pDoc->m_pAttrCtrl->IsPlstrs(elem_d.eltyp)) &&
						(gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey)) && !bEscapePressed ) 
			{
				if(m_PStrsComponent == PSTRS_COMPONENT_VECTOR) 
				{

					// KYE-HONG-20020903 : Hidden Option살려달라고 요구 
					// gm->m_bFrameLine = TRUE;		// Vector를 그릴 경우 Hidden을 끈다.

					if (m_bDeformedShapeContour)
						gm->m_pDeformEngine->DrawDeformedElement(pDC, atom_list[i].m_OKey);
					else
						gm->GPSDrawElement(pDC, atom_list[i].m_OKey);
					DoPStrsElementVector(pDC, atom_list[i].m_OKey);
				}
				else 
				{
					gm->m_DOPT.DR.m_bFrameLine = fl_bak;
					DoPStrsElementContour(pDC, atom_list[i].m_OKey);
				}
				// Plane Stress요소일때만 
				//if(m_pDoc->m_pAttrCtrl->IsPlstrs(elem_d.eltyp))
				if(m_bHingeStatus)DrawNLHngeStatus(pDC,atom_list[i].m_OKey);        
			}
			else 
			{
				// KYE-HONG-20020903 : Hidden Option살려달라고 요구 
				//if (m_PStrsComponent == PSTRS_COMPONENT_VECTOR) gm->m_bFrameLine = TRUE;		// Vector를 그릴 경우 Hidden을 끈다.
				//else gm->m_bFrameLine = fl_bak;
				if(m_bDeformedShapeContour) gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, atom_list[i].m_OKey);
				else					              gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
			}
		}
	}

		 gm->m_pGPSCtrl->XGL_Begin_CuttingPLDiagram();
	if (m_bOnCuttingLine)
		DrawCuttingLineDiagrams(pDC);
			 gm->m_pGPSCtrl->XGL_End_CuttingPLDiagram();
	
	gm->m_DOPT.DR.m_bFrameLine = fl_bak;

	// 변형된 그림에 Undeformed Shape을 같이 그릴 경우.
	if (m_bDeformedShapeContour && gm->m_DOPT.DR.m_bDrawInactive && (m_PStrsComponent!=PSTRS_COMPONENT_VECTOR)  && !bEscapePressed) {
		int	rf_bak=gm->m_DOPT.DR.m_RenderFlag;
		gm->m_DOPT.DR.m_RenderFlag = 2;
		gm->GPSDrawOriginal(pDC, TRUE);
		gm->m_DOPT.DR.m_RenderFlag = rf_bak;
	}

	pDC->SelectObject(old_pen);
	elem_pen.DeleteObject();


	//----------------------------------------------------------------------
	// UCS Icon Drawing
	//----------------------------------------------------------------------
	if( m_PStrsVal == PSTRS_VALUE_GLOBAL&& gm->m_bVirtualMode && m_bPrintUCSAxis) 
	{
		double UCS_vector[3][3];
		GetUCSVector(m_NUCS,UCS_vector);
		DrawUCSPlaneIcon(pDC,UCS_vector);
	}
}

// PMS:4093-HSSHIM-20091014
// DC에 그려지는 Label만 따로 그려주기 위해서 DrawPStrsContour() 함수를 분리하였음.
void CStressEngine::DrawPStrsContour_LabelOnly(CDC *pDC)
{
	if (!m_bHingeStatusText) return;

	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	
	int			i, elem_num;
	BOOL		fl_bak=gm->m_DOPT.DR.m_bFrameLine;
	T_ELEM_D	elem_d;
	CPen		elem_pen, *old_pen;
	CArray <int, int>				type_list;
	CArray <GRE_Atom, GRE_Atom&>		atom_list;
	BOOL bEscapePressed = FALSE;
	T_MIRE_K mkey;

	if (!gm->m_bContour && !m_bOnCuttingLine ) { return; }
	if (m_bDeformedShapeContour) { if (gm->m_pDeformEngine == NULL) return; }

	type_list.Add(gm->m_MinOTID + OBJECT_TYPE_ORIGINAL);

	elem_pen.CreatePen(PS_SOLID, gm->m_DOPT.DR.nElemHddn, m_pContourEngine->m_ElemColor);
	old_pen = (CPen *) pDC->SelectObject(&elem_pen);

	gm->m_pGPSCtrl->GetZSortedList(type_list, gm->m_EKeyListVisible_Mirror, atom_list);
	elem_num = atom_list.GetSize();
	
	for (i=0;i<elem_num;i++) 
	{
		if(gm->m_pGPSCtrl->WatchEscKeyPress()) return;

		if (gm->m_pGPSCtrl->IsZoomAllState() ||
			  gm->m_pGPSCtrl->IsObjectInClientWindow(atom_list[i].m_OType, atom_list[i].m_OKey)) 
		{
			mkey.keymap = atom_list[i].m_OKey;
			m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d);

			if ( (m_pDoc->m_pAttrCtrl->IsPlate(elem_d.eltyp) || m_pDoc->m_pAttrCtrl->IsPlstrs(elem_d.eltyp)) &&
						(gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey)) && !bEscapePressed ) 
			{
				// Plane Stress요소일때만 
				//if(m_pDoc->m_pAttrCtrl->IsPlstrs(elem_d.eltyp))
				if(m_bHingeStatus && m_bHingeStatusText) DrawNLHngeStatus_Text(pDC,atom_list[i].m_OKey);        
			}
		}
	}

	pDC->SelectObject(old_pen);
	elem_pen.DeleteObject();
}


// 주어진 요소의 Plane/Plate Stress Contour를 그린다.
// 1. 요소의 형상정보를 얻는다.
// 2. 요소의 형상을 이루는 polygon들의 각 Vertex에 해당 Stress값을 부여한다.
// 3. polygon별로 Contour를 실시하여 Stress값에 따라 나뉘어진 sub-polygon list를 얻는다.
// 4. sub-polygon들을 그린다.
void CStressEngine::DoPStrsElementContour(CDC *pDC, unsigned int ekey)
{
	T_MIRE_K mkey;
	mkey.keymap = ekey;

	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;
	
	int				i, j, poly_num, vtx_num, node_in_elem;
	double			pstrs_val[4];
	BOOL			ef[4];
	T_ELEM_D		elem_d;
	T_STRP_DG		pstrs_d;

	int nSurface;
	int nTopBot;// 0: Top, 1: Bottom

	CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray <CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					edge_list;
	CArray <CArray <T_NODE_K, T_NODE_K> *, CArray <T_NODE_K, T_NODE_K> *>	VertexNode;

	if ((gm->m_pDeformEngine==NULL) ||
		(m_pContourEngine==NULL) ||
		(!GetPlaneStress(mkey.key.elem_k, pstrs_d))) {
		return;
	}

	// 1. 요소의 형상정보를 얻는다.
	m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d);
	node_in_elem = m_pDoc->m_pAttrCtrl->GetNumNode(elem_d.eltyp, elem_d.elnod);
	BOOL bPlaneThickBak= gm->m_DOPT.DR.m_bPlaneThick;
	BOOL bFrameLineBak= gm->m_DOPT.DR.m_bFrameLine;
	if(m_PStrsSurface == PSTRS_SURFACE_TOPBOT) 
	{
		gm->m_DOPT.DR.m_bFrameLine = FALSE;
		gm->m_DOPT.DR.m_bPlaneThick = TRUE;
	}
	
	if (m_bDeformedShapeContour) {
		gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list, &VertexNode);
	}
	else {
		gm->GetShapeElement(ekey, polygon_list, &edge_list, NULL, &VertexNode);
	}

	gm->GPS_XGL_Begin_Elem(mkey.key.elem_k,elem_d);

	poly_num = polygon_list.GetSize();
	for (i=0;i<poly_num;i++) 
	{
		vtx_num = polygon_list[i]->GetCount();
		if(vtx_num == 2) {
			continue;
		}

		if(poly_num>1 && !gm->m_DOPT.DR.m_bFrameLine &&  gm->m_DOPT.DR.m_bPlaneThick && !gm->IsVisibleFace(polygon_list[i],vtx_num))
			 continue;

		
		// Fill+Outline의 경우 Contour를 수행하기 전의 Polygon의 Outline을 그림.// Line Only 일경우는 먼저그린다.
		if ((gm->m_DOPT.DR.m_RenderFlag == 3 || gm->m_DOPT.DR.m_RenderFlag == 2) && m_pContourEngine->m_nContourFill ==1)
		{
			//gm->DrawPolygon3DFill(pDC, *(polygon_list[i]), *(edge_list[i]), gm->m_ClientBackColor);
			gm->DrawPolygon3DFill(pDC, *(polygon_list[i]), *(edge_list[i]), gm->m_DOPT.CL.m_ClientBackColor);
			gm->GPSDrawPolygonEdge(pDC, polygon_list[i], edge_list[i]);
		}

		if(m_bContour)
		{
			// 2. 요소의 형상을 이루는 polygon들의 각 Vertex에 해당 Stress값을 부여한다.
			if ( m_PStrsSurface == PSTRS_SURFACE_TOPBOT)
					nSurface = GetSurface(elem_d, node_in_elem,VertexNode[i]); // 0: Top Surface , 1:Bot Surface, 2: Side Surface

			for (j=0;j<vtx_num;j++) 
			{
				if(m_PStrsSurface == PSTRS_SURFACE_TOPBOT)
					nTopBot = GetTopBot(nSurface,j); // 0: Top Vertex, 1: Bot Vertex;
				else 
					nTopBot = 0;

				if(gm->m_bElemCenter)
				{
					if (m_PStrsSurface == PSTRS_SURFACE_ABSMAX)
					{
						pstrs_val[j] = GetMaxElemPStrs(pstrs_d, node_in_elem, TRUE, 0, TRUE);
					}
					else
					{
						pstrs_val[j] = CalcPStrsValue(pstrs_d, 0, nTopBot);
					}
				}
				else
				{
					pstrs_val[j] = CalcPStrsValue(pstrs_d, GetNodeOrder(VertexNode[i]->GetAt(j), elem_d, node_in_elem)+1,nTopBot);	
				}
				
				if (gm->m_AnimEngine.m_bAnimateContour)
					pstrs_val[j] = m_pContourEngine->GetSubFrameValue(pstrs_val[j], gm->m_AnimEngine.GetAnimationFactor(TRUE));
				ef[j] = edge_list[i]->GetAt(j);
			}

			// 3. polygon별로 Contour를 실시하여 Stress값에 따라 나뉘어진 sub-polygon list를 얻는다.
			// 4. sub-polygon들을 그린다.
			DoSubPolyContour(pDC, pstrs_val, polygon_list[i], ef, FALSE);
		}
			
		// Fill+Outline의 경우 Contour를 수행하기 전의 Polygon의 Outline을 그림. Fill Type
		if ((gm->m_DOPT.DR.m_RenderFlag == 3 || gm->m_DOPT.DR.m_RenderFlag == 2) && m_pContourEngine->m_nContourFill ==0)
			gm->GPSDrawPolygonEdge(pDC, polygon_list[i], edge_list[i]);
			
		
	}
	gm->GPS_XGL_End_Elem();

	gm->m_DOPT.DR.m_bPlaneThick = bPlaneThickBak;
	gm->m_DOPT.DR.m_bFrameLine = bFrameLineBak;

	FreeMemoryPolyList(&polygon_list,&edge_list,&VertexNode); 
	/*
	for (i=0;i<poly_num;i++) {
		polygon_list[i]->RemoveAll();
		delete polygon_list[i];
		edge_list[i]->RemoveAll();
		delete edge_list[i];
		VertexNode[i]->RemoveAll();
		delete VertexNode[i];
	}
	polygon_list.RemoveAll();
	edge_list.RemoveAll();
	VertexNode.RemoveAll();
	*/
}




void CStressEngine::DoPStrsElementVector(CDC *pDC, unsigned int ekey)
{
	T_MIRE_K mkey;
	mkey.keymap = ekey;

	I_GPSModel *gm=(I_GPSModel *) m_pGPSModel;
	CClientDC	 dc(gm->m_pMyView);
	int			 i;
	double		 local_vec[3][3], node_p[4][3];
	T_STRP_DG	 pstrs_d;
	T_ELEM_D	 edata;
	CPen		 p1_pen, p2_pen, *old_pen,*old_pen2;
	C3DPoint	 pnt_p1, arr_p11, arr_p12, pnt_p2, arr_p21, arr_p22, pnt_c;

	if((gm->m_pDeformEngine==NULL) ||
		 (m_pContourEngine==NULL) || (!GetPlaneStress(mkey.key.elem_k, pstrs_d)))
	{
		return;
	}

	if(!m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, edata)) { ASSERT(0); return; }
	int node_num = m_pDoc->m_pAttrCtrl->GetNumNode(edata.eltyp, edata.elnod);

	BOOL bPlate_both = IsViewPStrsSurfacePlateBoth(edata.eltyp);	
	BOOL bCenter = (gm->m_nValOpt == 1);
    const BOOL bAbsMax = IsViewPStrsSurfaceAbsMax();

	double dP1   = GetMaxElemPStrs(pstrs_d, node_num, bCenter, bPlate_both, bAbsMax); // 최대주응력
	double dP2   = GetMinElemPStrs(pstrs_d, node_num, bCenter, bPlate_both, bAbsMax); // 최소주응력
	double angle = pstrs_d.dblStress[0][8]; // 주응력 방향

	gm->m_pGPSCtrl->XGL_Begin_Diagram(ekey,FALSE); // 20060224 Changkeun

	int nThkLine = GetVectorLineWidth();

	if (gm->m_bGradient)
	{
		p1_pen.CreatePen(PS_SOLID, nThkLine, m_pContourEngine->GetValueColorGrad(dP1));
		p2_pen.CreatePen(PS_SOLID, nThkLine, m_pContourEngine->GetValueColorGrad(dP2));
	}
	else
	{
		p1_pen.CreatePen(PS_SOLID, nThkLine, m_pContourEngine->GetValueColor(dP1));
		p2_pen.CreatePen(PS_SOLID, nThkLine, m_pContourEngine->GetValueColor(dP2));
	}

	if (m_bDeformedShapeContour)
	{
		for (i=0;i<node_num;i++)
		{
			gm->m_pDeformEngine->GetDisplacedPoint(edata.elnod[i], node_p[i]);
		}
		m_pDoc->calcPlaneLocalVector(node_num, node_p, edata.angle, local_vec);
		for (i=0;i<node_num-1;i++)
		{
			node_p[node_num-1][0] += node_p[i][0];
			node_p[node_num-1][1] += node_p[i][1];
			node_p[node_num-1][2] += node_p[i][2];
		}
		pnt_c.x = node_p[node_num-1][0] / ((double) node_num);
		pnt_c.y = node_p[node_num-1][1] / ((double) node_num);
		pnt_c.z = node_p[node_num-1][2] / ((double) node_num);
	}
	else
	{
		m_pDoc->calcPlaneLocalVector(mkey.key.elem_k, local_vec);
		m_pDoc->calcCenterElem(mkey.key.elem_k, pnt_c.x, pnt_c.y, pnt_c.z);
	}

	CMathFunc::mathRotate(angle,
						  local_vec[2][0], local_vec[2][1], local_vec[2][2],
						  local_vec[0][0], local_vec[0][1], local_vec[0][2]);
	CMathFunc::mathRotate(angle,
						  local_vec[2][0], local_vec[2][1], local_vec[2][2],
						  local_vec[1][0], local_vec[1][1], local_vec[1][2]);

	// Point 1
	CUtilFuncs::GetVectorDirectionPoint(local_vec[0], fabs(dP1),
										m_VectorAdjustFactor*m_VectorScaleFactor, pnt_c, pnt_p1);
	// Arrow Point 11
	CUtilFuncs::GetVectorDirectionPoint(local_vec[0], -dP1*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, pnt_p1, arr_p11);
	CUtilFuncs::GetVectorDirectionPoint(local_vec[1], fabs(dP1)*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, arr_p11, arr_p11);
	// Arrow Point 12
	CUtilFuncs::GetVectorDirectionPoint(local_vec[0], -dP1*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, pnt_p1, arr_p12);
	CUtilFuncs::GetVectorDirectionPoint(local_vec[1], -fabs(dP1)*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, arr_p12, arr_p12);

	// Point 2
	CUtilFuncs::GetVectorDirectionPoint(local_vec[1], fabs(dP2),
										m_VectorAdjustFactor*m_VectorScaleFactor, pnt_c, pnt_p2);
	// Arrow Point 21
	CUtilFuncs::GetVectorDirectionPoint(local_vec[1], -dP2*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, pnt_p2, arr_p21);
	CUtilFuncs::GetVectorDirectionPoint(local_vec[0], fabs(dP2)*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, arr_p21, arr_p21);
	// Arrow Point 22
	CUtilFuncs::GetVectorDirectionPoint(local_vec[1], -dP2*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, pnt_p2, arr_p22);
	CUtilFuncs::GetVectorDirectionPoint(local_vec[0], -fabs(dP2)*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, arr_p22, arr_p22);

	// Arrow of P1
	old_pen = (CPen *) pDC->SelectObject(&p1_pen);
	if(!gm->m_bVirtualMode&& !gm->m_bAnimation)
		old_pen2 = (CPen *) dc.SelectObject(&p1_pen);

	if (dP1 < 1.e-10)
	{
		if (gm->m_pStressEngine->m_bVectorNegative)
	    DrawVectorArrow(pDC,&dc,pnt_c,pnt_p1,arr_p11,arr_p12,mkey.key.mirror_k);
	}
	else
	{
		if (gm->m_pStressEngine->m_bVectorPositive)
			DrawVectorArrow(pDC,&dc,pnt_c,pnt_p1,arr_p11,arr_p12,mkey.key.mirror_k);
	}
	

	// Arrow of P2
	pDC->SelectObject(&p2_pen);
	if(!gm->m_bVirtualMode&& !gm->m_bAnimation)
		dc.SelectObject(&p2_pen);

	if (dP2 < 1.e-10)
	{
		if (gm->m_pStressEngine->m_bVectorNegative)
		  DrawVectorArrow(pDC,&dc,pnt_c,pnt_p2,arr_p21,arr_p22,mkey.key.mirror_k);
	}
	else
	{
		if (gm->m_pStressEngine->m_bVectorPositive)
			DrawVectorArrow(pDC,&dc,pnt_c,pnt_p2,arr_p21,arr_p22,mkey.key.mirror_k);
	}
	
	pDC->SelectObject(old_pen);
	if(!gm->m_bVirtualMode&& !gm->m_bAnimation)
		dc.SelectObject(old_pen2);
	p1_pen.DeleteObject();
	p2_pen.DeleteObject();
	
	gm->m_pGPSCtrl->XGL_End_Elem(FALSE);
}

#if defined(__OLD_OUTPUT_VALUE)
void CStressEngine::OutputPStrsNumbers(CDC* pDC)
{
	I_GPSModel* gm = (I_GPSModel*)m_pGPSModel;

	int				i, j, elem_num, node_in_elem, v_num;
	T_ELEM_K		ekey;
	T_ELEM_D		edata;
	T_STRP_DG		pstrs_d;
	C3DPoint		node[4], DrawPoint;
	CPoint			text_p;
	TCHAR			fmt_str[10], text_str[512];
	CFont			ft, * old_ft;
	double MaxStr, MinStr;

	BOOL			fl_bak;
	POSITION		pos;
	CArray <CList <C3DPoint, C3DPoint>*, CList <C3DPoint, C3DPoint>*>		polygon_list;
	CArray <CArray <BOOL, BOOL>*, CArray <BOOL, BOOL>*>					edge_list;

	if (!m_bPStrsDataSet)
		return;

	if (gm->m_DOPT.TX.m_bNumberOpaque)
		pDC->SetBkMode(OPAQUE);
	else
		pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
	pDC->SetBkColor(gm->m_DOPT.TX.m_NumberBackCol);
	pDC->SetTextAlign(TA_CENTER | TA_BOTTOM);

	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T("%s%de"), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T("%s%df"), _T("%."), gm->m_NumberDecimalPoint);

	fl_bak = gm->m_DOPT.DR.m_bFrameLine;
	gm->m_DOPT.DR.m_bFrameLine = TRUE;

	if (gm->m_DOPT.TX.m_bNumberSelOnly) {
	}
	else {

		gm->SetNumberFontOrientation(0);
		ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
		old_ft = (CFont*)pDC->SelectObject(&ft);

		//elem_num = gm->m_EKeyListActive.GetSize();
		BOOL bGrpFltMode = gm->m_pGPSCtrl->IsGroupFilterMode();
		if (!bGrpFltMode)elem_num = gm->m_EKeyListActive.GetSize();
		else            elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize();

		const BOOL bAbsMax = IsViewPStrsSurfaceAbsMax();

		for (i = 0; i < elem_num; i++)
		{
			//ekey = gm->m_EKeyListActive[i];
			if (!bGrpFltMode)ekey = gm->m_EKeyListActive[i];
			else            ekey = gm->m_pDispFilter->m_aGrpEKey[i];

			if (!gm->m_pGPSCtrl->IsActiveElem(ekey))
				continue;

			m_pDoc->m_pAttrCtrl->GetElem(ekey, edata);

			if (!(m_pDoc->m_pAttrCtrl->IsPlate(edata.eltyp) || m_pDoc->m_pAttrCtrl->IsPlstrs(edata.eltyp)))
				continue;
			node_in_elem = m_pDoc->m_pAttrCtrl->GetNumNode(edata.eltyp, edata.elnod);

			if (m_bDeformedShapeContour) {
				gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list);
			}
			else {
				gm->GetShapeElement(ekey, polygon_list, &edge_list);
			}

			v_num = polygon_list[0]->GetCount();
			pos = polygon_list[0]->GetHeadPosition();
			for (j = 0; j < v_num; j++)
				node[j] = polygon_list[0]->GetNext(pos);


			GetPlaneStress(ekey, pstrs_d);
			for (j = 0; j < v_num - 1; j++) {
				node[v_num - 1].x += node[j].x;
				node[v_num - 1].y += node[j].y;
				node[v_num - 1].z += node[j].z;
			}

			BOOL bPlate_both = IsViewPStrsSurfacePlateBoth(edata.eltyp);

			DrawPoint.x = (node[v_num - 1].x / ((double)v_num));
			DrawPoint.y = (node[v_num - 1].y / ((double)v_num));
			DrawPoint.z = (node[v_num - 1].z / ((double)v_num));

			if (gm->m_nValOpt == 1)
			{
				if (m_PStrsComponent == PSTRS_COMPONENT_VECTOR)
				{
					MaxStr = GetMaxElemPStrs(pstrs_d, node_in_elem, TRUE, bPlate_both, bAbsMax);
					MinStr = GetMinElemPStrs(pstrs_d, node_in_elem, TRUE, bPlate_both, bAbsMax);
				}
				else
				{
					if (m_PStrsSurface == PSTRS_SURFACE_TOPBOT)
					{
						double dBotCVal, dTopCVal;
						dTopCVal = CalcPStrsValue(pstrs_d, 0, 0);
						dBotCVal = CalcPStrsValue(pstrs_d, 0, 1);
						MaxStr = MinStr = (fabs(dBotCVal) > fabs(dTopCVal)) ? dBotCVal : dTopCVal;
					}
					else
					{
						MaxStr = MinStr = CalcPStrsValue(pstrs_d, 0, 0);
					}
				}
			}
			else
			{
				MaxStr = GetMaxElemPStrs(pstrs_d, node_in_elem, FALSE, bPlate_both, bAbsMax);
				MinStr = GetMinElemPStrs(pstrs_d, node_in_elem, FALSE, bPlate_both, bAbsMax);
			}

			double dAbsMaxStr = 0.;
			if ((m_PStrsComponent != PSTRS_COMPONENT_VECTOR) || (m_bVectorPositive && m_bVectorNegative))
				dAbsMaxStr = (fabs(MaxStr) > fabs(MinStr)) ? MaxStr : MinStr;
			else if (m_bVectorPositive && MaxStr > 0.)
				dAbsMaxStr = fabs(MaxStr);
			else if (m_bVectorNegative && MinStr < 0.)
				dAbsMaxStr = fabs(MinStr);

			/////////////////////////////////////////////////////////////////////////////////////////////
			if (gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
			{
				double dLimit = (m_dMaxValue - m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;
				// MNET:XXXX-CJJEONG-20080508
				if ((m_PStrsComponent != PSTRS_COMPONENT_VECTOR) || (m_bVectorPositive && m_bVectorNegative))
				{
					switch (gm->m_DOPT.TX.m_nOutputMinMaxType)
					{
					case 0: // Min & Max
						if ((m_dMaxValue - MaxStr) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, MaxStr);
						else if ((MinStr - m_dMinValue) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, MinStr);
						break;
					case 1: // Abs Max
						if (fabs(m_dMaxValue) >= fabs(m_dMinValue))
						{
							if (fabs(m_dMaxValue) - fabs(dAbsMaxStr) <= dLimit)
								DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, dAbsMaxStr);
						}
						else
						{
							if (fabs(m_dMinValue) - fabs(dAbsMaxStr) <= dLimit)
								DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, dAbsMaxStr);
						}
						break;
					case 2: // Max
						if ((m_dMaxValue - MaxStr) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, MaxStr);
						break;
					case 3: // Min
						if ((MinStr - m_dMinValue) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, MinStr);
						break;
					}
				}
				else if (m_bVectorPositive && m_dMaxValue > 0.)
				{
					switch (gm->m_DOPT.TX.m_nOutputMinMaxType)
					{
					case 0: // Min & Max
						if ((m_dMaxValue - MaxStr) <= dLimit && MaxStr > 0.)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, MaxStr);
						else if ((MaxStr - m_dMinValue) <= dLimit && MaxStr > 0.)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, MaxStr);
						break;
					case 1: // Abs Max
						if (fabs(m_dMaxValue) - fabs(dAbsMaxStr) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, dAbsMaxStr);
						break;
					case 2: // Max
						if ((m_dMaxValue - MaxStr) <= dLimit && MaxStr > 0.)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, MaxStr);
						break;
					case 3: // Min
						if ((MaxStr - m_dMinValue) <= dLimit && MaxStr > 0.)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, MaxStr);
						break;
					}
				}
				else if (m_bVectorNegative && m_dMinValue < 0.)
				{
					switch (gm->m_DOPT.TX.m_nOutputMinMaxType)
					{
					case 0: // Min & Max
						if ((m_dMaxValue - MinStr) <= dLimit && MinStr < 0.)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, MinStr);
						else if ((MinStr - m_dMinValue) <= dLimit && MinStr < 0.)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, MinStr);
						break;
					case 1: // Abs Max
						if (fabs(m_dMinValue) - fabs(dAbsMaxStr) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, dAbsMaxStr);
						break;
					case 2: // Max
						if ((m_dMaxValue - MinStr) <= dLimit && MinStr < 0.)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, MinStr);
						break;
					case 3: // Min
						if ((MinStr - m_dMinValue) <= dLimit && MinStr < 0.)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, MinStr);
						break;
					}
				}
				//////////////////////////////////////////////////////////////////////////////////////
			}
			else
			{
				if (gm->m_bVirtualMode)
					text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(DrawPoint);
				else
					text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(DrawPoint);

				// MNET:XXXX-CJJEONG-20080507
				BOOL  bText = TRUE;
				if (m_bVectorPositive && m_bVectorNegative)
				{
					if (fabs(MaxStr) > fabs(MinStr))
						_stprintf(text_str, fmt_str, MaxStr);
					else
						_stprintf(text_str, fmt_str, MinStr);
				}
				else if (m_bVectorPositive && MaxStr > 0.)
					_stprintf(text_str, fmt_str, MaxStr);
				else if (m_bVectorNegative && MinStr < 0.)
					_stprintf(text_str, fmt_str, MinStr);
				else bText = FALSE;

				if (text_p.x >= 0 && text_p.y >= 0 && bText)
					pDC->TextOut(text_p.x, text_p.y + 10, text_str);
			}

			for (j = 0; j < polygon_list.GetSize(); j++) {
				polygon_list[j]->RemoveAll();
				delete polygon_list[j];
				edge_list[j]->RemoveAll();
				delete edge_list[j];
			}
			polygon_list.RemoveAll();
			edge_list.RemoveAll();
		}
		pDC->SelectObject(old_ft);
		ft.DeleteObject();
	}

	gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}
#else
void CStressEngine::OutputPStrsNumbers(CDC *pDC)
{
	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;
	
	int				i, j, elem_num, node_in_elem, v_num;
	T_ELEM_K		ekey;
	T_ELEM_D		edata;
	T_STRP_DG		pstrs_d;
	C3DPoint		node[4],DrawPoint;
	CPoint			text_p;
	TCHAR			fmt_str[10], text_str[512];
	CFont			ft, *old_ft;
	double MaxStr,MinStr;

	BOOL			fl_bak;
	POSITION		pos;
	CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray <CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					edge_list;

	if (!m_bPStrsDataSet)
		return;

	GPostTextOut TextOutModel;
	TextOutModel.SetDC(pDC);
	TextOutModel.StartPStressVal();
	TextOutModel.SettingPStress(gm);

	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T("%s%de"), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T("%s%df"), _T("%."), gm->m_NumberDecimalPoint);

	fl_bak = gm->m_DOPT.DR.m_bFrameLine;
	gm->m_DOPT.DR.m_bFrameLine = TRUE;

	if (gm->m_DOPT.TX.m_bNumberSelOnly) {
	}
	else {

		TextOutModel.Font4PStress(gm, 0);

		BOOL bGrpFltMode=gm->m_pGPSCtrl->IsGroupFilterMode();
		if(!bGrpFltMode)elem_num = gm->m_EKeyListActive.GetSize();
		else            elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize(); 

        const BOOL bAbsMax = IsViewPStrsSurfaceAbsMax();

		for (i=0;i<elem_num;i++) 
		{
			//ekey = gm->m_EKeyListActive[i];
			if(!bGrpFltMode)ekey = gm->m_EKeyListActive[i];
			else            ekey = gm->m_pDispFilter->m_aGrpEKey[i]; 

			if(!gm->m_pGPSCtrl->IsActiveElem(ekey))
				continue;

			m_pDoc->m_pAttrCtrl->GetElem(ekey, edata);

			if (!(m_pDoc->m_pAttrCtrl->IsPlate(edata.eltyp)||m_pDoc->m_pAttrCtrl->IsPlstrs(edata.eltyp)))
				continue;
			node_in_elem = m_pDoc->m_pAttrCtrl->GetNumNode(edata.eltyp, edata.elnod);

			if (m_bDeformedShapeContour) {
				gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list);
			}
			else {
				gm->GetShapeElement(ekey, polygon_list, &edge_list);
			}

			v_num = polygon_list[0]->GetCount();
			pos = polygon_list[0]->GetHeadPosition();
			for (j=0;j<v_num;j++) 
				node[j] = polygon_list[0]->GetNext(pos);
			

			GetPlaneStress(ekey, pstrs_d);
			for (j=0;j<v_num-1;j++) {
				node[v_num-1].x += node[j].x;
				node[v_num-1].y += node[j].y;
				node[v_num-1].z += node[j].z;
			}

            BOOL bPlate_both = IsViewPStrsSurfacePlateBoth(edata.eltyp);
			
			DrawPoint.x =  (node[v_num-1].x/((double) v_num));
			DrawPoint.y =  (node[v_num-1].y/((double) v_num));
			DrawPoint.z =  (node[v_num-1].z/((double) v_num));

			if(gm->m_nValOpt == 1)
			{
				if(m_PStrsComponent == PSTRS_COMPONENT_VECTOR) 
				{
                    MaxStr = GetMaxElemPStrs(pstrs_d, node_in_elem, TRUE, bPlate_both, bAbsMax);
                    MinStr = GetMinElemPStrs(pstrs_d, node_in_elem, TRUE, bPlate_both, bAbsMax);
				}
				else
				{
					if(m_PStrsSurface == PSTRS_SURFACE_TOPBOT )
					{
						double dBotCVal,dTopCVal;
						dTopCVal = CalcPStrsValue(pstrs_d,0,0);
						dBotCVal = CalcPStrsValue(pstrs_d,0,1);
						MaxStr = MinStr = (fabs(dBotCVal)>fabs(dTopCVal)) ? dBotCVal : dTopCVal;
					}
					else if (m_PStrsSurface == PSTRS_SURFACE_ABSMAX)
					{
						MaxStr = MinStr = GetMaxElemPStrs(pstrs_d, node_in_elem, TRUE, 0, bAbsMax);
					}
					else
					{
						MaxStr = MinStr = CalcPStrsValue(pstrs_d,0,0);
					}
				}
			}
			else
			{
				MaxStr = GetMaxElemPStrs(pstrs_d, node_in_elem, FALSE, bPlate_both, bAbsMax);
				MinStr = GetMinElemPStrs(pstrs_d, node_in_elem, FALSE, bPlate_both, bAbsMax);
			}
			
			double dAbsMaxStr = 0.;
			if ((m_PStrsComponent!=PSTRS_COMPONENT_VECTOR) || (m_bVectorPositive && m_bVectorNegative))
				dAbsMaxStr = (fabs(MaxStr) > fabs(MinStr))? MaxStr:MinStr;
			else if (m_bVectorPositive && MaxStr>0.)
				dAbsMaxStr = fabs(MaxStr);
			else if (m_bVectorNegative && MinStr<0.)
				dAbsMaxStr = fabs(MinStr);
		
			/////////////////////////////////////////////////////////////////////////////////////////////
			if(gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
			{
				double dLimit = (m_dMaxValue-m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;
				// MNET:XXXX-CJJEONG-20080508
				if ((m_PStrsComponent!=PSTRS_COMPONENT_VECTOR) || (m_bVectorPositive && m_bVectorNegative))
				{
					switch(gm->m_DOPT.TX.m_nOutputMinMaxType)
					{
					case 0: // Min & Max
						if((m_dMaxValue-MaxStr) <= dLimit)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,MaxStr);
						else if((MinStr-m_dMinValue) <= dLimit)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,MinStr);
						break;
					case 1: // Abs Max
						if(fabs(m_dMaxValue) >= fabs(m_dMinValue))
						{
							if( fabs(m_dMaxValue)-fabs(dAbsMaxStr) <= dLimit)
								DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dAbsMaxStr);
						}
						else
						{
							if( fabs(m_dMinValue)-fabs(dAbsMaxStr) <= dLimit)
								DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dAbsMaxStr);
						}
						break;
					case 2: // Max
						if((m_dMaxValue-MaxStr) <= dLimit)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,MaxStr);
						break;
					case 3: // Min
						if((MinStr-m_dMinValue) <= dLimit)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,MinStr);
						break;
					}
				}
				else if (m_bVectorPositive && m_dMaxValue>0.)
				{
					switch(gm->m_DOPT.TX.m_nOutputMinMaxType)
					{
					case 0: // Min & Max
						if((m_dMaxValue-MaxStr) <= dLimit  && MaxStr>0.)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,MaxStr);
						else if((MaxStr-m_dMinValue) <= dLimit && MaxStr>0.)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,MaxStr);           
						break;
					case 1: // Abs Max
						if(fabs(m_dMaxValue)-fabs(dAbsMaxStr) <= dLimit)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dAbsMaxStr);
						break;
					case 2: // Max
						if((m_dMaxValue-MaxStr) <= dLimit && MaxStr>0.)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,MaxStr);
						break;
					case 3: // Min
						if ((MaxStr-m_dMinValue) <= dLimit && MaxStr>0.)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,MaxStr);           
						break;
					}
				}
				else if (m_bVectorNegative && m_dMinValue<0.)
				{
					switch(gm->m_DOPT.TX.m_nOutputMinMaxType)
					{
					case 0: // Min & Max
						if((m_dMaxValue-MinStr) <= dLimit && MinStr<0.)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,MinStr);            
						else if((MinStr-m_dMinValue) <= dLimit && MinStr<0.)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,MinStr);
						break;
					case 1: // Abs Max
						if( fabs(m_dMinValue)-fabs(dAbsMaxStr) <= dLimit)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dAbsMaxStr);
						break;
					case 2: // Max
						if((m_dMaxValue-MinStr) <= dLimit && MinStr<0.)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,MinStr);            
						break;
					case 3: // Min
						if((MinStr-m_dMinValue) <= dLimit && MinStr<0.)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,MinStr);
						break;
					}
				}        
			//////////////////////////////////////////////////////////////////////////////////////
			}
			else
			{
				if (gm->m_bVirtualMode)
			    text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(DrawPoint);
		    else
			    text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(DrawPoint);

				// MNET:XXXX-CJJEONG-20080507
				BOOL  bText = TRUE;
				if (m_bVectorPositive && m_bVectorNegative)
				{
					if (fabs(MaxStr) > fabs(MinStr))
						_stprintf(text_str, fmt_str, MaxStr);
					else
						_stprintf(text_str, fmt_str, MinStr);
				}
				else if (m_bVectorPositive && MaxStr>0.)
					_stprintf(text_str, fmt_str, MaxStr);
				else if (m_bVectorNegative && MinStr<0.)        
					_stprintf(text_str, fmt_str, MinStr);
				else bText = FALSE;
				
				if (text_p.x >= 0 && text_p.y >= 0 && bText)
					TextOutModel.TextOutPStress(text_p.x, text_p.y + 10, text_str);
			}

			for (j=0;j<polygon_list.GetSize();j++) {
				polygon_list[j]->RemoveAll();
				delete polygon_list[j];
				edge_list[j]->RemoveAll();
				delete edge_list[j];
			}
			polygon_list.RemoveAll();
			edge_list.RemoveAll();
		}
		TextOutModel.DeleteFont();
	}
	TextOutModel.EndPStressVal();
	gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}
#endif

////////////////////////////////////////////////////////////////////////////////////////
// Routines for Drawing Influence Surface                           ////////////////////
////////////////////////////////////////////////////////////////////////////////////////
//DEL double CStressEngine::CalcPStrsValue(T_STRP_DL &pstrs_d)
//DEL {
//DEL 	double	len;
//DEL 
//DEL 	switch (m_PStrsComponent) {
//DEL 		case PSTRS_COMPONENT_SIGXX:
//DEL 			len = pstrs_d.dblStress[m_PStrsPart][14];
//DEL 			break;
//DEL 		case PSTRS_COMPONENT_SIGYY:
//DEL 			len = pstrs_d.dblStress[m_PStrsPart][15];
//DEL 			break;
//DEL 		case PSTRS_COMPONENT_SIGZZ:
//DEL 			len = pstrs_d.dblStress[m_PStrsPart][16];
//DEL 			break;
//DEL 		case PSTRS_COMPONENT_SIGXY:
//DEL 			len = pstrs_d.dblStress[m_PStrsPart][20];
//DEL 			break;
//DEL 		case PSTRS_COMPONENT_SIGYZ:
//DEL 			len = pstrs_d.dblStress[m_PStrsPart][21];
//DEL 			break;
//DEL 		case PSTRS_COMPONENT_SIGXZ:
//DEL 			len = pstrs_d.dblStress[m_PStrsPart][22];
//DEL 			break;
//DEL 		case PSTRS_COMPONENT_SIGMAX:
//DEL 			len = pstrs_d.dblStress[m_PStrsPart][26];
//DEL 			break;
//DEL 		case PSTRS_COMPONENT_SIGMIN:
//DEL 			len = pstrs_d.dblStress[m_PStrsPart][27];
//DEL 			break;
//DEL 	}
//DEL 
//DEL 	return len;
//DEL }

////////////////////////////////////////////////////////////////////////////////////////
// Initialization and Utility Routines for Solid Member Stress        /////////////////
////////////////////////////////////////////////////////////////////////////////////////
double CStressEngine::CalcSStrsValue(T_STRS_D &sstrs_d, int node)
{
	double	len;

	switch (m_SStrsComponent) {
		case SSTRS_COMPONENT_SIGXX:
		case SSTRS_COMPONENT_SIGX:
			len = sstrs_d.dblStress[node][0];
			break;
		case SSTRS_COMPONENT_SIGYY:
		case SSTRS_COMPONENT_SIGY:
			len = sstrs_d.dblStress[node][1];
			break;
		case SSTRS_COMPONENT_SIGZZ:
		case SSTRS_COMPONENT_SIGZ:
			len = sstrs_d.dblStress[node][2];
			break;
		case SSTRS_COMPONENT_SIGXY:
		case SSTRS_COMPONENT_LOCSIGXY:
			len = sstrs_d.dblStress[node][3];
			break;
		case SSTRS_COMPONENT_SIGYZ:
		case SSTRS_COMPONENT_LOCSIGYZ:
			len = sstrs_d.dblStress[node][4];
			break;
		case SSTRS_COMPONENT_SIGXZ:
		case SSTRS_COMPONENT_LOCSIGXZ:
			len = sstrs_d.dblStress[node][5];
			break;
		case SSTRS_COMPONENT_SIGP1:
			len = sstrs_d.dblStress[node][6];
			break;
		case SSTRS_COMPONENT_SIGP2:
			len = sstrs_d.dblStress[node][7];
			break;
		case SSTRS_COMPONENT_SIGP3:
			len = sstrs_d.dblStress[node][8];
			break;
		case SSTRS_COMPONENT_SHRMAX:
			len = sstrs_d.dblStress[node][9];
			break;
		case SSTRS_COMPONENT_SIGEFF:
			len = sstrs_d.dblStress[node][10];
			break;
		case SSTRS_COMPONENT_SIGMAX:
			if(fabs(sstrs_d.dblStress[node][6]) > fabs(sstrs_d.dblStress[node][7]))
				len = sstrs_d.dblStress[node][6];
			else
				len = sstrs_d.dblStress[node][7];
			if(fabs(len) < fabs(sstrs_d.dblStress[node][8]))
				len = sstrs_d.dblStress[node][8];

			break;
	}

	return len;
}

double CStressEngine::CalcSStrsValue(T_STRS_D &sstrs_d, int node, int component)
{
		double	len;

		switch (component) {
		case SSTRS_COMPONENT_SIGXX:
		case SSTRS_COMPONENT_SIGX:
				len = sstrs_d.dblStress[node][0];
				break;
		case SSTRS_COMPONENT_SIGYY:
		case SSTRS_COMPONENT_SIGY:
				len = sstrs_d.dblStress[node][1];
				break;
		case SSTRS_COMPONENT_SIGZZ:
		case SSTRS_COMPONENT_SIGZ:
				len = sstrs_d.dblStress[node][2];
				break;
		case SSTRS_COMPONENT_SIGXY:
		case SSTRS_COMPONENT_LOCSIGXY:
				len = sstrs_d.dblStress[node][3];
				break;
		case SSTRS_COMPONENT_SIGYZ:
		case SSTRS_COMPONENT_LOCSIGYZ:
				len = sstrs_d.dblStress[node][4];
				break;
		case SSTRS_COMPONENT_SIGXZ:
		case SSTRS_COMPONENT_LOCSIGXZ:
				len = sstrs_d.dblStress[node][5];
				break;
		case SSTRS_COMPONENT_SIGP1:
				len = sstrs_d.dblStress[node][6];
				break;
		case SSTRS_COMPONENT_SIGP2:
				len = sstrs_d.dblStress[node][7];
				break;
		case SSTRS_COMPONENT_SIGP3:
				len = sstrs_d.dblStress[node][8];
				break;
		case SSTRS_COMPONENT_SHRMAX:
				len = sstrs_d.dblStress[node][9];
				break;
		case SSTRS_COMPONENT_SIGEFF:
				len = sstrs_d.dblStress[node][10];
				break;
		case SSTRS_COMPONENT_SIGMAX:
				if(fabs(sstrs_d.dblStress[node][6]) > fabs(sstrs_d.dblStress[node][7]))
						len = sstrs_d.dblStress[node][6];
				else
						len = sstrs_d.dblStress[node][7];
				if(fabs(len) < fabs(sstrs_d.dblStress[node][8]))
						len = sstrs_d.dblStress[node][8];

				break;
		}

		return len;
}

void CStressEngine::SetSStrsComponent(T_STRS_D &sstrs_d, int node, double strs_val)
{
	switch (m_SStrsComponent) {
		case SSTRS_COMPONENT_SIGXX:
		case SSTRS_COMPONENT_SIGX:
			sstrs_d.dblStress[node][0] = strs_val;
			break;
		case SSTRS_COMPONENT_SIGYY:
		case SSTRS_COMPONENT_SIGY:
			sstrs_d.dblStress[node][1] = strs_val;
			break;
		case SSTRS_COMPONENT_SIGZZ:
		case SSTRS_COMPONENT_SIGZ:
			sstrs_d.dblStress[node][2] = strs_val;
			break;
		case SSTRS_COMPONENT_SIGXY:
		case SSTRS_COMPONENT_LOCSIGXY:
			sstrs_d.dblStress[node][3] = strs_val;
			break;
		case SSTRS_COMPONENT_SIGYZ:
		case SSTRS_COMPONENT_LOCSIGYZ:
			sstrs_d.dblStress[node][4] = strs_val;
			break;
		case SSTRS_COMPONENT_SIGXZ:
		case SSTRS_COMPONENT_LOCSIGXZ:
			sstrs_d.dblStress[node][5] = strs_val;
			break;
		case SSTRS_COMPONENT_SIGP1:
			sstrs_d.dblStress[node][6] = strs_val;
			break;
		case SSTRS_COMPONENT_SIGP2:
			sstrs_d.dblStress[node][7] = strs_val;
			break;
		case SSTRS_COMPONENT_SIGP3:
			sstrs_d.dblStress[node][8] = strs_val;
			break;
		case SSTRS_COMPONENT_SHRMAX:
			sstrs_d.dblStress[node][9] = strs_val;
			break;
		case SSTRS_COMPONENT_SIGEFF:
			sstrs_d.dblStress[node][10] = strs_val;
			break;
	}
}

double CStressEngine::GetMaxElemSStrs(T_STRS_D &sstrs_d, BOOL bCenter, int node_num)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	double		len, max=-DBL_MAX;

	if (m_SStrsComponent == SSTRS_COMPONENT_VECTOR)
	{
		if (max < sstrs_d.dblStress[0][6])
		{
			max = sstrs_d.dblStress[0][6];
		}
		if (max < sstrs_d.dblStress[0][7])
		{
			max = sstrs_d.dblStress[0][7];
		}
		if (max < sstrs_d.dblStress[0][8])
		{
			max = sstrs_d.dblStress[0][8];
		}
	}
	else
	{
		if(bCenter)
		{
			len = CalcSStrsValue(sstrs_d, 0);
			if (max < len)
			{
				max = len;
			}
		}
		else
		{
			for (int i=0;i<node_num;i++)
			{
				len = CalcSStrsValue(sstrs_d, i+1);
				if (max < len)
				{
					max = len;
				}
			}
		}
	}

	return max;
}

double CStressEngine::GetMinElemSStrs(T_STRS_D &sstrs_d, BOOL bCenter, int node_num)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	double		len, min=DBL_MAX;

	if (m_SStrsComponent == SSTRS_COMPONENT_VECTOR) 
	{
		if (min > sstrs_d.dblStress[0][6]) 
		{
			min = sstrs_d.dblStress[0][6];
		}
		if (min > sstrs_d.dblStress[0][7])
		{
			min = sstrs_d.dblStress[0][7];
		}
		if (min > sstrs_d.dblStress[0][8])
		{
			min = sstrs_d.dblStress[0][8];
		}
	}
	else 
	{
		if(bCenter)
		{
			len = CalcSStrsValue(sstrs_d, 0);
			if (min > len) 
			{
				min = len;
			}
		}
		else
		{
			for (int i=0;i<node_num;i++) 
			{
				len = CalcSStrsValue(sstrs_d, i+1);
				if (min > len) 
				{
					min = len;
				}
			}
		}
	}

	return min;
}

BOOL CStressEngine::IsWithinRangeElemSStrs(T_STRS_D &StrsD,int node_num,double& max_strs,double& min_strs)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	double len_max = GetMaxElemSStrs(StrsD, gm->m_bElemCenter, node_num);
	double len_min = GetMinElemSStrs(StrsD, gm->m_bElemCenter, node_num);

	if (len_min <= min_strs && len_max >= max_strs)
		return TRUE;
	if (len_min >= min_strs && len_min <= max_strs)
		return TRUE;
	if (len_max >= min_strs && len_max <= max_strs)
		return TRUE;

	return FALSE;
}


// 각 노드별로 인접한 요소의 Stress 값의 평균값을 구한다.
void CStressEngine::GetAverageNodalDataListS(BOOL bInitCalc/*=TRUE*/)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	MakeSerialNodeMap();
	T_NODE_K serial_node;

	int			i, j, linked_elem_num, nodes_in_elem,
				node_num=m_pDoc->m_pAttrCtrl->GetCountNode(), elem_num=m_SolidKeyList.GetSize();
	double		strs_val;
	T_ELEM_D	elem_data;
	T_STRS_D	sstrs_d;
	CArray <double, double &>											*elem_ptr;
	CArray <CArray <double, double &> *, CArray <double, double &> *>	elem_ptr_list;


	// KYE-HONG-200605
	// Global인 경우 von-Mises와 Tresca는 
	// 각 Component별로 Average한 다음 
	// 각 응력 계산을 하고 그것을 Average한다. 
	if(bInitCalc)
	if(m_SStrsVal == PSTRS_VALUE_GLOBAL )
	if(m_SStrsComponent == SSTRS_COMPONENT_SIGP1 || 
		 m_SStrsComponent == SSTRS_COMPONENT_SIGP2 ||
		 m_SStrsComponent == SSTRS_COMPONENT_SIGP3 ||
		 m_SStrsComponent == SSTRS_COMPONENT_SHRMAX ||
		 m_SStrsComponent == SSTRS_COMPONENT_SIGEFF || 
		 m_SStrsComponent == SSTRS_COMPONENT_SIGMAX)
	{
		int nBackSStrsComponent = m_SStrsComponent;
		int nCompNum = 6;
		int nComponent[] = {  SSTRS_COMPONENT_SIGXX, SSTRS_COMPONENT_SIGYY, SSTRS_COMPONENT_SIGZZ, 
													SSTRS_COMPONENT_SIGXY, SSTRS_COMPONENT_SIGYZ, SSTRS_COMPONENT_SIGXZ };

		// Component별 Average
		for(i=0; i<nCompNum; i++)
		{
			m_SStrsComponent = nComponent[i]; 
			GetAverageNodalDataListS(FALSE);
		}
		
		// von-Mises와 Tresca를 다시 계산한다. 
		for(i=0; i<elem_num; i++)
		{
			m_mapSolidStrsData.Lookup(m_SolidKeyList[i],sstrs_d);

			for(j=0; j<9; j++)
			{
				CDBDoc::GetDocPoint()->m_pPostCtrl->PRIN_SOL( &sstrs_d.dblStress[j][0], 
																											&sstrs_d.dblStress[j][6], 
																											(double(*)[3])(&sstrs_d.dblStress[j][12]));
			}
			m_mapSolidStrsData.SetAt(m_SolidKeyList[i],sstrs_d);
		}
		m_SStrsComponent = nBackSStrsComponent;
		// GetAverageNodalDataListS(FALSE);
		return; 
	}


	for (i=0;i<node_num;i++) 
	{
		elem_ptr = new CArray <double, double &>;
		elem_ptr_list.Add(elem_ptr);
	}

	for (i=0;i<elem_num;i++) 
	{
		m_pDoc->m_pAttrCtrl->GetElem(m_SolidKeyList[i], elem_data);
		m_mapNodesInElem.Lookup(m_SolidKeyList[i],nodes_in_elem);
		for (j=0;j<nodes_in_elem;j++) 
		{
			m_mapSolidStrsData.Lookup(m_SolidKeyList[i],sstrs_d);
			if(gm->m_bElemCenter)
			{
				strs_val = CalcSStrsValue(sstrs_d, 0);
			}
			else
			{
				strs_val = CalcSStrsValue(sstrs_d, j+1);
			}			
			if(!m_mapSerialNode.Lookup(elem_data.elnod[j],serial_node)) continue;
			elem_ptr_list[serial_node]->Add(strs_val);
		}
	}

	for (i=0;i<node_num;i++)
	{
		linked_elem_num = elem_ptr_list[i]->GetSize();
		if (linked_elem_num < 2)
			continue;
		strs_val = 0.0;
		for (j=0;j<linked_elem_num;j++)
		{
			strs_val += elem_ptr_list[i]->GetAt(j);
		}
		strs_val /= (double) linked_elem_num;
		elem_ptr_list[i]->SetAt(0, strs_val);
	}

	for (i=0;i<elem_num;i++) 
	{
		m_pDoc->m_pAttrCtrl->GetElem(m_SolidKeyList[i], elem_data);
		m_mapNodesInElem.Lookup(m_SolidKeyList[i],nodes_in_elem);
		for (j=0;j<nodes_in_elem;j++)
		{
			m_mapSolidStrsData.Lookup(m_SolidKeyList[i],sstrs_d);
			if(!m_mapSerialNode.Lookup(elem_data.elnod[j],serial_node)) continue;
			strs_val = elem_ptr_list[serial_node]->GetAt(0);
			SetSStrsComponent(sstrs_d, j+1, strs_val);
			m_mapSolidStrsData.SetAt(m_SolidKeyList[i],sstrs_d);
		}
	}

	for (i=0;i<node_num;i++) 
	{
		elem_ptr_list[i]->RemoveAll();
		delete elem_ptr_list[i];
	}
	elem_ptr_list.RemoveAll();
}

// Solid Key List 중 현재 Active인 것들의 List를 구한다.
void CStressEngine::GetActiveSolidList()
{
	
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	
	int			i, elem_num;
	
	T_ELEM_K	elem_key;
	T_ELEM_D  elem_data;	
	m_SolidKeyList.RemoveAll();
	elem_num = gm->m_EKeyListActive.GetSize(); 
	
	for (i=0;i<elem_num;i++) 
	{
		elem_key = gm->m_EKeyListActive[i];
		
		m_pDoc->m_pAttrCtrl->GetElem(elem_key, elem_data);
		if (m_pDoc->m_pAttrCtrl->IsSolid(elem_data.eltyp))
			m_SolidKeyList.Add(elem_key);
	}
	
}

void CStressEngine::InitVectorAdjustFactorS()
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	C3DPoint	min_pm, max_pm, min_pe, max_pe;
	double		max_lm, max_le, max_l;

	if(m_bLockAdjFactor)
		return;

	if (!m_pDoc->m_pAttrCtrl->ExistElem(m_KeyMaxSStrsElem)) {
		m_VectorAdjustFactor = 1.0;
		return;
	}

	// 전체 모델의 Range와 최대값이 발생한 요소의 Range를 동시에 고려한다.

/*	m_pDoc->calcRangeModel(min_pm.x, min_pm.y, min_pm.z,
								   max_pm.x, max_pm.y, max_pm.z,
								   NULL, NULL, TRUE, NULL, TRUE,
								   gm->m_bFrameThick||gm->m_bPlaneThick);*/
		
	gm->GetRangeModel(&min_pm,&max_pm);
	max_lm = max(max(max_pm.x-min_pm.x, max_pm.y-min_pm.y), max_pm.z-min_pm.z);

	gm->GetRangeElement(m_KeyMaxSStrsElem, &min_pe, &max_pe);
	max_le = max(max(max_pe.x-min_pe.x, max_pe.y-min_pe.y), max_pe.z-min_pe.z);

	if (m_MaxAbsValue > -1e-15 && m_MaxAbsValue < 1e-15)
		m_MaxAbsValue = 1.0f;

	if ((max_le*0.35) < (max_lm/40.0)) {
		max_l = max_lm/40.0;
	}
	else {
		max_l = max_le*0.35;
	}

	m_VectorAdjustFactor = max_l / m_MaxAbsValue;
}

// Solid Stress 데이터를 만든다.
// 전체 Element List에 대해 Loop를 돌며
// 1. DB로 부터 해당 Element의 Solid Stress 데이터를 얻고
// 2. Solid Stress값 및 해당 Element번호 등을 CArray에 저장
// 3. 필요시 각 노드별로 인접한 요소의 Solid Stress의 값의 평균값을 구한다.
// 4. Solid Key List 중 현재 Active인 것들의 List를 구한다.
// 5. 현재 Active Solid Key List에 대해 Loop를 돌며 최대/최소값을 갱신한다.
BOOL CStressEngine::MakeSStrsDataList()
{
	if (CTestEnvMgr::IsTestEnvST(_LSX(ProfilingSTL), _LSX(yes)))
	{
		M_PROFILE('MakeSStrsDataList()');
	}

	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	if(!gm->m_bLoadDataSet)	return FALSE;

	int			  i, elem_num, nie;
	double		max_sstrs=-DBL_MAX, min_sstrs=DBL_MAX, len;
	BOOL	  	has_content=FALSE;
	T_ELEM_K	elem_key;
	T_STRS_D	sstrs_d;
	T_STRS_D	sstrs_max,sstrs_min;
	BOOL      bWithSign = m_pDoc->m_pPostCtrl->GetSignFlag();


	gm->m_pMyView->BeginWaitCursor();

	m_SolidKeyList.RemoveAll();
	m_mapSolidStrsData.RemoveAll();

	// Get the Original LoadCombination Data
	T_LCOM_D  LcomOrg=m_pDoc->m_pPostCtrl->GetLoadComb();

	if(m_bAverageNodalActiveOnly || (m_SStrsAve != PSTRS_VALUE_AVENODAL))
	  elem_num = gm->m_EKeyListActive.GetSize(); // Active된 요소에 대해서만 Average Nodal을 계산.
	else
		elem_num = gm->m_EKeyList.GetSize(); // Average Nodal이 가능하도록...전체 요소를 취한다.

	m_mapSolidStrsData.InitHashTable(GF_GetHashSizeByCount(elem_num));

	//GTimeCheckStart();
	if(m_SStrsAve == PSTRS_VALUE_AVENODAL) MakeSerialNodeMap();

	CMapEx<T_ELEM_K,T_ELEM_K,T_STRS_D,T_STRS_D&> mapSStrsDataMax,mapSStrsDataMin;
	mapSStrsDataMax.InitHashTable(GF_GetHashSizeByCount(elem_num));
	mapSStrsDataMin.InitHashTable(GF_GetHashSizeByCount(elem_num));
	MakeSStrsDataListLcom(LcomOrg,elem_num,1.0,mapSStrsDataMax,mapSStrsDataMin);

	for(i=0;i<m_SolidKeyList.GetSize();i++) 
	{
		elem_key = m_SolidKeyList[i];
		mapSStrsDataMax.Lookup(elem_key, sstrs_max);
		mapSStrsDataMin.Lookup(elem_key, sstrs_min);
		
		switch (gm->m_LoadMinMaxType) 
		{
		case LOADTYPE_NORMAL:
		case LOADTYPE_MAX:
			m_mapSolidStrsData.SetAt(elem_key,sstrs_max);
			break;
		case LOADTYPE_MIN:
			m_mapSolidStrsData.SetAt(elem_key,sstrs_min);
			break;
		case LOADTYPE_ALL:
			if(bWithSign)
				sstrs_max.AbsMaxwithSign(sstrs_min);
			else
				sstrs_max.AbsMax(sstrs_min);
			m_mapSolidStrsData.SetAt(elem_key,sstrs_max);
			break;
		}
	}
	//double t1=GTimeCheckEnd();

	// Back to the Original LoadCombination Data
	m_pDoc->m_pPostCtrl->ChangeLoadComb(LcomOrg);

	// 3. 필요시 각 노드별로 인접한 요소의 Solid Stress의 값의 평균값을 구한다.
	// 1번 단계에서 구하도록 한다. (버그수정)
	//GTimeCheckStart();
	//if(m_SStrsAve == PSTRS_VALUE_AVENODAL)GetAverageNodalDataListS();
	//double t2=GTimeCheckEnd();
	
	// 4. Solid Key List 중 현재 Active인 것들의 List를 구한다.
	if(!(m_bAverageNodalActiveOnly || (m_SStrsAve != PSTRS_VALUE_AVENODAL)))
		GetActiveSolidList();

	// 5. 현재 Active Solid Key List에 대해 Loop를 돌며 최대/최소값을 갱신한다.
	//GTimeCheckStart();
	elem_num = m_SolidKeyList.GetSize();
	if(elem_num) has_content = TRUE;
	m_MaxAbsValue = -DBL_MAX;
	for(i=0;i<elem_num;i++) 
	{
		m_mapSolidStrsData.Lookup(m_SolidKeyList[i], sstrs_d);
		m_mapNodesInElem.Lookup(m_SolidKeyList[i],nie);
		len = GetMaxElemSStrs(sstrs_d, gm->m_bElemCenter, nie);
		if (len > max_sstrs) 
		{
			max_sstrs = len;
			gm->m_nLgdMaxValKey = m_SolidKeyList[i];
		}
		if (fabs(len) > m_MaxAbsValue) {
			m_MaxAbsValue = fabs(len);
			m_KeyMaxSStrsElem = m_SolidKeyList[i];
		}

		len = GetMinElemSStrs(sstrs_d, gm->m_bElemCenter, nie);
		if (len < min_sstrs) 
		{
			min_sstrs = len;
			gm->m_nLgdMinValKey = m_SolidKeyList[i];
		}
		if (fabs(len) > m_MaxAbsValue) {
			m_MaxAbsValue = fabs(len);
			m_KeyMaxSStrsElem = m_SolidKeyList[i];
		}
	}
	//double t3=GTimeCheckEnd();

	if (!has_content) 
	{
		min_sstrs = max_sstrs = 0.0;
		gm->m_nLgdMaxValKey = 0;
		gm->m_nLgdMinValKey = 0;
	}

	m_dMaxValue = max_sstrs;
	m_dMinValue = min_sstrs;

	//GTimeCheckStart();
	if (m_pContourEngine == NULL)
		m_pContourEngine = new CContourEngine(min_sstrs, max_sstrs);
	else
		m_pContourEngine->MakeRankMap(min_sstrs, max_sstrs);
	//double t4=GTimeCheckEnd();
	//CString sTemp;
	//sTemp.Format("t1=%g, t2=%g, t3=%g, t4=%g", t1, t2, t3, t4);
	//AfxMessageBox(sTemp);
	
	m_mapNodesInElem.RemoveAll();

	gm->m_pMyView->EndWaitCursor();

	m_bSStrsDataSet = TRUE;
	return TRUE;
}

BOOL CStressEngine::GetSStrsRangeDataList(double& dMaxRange, double& dMinRange, CArray<UINT,UINT>& aElemKeyList)
{
	aElemKeyList.RemoveAll();

	if (CTestEnvMgr::IsTestEnvST(_LSX(ProfilingSTL), _LSX(yes)))
	{
		M_PROFILE('GetSStrsRangeDataList()');
	}

	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	int			  i, nie;
	T_ELEM_K	elem_key;
	T_ELEM_D	elem_data;
	T_STRS_D	sstrs_d;
	BOOL      bWithSign = m_pDoc->m_pPostCtrl->GetSignFlag();

	gm->m_pMyView->BeginWaitCursor();

	int elem_num = m_SolidKeyList.GetSize();
	for(i=0;i<elem_num;i++) 
	{
		elem_key = m_SolidKeyList[i];
		if(!m_mapSolidStrsData.Lookup(elem_key, sstrs_d)) continue;

		elem_data.Initialize();
		m_pDoc->m_pAttrCtrl->GetElem(elem_key, elem_data);
		nie = m_pDoc->m_pAttrCtrl->GetNumNode(elem_data.eltyp, elem_data.elnod);

		if(!IsWithinRangeElemSStrs(sstrs_d, nie, dMaxRange, dMinRange)) continue;

		aElemKeyList.Add(elem_key);
	}	

	gm->m_pMyView->EndWaitCursor();
	
	return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////
// Routines for Drawing Solid Member Stress Contour                ////////////////////
////////////////////////////////////////////////////////////////////////////////////////

void CStressEngine::DrawSStrsContour(CDC *pDC)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	
	int			i, elem_num;
	BOOL		fl_bak=gm->m_DOPT.DR.m_bFrameLine;
	T_ELEM_D	elem_d;
	CPen		elem_pen, *old_pen;
	CArray <int, int>				type_list;
	CArray <GRE_Atom, GRE_Atom&>		atom_list;
	BOOL bEscapePressed = FALSE;  
	T_MIRE_K mkey;
	
	/*
	if(!gm->m_bContour) 
	{
		gm->GPSDrawOriginal(pDC);
		return;
	}
	*/

	if(m_bOnCuttingPlane && gm->m_AnimEngine.m_bAnimateContour && gm->m_bAnimation)
	{
		gm->GetRangeModelOneType(&m_CutPlnMovingRangeMinPnt,&m_CutPlnMovingRangeMaxPnt,SOLID_EL);
		if(gm->m_nMovingDir == 3) // normal to Plane 
			MakeCutPlaneMovingPath();
	}
		
	if(m_SStrsComponent == SSTRS_COMPONENT_VECTOR)InitVectorAdjustFactorS();

	if(m_bDeformedShapeContour) 
	{
		if(gm->m_pDeformEngine == NULL)return;
		type_list.Add(gm->m_MinOTID + OBJECT_TYPE_DEFORMED);

		// 변형된 그림에 Undeformed Shape을 같이 그릴 경우.
		if(gm->m_DOPT.DR.m_bDrawInactive && (m_SStrsComponent==SSTRS_COMPONENT_VECTOR)) 
		{
			gm->m_DOPT.DR.m_bFrameLine = TRUE;
			gm->GPSDrawOriginal(pDC, TRUE);
		}
	}
	else 
	{
		type_list.Add(gm->m_MinOTID + OBJECT_TYPE_ORIGINAL);
	}

	elem_pen.CreatePen(PS_SOLID, gm->m_DOPT.DR.nElemHddn, m_pContourEngine->m_ElemColor);
	old_pen = (CPen *) pDC->SelectObject(&elem_pen);

	gm->m_pGPSCtrl->GetZSortedList(type_list, gm->m_EKeyListVisible_Mirror, atom_list);
	elem_num = atom_list.GetSize();

	//GTimeCheckStart();
	if((m_bOnCuttingPlane || m_bIsoSurface) && gm->m_bFreeEdgeOnly && !m_bIsFreeEdgeDataSet)
		MakeFreeEdgeData();
	else if(!gm->m_DOPT.RD.m_bShrink && !m_bIsFreeFaceDataSet && (m_SStrsComponent != SSTRS_COMPONENT_VECTOR))
		MakeFreeFaceData();
 	//double t1=GTimeCheckEnd();

	//GTimeCheckStart();
	for(i=0;i<elem_num;i++) 
	{
		//if(gm->m_pGPSCtrl->WatchEscKeyPress()) bEscapePressed = TRUE;
		if(gm->m_pGPSCtrl->WatchEscKeyPress()) return;
		if(gm->m_pGPSCtrl->IsZoomAllState() ||
			gm->m_pGPSCtrl->IsObjectInClientWindow(atom_list[i].m_OType, atom_list[i].m_OKey)) {
			mkey.keymap = atom_list[i].m_OKey;
			m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d);
			if (m_pDoc->m_pAttrCtrl->IsSolidType(elem_d.eltyp) && (gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey)) && !bEscapePressed) 
			{
				if (m_SStrsComponent == SSTRS_COMPONENT_VECTOR) 
				{
					//gm->m_bFrameLine = TRUE;		// Vector를 그릴 경우 Hidden을 끈다.
					if (m_bDeformedShapeContour)
						gm->m_pDeformEngine->DrawDeformedElement(pDC, atom_list[i].m_OKey);
					else
						gm->GPSDrawElement(pDC, atom_list[i].m_OKey);
					if(gm->m_bContour)
						DoSStrsElementVector(pDC, atom_list[i].m_OKey);
				}
				else 
				{
					gm->m_DOPT.DR.m_bFrameLine = fl_bak;

					if(gm->m_bContour)
					{
					  if(m_bOnCuttingPlane)
						  DoSStrsElementContourOnCuttingPlane(pDC, atom_list[i].m_OKey);
					  else if(m_bIsoSurface)
						  DoSStrsElementIsoSurfaceContour(pDC,atom_list[i].m_OKey,gm->m_aIsoValues);
					  else
						  DoSStrsElementContour(pDC, atom_list[i].m_OKey);
					}
					else
					{
						gm->GPSDrawElement(pDC, atom_list[i].m_OKey);   
					}
				}
				if(m_bHingeStatus)DrawNLHngeStatus(pDC,atom_list[i].m_OKey);
			}
			else 
			{
				if(m_SStrsComponent == SSTRS_COMPONENT_VECTOR)
					;//gm->m_bFrameLine = TRUE;		// Vector를 그릴 경우 Hidden을 끈다.
				else
					gm->m_DOPT.DR.m_bFrameLine = fl_bak;
				if(m_bDeformedShapeContour)
					gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, atom_list[i].m_OKey);
				else
					gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
			}
		}
	}
 	//double t2=GTimeCheckEnd();
	//CString sTemp;
	//sTemp.Format("t1=%g, t2=%g", t1, t2);
	//GSaveHistoryFormatNF("DrawSStrsContour : makeFreeFace=%g, Draw=%g", t1, t2);

	gm->m_DOPT.DR.m_bFrameLine = fl_bak;

	// 변형된 그림에 Undeformed Shape을 같이 그릴 경우.
	if (m_bDeformedShapeContour && gm->m_DOPT.DR.m_bDrawInactive && (m_SStrsComponent!=SSTRS_COMPONENT_VECTOR) && !bEscapePressed) {
		int	rf_bak=gm->m_DOPT.DR.m_RenderFlag;
		gm->m_DOPT.DR.m_RenderFlag = 2;
		gm->GPSDrawOriginal(pDC, TRUE);
		gm->m_DOPT.DR.m_RenderFlag = rf_bak;
	}

	pDC->SelectObject(old_pen);
	elem_pen.DeleteObject();


	//----------------------------------------------------------------------
	// UCS Icon Drawing
	//----------------------------------------------------------------------
	if( (m_SStrsVal == PSTRS_VALUE_GLOBAL)  && gm->m_bVirtualMode && m_bPrintUCSAxis) 
	{
		double UCS_vector[3][3];
		GetUCSVector(m_NUCS,UCS_vector);
		DrawUCSPlaneIcon(pDC,UCS_vector);
	}
	
}


// 주어진 요소의 Solid Stress Contour를 그린다.
// 1. 요소의 형상정보를 얻는다.
// 2. 요소의 형상을 이루는 polygon들의 각 Vertex에 해당 Solid Stress값을 부여한다.
// 3. polygon별로 Contour를 실시하여 Solid Stress값에 따라 나뉘어진 sub-polygon list를 얻는다.
// 4. sub-polygon들을 그린다.
void CStressEngine::DoSStrsElementContour(CDC *pDC, unsigned int ekey)
{
	T_MIRE_K mkey;
	mkey.keymap = ekey;

	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;
	
	int				i, j, poly_num, vtx_num, node_in_elem;
	double			sstrs_val[4];
	BOOL			ef[4];
	T_ELEM_D		elem_d;
	T_STRS_D		sstrs_d;
	
	CArray<int, int>* paFreeFace; 
	if(!m_mapFreeFacebyElemKey.Lookup(mkey.key.elem_k,paFreeFace) && !gm->m_DOPT.RD.m_bShrink)
		return;

	if ((gm->m_pDeformEngine==NULL) ||
		(m_pContourEngine==NULL) ||
		(!GetSolidStress(mkey.key.elem_k, sstrs_d)))
	{
		return;
	}
	
	CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray <CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					edge_list;
	CArray <CArray <T_NODE_K, T_NODE_K> *, CArray <T_NODE_K, T_NODE_K> *>	VertexNode;
	CArray <int, int> aSort_index_list;

	// 1. 요소의 형상정보를 얻는다.
	m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d);
	node_in_elem = m_pDoc->m_pAttrCtrl->GetNumNode(elem_d.eltyp, elem_d.elnod);
	
	if(!gm->m_DOPT.RD.m_bShrink) // Free Face만 Contour with 배면 제거
	{
	  if (m_bDeformedShapeContour)
		  gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list, &VertexNode,NULL,&aSort_index_list);
	  else
		  gm->GetShapeElement(ekey, polygon_list, &edge_list, NULL, &VertexNode,NULL,&aSort_index_list);
	}
	else // 모든 요소를 Contour 단 배면은 제거...
	{
		if (m_bDeformedShapeContour)
		  gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list, &VertexNode,NULL,NULL);
	  else
		  gm->GetShapeElement(ekey, polygon_list, &edge_list, NULL, &VertexNode,NULL,NULL);
	}

	gm->GPS_XGL_Begin_Elem(mkey.key.elem_k,elem_d);
	poly_num = polygon_list.GetSize();
	for (i=0;i<poly_num;i++) 
	{
		
		if(!gm->m_DOPT.RD.m_bShrink && !IsFreeFace(paFreeFace,aSort_index_list[i])) // Solid인경우 FreeFace-only Contour 적용.
			continue;

		vtx_num = polygon_list[i]->GetCount();
		if (vtx_num == 2)
			continue;
		
		if(poly_num>1 && !gm->IsVisibleFace(polygon_list[i],vtx_num))
			 continue;
		
		
		// Fill+Outline의 경우 Contour를 수행하기 전의 Polygon의 Outline을 그림.// Line Only 일경우는 먼저그린다.
		if ((gm->m_DOPT.DR.m_RenderFlag == 3 || gm->m_DOPT.DR.m_RenderFlag == 2) && m_pContourEngine->m_nContourFill ==1)
		{
			//gm->DrawPolygon3DFill(pDC, *(polygon_list[i]), *(edge_list[i]), gm->m_ClientBackColor);
			gm->DrawPolygon3DFill(pDC, *(polygon_list[i]), *(edge_list[i]), gm->m_DOPT.CL.m_ClientBackColor);
			gm->GPSDrawPolygonEdge(pDC, polygon_list[i], edge_list[i]);
		}

		// 2. 요소의 형상을 이루는 polygon들의 각 Vertex에 해당 Solid Stress값을 부여한다.
		for (j=0;j<vtx_num;j++) 
		{
			if(gm->m_bElemCenter)
			{
				sstrs_val[j] = CalcSStrsValue(sstrs_d, 0);
			}
			else
			{
				sstrs_val[j] = CalcSStrsValue(sstrs_d, GetNodeOrder(VertexNode[i]->GetAt(j), elem_d, node_in_elem)+1);
			}
			if (gm->m_AnimEngine.m_bAnimateContour)
				sstrs_val[j] = m_pContourEngine->GetSubFrameValue(sstrs_val[j], gm->m_AnimEngine.GetAnimationFactor(TRUE));
			ef[j] = edge_list[i]->GetAt(j);
		}

		// 3. polygon별로 Contour를 실시하여 Solid Stress값에 따라 나뉘어진 sub-polygon list를 얻는다.
		// 4. sub-polygon들을 그린다.
		DoSubPolyContour(pDC, sstrs_val, polygon_list[i], ef, FALSE);

		// Fill+Outline의 경우 Contour를 수행하기 전의 Polygon의 Outline을 그림.
		//----------------------------------------------------------------------------------------------------------------
		//XGLRenderer
		// Solid face만 그릴경우 EdgeLine처리 부분 수정 Edge 정보필요 없음.
		// 2005.04.01 창근 
		//if ((gm->m_DOPT.DR.m_RenderFlag == 3 || gm->m_DOPT.DR.m_RenderFlag == 2) && m_pContourEngine->m_nContourFill ==0)
		//	gm->GPSDrawPolygonEdge(pDC, polygon_list[i], edge_list[i]);
		if ((gm->m_DOPT.DR.m_RenderFlag == 3 || gm->m_DOPT.DR.m_RenderFlag == 2) && m_pContourEngine->m_nContourFill ==0)
			gm->GPSDrawPolygonEdge(pDC, polygon_list[i],NULL);
	}
	gm->GPS_XGL_End_Elem();

	FreeMemoryPolyList(&polygon_list,&edge_list,&VertexNode); 
	/*
	for (i=0;i<poly_num;i++) {
		polygon_list[i]->RemoveAll();
		delete polygon_list[i];
		edge_list[i]->RemoveAll();
		delete edge_list[i];
		VertexNode[i]->RemoveAll();
		delete VertexNode[i];
	}
	polygon_list.RemoveAll();
	edge_list.RemoveAll();
	VertexNode.RemoveAll();
	*/
}

// 주어진 요소의 Solid Stress Contour를 그린다.
// 1. 요소의 형상정보를 얻는다.
// 2. 요소의 형상을 이루는 polygon들의 각 Vertex에 해당 Solid Stress값을 부여한다.
// 3. polygon별로 Contour를 실시하여 Solid Stress값에 따라 나뉘어진 sub-polygon list를 얻는다.
// 4. sub-polygon들을 그린다.
void CStressEngine::DoSStrsElementContourOnCuttingPlane(CDC *pDC, unsigned int ekey)
{
	T_MIRE_K mkey;
	mkey.keymap = ekey;

	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;

	int		  i, j, poly_num, vtx_num, node_in_elem;
	double	sstrs_val[4],sstrs_val2[4];
	double  dCutStress;
	BOOL		ef[4],ef2[4];
	T_ELEM_D	elem_d;
	T_STRS_D	sstrs_d;

	CArray<CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray<CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					edge_list;
	CArray<CArray <T_NODE_K, T_NODE_K> *, CArray <T_NODE_K, T_NODE_K> *>	VertexNode;
	CArray<C3DPoint,C3DPoint> aCutVertex;
	CArray<double,double>     aCutVertexVal;
	CArray<C3DPoint,C3DPoint> aUnSortedVertex;

	// 20100518 KIMJM, differnce가 e-16으로 작게 나옴.
	double dTol = M_InitValueCurUnit(1.E-10, N, MM, D_UNITSYS_BASE_STRESS);
	if (dTol > 1.0e-7) dTol = 1.0e-7;   // dTol가 너무 커지는 경우가 있어서 좀더 줄여줌.. // MNET:XXXX-HSSHIM-20130807

	if((gm->m_pDeformEngine==NULL) ||
		(m_pContourEngine==NULL) ||
		(!GetSolidStress(mkey.key.elem_k, sstrs_d))) 
	{
		return;
	}

	// 1. 요소의 형상정보를 얻는다. // Mirror 안된 형상을 얻어서 cutting한후 mirror하도록 한다.
	m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d);
	node_in_elem = m_pDoc->m_pAttrCtrl->GetNumNode(elem_d.eltyp, elem_d.elnod);
	if(gm->m_bFreeEdgeOnly)
	{
		if(m_bDeformedShapeContour) 
			gm->m_pDeformEngine->GetDeformedShapeElement(mkey.key.elem_k, &polygon_list, &edge_list, &VertexNode,&aUnSortedVertex);
		else
			gm->GetShapeElement(mkey.key.elem_k, polygon_list, &edge_list, NULL, &VertexNode,&aUnSortedVertex);
	}
	else
	{
		if(m_bDeformedShapeContour)
			gm->m_pDeformEngine->GetDeformedShapeElement(mkey.key.elem_k, &polygon_list, &edge_list, &VertexNode);
		else
			gm->GetShapeElement(mkey.key.elem_k, polygon_list, &edge_list, NULL, &VertexNode);
	}

	poly_num = polygon_list.GetSize();

	int point1,point2;
	C3DPoint Point1,Point2,Vector,Point3;
	double dPoint1[3],dPoint3[3],dVector[3],dNormalVector[3];

	double d1,d2;
	CArray <T_NPLN_D,T_NPLN_D&> aCuttingPlane;
	T_NPLN_D CuttingPlane;
	int nSurface;
	PLANE_FUNC CuttingPlaneF;


	int nNumOfCutPlanes;

	if (gm->m_AnimEngine.m_bAnimateContour && gm->m_bAnimation)
	{
		nNumOfCutPlanes = 1; // Moving Plane에 대해서만 적용한다.
		if(gm->m_nMovingDir==3) 
		{
			if(!GetNPLN(gm->m_aCutPlanes[gm->m_nMovingPlane],CuttingPlane)) return; // Moving Plane 
		}
		else
		{ 
			CuttingPlane.Initialize();
			CuttingPlane.nPlaneType =1 ;
		}
		aCuttingPlane.Add(CuttingPlane);
	}
	else
	{
		nNumOfCutPlanes = gm->m_aCutPlanes.GetSize();
		for(int nKey = 0; nKey < nNumOfCutPlanes; nKey++)
		{
			if(GetNPLN(gm->m_aCutPlanes[nKey],CuttingPlane))
				aCuttingPlane.Add(CuttingPlane);
			else
			{
				nNumOfCutPlanes--;
				gm->m_aCutPlanes.RemoveAt(nKey);
				nKey--;
			}
		}
	}

	gm->GPS_XGL_Begin_Elem(mkey.key.elem_k,elem_d);    

	for(int nPLN = 0; nPLN < nNumOfCutPlanes; nPLN++)
	{
		CuttingPlane = aCuttingPlane[nPLN];
		if (gm->m_AnimEngine.m_bAnimateContour && gm->m_bAnimation)
			GetMovedCuttingPlane(CuttingPlane);

		GetPlaneFunction(CuttingPlane,CuttingPlaneF);

		dNormalVector[0] =CuttingPlaneF.a;
		dNormalVector[1] =CuttingPlaneF.b;
		dNormalVector[2] =CuttingPlaneF.c; // CuttingPlane Normal Vector

		aCutVertex.RemoveAll();
		aCutVertexVal.RemoveAll();

		poly_num = polygon_list.GetSize();
		for (i=0;i<poly_num;i++) 
		{
			vtx_num = polygon_list[i]->GetCount();
			if (vtx_num == 2) 
				continue;
			else 
			{
				if(poly_num >= 5) // 5면체 6면체에 대해서만 위 아랫 면을 계산에서 제외한다.(중복되므로)
				{
					nSurface = GetSolidSurface(elem_d, node_in_elem,VertexNode[i]); // 0: Top Surface , 1:Bot Surface, 2: Side Surface
					if(nSurface <2) continue;
				}
				// 2. 요소의 형상을 이루는 polygon들의 각 Vertex에 해당 Solid Stress값을 부여한다.
				for (j=0;j<vtx_num;j++) 
				{
					sstrs_val[j] = CalcSStrsValue(sstrs_d, GetNodeOrder(VertexNode[i]->GetAt(j), elem_d, node_in_elem)+1);
					ef[j] = edge_list[i]->GetAt(j);
				}


				POSITION pos = polygon_list[i]->GetHeadPosition();
				Point1= polygon_list[i]->GetNext(pos);
				for (j=0;j<vtx_num-1;j++) 
				{
					point1 = j; 
					point2=j+1;
					if(j>0) Point1 = Point2;

					Point2= polygon_list[i]->GetNext(pos);


					dVector[0] = Point2.x-Point1.x;
					dVector[1] = Point2.y-Point1.y;
					dVector[2] = Point2.z-Point1.z;


					d1 = CuttingPlaneF.a*Point1.x + CuttingPlaneF.b * Point1.y + CuttingPlaneF.c * Point1.z + CuttingPlaneF.h ;
					d2 = CuttingPlaneF.a*Point2.x + CuttingPlaneF.b * Point2.y + CuttingPlaneF.c * Point2.z + CuttingPlaneF.h ;

					if(fabs(d1) < dTol) d1 = 0.0;
					if(fabs(d2) < dTol) d2 = 0.0;				


					if(d1*d2<0.0)
					{
						dPoint1[0] = Point1.x;
						dPoint1[1] = Point1.y;
						dPoint1[2] = Point1.z;

						if(!CMathFunc::project_on_plane_vector_for_CuttingPlane(dPoint1,dVector,CuttingPlane.dPoint[0],
							CuttingPlane.dPoint[1],CuttingPlane.dPoint[2],dPoint3)) continue;
						Point3.Set(dPoint3[0],dPoint3[1],dPoint3[2]);

						aCutVertex.Add(Point3);

						d1 = CMathFunc::mathLength(Point3.x,Point3.y,Point3.z,
							Point1.x,Point1.y,Point1.z);
						d2 = CMathFunc::mathLength(Point3.x,Point3.y,Point3.z,
							Point2.x,Point2.y,Point2.z);

						dCutStress = sstrs_val[point1] + (sstrs_val[point2]-sstrs_val[point1])*d1/(d1+d2);
						aCutVertexVal.Add(dCutStress);
					}

					if(fabs(d1 - 0.0)<1e-18)
					{
						aCutVertex.Add(Point1);

						dCutStress = sstrs_val[point1] ;
						aCutVertexVal.Add(dCutStress);
					}

					if(fabs(d2 - 0.0)<1e-18)
					{
						aCutVertex.Add(Point2);

						dCutStress = sstrs_val[point2] ;
						aCutVertexVal.Add(dCutStress);
					}

				}

			}
		}

		/////////////////////////////////////////////////////////////////////////////////////////////////////
		// Draw Cut-plane polygon
		CList <C3DPoint, C3DPoint> cut_polygon_list;
		CList <C3DPoint, C3DPoint> cut_polygon_list2;//Polygon이 4개이상의 정점을 가질때 2개로 분할.
		if(aCutVertex.GetSize())
		{
			GetPolygon(aCutVertex,aCutVertexVal,CuttingPlaneF);// 정점들을 꼬이지 않은 CCW 폴리곤을 만들도록 재배열

			if(mkey.key.mirror_k)
				for(int i=0; i<aCutVertex.GetSize(); i++)
					gm->RE_GetMirroredPoint(mkey.key.mirror_k,&aCutVertex[i]);

			if(aCutVertex.GetSize() >4)
			{
				int nFistPolySize =4;
				for(int i=0; i<nFistPolySize; i++)
				{
					cut_polygon_list.AddTail(aCutVertex[i]);
					sstrs_val[i] = aCutVertexVal[i];
					ef[i] = FALSE;
				}

				cut_polygon_list2.AddTail(aCutVertex[0]);
				sstrs_val2[0] = aCutVertexVal[0];
				ef2[0] = FALSE;

				int nSecondPolySize =aCutVertex.GetSize()-4 +2 ;
				for( i=1; i<nSecondPolySize; i++)
				{
					cut_polygon_list2.AddTail(aCutVertex[2+i]);
					sstrs_val2[i] = aCutVertexVal[2+i];
					ef2[i] = FALSE;
				}

				DoSubPolyContour(pDC, sstrs_val, &cut_polygon_list, ef, FALSE);
				DoSubPolyContour(pDC, sstrs_val2, &cut_polygon_list2, ef2, FALSE);
			}
			else
			{
				for(int i=0; i<aCutVertex.GetSize(); i++)
				{
					cut_polygon_list.AddTail(aCutVertex[i]);
					sstrs_val[i] = aCutVertexVal[i];
					ef[i] = FALSE;
				}
				DoSubPolyContour(pDC, sstrs_val, &cut_polygon_list, ef, FALSE);
			}

		}
		cut_polygon_list.RemoveAll();
		cut_polygon_list2.RemoveAll();
		//////////////////////////////////////////////////////////////////////////////////////////////////////
	}

	gm->GPS_XGL_End_Elem();

	if(gm->m_bFreeEdgeOnly) //현재 항상 TRUE
		DrawSolidFreeEdge(pDC,ekey,aUnSortedVertex);
	else
	{
		// Fill+Outline의 경우 Contour를 수행하기 전의 Polygon의 Outline을 그림. 
		// Mirror가 고려안됨. 현재 무의미한 루틴...
		for (i=0;i<poly_num;i++) 
			if (gm->m_DOPT.DR.m_RenderFlag == 3 || gm->m_DOPT.DR.m_RenderFlag == 2)
				gm->GPSDrawPolygonEdge(pDC, polygon_list[i], edge_list[i]);
	}

	for(i=0;i<poly_num;i++) 
	{
		polygon_list[i]->RemoveAll();
		delete []polygon_list[i];
		edge_list[i]->RemoveAll();
		delete []edge_list[i];
		VertexNode[i]->RemoveAll();
		delete []VertexNode[i];
	}
	polygon_list.RemoveAll();
	edge_list.RemoveAll();
	VertexNode.RemoveAll();
}

	

void CStressEngine::DoSStrsElementVector(CDC *pDC, unsigned int ekey)
{
	T_MIRE_K mkey;
	mkey.keymap = ekey;
	
	

	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;
	CClientDC			dc(gm->m_pMyView);
	int				i, node_num;
	double			local_vec[3][3], node_p[8][3];
	T_STRS_D		sstrs_d;
	T_ELEM_D		edata;
	CPen			p1_pen, p2_pen, p3_pen, *old_pen,*old_pen2;
	C3DPoint		pnt_p1, arr_p11, arr_p12,
					pnt_p2, arr_p21, arr_p22,
					pnt_p3, arr_p31, arr_p32,
					pnt_c;

	if ((gm->m_pDeformEngine==NULL) ||
		(m_pContourEngine==NULL) ||
		(!GetSolidStress(mkey.key.elem_k, sstrs_d))) {
		return;
	}

	gm->m_pGPSCtrl->XGL_Begin_Diagram(ekey,FALSE); // 20060224 Changkeun

	int nThkLine = GetVectorLineWidth();

	if (gm->m_bGradient) {
		p1_pen.CreatePen(PS_SOLID, nThkLine, m_pContourEngine->GetValueColorGrad(sstrs_d.dblStress[0][6]));
		p2_pen.CreatePen(PS_SOLID, nThkLine, m_pContourEngine->GetValueColorGrad(sstrs_d.dblStress[0][7]));
		p3_pen.CreatePen(PS_SOLID, nThkLine, m_pContourEngine->GetValueColorGrad(sstrs_d.dblStress[0][8]));
	}
	else {
		p1_pen.CreatePen(PS_SOLID, nThkLine, m_pContourEngine->GetValueColor(sstrs_d.dblStress[0][6]));
		p2_pen.CreatePen(PS_SOLID, nThkLine, m_pContourEngine->GetValueColor(sstrs_d.dblStress[0][7]));
		p3_pen.CreatePen(PS_SOLID, nThkLine, m_pContourEngine->GetValueColor(sstrs_d.dblStress[0][8]));
	}

	if (m_bDeformedShapeContour) {
		
		m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, edata);
		node_num = m_pDoc->m_pAttrCtrl->GetNumNode(edata.eltyp, edata.elnod);
		for (i=0;i<node_num;i++) {
			gm->m_pDeformEngine->GetDisplacedPoint(edata.elnod[i], node_p[i]);
		}
		/* 이거 아주 이상하다... 주응력 방향과 상관없이 요소의 로컬축 방향으로 벡터를  잡는다.
		if (node_num == 8)
			m_pDoc->calcPlaneLocalVector(4, node_p, local_vec);
		else
			m_pDoc->calcPlaneLocalVector(3, node_p, local_vec);
		*/
		local_vec[0][0] = sstrs_d.dblStress[0][12];
		local_vec[0][1] = sstrs_d.dblStress[0][13];
		local_vec[0][2] = sstrs_d.dblStress[0][14];
		local_vec[1][0] = sstrs_d.dblStress[0][15];
		local_vec[1][1] = sstrs_d.dblStress[0][16];
		local_vec[1][2] = sstrs_d.dblStress[0][17];
		local_vec[2][0] = sstrs_d.dblStress[0][18];
		local_vec[2][1] = sstrs_d.dblStress[0][19];
		local_vec[2][2] = sstrs_d.dblStress[0][20];

		for (i=0;i<node_num-1;i++) {
			node_p[node_num-1][0] += node_p[i][0];
			node_p[node_num-1][1] += node_p[i][1];
			node_p[node_num-1][2] += node_p[i][2];
		}
		pnt_c.x = node_p[node_num-1][0] / ((double) node_num);
		pnt_c.y = node_p[node_num-1][1] / ((double) node_num);
		pnt_c.z = node_p[node_num-1][2] / ((double) node_num);
	}
	else {
		local_vec[0][0] = sstrs_d.dblStress[0][12];
		local_vec[0][1] = sstrs_d.dblStress[0][13];
		local_vec[0][2] = sstrs_d.dblStress[0][14];
		local_vec[1][0] = sstrs_d.dblStress[0][15];
		local_vec[1][1] = sstrs_d.dblStress[0][16];
		local_vec[1][2] = sstrs_d.dblStress[0][17];
		local_vec[2][0] = sstrs_d.dblStress[0][18];
		local_vec[2][1] = sstrs_d.dblStress[0][19];
		local_vec[2][2] = sstrs_d.dblStress[0][20];

		m_pDoc->calcCenterElem(mkey.key.elem_k, pnt_c.x, pnt_c.y, pnt_c.z);

	}

	// Point 1
	CUtilFuncs::GetVectorDirectionPoint(local_vec[0], fabs(sstrs_d.dblStress[0][6]),
										m_VectorAdjustFactor*m_VectorScaleFactor, pnt_c, pnt_p1);
	// Arrow Point 11
	CUtilFuncs::GetVectorDirectionPoint(local_vec[0], -sstrs_d.dblStress[0][6]*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, pnt_p1, arr_p11);
	CUtilFuncs::GetVectorDirectionPoint(local_vec[1], fabs(sstrs_d.dblStress[0][6])*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, arr_p11, arr_p11);
	// Arrow Point 12
	CUtilFuncs::GetVectorDirectionPoint(local_vec[0], -sstrs_d.dblStress[0][6]*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, pnt_p1, arr_p12);
	CUtilFuncs::GetVectorDirectionPoint(local_vec[1], -fabs(sstrs_d.dblStress[0][6])*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, arr_p12, arr_p12);

	// Point 2
	CUtilFuncs::GetVectorDirectionPoint(local_vec[1], fabs(sstrs_d.dblStress[0][7]),
										m_VectorAdjustFactor*m_VectorScaleFactor, pnt_c, pnt_p2);
	// Arrow Point 21
	CUtilFuncs::GetVectorDirectionPoint(local_vec[1], -sstrs_d.dblStress[0][7]*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, pnt_p2, arr_p21);
	CUtilFuncs::GetVectorDirectionPoint(local_vec[0], fabs(sstrs_d.dblStress[0][7])*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, arr_p21, arr_p21);
	// Arrow Point 22
	CUtilFuncs::GetVectorDirectionPoint(local_vec[1], -sstrs_d.dblStress[0][7]*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, pnt_p2, arr_p22);
	CUtilFuncs::GetVectorDirectionPoint(local_vec[0], -fabs(sstrs_d.dblStress[0][7])*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, arr_p22, arr_p22);

	// Point 3
	CUtilFuncs::GetVectorDirectionPoint(local_vec[2], fabs(sstrs_d.dblStress[0][8]),
										m_VectorAdjustFactor*m_VectorScaleFactor, pnt_c, pnt_p3);
	// Arrow Point 31
	CUtilFuncs::GetVectorDirectionPoint(local_vec[2], -sstrs_d.dblStress[0][8]*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, pnt_p3, arr_p31);
	CUtilFuncs::GetVectorDirectionPoint(local_vec[1], -fabs(sstrs_d.dblStress[0][8])*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, arr_p31, arr_p31);
	CUtilFuncs::GetVectorDirectionPoint(local_vec[0], fabs(sstrs_d.dblStress[0][8])*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, arr_p31, arr_p31);
	// Arrow Point 32
	CUtilFuncs::GetVectorDirectionPoint(local_vec[2], -sstrs_d.dblStress[0][8]*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, pnt_p3, arr_p32);
	CUtilFuncs::GetVectorDirectionPoint(local_vec[1], fabs(sstrs_d.dblStress[0][8])*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, arr_p32, arr_p32);
	CUtilFuncs::GetVectorDirectionPoint(local_vec[0], -fabs(sstrs_d.dblStress[0][8])*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, arr_p32, arr_p32);

	// Arrow of P1
	old_pen = (CPen *) pDC->SelectObject(&p1_pen);
	if(!gm->m_bVirtualMode&& !gm->m_bAnimation)
		old_pen2 = (CPen *) dc.SelectObject(&p1_pen);
	
	DrawVectorArrow(pDC,&dc,pnt_c,pnt_p1,arr_p11,arr_p12,mkey.key.mirror_k);

	// Arrow of P2
	pDC->SelectObject(&p2_pen);
	if(!gm->m_bVirtualMode&& !gm->m_bAnimation)
		dc.SelectObject(&p2_pen);

	DrawVectorArrow(pDC,&dc,pnt_c,pnt_p2,arr_p21,arr_p22,mkey.key.mirror_k);  

	// Arrow of P3
	pDC->SelectObject(&p3_pen);
	if(!gm->m_bVirtualMode&& !gm->m_bAnimation)
		dc.SelectObject(&p3_pen);

	DrawVectorArrow(pDC,&dc,pnt_c,pnt_p3,arr_p31,arr_p32,mkey.key.mirror_k);

	pDC->SelectObject(old_pen);
	if(!gm->m_bVirtualMode&& !gm->m_bAnimation)
		dc.SelectObject(old_pen);
	p1_pen.DeleteObject();
	p2_pen.DeleteObject();
	p3_pen.DeleteObject();

	gm->m_pGPSCtrl->XGL_End_Elem(FALSE); // 20060224 Changkeun
}

#if defined(__OLD_OUTPUT_VALUE)
void CStressEngine::OutputSStrsNumbers(CDC *pDC)
{
	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;
	
	int				i, j, elem_num, node_in_elem;
	T_ELEM_K		ekey;
	T_ELEM_D		edata;
	T_NODE_D		node_d;
	T_STRS_D		sstrs_d;
	C3DPoint		node[8],DrawPoint,Node;
	CPoint      DrawPoint2d;
	CPoint			text_p;
	TCHAR			fmt_str[10], text_str[512];
	CFont			ft, *old_ft;

	if (!m_bSStrsDataSet)
		return;

	if (gm->m_DOPT.TX.m_bNumberOpaque)
		pDC->SetBkMode(OPAQUE);
	else
		pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
	pDC->SetBkColor(gm->m_DOPT.TX.m_NumberBackCol);
	pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);

	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T("%s%de"), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T("%s%df"), _T("%."), gm->m_NumberDecimalPoint);

	if (gm->m_DOPT.TX.m_bNumberSelOnly) {
	}
	else {
		//elem_num = gm->m_EKeyListActive.GetSize();
		BOOL bGrpFltMode=gm->m_pGPSCtrl->IsGroupFilterMode();
		if(!bGrpFltMode)elem_num = gm->m_EKeyListActive.GetSize();
		else            elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize(); 

	 	gm->SetNumberFontOrientation(0);
		ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
		old_ft = (CFont *) pDC->SelectObject(&ft);

		for (i=0;i<elem_num;i++) {
			//ekey = gm->m_EKeyListActive[i];
			if(!bGrpFltMode)ekey = gm->m_EKeyListActive[i];
			else            ekey = gm->m_pDispFilter->m_aGrpEKey[i]; 

			if(!gm->m_pGPSCtrl->IsActiveElem(ekey))
				continue;

			m_pDoc->m_pAttrCtrl->GetElem(ekey, edata);

			if (!m_pDoc->m_pAttrCtrl->IsSolidType(edata.eltyp))
				continue;
			node_in_elem = m_pDoc->m_pAttrCtrl->GetNumNode(edata.eltyp, edata.elnod);

			for (j=0;j<node_in_elem;j++) 
			{
				m_pDoc->m_pAttrCtrl->GetNode(edata.elnod[j], node_d);
			  if (m_bDeformedShapeContour)
				{
					Node.x = node_d.x; Node.y = node_d.y; Node.z = node_d.z;
					node[j] = gm->m_pDeformEngine->GetDisplacedPoint(edata.elnod[j], Node);
				}
				else
					node[j].Set(node_d.x, node_d.y, node_d.z);
			}

		
			GetSolidStress(ekey, sstrs_d);
				for (j=0;j<node_in_elem-1;j++) {
				node[node_in_elem-1].x += node[j].x;
				node[node_in_elem-1].y += node[j].y;
				node[node_in_elem-1].z += node[j].z;
			}
			
			DrawPoint.x =  (node[node_in_elem-1].x/((double) node_in_elem));
			DrawPoint.y =  (node[node_in_elem-1].y/((double) node_in_elem));
			DrawPoint.z =  (node[node_in_elem-1].z/((double) node_in_elem));

			double MaxStr = GetMaxElemSStrs(sstrs_d, gm->m_nValOpt == 1, node_in_elem);
			double MinStr = GetMinElemSStrs(sstrs_d, gm->m_nValOpt == 1, node_in_elem);
			double dAbsMaxStr = (fabs(MaxStr) > fabs(MinStr))? MaxStr:MinStr;
		
			/////////////////////////////////////////////////////////////////////////////////////////////
			if(gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
			{
				double dLimit = (m_dMaxValue-m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;
		
				switch(gm->m_DOPT.TX.m_nOutputMinMaxType)
				{
				case 0: // Min & Max
					if((m_dMaxValue-MaxStr) <= dLimit)
						 DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,MaxStr);
					else if((MinStr-m_dMinValue) <= dLimit)
						 DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,MinStr);
					break;
				case 1: // Abs Max
					if(fabs(m_dMaxValue) >= fabs(m_dMinValue))
					{
						if( fabs(m_dMaxValue)-fabs(dAbsMaxStr) <= dLimit)
						DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dAbsMaxStr);
					}
					else
					{
						if( fabs(m_dMinValue)-fabs(dAbsMaxStr) <= dLimit)
						DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dAbsMaxStr);
					}
					break;
				case 2: // Max
					if((m_dMaxValue-MaxStr) <= dLimit)
						 DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,MaxStr);
					break;
				case 3: // Min
					if((MinStr-m_dMinValue) <= dLimit)
						 DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,MinStr);
					break;
				}
			//////////////////////////////////////////////////////////////////////////////////////
			}
			else
			{
				if (gm->m_bVirtualMode)
			    text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(DrawPoint);
		    else
			    text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(DrawPoint);
			 
		    
			  if (fabs(MaxStr) > fabs(MinStr))
				  _stprintf(text_str, fmt_str, MaxStr);
			  else
				  _stprintf(text_str, fmt_str, MinStr);
				if(text_p.x>=0 && text_p.y>=0)
			    pDC->TextOut(text_p.x, text_p.y, text_str);
			}
		}
		pDC->SelectObject(old_ft);
		ft.DeleteObject();
	}
}
#else
void CStressEngine::OutputSStrsNumbers(CDC* pDC)
{
	I_GPSModel* gm = (I_GPSModel*)m_pGPSModel;

	int				i, j, elem_num, node_in_elem;
	T_ELEM_K		ekey;
	T_ELEM_D		edata;
	T_NODE_D		node_d;
	T_STRS_D		sstrs_d;
	C3DPoint		node[8], DrawPoint, Node;
	CPoint      DrawPoint2d;
	CPoint			text_p;
	TCHAR			fmt_str[10], text_str[512];
	CFont			ft, * old_ft;

	if (!m_bSStrsDataSet)
		return;

	GPostTextOut TextOutModel;
	TextOutModel.SetDC(pDC);
	TextOutModel.StartSolidStressVal();
	TextOutModel.SettingSolidStress(gm);

	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T("%s%de"), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T("%s%df"), _T("%."), gm->m_NumberDecimalPoint);

	if (gm->m_DOPT.TX.m_bNumberSelOnly) {
	}
	else {
		//elem_num = gm->m_EKeyListActive.GetSize();
		BOOL bGrpFltMode = gm->m_pGPSCtrl->IsGroupFilterMode();
		if (!bGrpFltMode)elem_num = gm->m_EKeyListActive.GetSize();
		else            elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize();

		TextOutModel.Font4SolidStress(gm, 0);

		for (i = 0; i < elem_num; i++) {
			//ekey = gm->m_EKeyListActive[i];
			if (!bGrpFltMode)ekey = gm->m_EKeyListActive[i];
			else            ekey = gm->m_pDispFilter->m_aGrpEKey[i];

			if (!gm->m_pGPSCtrl->IsActiveElem(ekey))
				continue;

			m_pDoc->m_pAttrCtrl->GetElem(ekey, edata);

			if (!m_pDoc->m_pAttrCtrl->IsSolidType(edata.eltyp))
				continue;
			node_in_elem = m_pDoc->m_pAttrCtrl->GetNumNode(edata.eltyp, edata.elnod);

			for (j = 0; j < node_in_elem; j++)
			{
				m_pDoc->m_pAttrCtrl->GetNode(edata.elnod[j], node_d);
				if (m_bDeformedShapeContour)
				{
					Node.x = node_d.x; Node.y = node_d.y; Node.z = node_d.z;
					node[j] = gm->m_pDeformEngine->GetDisplacedPoint(edata.elnod[j], Node);
				}
				else
					node[j].Set(node_d.x, node_d.y, node_d.z);
			}


			GetSolidStress(ekey, sstrs_d);
			for (j = 0; j < node_in_elem - 1; j++) {
				node[node_in_elem - 1].x += node[j].x;
				node[node_in_elem - 1].y += node[j].y;
				node[node_in_elem - 1].z += node[j].z;
			}

			DrawPoint.x = (node[node_in_elem - 1].x / ((double)node_in_elem));
			DrawPoint.y = (node[node_in_elem - 1].y / ((double)node_in_elem));
			DrawPoint.z = (node[node_in_elem - 1].z / ((double)node_in_elem));

			double MaxStr = GetMaxElemSStrs(sstrs_d, gm->m_nValOpt == 1, node_in_elem);
			double MinStr = GetMinElemSStrs(sstrs_d, gm->m_nValOpt == 1, node_in_elem);
			double dAbsMaxStr = (fabs(MaxStr) > fabs(MinStr)) ? MaxStr : MinStr;

			/////////////////////////////////////////////////////////////////////////////////////////////
			if (gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
			{
				double dLimit = (m_dMaxValue - m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;

				switch (gm->m_DOPT.TX.m_nOutputMinMaxType)
				{
				case 0: // Min & Max
					if ((m_dMaxValue - MaxStr) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, MaxStr);
					else if ((MinStr - m_dMinValue) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, MinStr);
					break;
				case 1: // Abs Max
					if (fabs(m_dMaxValue) >= fabs(m_dMinValue))
					{
						if (fabs(m_dMaxValue) - fabs(dAbsMaxStr) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, dAbsMaxStr);
					}
					else
					{
						if (fabs(m_dMinValue) - fabs(dAbsMaxStr) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, dAbsMaxStr);
					}
					break;
				case 2: // Max
					if ((m_dMaxValue - MaxStr) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, MaxStr);
					break;
				case 3: // Min
					if ((MinStr - m_dMinValue) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, MinStr);
					break;
				}
				//////////////////////////////////////////////////////////////////////////////////////
			}
			else
			{
				if (gm->m_bVirtualMode)
					text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(DrawPoint);
				else
					text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(DrawPoint);


				if (fabs(MaxStr) > fabs(MinStr))
					_stprintf(text_str, fmt_str, MaxStr);
				else
					_stprintf(text_str, fmt_str, MinStr);
				if (text_p.x >= 0 && text_p.y >= 0)
					TextOutModel.TextOutSolidStress(text_p.x, text_p.y, text_str);
			}
		}
		TextOutModel.DeleteFont();
	}
}
#endif
////////////////////////////////////////////////////////////////////////////////////////
// Initialization and Utility Routines for Plane Strain Member Stress    //////////////
////////////////////////////////////////////////////////////////////////////////////////
double CStressEngine::CalcPnStrsValue(T_STPN_D &pnstrs_d, int node)
{
	double	len=0.0;

	switch(m_PnStrsComponent) 
	{
	case SSTRS_COMPONENT_SIGXX:
	case SSTRS_COMPONENT_SIGX:
		len = pnstrs_d.dblStress[node][0];
		break;
	case SSTRS_COMPONENT_SIGYY:
	case SSTRS_COMPONENT_SIGY:
		len = pnstrs_d.dblStress[node][1];
		break;
	case SSTRS_COMPONENT_SIGZZ:
	case SSTRS_COMPONENT_SIGZ:
		len = pnstrs_d.dblStress[node][2];
		break;
	case SSTRS_COMPONENT_LOCSIGXY:
	case SSTRS_COMPONENT_SIGXY:
		len = pnstrs_d.dblStress[node][3];
		break;
	case SSTRS_COMPONENT_LOCSIGYZ:
	case SSTRS_COMPONENT_SIGYZ:
		len = pnstrs_d.dblStress[node][4];
		break;
	case SSTRS_COMPONENT_SIGXZ:
		len = pnstrs_d.dblStress[node][5];
		break;
	case SSTRS_COMPONENT_SIGP1:
		len = pnstrs_d.dblStress[node][6];
		break;
	case SSTRS_COMPONENT_SIGP2:
		len = pnstrs_d.dblStress[node][7];
		break;
	case SSTRS_COMPONENT_SIGP3:
		len = pnstrs_d.dblStress[node][8];
		break;
	case SSTRS_COMPONENT_SHRMAX:
		len = pnstrs_d.dblStress[node][9];
		break;
	case SSTRS_COMPONENT_SIGEFF:
		len = pnstrs_d.dblStress[node][10];
		break;
	case SSTRS_COMPONENT_SIGMAX:
		if(fabs(pnstrs_d.dblStress[node][6]) > fabs(pnstrs_d.dblStress[node][7]))
			len = pnstrs_d.dblStress[node][6];
		else
			len = pnstrs_d.dblStress[node][7];
		if(fabs(len) < fabs(pnstrs_d.dblStress[node][8]))
			len = pnstrs_d.dblStress[node][8];
		break; 
	}
	return len;
}

void CStressEngine::SetPnStrsComponent(T_STPN_D &pnstrs_d, int node, double strs_val)
{
	switch(m_PnStrsComponent) 
	{
	case SSTRS_COMPONENT_SIGXX:
	case SSTRS_COMPONENT_SIGX:
		pnstrs_d.dblStress[node][0] = strs_val;
		break;
	case SSTRS_COMPONENT_SIGYY:
	case SSTRS_COMPONENT_SIGY:
		pnstrs_d.dblStress[node][1] = strs_val;
		break;
	case SSTRS_COMPONENT_SIGZZ:
	case SSTRS_COMPONENT_SIGZ:
		pnstrs_d.dblStress[node][2] = strs_val;
		break;
	case SSTRS_COMPONENT_LOCSIGXY:
	case SSTRS_COMPONENT_SIGXY:
		pnstrs_d.dblStress[node][3] = strs_val;
		break;
	case SSTRS_COMPONENT_LOCSIGYZ:
	case SSTRS_COMPONENT_SIGYZ:
		pnstrs_d.dblStress[node][4] = strs_val;
		break;
	case SSTRS_COMPONENT_LOCSIGXZ:
	case SSTRS_COMPONENT_SIGXZ:
		pnstrs_d.dblStress[node][5] = strs_val;
		break;
	case SSTRS_COMPONENT_SIGP1:
		pnstrs_d.dblStress[node][6] = strs_val;
		break;
	case SSTRS_COMPONENT_SIGP2:
		pnstrs_d.dblStress[node][7] = strs_val;
		break;
	case SSTRS_COMPONENT_SIGP3:
		pnstrs_d.dblStress[node][8] = strs_val;
		break;
	case SSTRS_COMPONENT_SHRMAX:
		pnstrs_d.dblStress[node][9] = strs_val;
		break;
	case SSTRS_COMPONENT_SIGEFF:
		pnstrs_d.dblStress[node][10] = strs_val;
		break;
	}
}

double CStressEngine::GetMaxElemPnStrs(T_STPN_D &pnstrs_d, BOOL bCenter, int node_num)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	double		len, max=-DBL_MAX;

	if (m_PnStrsComponent == SSTRS_COMPONENT_VECTOR) 
	{
		if (max < pnstrs_d.dblStress[0][6]) 
		{
			max = pnstrs_d.dblStress[0][6];
		}
		if (max < pnstrs_d.dblStress[0][7]) 
		{
			max = pnstrs_d.dblStress[0][7];
		}
		if (max < pnstrs_d.dblStress[0][8])
		{
			max = pnstrs_d.dblStress[0][8];
		}
	}
	else 
	{
		if(bCenter)
		{
			len = CalcPnStrsValue(pnstrs_d, 0);
			if (max < len) 
			{
				max = len;
			}
		}
		else
		{
			for (int i=0;i<node_num;i++) 
			{
				len = CalcPnStrsValue(pnstrs_d, i+1);
				if (max < len) 
				{
					max = len;
				}
			}
		}
	}

	return max;
}

double CStressEngine::GetMinElemPnStrs(T_STPN_D &pnstrs_d, BOOL bCenter, int node_num)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	double		len, min=DBL_MAX;

	if (m_PnStrsComponent == SSTRS_COMPONENT_VECTOR) 
	{
		if (min > pnstrs_d.dblStress[0][6])
		{
			min = pnstrs_d.dblStress[0][6];
		}
		if (min > pnstrs_d.dblStress[0][7]) 
		{
			min = pnstrs_d.dblStress[0][7];
		}
		if (min > pnstrs_d.dblStress[0][8]) 
		{
			min = pnstrs_d.dblStress[0][8];
		}
	}
	else
	{
		if(bCenter)
		{
			len = CalcPnStrsValue(pnstrs_d, 0);
			if (min > len)
			{
				min = len;
			}
		}
		else
		{
			for (int i=0;i<node_num;i++) 
			{
				len = CalcPnStrsValue(pnstrs_d, i+1);
				if (min > len)
				{
					min = len;
				}
			}
		}
	}

	return min;
}

BOOL CStressEngine::IsWithinRangeElemPnStrs(T_STPN_D &StpnD,int node_num,double& max_stpn,double& min_stpn)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	double len_max = GetMaxElemPnStrs(StpnD, gm->m_bElemCenter, node_num);
	double len_min = GetMinElemPnStrs(StpnD, gm->m_bElemCenter, node_num);

	if (len_min <= min_stpn && len_max >= max_stpn)
		return TRUE;
	if (len_min >= min_stpn && len_min <= max_stpn)
		return TRUE;
	if (len_max >= min_stpn && len_max <= max_stpn)
		return TRUE;

	return FALSE;
}

// Plane Strain Key List 중 현재 Active인 것들의 List를 구한다.
void CStressEngine::GetActivePnList()
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	
	int			i, elem_num;
	
	T_ELEM_K	elem_key;
	T_ELEM_D  elem_data;	
	m_PnKeyList.RemoveAll();
	elem_num = gm->m_EKeyListActive.GetSize(); 
	
	for (i=0;i<elem_num;i++) 
	{
		elem_key = gm->m_EKeyListActive[i];
		
		m_pDoc->m_pAttrCtrl->GetElem(elem_key, elem_data);
		if (m_pDoc->m_pAttrCtrl->IsPlstrn(elem_data.eltyp))
			m_PnKeyList.Add(elem_key);
	}
}

void CStressEngine::InitVectorAdjustFactorPn()
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	C3DPoint	min_pm, max_pm, min_pe, max_pe;
	double		max_lm, max_le, max_l;

	if(m_bLockAdjFactor)
		return;

	if (!m_pDoc->m_pAttrCtrl->ExistElem(m_KeyMaxPnStrsElem)) {
		m_VectorAdjustFactor = 1.0;
		return;
	}

	// 전체 모델의 Range와 최대값이 발생한 요소의 Range를 동시에 고려한다.

/*	m_pDoc->calcRangeModel(min_pm.x, min_pm.y, min_pm.z,
								   max_pm.x, max_pm.y, max_pm.z,
								   NULL, NULL, TRUE, NULL, TRUE,
								   gm->m_bFrameThick||gm->m_bPlaneThick);*/
		
	gm->GetRangeModel(&min_pm,&max_pm);
	max_lm = max(max(max_pm.x-min_pm.x, max_pm.y-min_pm.y), max_pm.z-min_pm.z);

	gm->GetRangeElement(m_KeyMaxPnStrsElem, &min_pe, &max_pe);
	max_le = max(max(max_pe.x-min_pe.x, max_pe.y-min_pe.y), max_pe.z-min_pe.z);

	if (m_MaxAbsValue > -1e-15 && m_MaxAbsValue < 1e-15)
		m_MaxAbsValue = 1.0f;

	if ((max_le*0.35) < (max_lm/40.0)) {
		max_l = max_lm/40.0;
	}
	else {
		max_l = max_le*0.35;
	}

	m_VectorAdjustFactor = max_l / m_MaxAbsValue;
}

double CStressEngine::CalcPlstrnValue(T_PLSTRN_OUTVAL_D& Data, int node, int nSurface)
{
	double	len;
	int nOffset = 9 * nSurface;
	int nOffsetDR = 3 * nSurface;

	double dStrain[5][20] = {0.,};
	if(m_PlstrnType!=2)
	{
		memcpy(dStrain, m_PlstrnType==0? Data.GslhDG.dStrain : Data.PslhDG.dStrain, sizeof(dStrain));
	}

	switch (m_PlstrnComponent) 
	{
	case PLTSL_COMPONENT_STNXX:
		len = dStrain[node][0+nOffset];
		break;
	case PLTSL_COMPONENT_STNYY:
		len = dStrain[node][1+nOffset];
		break;
	case PLTSL_COMPONENT_STNZZ:
		len = dStrain[node][2+nOffset];
		break;
	case PLTSL_COMPONENT_STNXY:
		len = dStrain[node][3+nOffset];
		break;
	case PLTSL_COMPONENT_STNYZ:
		len = dStrain[node][4+nOffset];
		break;
	case PLTSL_COMPONENT_STNXZ:
		len = dStrain[node][5+nOffset];
		break;
	case PLTSL_COMPONENT_STNMAX:
		len = dStrain[node][6+nOffset];
		break;
	case PLTSL_COMPONENT_STNMIN:
		len = dStrain[node][7+nOffset];
		break;
	case PLTSL_COMPONENT_SHRMAX:
		len = dStrain[node][18+nSurface] ;
		break;
	case PLTSL_COMPONENT_STNX:
		len = dStrain[node][0+nOffset];
		break;
	case PLTSL_COMPONENT_STNY:
		len = dStrain[node][1+nOffset];
		break;
	case PLTSL_COMPONENT_STNLXY:
		len = dStrain[node][3+nOffset];
		break;
	case PLTSL_COMPONENT_VECTOR:
		ASSERT(0);
		len = dStrain[node][3+nOffset];
		break;

	case PLTSL_COMPONENT_COMP:
		len = Data.PdidD.dDamage[node][0+nOffsetDR];
		break;
	case PLTSL_COMPONENT_TENS:
		len = Data.PdidD.dDamage[node][1+nOffsetDR];
		break;
	case PLTSL_COMPONENT_TOTAL:
		len = Data.PdidD.dDamage[node][2+nOffsetDR];
		break;
	}

	return len;
}

double CStressEngine::GetMaxElemPlstrn(T_PLSTRN_OUTVAL_D& Data, int node_num, BOOL bPlate_both)
{
	double len=0., max=-DBL_MAX;

	if(m_PlstrnComponent == PLTSL_COMPONENT_VECTOR) 
	{
		if(m_nPlstrnValueOpt == PLTSL_VALUE_OPT_MAX)
		{
			switch (m_PlstrnType)
			{
			case 0:
				for(int i=0; i<5; i++)
				{
					max = __max(max, Data.GslhDG.dStrain[i][6]);
					max = __max(max, Data.GslhDG.dStrain[i][7]);
				}
				break;
			case 1:
				for(int i=0; i<5; i++)
				{
					max = __max(max, Data.PslhDG.dStrain[i][6]);
					max = __max(max, Data.PslhDG.dStrain[i][7]);
				}
				break;
			case 2:
				break;

			default:
				break;
			}
		}
		else
		{
			switch (m_PlstrnType)
			{
			case 0:
				max = __max(max, Data.GslhDG.dStrain[0][6]);
				max = __max(max, Data.GslhDG.dStrain[0][7]);
				break;
			case 1:
				max = __max(max, Data.PslhDG.dStrain[0][6]);
				max = __max(max, Data.PslhDG.dStrain[0][7]);
				break;
			case 2:
				break;

			default:
				break;
			}
		}
	}
	else 
	{
		for (int i=0;i<node_num;i++) 
		{
			len = CalcPlstrnValue(Data, i+1,0);
			max = __max(max, len);
		}
	}

	if(bPlate_both) // plate both surface 일 때 bottom 
	{
		if (m_PlstrnComponent == PLTSL_COMPONENT_VECTOR)
		{
			if(m_nPlstrnValueOpt == PLTSL_VALUE_OPT_MAX)
			{
				switch (m_PlstrnType)
				{
				case 0:
					for(int i=0; i<5; i++)
					{
						max = __max(max, Data.GslhDG.dStrain[i][16]);
						max = __max(max, Data.GslhDG.dStrain[i][17]);
					}
					break;
				case 1:
					for(int i=0; i<5; i++)
					{
						max = __max(max, Data.PslhDG.dStrain[i][16]);
						max = __max(max, Data.PslhDG.dStrain[i][17]);
					}
					break;
				case 2:
					break;

				default:
					break;
				}
			}
			else
			{
				switch (m_PlstrnType)
				{
				case 0:
					max = __max(max, Data.GslhDG.dStrain[0][16]);
					max = __max(max, Data.GslhDG.dStrain[0][17]);
					break;
				case 1:
					max = __max(max, Data.PslhDG.dStrain[0][16]);
					max = __max(max, Data.PslhDG.dStrain[0][17]);
					break;
				case 2:
					break;

				default:
					break;
				}
			}
		}
		else
		{
			for (int i=0;i<node_num;i++)
			{
				len = CalcPlstrnValue(Data, i+1,1); 
				max = __max(max, len);
			}
		}
	}

	return max;
}

double CStressEngine::GetMinElemPlstrn(T_PLSTRN_OUTVAL_D& Data, int node_num, BOOL bPlate_both)
{
	double len=0., min=DBL_MAX;

	if(m_PlstrnComponent == PLTSL_COMPONENT_VECTOR) 
	{
		if(m_nPlstrnValueOpt == PLTSL_VALUE_OPT_MAX)
		{
			switch (m_PlstrnType)
			{
			case 0:
				for(int i=0; i<5; i++)
				{
					min = __min(min, Data.GslhDG.dStrain[i][6]);
					min = __min(min, Data.GslhDG.dStrain[i][7]);
				}
				break;
			case 1:
				for(int i=0; i<5; i++)
				{
					min = __min(min, Data.PslhDG.dStrain[i][6]);
					min = __min(min, Data.PslhDG.dStrain[i][7]);
				}
				break;
			case 2:
				break;

			default:
				break;
			}
		}
		else
		{
			switch (m_PlstrnType)
			{
			case 0:
				min = __min(min, Data.GslhDG.dStrain[0][6]);
				min = __min(min, Data.GslhDG.dStrain[0][7]);
				break;
			case 1:
				min = __min(min, Data.PslhDG.dStrain[0][6]);
				min = __min(min, Data.PslhDG.dStrain[0][7]);
				break;
			case 2:
				break;

			default:
				break;
			}
		}
	}
	else 
	{
		for (int i=0;i<node_num;i++) 
		{
			len = CalcPlstrnValue(Data, i+1,0);
			min = __min(min, len);
		}
	}

	if(bPlate_both) // plate both surface 일 때 bottom 
	{
		if (m_PlstrnComponent == PLTSL_COMPONENT_VECTOR)
		{
			if(m_nPlstrnValueOpt == PLTSL_VALUE_OPT_MAX)
			{
				switch (m_PlstrnType)
				{
				case 0:
					for(int i=0; i<5; i++)
					{
						min = __min(min, Data.GslhDG.dStrain[i][16]);
						min = __min(min, Data.GslhDG.dStrain[i][17]);
					}
					break;
				case 1:
					for(int i=0; i<5; i++)
					{
						min = __min(min, Data.PslhDG.dStrain[i][16]);
						min = __min(min, Data.PslhDG.dStrain[i][17]);
					}
					break;
				case 2:
					break;

				default:
					break;
				}
			}
			else
			{
				switch (m_PlstrnType)
				{
				case 0:
					min = __min(min, Data.GslhDG.dStrain[0][16]);
					min = __min(min, Data.GslhDG.dStrain[0][17]);
					break;
				case 1:
					min = __min(min, Data.PslhDG.dStrain[0][16]);
					min = __min(min, Data.PslhDG.dStrain[0][17]);
					break;
				case 2:
					break;

				default:
					break;
				}
			}
		}
		else
		{
			for (int i=0;i<node_num;i++)
			{
				len = CalcPlstrnValue(Data, i+1,1); 
				min = __min(min, len);
			}
		}
	}

	return min;
}

BOOL CStressEngine::IsWithinRangeElemPlstrn(T_PLSTRN_OUTVAL_D& Data, int node_num,BOOL bPlate_both,double& max_value,double& min_value)
{
	double len_max = GetMaxElemPlstrn(Data, node_num, bPlate_both);
	double len_min = GetMinElemPlstrn(Data, node_num, bPlate_both);

	if (len_min <= min_value && len_max >= max_value)
		return TRUE;
	if (len_min >= min_value && len_min <= max_value)
		return TRUE;
	if (len_max >= min_value && len_max <= max_value)
		return TRUE;

	return FALSE;
}

void CStressEngine::DrawPlstrnContour(CDC *pDC)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	int			i, elem_num;
	BOOL		fl_bak=gm->m_DOPT.DR.m_bFrameLine;
	T_ELEM_D	elem_d;
	CPen		elem_pen, *old_pen;
	CArray <int, int>				type_list;
	CArray <GRE_Atom, GRE_Atom&>		atom_list;
	BOOL bEscapePressed = FALSE;
	T_MIRE_K mkey;

	if (!gm->m_bContour) { 
		gm->GPSDrawOriginal(pDC);
		return;
	}

	BOOL bExistResult = TRUE;
	if(!CGPSPostCtrl::IsMatlNonlinearAnalysis(gm->m_LoadCaseType)) bExistResult = FALSE;
	int nResVer = CDBLib::Get_BnDataFileVesion();
	if(nResVer<8750) bExistResult = FALSE;

	if (m_PlstrnComponent == PLTSL_COMPONENT_VECTOR)
		InitVectorAdjustFactorPlstrn();

	if (m_bDeformedShapeContour) {
		if (gm->m_pDeformEngine == NULL) {
			return;
		}
		type_list.Add(gm->m_MinOTID + OBJECT_TYPE_DEFORMED);

		// 변형된 그림에 Undeformed Shape을 같이 그릴 경우.
		if (gm->m_DOPT.DR.m_bDrawInactive && (m_PlstrnComponent==PLTSL_COMPONENT_VECTOR)) {
			gm->m_DOPT.DR.m_bFrameLine = TRUE;
			gm->GPSDrawOriginal(pDC, TRUE);
		}
	}
	else {
		type_list.Add(gm->m_MinOTID + OBJECT_TYPE_ORIGINAL);
	}

	elem_pen.CreatePen(PS_SOLID, gm->m_DOPT.DR.nElemHddn, m_pContourEngine->m_ElemColor);
	old_pen = (CPen *) pDC->SelectObject(&elem_pen);

	gm->m_pGPSCtrl->GetZSortedList(type_list, gm->m_EKeyListVisible_Mirror, atom_list);
	elem_num = atom_list.GetSize();

	for (i=0;i<elem_num;i++) 
	{
		if(gm->m_pGPSCtrl->WatchEscKeyPress()) return;
		if (gm->m_pGPSCtrl->IsZoomAllState() ||
			gm->m_pGPSCtrl->IsObjectInClientWindow(atom_list[i].m_OType, atom_list[i].m_OKey)) {
				mkey.keymap = atom_list[i].m_OKey;
				m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d);
				if (bExistResult && m_pDoc->m_pAttrCtrl->IsPlate(elem_d.eltyp) && (gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey)) && !bEscapePressed ) 
				{
					if(m_PlstrnComponent == PLTSL_COMPONENT_VECTOR) 
					{
						// KYE-HONG-20020903 : Hidden Option살려달라고 요구 
						// gm->m_bFrameLine = TRUE;		// Vector를 그릴 경우 Hidden을 끈다
						if (m_bDeformedShapeContour)
							gm->m_pDeformEngine->DrawDeformedElement(pDC, atom_list[i].m_OKey);
						else
							gm->GPSDrawElement(pDC, atom_list[i].m_OKey);
						DoPlstrnElementVector(pDC, atom_list[i].m_OKey);
					}
					else 
					{
						gm->m_DOPT.DR.m_bFrameLine = fl_bak;
						DoPlstrnElementContour(pDC, atom_list[i].m_OKey);
					}
				}
				else 
				{
					if(m_bDeformedShapeContour) gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, atom_list[i].m_OKey);
					else					              gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
				}
		}
	}

	gm->m_DOPT.DR.m_bFrameLine = fl_bak;

	// 변형된 그림에 Undeformed Shape을 같이 그릴 경우.
	if (m_bDeformedShapeContour && gm->m_DOPT.DR.m_bDrawInactive && (m_PlstrnComponent!=PLTSL_COMPONENT_VECTOR)  && !bEscapePressed) {
		int	rf_bak=gm->m_DOPT.DR.m_RenderFlag;
		gm->m_DOPT.DR.m_RenderFlag = 2;
		gm->GPSDrawOriginal(pDC, TRUE);
		gm->m_DOPT.DR.m_RenderFlag = rf_bak;
	}

	pDC->SelectObject(old_pen);
	elem_pen.DeleteObject();


	//----------------------------------------------------------------------
	// UCS Icon Drawing
	//----------------------------------------------------------------------
	if( m_PlstrnVal == PLTSL_VALUE_GLOBAL&& gm->m_bVirtualMode && m_bPrintUCSAxis) 
	{
		double UCS_vector[3][3];
		GetUCSVector(m_NUCS,UCS_vector);
		DrawUCSPlaneIcon(pDC,UCS_vector);
	}
}
#if defined (__OLD_OUTPUT_VALUE)
void CStressEngine::OutputPlstrnNumbers(CDC *pDC)
{
	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;

	int				i, j, elem_num, node_in_elem, v_num;
	T_ELEM_K		ekey;
	T_ELEM_D		edata;
	T_PLSTRN_OUTVAL_D PlStrnD;
	C3DPoint		node[4],DrawPoint;
	CPoint			text_p;
	TCHAR			fmt_str[10], text_str[512];
	CFont			ft, *old_ft;
	double MaxStr,MinStr;

	BOOL			fl_bak;
	POSITION		pos;
	CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray <CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					edge_list;

	if (!m_bPlstrnDataSet)
		return;

	if (gm->m_DOPT.TX.m_bNumberOpaque)
		pDC->SetBkMode(OPAQUE);
	else
		pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
	pDC->SetBkColor(gm->m_DOPT.TX.m_NumberBackCol);
	pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);

	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T("%s%de"), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T("%s%df"), _T("%."), gm->m_NumberDecimalPoint);

	fl_bak = gm->m_DOPT.DR.m_bFrameLine;
	gm->m_DOPT.DR.m_bFrameLine = TRUE;

	if (gm->m_DOPT.TX.m_bNumberSelOnly) {
	}
	else {

		gm->SetNumberFontOrientation(0);
		ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
		old_ft = (CFont *) pDC->SelectObject(&ft);

		//elem_num = gm->m_EKeyListActive.GetSize();
		BOOL bGrpFltMode=gm->m_pGPSCtrl->IsGroupFilterMode();
		if(!bGrpFltMode)elem_num = gm->m_EKeyListActive.GetSize();
		else            elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize(); 

		for (i=0;i<elem_num;i++) 
		{
			//ekey = gm->m_EKeyListActive[i];
			if(!bGrpFltMode)ekey = gm->m_EKeyListActive[i];
			else            ekey = gm->m_pDispFilter->m_aGrpEKey[i]; 

			if(!gm->m_pGPSCtrl->IsActiveElem(ekey))
				continue;

			m_pDoc->m_pAttrCtrl->GetElem(ekey, edata);

			if (!m_pDoc->m_pAttrCtrl->IsPlate(edata.eltyp))
				continue;
			node_in_elem = m_pDoc->m_pAttrCtrl->GetNumNode(edata.eltyp, edata.elnod);

			if (m_bDeformedShapeContour) {
				gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list);
			}
			else {
				gm->GetShapeElement(ekey, polygon_list, &edge_list);
			}

			v_num = polygon_list[0]->GetCount();
			pos = polygon_list[0]->GetHeadPosition();
			for (j=0;j<v_num;j++) 
				node[j] = polygon_list[0]->GetNext(pos);

			if(!GetPlStrain(ekey, PlStrnD)) continue;

			for (j=0;j<v_num-1;j++) {
				node[v_num-1].x += node[j].x;
				node[v_num-1].y += node[j].y;
				node[v_num-1].z += node[j].z;
			}

            BOOL bPlate_both = IsViewPStrsSurfacePlateBoth(edata.eltyp);
			
			DrawPoint.x =  (node[v_num-1].x/((double) v_num));
			DrawPoint.y =  (node[v_num-1].y/((double) v_num));
			DrawPoint.z =  (node[v_num-1].z/((double) v_num));

			switch(m_nPlstrnValueOpt)
			{
			case PLTSL_VALUE_OPT_MAX:
				MaxStr = GetMaxElemPlstrn(PlStrnD, node_in_elem,bPlate_both);
				MinStr = GetMinElemPlstrn(PlStrnD, node_in_elem,bPlate_both);
				break; 
			case PLTSL_VALUE_OPT_CENTER:
				if(m_PlstrnComponent == PLTSL_COMPONENT_VECTOR) 
				{
					MaxStr = GetMaxElemPlstrn(PlStrnD, node_in_elem,bPlate_both);
					MinStr = GetMinElemPlstrn(PlStrnD, node_in_elem,bPlate_both);
				}
				else
				{
					if(m_PlstrnSurface == PLTSL_SURFACE_TOPBOT )
					{
						double dBotCVal,dTopCVal;
						dTopCVal = CalcPlstrnValue(PlStrnD,0,0);
						dBotCVal = CalcPlstrnValue(PlStrnD,0,1);
						MaxStr = MinStr = (fabs(dBotCVal)>fabs(dTopCVal)) ? dBotCVal : dTopCVal;
					}
					else
					{
						MaxStr = MinStr = CalcPlstrnValue(PlStrnD,0,0);
					}
				}
				break; 
			default:
				MaxStr = GetMaxElemPlstrn(PlStrnD, node_in_elem,bPlate_both);
				MinStr = GetMinElemPlstrn(PlStrnD, node_in_elem,bPlate_both);
				break; 
			}

			double dAbsMaxStr = 0.;
			if ((m_PlstrnComponent!=PLTSL_COMPONENT_VECTOR) || (m_bVectorPositive && m_bVectorNegative))
				dAbsMaxStr = (fabs(MaxStr) > fabs(MinStr))? MaxStr:MinStr;
			else if (m_bVectorPositive && MaxStr>0.)
				dAbsMaxStr = fabs(MaxStr);
			else if (m_bVectorNegative && MinStr<0.)
				dAbsMaxStr = fabs(MinStr);

			/////////////////////////////////////////////////////////////////////////////////////////////
			if(gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
			{
				double dLimit = (m_dMaxValue-m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;
				if ((m_PlstrnComponent!=PLTSL_COMPONENT_VECTOR) || (m_bVectorPositive && m_bVectorNegative))
				{
					switch(gm->m_DOPT.TX.m_nOutputMinMaxType)
					{
					case 0: // Min & Max
						if((m_dMaxValue-MaxStr) <= dLimit)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,MaxStr);
						else if((MinStr-m_dMinValue) <= dLimit)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,MinStr);
						break;
					case 1: // Abs Max
						if(fabs(m_dMaxValue) >= fabs(m_dMinValue))
						{
							if( fabs(m_dMaxValue)-fabs(dAbsMaxStr) <= dLimit)
								DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dAbsMaxStr);
						}
						else
						{
							if( fabs(m_dMinValue)-fabs(dAbsMaxStr) <= dLimit)
								DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dAbsMaxStr);
						}
						break;
					case 2: // Max
						if((m_dMaxValue-MaxStr) <= dLimit)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,MaxStr);
						break;
					case 3: // Min
						if((MinStr-m_dMinValue) <= dLimit)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,MinStr);
						break;
					}
				}
				else if (m_bVectorPositive && m_dMaxValue>0.)
				{
					switch(gm->m_DOPT.TX.m_nOutputMinMaxType)
					{
					case 0: // Min & Max
						if((m_dMaxValue-MaxStr) <= dLimit  && MaxStr>0.)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,MaxStr);
						else if((MaxStr-m_dMinValue) <= dLimit && MaxStr>0.)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,MaxStr);           
						break;
					case 1: // Abs Max
						if(fabs(m_dMaxValue)-fabs(dAbsMaxStr) <= dLimit)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dAbsMaxStr);
						break;
					case 2: // Max
						if((m_dMaxValue-MaxStr) <= dLimit && MaxStr>0.)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,MaxStr);
						break;
					case 3: // Min
						if ((MaxStr-m_dMinValue) <= dLimit && MaxStr>0.)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,MaxStr);           
						break;
					}
				}
				else if (m_bVectorNegative && m_dMinValue<0.)
				{
					switch(gm->m_DOPT.TX.m_nOutputMinMaxType)
					{
					case 0: // Min & Max
						if((m_dMaxValue-MinStr) <= dLimit && MinStr<0.)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,MinStr);            
						else if((MinStr-m_dMinValue) <= dLimit && MinStr<0.)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,MinStr);
						break;
					case 1: // Abs Max
						if( fabs(m_dMinValue)-fabs(dAbsMaxStr) <= dLimit)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dAbsMaxStr);
						break;
					case 2: // Max
						if((m_dMaxValue-MinStr) <= dLimit && MinStr<0.)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,MinStr);            
						break;
					case 3: // Min
						if((MinStr-m_dMinValue) <= dLimit && MinStr<0.)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,MinStr);
						break;
					}
				}        
				//////////////////////////////////////////////////////////////////////////////////////
			}
			else
			{
				if (gm->m_bVirtualMode)
					text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(DrawPoint);
				else
					text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(DrawPoint);

				// MNET:XXXX-CJJEONG-20080507
				BOOL  bText = TRUE;
				if (m_bVectorPositive && m_bVectorNegative)
				{
					if (fabs(MaxStr) > fabs(MinStr))
						_stprintf(text_str, fmt_str, MaxStr);
					else
						_stprintf(text_str, fmt_str, MinStr);
				}
				else if (m_bVectorPositive && MaxStr>0.)
					_stprintf(text_str, fmt_str, MaxStr);
				else if (m_bVectorNegative && MinStr<0.)        
					_stprintf(text_str, fmt_str, MinStr);
				else bText = FALSE;

				if(text_p.x>=0 && text_p.y>=0 && bText)
					pDC->TextOut(text_p.x, text_p.y+10, text_str);
			}

			for (j=0;j<polygon_list.GetSize();j++) {
				polygon_list[j]->RemoveAll();
				delete polygon_list[j];
				edge_list[j]->RemoveAll();
				delete edge_list[j];
			}
			polygon_list.RemoveAll();
			edge_list.RemoveAll();
		}
		pDC->SelectObject(old_ft);
		ft.DeleteObject();
	}

	gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}
#else
void CStressEngine::OutputPlstrnNumbers(CDC* pDC)
{
	I_GPSModel* gm = (I_GPSModel*)m_pGPSModel;

	int				i, j, elem_num, node_in_elem, v_num;
	T_ELEM_K		ekey;
	T_ELEM_D		edata;
	T_PLSTRN_OUTVAL_D PlStrnD;
	C3DPoint		node[4], DrawPoint;
	CPoint			text_p;
	TCHAR			fmt_str[10], text_str[512];
	CFont			ft, * old_ft;
	double MaxStr, MinStr;

	BOOL			fl_bak;
	POSITION		pos;
	CArray <CList <C3DPoint, C3DPoint>*, CList <C3DPoint, C3DPoint>*>		polygon_list;
	CArray <CArray <BOOL, BOOL>*, CArray <BOOL, BOOL>*>					edge_list;

	if (!m_bPlstrnDataSet)
		return;

	GPostTextOut TextOutModel;
	TextOutModel.SetDC(pDC);
	TextOutModel.StartPlateStrainVal();
	TextOutModel.SettingPlateStrain(gm);

	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T("%s%de"), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T("%s%df"), _T("%."), gm->m_NumberDecimalPoint);

	fl_bak = gm->m_DOPT.DR.m_bFrameLine;
	gm->m_DOPT.DR.m_bFrameLine = TRUE;

	if (gm->m_DOPT.TX.m_bNumberSelOnly) {
	}
	else {
		TextOutModel.Font4PlateStrain(gm, 0);
		//elem_num = gm->m_EKeyListActive.GetSize();
		BOOL bGrpFltMode = gm->m_pGPSCtrl->IsGroupFilterMode();
		if (!bGrpFltMode)elem_num = gm->m_EKeyListActive.GetSize();
		else            elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize();

		for (i = 0; i < elem_num; i++)
		{
			//ekey = gm->m_EKeyListActive[i];
			if (!bGrpFltMode)ekey = gm->m_EKeyListActive[i];
			else            ekey = gm->m_pDispFilter->m_aGrpEKey[i];

			if (!gm->m_pGPSCtrl->IsActiveElem(ekey))
				continue;

			m_pDoc->m_pAttrCtrl->GetElem(ekey, edata);

			if (!m_pDoc->m_pAttrCtrl->IsPlate(edata.eltyp))
				continue;
			node_in_elem = m_pDoc->m_pAttrCtrl->GetNumNode(edata.eltyp, edata.elnod);

			if (m_bDeformedShapeContour) {
				gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list);
			}
			else {
				gm->GetShapeElement(ekey, polygon_list, &edge_list);
			}

			v_num = polygon_list[0]->GetCount();
			pos = polygon_list[0]->GetHeadPosition();
			for (j = 0; j < v_num; j++)
				node[j] = polygon_list[0]->GetNext(pos);

			if (!GetPlStrain(ekey, PlStrnD)) continue;

			for (j = 0; j < v_num - 1; j++) {
				node[v_num - 1].x += node[j].x;
				node[v_num - 1].y += node[j].y;
				node[v_num - 1].z += node[j].z;
			}

			BOOL bPlate_both = IsViewPStrsSurfacePlateBoth(edata.eltyp);

			DrawPoint.x = (node[v_num - 1].x / ((double)v_num));
			DrawPoint.y = (node[v_num - 1].y / ((double)v_num));
			DrawPoint.z = (node[v_num - 1].z / ((double)v_num));

			switch (m_nPlstrnValueOpt)
			{
			case PLTSL_VALUE_OPT_MAX:
				MaxStr = GetMaxElemPlstrn(PlStrnD, node_in_elem, bPlate_both);
				MinStr = GetMinElemPlstrn(PlStrnD, node_in_elem, bPlate_both);
				break;
			case PLTSL_VALUE_OPT_CENTER:
				if (m_PlstrnComponent == PLTSL_COMPONENT_VECTOR)
				{
					MaxStr = GetMaxElemPlstrn(PlStrnD, node_in_elem, bPlate_both);
					MinStr = GetMinElemPlstrn(PlStrnD, node_in_elem, bPlate_both);
				}
				else
				{
					if (m_PlstrnSurface == PLTSL_SURFACE_TOPBOT)
					{
						double dBotCVal, dTopCVal;
						dTopCVal = CalcPlstrnValue(PlStrnD, 0, 0);
						dBotCVal = CalcPlstrnValue(PlStrnD, 0, 1);
						MaxStr = MinStr = (fabs(dBotCVal) > fabs(dTopCVal)) ? dBotCVal : dTopCVal;
					}
					else
					{
						MaxStr = MinStr = CalcPlstrnValue(PlStrnD, 0, 0);
					}
				}
				break;
			default:
				MaxStr = GetMaxElemPlstrn(PlStrnD, node_in_elem, bPlate_both);
				MinStr = GetMinElemPlstrn(PlStrnD, node_in_elem, bPlate_both);
				break;
			}

			double dAbsMaxStr = 0.;
			if ((m_PlstrnComponent != PLTSL_COMPONENT_VECTOR) || (m_bVectorPositive && m_bVectorNegative))
				dAbsMaxStr = (fabs(MaxStr) > fabs(MinStr)) ? MaxStr : MinStr;
			else if (m_bVectorPositive && MaxStr > 0.)
				dAbsMaxStr = fabs(MaxStr);
			else if (m_bVectorNegative && MinStr < 0.)
				dAbsMaxStr = fabs(MinStr);

			/////////////////////////////////////////////////////////////////////////////////////////////
			if (gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
			{
				double dLimit = (m_dMaxValue - m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;
				if ((m_PlstrnComponent != PLTSL_COMPONENT_VECTOR) || (m_bVectorPositive && m_bVectorNegative))
				{
					switch (gm->m_DOPT.TX.m_nOutputMinMaxType)
					{
					case 0: // Min & Max
						if ((m_dMaxValue - MaxStr) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, MaxStr);
						else if ((MinStr - m_dMinValue) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, MinStr);
						break;
					case 1: // Abs Max
						if (fabs(m_dMaxValue) >= fabs(m_dMinValue))
						{
							if (fabs(m_dMaxValue) - fabs(dAbsMaxStr) <= dLimit)
								DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, dAbsMaxStr);
						}
						else
						{
							if (fabs(m_dMinValue) - fabs(dAbsMaxStr) <= dLimit)
								DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, dAbsMaxStr);
						}
						break;
					case 2: // Max
						if ((m_dMaxValue - MaxStr) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, MaxStr);
						break;
					case 3: // Min
						if ((MinStr - m_dMinValue) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, MinStr);
						break;
					}
				}
				else if (m_bVectorPositive && m_dMaxValue > 0.)
				{
					switch (gm->m_DOPT.TX.m_nOutputMinMaxType)
					{
					case 0: // Min & Max
						if ((m_dMaxValue - MaxStr) <= dLimit && MaxStr > 0.)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, MaxStr);
						else if ((MaxStr - m_dMinValue) <= dLimit && MaxStr > 0.)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, MaxStr);
						break;
					case 1: // Abs Max
						if (fabs(m_dMaxValue) - fabs(dAbsMaxStr) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, dAbsMaxStr);
						break;
					case 2: // Max
						if ((m_dMaxValue - MaxStr) <= dLimit && MaxStr > 0.)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, MaxStr);
						break;
					case 3: // Min
						if ((MaxStr - m_dMinValue) <= dLimit && MaxStr > 0.)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, MaxStr);
						break;
					}
				}
				else if (m_bVectorNegative && m_dMinValue < 0.)
				{
					switch (gm->m_DOPT.TX.m_nOutputMinMaxType)
					{
					case 0: // Min & Max
						if ((m_dMaxValue - MinStr) <= dLimit && MinStr < 0.)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, MinStr);
						else if ((MinStr - m_dMinValue) <= dLimit && MinStr < 0.)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, MinStr);
						break;
					case 1: // Abs Max
						if (fabs(m_dMinValue) - fabs(dAbsMaxStr) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, dAbsMaxStr);
						break;
					case 2: // Max
						if ((m_dMaxValue - MinStr) <= dLimit && MinStr < 0.)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, MinStr);
						break;
					case 3: // Min
						if ((MinStr - m_dMinValue) <= dLimit && MinStr < 0.)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, MinStr);
						break;
					}
				}
				//////////////////////////////////////////////////////////////////////////////////////
			}
			else
			{
				if (gm->m_bVirtualMode)
					text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(DrawPoint);
				else
					text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(DrawPoint);

				// MNET:XXXX-CJJEONG-20080507
				BOOL  bText = TRUE;
				if (m_bVectorPositive && m_bVectorNegative)
				{
					if (fabs(MaxStr) > fabs(MinStr))
						_stprintf(text_str, fmt_str, MaxStr);
					else
						_stprintf(text_str, fmt_str, MinStr);
				}
				else if (m_bVectorPositive && MaxStr > 0.)
					_stprintf(text_str, fmt_str, MaxStr);
				else if (m_bVectorNegative && MinStr < 0.)
					_stprintf(text_str, fmt_str, MinStr);
				else bText = FALSE;

				if (text_p.x >= 0 && text_p.y >= 0 && bText)
					TextOutModel.TextOutPlateStrain(text_p.x, text_p.y + 10, text_str);
			}

			for (j = 0; j < polygon_list.GetSize(); j++) {
				polygon_list[j]->RemoveAll();
				delete polygon_list[j];
				edge_list[j]->RemoveAll();
				delete edge_list[j];
			}
			polygon_list.RemoveAll();
			edge_list.RemoveAll();
		}
		TextOutModel.DeleteFont();
	}
	TextOutModel.EndPlateStrainVal();
	gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}
#endif
BOOL CStressEngine::GetPlstrnRangeDataList(double& dMaxRange, double& dMinRange, CArray<UINT,UINT>& aElemKeyList)
{
	aElemKeyList.RemoveAll();

	if (CTestEnvMgr::IsTestEnvST(_LSX(ProfilingSTL), _LSX(yes)))
	{
		M_PROFILE('GetPlstrnRangeDataList()');
	}

	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	int			  i, nie;
	T_ELEM_K	elem_key;
	T_ELEM_D	elem_data;
	T_PLSTRN_OUTVAL_D PlStrnD;
	BOOL			bPlate_both;
	BOOL			bWithSign = m_pDoc->m_pPostCtrl->GetSignFlag();

	gm->m_pMyView->BeginWaitCursor();

	int elem_num = m_PlateKeyList.GetSize();
	for(i=0;i<elem_num;i++) 
	{
		elem_key = m_PlateKeyList[i];
		if(!m_mapPlStrnData.Lookup(elem_key, PlStrnD)) continue;

		elem_data.Initialize();
		m_pDoc->m_pAttrCtrl->GetElem(elem_key, elem_data);
		nie = m_pDoc->m_pAttrCtrl->GetNumNode(elem_data.eltyp, elem_data.elnod);

		bPlate_both = IsViewPStrsSurfacePlateBoth(elem_data.eltyp);
		
		if(!IsWithinRangeElemPlstrn(PlStrnD,nie,bPlate_both,dMaxRange,dMinRange)) continue;

		aElemKeyList.Add(elem_key);
	}

	gm->m_pMyView->EndWaitCursor();

	return TRUE;
}

void CStressEngine::GetActiveSnList()
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	int			i, elem_num;

	T_ELEM_K	elem_key;
	T_ELEM_D  elem_data;	
	m_PsKeyList.RemoveAll();
	elem_num = gm->m_EKeyListActive.GetSize(); 

	for (i=0;i<elem_num;i++) 
	{
		elem_key = gm->m_EKeyListActive[i];

		m_pDoc->m_pAttrCtrl->GetElem(elem_key, elem_data);
		if (m_pDoc->m_pAttrCtrl->IsPlate(elem_data.eltyp))
			m_PsKeyList.Add(elem_key);
	}
}

void CStressEngine::InitVectorAdjustFactorPlstrn()
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	C3DPoint	min_pm, max_pm, min_pe, max_pe;
	double		max_lm, max_le, max_l;

	if(m_bLockAdjFactor)
		return;

	if (!m_pDoc->m_pAttrCtrl->ExistElem(m_KeyMaxPlstrnElem)) {
		m_VectorAdjustFactor = 1.0;
		return;
	}

	// 전체 모델의 Range와 최대값이 발생한 요소의 Range를 동시에 고려한다.
		
	gm->GetRangeModel(&min_pm,&max_pm);
	max_lm = max(max(max_pm.x-min_pm.x, max_pm.y-min_pm.y), max_pm.z-min_pm.z);

	gm->GetRangeElement(m_KeyMaxPlstrnElem, &min_pe, &max_pe);
	max_le = max(max(max_pe.x-min_pe.x, max_pe.y-min_pe.y), max_pe.z-min_pe.z);

	if (m_MaxAbsValue > -1e-15 && m_MaxAbsValue < 1e-15)
		m_MaxAbsValue = 1.0f;

	if ((max_le*0.35) < (max_lm/40.0)) {
		max_l = max_lm/40.0;
	}
	else {
		max_l = max_le*0.35;
	}

	m_VectorAdjustFactor = max_l / m_MaxAbsValue;
}

BOOL CStressEngine::MakePlstrnDataList()
{
	if (CTestEnvMgr::IsTestEnvST(_LSX(ProfilingSTL), _LSX(yes)))
	{
		M_PROFILE('MakePlstrnDataList()');
	}

	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	if(!gm->m_bLoadDataSet)	return FALSE;

	BOOL bExistResult = TRUE;
	if(!CGPSPostCtrl::IsMatlNonlinearAnalysis(gm->m_LoadCaseType)) bExistResult = FALSE;
	int nResVer = CDBLib::Get_BnDataFileVesion();
	if(nResVer<8750) bExistResult = FALSE;

	int			  i, elem_num, nie;
	double		max_Plstrn=-DBL_MAX, min_Plstrn=DBL_MAX, len;
	double		max_Pdid=-DBL_MAX, min_Pdid=DBL_MAX;
	BOOL		  has_content=FALSE;
	T_ELEM_K	elem_key;
	T_ELEM_D	elem_data;
	T_PLSTRN_OUTVAL_D PlStrnD;
	T_PLSTRN_OUTVAL_D PlStrnD_max, PlStrnD_min;
	BOOL      bPlate_both;
	BOOL   bWithSign = m_pDoc->m_pPostCtrl->GetSignFlag();

	gm->m_pMyView->BeginWaitCursor();

	m_PlateKeyList.RemoveAll();
	m_mapPlStrnData.RemoveAll();
	m_mapNodesInElem.RemoveAll();

	if(bExistResult)
	{
		// Get the Original LoadCombination Data
		T_LCOM_D  LcomOrg=m_pDoc->m_pPostCtrl->GetLoadComb();

		if(m_bAverageNodalActiveOnly || (m_PlstrnAve !=PLTSL_VALUE_AVENODAL))
			elem_num = gm->m_EKeyListActive.GetSize(); // Active된 요소에 대해서만 Average Nodal을 계산.
		else
			elem_num = gm->m_EKeyList.GetSize(); // Average Nodal이 가능하도록...전체 요소를 취한다.

		if(m_PlstrnAve == PLTSL_VALUE_AVENODAL) MakeSerialNodeMap();

		m_mapPstrnBothData.clear();
		m_mapAvgPstrnBothData.clear();

		CMap<T_ELEM_K,T_ELEM_K,T_PLSTRN_OUTVAL_D,T_PLSTRN_OUTVAL_D&> mapPlStrnDataMax,mapPlStrnDataMin;
		mapPlStrnDataMax.InitHashTable(HASHSIZEELEM);
		mapPlStrnDataMin.InitHashTable(HASHSIZEELEM);
		MakePlStrnDataListLcom(LcomOrg,elem_num,1.0,mapPlStrnDataMax,mapPlStrnDataMin);
		for(i=0;i<m_PlateKeyList.GetSize();i++) 
		{
			elem_key = m_PlateKeyList[i];
			mapPlStrnDataMax.Lookup(elem_key, PlStrnD_max);
			mapPlStrnDataMin.Lookup(elem_key, PlStrnD_min);

			switch (gm->m_LoadMinMaxType) 
			{
			case LOADTYPE_NORMAL:
			case LOADTYPE_MAX:
				m_mapPlStrnData.SetAt(elem_key,PlStrnD_max);
				break;
			case LOADTYPE_MIN:
				m_mapPlStrnData.SetAt(elem_key,PlStrnD_min);
				break;
			case LOADTYPE_ALL:
				if(bWithSign)
					PlStrnD_max.AbsMaxwithSign(m_PlstrnType, PlStrnD_min);
				else
					PlStrnD_max.AbsMax(m_PlstrnType, PlStrnD_min);

				m_mapPlStrnData.SetAt(elem_key,PlStrnD_max);
				break;
			}
		}

		// Back to the Original LoadCombination Data
		m_pDoc->m_pPostCtrl->ChangeLoadComb(LcomOrg);

		// AverageNodalData를 얻기 위해 전체 리스트를 대상으로 값을 얻어놓은후 
		// # Plane/Plate Key List 중 현재 Active인 것들의 List를 재 구성한다.
		if(!(m_bAverageNodalActiveOnly || (m_PlstrnAve !=PLTSL_VALUE_AVENODAL)))
			GetActiveSnList();

		// # 현재 Active Plane/Plate Key List에 대해 Loop를 돌며 최대/최소값을 갱신한다.
		elem_num = m_PlateKeyList.GetSize();
		if(elem_num) has_content = TRUE;
		m_MaxAbsValue = -DBL_MAX;

		for(i=0;i<elem_num;i++) 
		{
			if(!m_mapPlStrnData.Lookup(m_PlateKeyList[i], PlStrnD)) PlStrnD.Initialize();
			m_mapNodesInElem.Lookup(m_PlateKeyList[i],nie);
			m_pDoc->m_pAttrCtrl->GetElem(m_PlateKeyList[i], elem_data);

            bPlate_both = IsViewPStrsSurfacePlateBoth(elem_data.eltyp);

			len = GetMaxElemPlstrn(PlStrnD, nie, bPlate_both);
			if (m_PlstrnComponent != PLTSL_COMPONENT_VECTOR || (m_bVectorPositive && m_bVectorNegative))
			{
				if (len > max_Plstrn) 
				{
					max_Plstrn = len;
					gm->m_nLgdMaxValKey = m_PlateKeyList[i];
				}
			}
			else if ((m_bVectorPositive && len>0.0) || (m_bVectorNegative && len<0.0))
			{
				if (len > max_Plstrn) 
				{
					max_Plstrn = len;
					gm->m_nLgdMaxValKey = m_PlateKeyList[i];
				}
				if (len < min_Plstrn) 
				{
					min_Plstrn = len;
					gm->m_nLgdMinValKey = m_PlateKeyList[i];
				}
			}
			if (fabs(len) > m_MaxAbsValue) 
			{
				m_MaxAbsValue = fabs(len);
				m_KeyMaxPlstrnElem = m_PlateKeyList[i];
			}

			len = GetMinElemPlstrn(PlStrnD, nie,bPlate_both);
			if (m_PlstrnComponent != PLTSL_COMPONENT_VECTOR || (m_bVectorPositive && m_bVectorNegative))
			{
				if (len < min_Plstrn) 
				{
					min_Plstrn = len;
					gm->m_nLgdMinValKey = m_PlateKeyList[i];
				}
			}
			else if ((m_bVectorPositive && len>0.0) || (m_bVectorNegative  && len<0.0))
			{
				if (len > max_Plstrn) 
				{
					max_Plstrn = len;
					gm->m_nLgdMaxValKey = m_PlateKeyList[i];
				}
				if (len < min_Plstrn) 
				{
					min_Plstrn = len;
					gm->m_nLgdMinValKey = m_PlateKeyList[i];
				}
			}
			if (fabs(len) > m_MaxAbsValue) 
			{
				m_MaxAbsValue = fabs(len);
				m_KeyMaxPlstrnElem = m_PlateKeyList[i];
			}
		}

		if (fabs(max_Plstrn+DBL_MAX)<1.e-10) max_Plstrn=0.;
		if (fabs(min_Plstrn-DBL_MAX)<1.e-10) min_Plstrn=0.;
	}

	if (!has_content) 
	{
		min_Plstrn = max_Plstrn = 0.0;
		gm->m_nLgdMaxValKey = 0;
		gm->m_nLgdMinValKey = 0;
	}

	m_dMaxValue = max_Plstrn;
	m_dMinValue = min_Plstrn;

	if (m_pContourEngine == NULL)
		m_pContourEngine = new CContourEngine(m_dMinValue, m_dMaxValue);
	else
		m_pContourEngine->MakeRankMap(m_dMinValue, m_dMaxValue);

	m_mapNodesInElem.RemoveAll();

	gm->m_pMyView->EndWaitCursor();

	m_bPlstrnDataSet = TRUE;
	return TRUE;
}

void CStressEngine::DoPlstrnElementContour(CDC *pDC, unsigned int ekey)
{
	T_MIRE_K mkey;
	mkey.keymap = ekey;

	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;
	
	int				i, j, poly_num, vtx_num, node_in_elem;
	double			pltsl_val[4];
	BOOL			ef[4];
	T_ELEM_D		elem_d;
	T_PLSTRN_OUTVAL_D	PlStrnD;

	int nSurface;
	int nTopBot;// 0: Top, 1: Bottom

	CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray <CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					edge_list;
	CArray <CArray <T_NODE_K, T_NODE_K> *, CArray <T_NODE_K, T_NODE_K> *>	VertexNode;

	if ((gm->m_pDeformEngine==NULL) ||
		(m_pContourEngine==NULL) ||
		(!GetPlStrain(mkey.key.elem_k, PlStrnD))) {
		return;
	}

	// 1. 요소의 형상정보를 얻는다.
	m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d);
	node_in_elem = m_pDoc->m_pAttrCtrl->GetNumNode(elem_d.eltyp, elem_d.elnod);
	BOOL bPlaneThickBak= gm->m_DOPT.DR.m_bPlaneThick;
	BOOL bFrameLineBak= gm->m_DOPT.DR.m_bFrameLine;
	if(m_PlstrnSurface == PLTSL_SURFACE_TOPBOT) 
	{
		gm->m_DOPT.DR.m_bFrameLine = FALSE;
		gm->m_DOPT.DR.m_bPlaneThick = TRUE;
	}
	
	if (m_bDeformedShapeContour) {
		gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list, &VertexNode);
	}
	else {
		gm->GetShapeElement(ekey, polygon_list, &edge_list, NULL, &VertexNode);
	}

	gm->GPS_XGL_Begin_Elem(mkey.key.elem_k,elem_d);

	poly_num = polygon_list.GetSize();
	for (i=0;i<poly_num;i++) 
	{
		vtx_num = polygon_list[i]->GetCount();
		if(vtx_num == 2) {
			continue;
		}

		if(poly_num>1 && !gm->m_DOPT.DR.m_bFrameLine &&  gm->m_DOPT.DR.m_bPlaneThick && !gm->IsVisibleFace(polygon_list[i],vtx_num))
			 continue;

		
		// Fill+Outline의 경우 Contour를 수행하기 전의 Polygon의 Outline을 그림.// Line Only 일경우는 먼저그린다.
		if ((gm->m_DOPT.DR.m_RenderFlag == 3 || gm->m_DOPT.DR.m_RenderFlag == 2) && m_pContourEngine->m_nContourFill ==1)
		{
			//gm->DrawPolygon3DFill(pDC, *(polygon_list[i]), *(edge_list[i]), gm->m_ClientBackColor);
			gm->DrawPolygon3DFill(pDC, *(polygon_list[i]), *(edge_list[i]), gm->m_DOPT.CL.m_ClientBackColor);
			gm->GPSDrawPolygonEdge(pDC, polygon_list[i], edge_list[i]);
		}

		if(m_bContour)
		{
			// 2. 요소의 형상을 이루는 polygon들의 각 Vertex에 해당 Stress값을 부여한다.
			if ( m_PlstrnSurface == PLTSL_SURFACE_TOPBOT)
					nSurface = GetSurface(elem_d, node_in_elem,VertexNode[i]); // 0: Top Surface , 1:Bot Surface, 2: Side Surface

			for (j=0;j<vtx_num;j++) 
			{
				if(m_PlstrnSurface == PLTSL_SURFACE_TOPBOT)
					nTopBot = GetTopBot(nSurface,j); // 0: Top Vertex, 1: Bot Vertex;
				else 
					nTopBot = 0;

				pltsl_val[j] = CalcPlstrnValue(PlStrnD, GetNodeOrder(VertexNode[i]->GetAt(j), elem_d, node_in_elem)+1,nTopBot);
				
				if (gm->m_AnimEngine.m_bAnimateContour)
					pltsl_val[j] = m_pContourEngine->GetSubFrameValue(pltsl_val[j], gm->m_AnimEngine.GetAnimationFactor(TRUE));
				ef[j] = edge_list[i]->GetAt(j);
			}

			// 3. polygon별로 Contour를 실시하여 Stress값에 따라 나뉘어진 sub-polygon list를 얻는다.
			// 4. sub-polygon들을 그린다.
			DoSubPolyContour(pDC, pltsl_val, polygon_list[i], ef, FALSE);
		}
			
		// Fill+Outline의 경우 Contour를 수행하기 전의 Polygon의 Outline을 그림. Fill Type
		if ((gm->m_DOPT.DR.m_RenderFlag == 3 || gm->m_DOPT.DR.m_RenderFlag == 2) && m_pContourEngine->m_nContourFill ==0)
			gm->GPSDrawPolygonEdge(pDC, polygon_list[i], edge_list[i]);
			
		
	}
	gm->GPS_XGL_End_Elem();

	gm->m_DOPT.DR.m_bPlaneThick = bPlaneThickBak;
	gm->m_DOPT.DR.m_bFrameLine = bFrameLineBak;

	FreeMemoryPolyList(&polygon_list,&edge_list,&VertexNode);
}

void CStressEngine::DoPlstrnElementVector(CDC *pDC, unsigned int ekey)
{
	if(IsDamageRatioComponent()) return;

	T_MIRE_K mkey;
	mkey.keymap = ekey;

	I_GPSModel *gm=(I_GPSModel *) m_pGPSModel;
	CClientDC	 dc(gm->m_pMyView);
	int				 i, node_num;
	double		 local_vec[3][3], node_p[4][3];
	T_PLSTRN_OUTVAL_D	PlStrnD;
	T_ELEM_D	 edata;
	CPen			 p1_pen, p2_pen, *old_pen,*old_pen2;
	C3DPoint	 pnt_p1, arr_p11, arr_p12, pnt_p2, arr_p21, arr_p22, pnt_c;

	if((gm->m_pDeformEngine==NULL) ||
		(m_pContourEngine==NULL) || (!GetPlStrain(mkey.key.elem_k, PlStrnD)))
	{
		return;
	}
	double dP1   = PlStrnD.GslhDG.dStrain[0][6]; // 최대주응력
	double dP2   = PlStrnD.GslhDG.dStrain[0][7]; // 최소주응력
	double angle = PlStrnD.GslhDG.dStrain[0][8]; // 주응력 방향

	gm->m_pGPSCtrl->XGL_Begin_Diagram(ekey,FALSE); // 20060224 Changkeun

	int nThkLine = GetVectorLineWidth();

	if (gm->m_bGradient)
	{
		p1_pen.CreatePen(PS_SOLID, nThkLine, m_pContourEngine->GetValueColorGrad(dP1));
		p2_pen.CreatePen(PS_SOLID, nThkLine, m_pContourEngine->GetValueColorGrad(dP2));
	}
	else
	{
		p1_pen.CreatePen(PS_SOLID, nThkLine, m_pContourEngine->GetValueColor(dP1));
		p2_pen.CreatePen(PS_SOLID, nThkLine, m_pContourEngine->GetValueColor(dP2));
	}

	if (m_bDeformedShapeContour)
	{
		m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, edata);
		node_num = m_pDoc->m_pAttrCtrl->GetNumNode(edata.eltyp, edata.elnod);
		for (i=0;i<node_num;i++)
		{
			gm->m_pDeformEngine->GetDisplacedPoint(edata.elnod[i], node_p[i]);
		}
		m_pDoc->calcPlaneLocalVector(node_num, node_p, edata.angle, local_vec);
		for (i=0;i<node_num-1;i++)
		{
			node_p[node_num-1][0] += node_p[i][0];
			node_p[node_num-1][1] += node_p[i][1];
			node_p[node_num-1][2] += node_p[i][2];
		}
		pnt_c.x = node_p[node_num-1][0] / ((double) node_num);
		pnt_c.y = node_p[node_num-1][1] / ((double) node_num);
		pnt_c.z = node_p[node_num-1][2] / ((double) node_num);
	}
	else
	{
		m_pDoc->calcPlaneLocalVector(mkey.key.elem_k, local_vec);
		m_pDoc->calcCenterElem(mkey.key.elem_k, pnt_c.x, pnt_c.y, pnt_c.z);
	}

	CMathFunc::mathRotate(angle,
		local_vec[2][0], local_vec[2][1], local_vec[2][2],
		local_vec[0][0], local_vec[0][1], local_vec[0][2]);
	CMathFunc::mathRotate(angle,
		local_vec[2][0], local_vec[2][1], local_vec[2][2],
		local_vec[1][0], local_vec[1][1], local_vec[1][2]);

	// Point 1
	CUtilFuncs::GetVectorDirectionPoint(local_vec[0], fabs(dP1),
		m_VectorAdjustFactor*m_VectorScaleFactor, pnt_c, pnt_p1);
	// Arrow Point 11
	CUtilFuncs::GetVectorDirectionPoint(local_vec[0], -dP1*0.2,
		m_VectorAdjustFactor*m_VectorScaleFactor, pnt_p1, arr_p11);
	CUtilFuncs::GetVectorDirectionPoint(local_vec[1], fabs(dP1)*0.2,
		m_VectorAdjustFactor*m_VectorScaleFactor, arr_p11, arr_p11);
	// Arrow Point 12
	CUtilFuncs::GetVectorDirectionPoint(local_vec[0], -dP1*0.2,
		m_VectorAdjustFactor*m_VectorScaleFactor, pnt_p1, arr_p12);
	CUtilFuncs::GetVectorDirectionPoint(local_vec[1], -fabs(dP1)*0.2,
		m_VectorAdjustFactor*m_VectorScaleFactor, arr_p12, arr_p12);

	// Point 2
	CUtilFuncs::GetVectorDirectionPoint(local_vec[1], fabs(dP2),
		m_VectorAdjustFactor*m_VectorScaleFactor, pnt_c, pnt_p2);
	// Arrow Point 21
	CUtilFuncs::GetVectorDirectionPoint(local_vec[1], -dP2*0.2,
		m_VectorAdjustFactor*m_VectorScaleFactor, pnt_p2, arr_p21);
	CUtilFuncs::GetVectorDirectionPoint(local_vec[0], fabs(dP2)*0.2,
		m_VectorAdjustFactor*m_VectorScaleFactor, arr_p21, arr_p21);
	// Arrow Point 22
	CUtilFuncs::GetVectorDirectionPoint(local_vec[1], -dP2*0.2,
		m_VectorAdjustFactor*m_VectorScaleFactor, pnt_p2, arr_p22);
	CUtilFuncs::GetVectorDirectionPoint(local_vec[0], -fabs(dP2)*0.2,
		m_VectorAdjustFactor*m_VectorScaleFactor, arr_p22, arr_p22);

	// Arrow of P1
	old_pen = (CPen *) pDC->SelectObject(&p1_pen);
	if(!gm->m_bVirtualMode&& !gm->m_bAnimation)
		old_pen2 = (CPen *) dc.SelectObject(&p1_pen);

	if (dP1 < 1.e-10)
	{
		if (gm->m_pStressEngine->m_bVectorNegative)
			DrawVectorArrow(pDC,&dc,pnt_c,pnt_p1,arr_p11,arr_p12,mkey.key.mirror_k);
	}
	else
	{
		if (gm->m_pStressEngine->m_bVectorPositive)
			DrawVectorArrow(pDC,&dc,pnt_c,pnt_p1,arr_p11,arr_p12,mkey.key.mirror_k);
	}


	// Arrow of P2
	pDC->SelectObject(&p2_pen);
	if(!gm->m_bVirtualMode&& !gm->m_bAnimation)
		dc.SelectObject(&p2_pen);

	if (dP2 < 1.e-10)
	{
		if (gm->m_pStressEngine->m_bVectorNegative)
			DrawVectorArrow(pDC,&dc,pnt_c,pnt_p2,arr_p21,arr_p22,mkey.key.mirror_k);
	}
	else
	{
		if (gm->m_pStressEngine->m_bVectorPositive)
			DrawVectorArrow(pDC,&dc,pnt_c,pnt_p2,arr_p21,arr_p22,mkey.key.mirror_k);
	}

	pDC->SelectObject(old_pen);
	if(!gm->m_bVirtualMode&& !gm->m_bAnimation)
		dc.SelectObject(old_pen2);
	p1_pen.DeleteObject();
	p2_pen.DeleteObject();

	gm->m_pGPSCtrl->XGL_End_Elem(FALSE);
}

BOOL CStressEngine::IsDamageRatioComponent()
{
	switch (m_PlstrnComponent)
	{
	case PLTSL_COMPONENT_COMP:
	case PLTSL_COMPONENT_TENS:
	case PLTSL_COMPONENT_TOTAL:
		return TRUE;
		break;
	}
	return FALSE;
}

double CStressEngine::CalcSlstrnValue(T_SLSTRN_OUTVAL_D& Data, int node)
{
	double	len;

	double dStrain[9][21] = {0.,};
	if(m_SlstrnType!=2)
	{
		memcpy(dStrain, m_SlstrnType==0? Data.GslsD.dStrain : Data.PslsD.dStrain, sizeof(dStrain));
	}

	switch (m_SlstrnComponent) {
	case SLTSL_COMPONENT_STNXX:
	case SLTSL_COMPONENT_STNX:
		len = dStrain[node][0];
		break;
	case SLTSL_COMPONENT_STNYY:
	case SLTSL_COMPONENT_STNY:
		len = dStrain[node][1];
		break;
	case SLTSL_COMPONENT_STNZZ:
	case SLTSL_COMPONENT_STNZ:
		len = dStrain[node][2];
		break;
	case SLTSL_COMPONENT_STNXY:
	case SLTSL_COMPONENT_STNLXY:
		len = dStrain[node][3];
		break;
	case SLTSL_COMPONENT_STNYZ:
	case SLTSL_COMPONENT_STNLYZ:
		len = dStrain[node][4];
		break;
	case SLTSL_COMPONENT_STNXZ:
	case SLTSL_COMPONENT_STNLXZ:
		len = dStrain[node][5];
		break;
	case SLTSL_COMPONENT_STNP1:
		len = dStrain[node][6];
		break;
	case SLTSL_COMPONENT_STNP2:
		len = dStrain[node][7];
		break;
	case SLTSL_COMPONENT_STNP3:
		len = dStrain[node][8];
		break;
	case SLTSL_COMPONENT_SHRMAX:
		len = dStrain[node][9];
		break;
	case SLTSL_COMPONENT_STNMAX:
		if(fabs(dStrain[node][6]) > fabs(dStrain[node][7]))
			len = dStrain[node][6];
		else
			len = dStrain[node][7];
		if(fabs(len) < fabs(dStrain[node][8]))
			len = dStrain[node][8];
		break;
	case SLTSL_COMPONENT_COMP:
		len = Data.SdidD.dDamage[node][0];
		break;
	case SLTSL_COMPONENT_TENS:
		len = Data.SdidD.dDamage[node][1];
		break;
	case SLTSL_COMPONENT_TOTAL:
		len = Data.SdidD.dDamage[node][2];
		break;
	}

	return len;
}

void CStressEngine::SetSlstrnComponent(T_SLSTRN_OUTVAL_D& Data, int node, double strs_val)
{
	double dStrain[9][21] = {0.,};
	if(m_SlstrnType!=2)
	{
		memcpy(dStrain, m_SlstrnType==0? Data.GslsD.dStrain : Data.PslsD.dStrain, sizeof(dStrain));
	}

	switch (m_SlstrnComponent) {
	case SLTSL_COMPONENT_STNXX:
	case SLTSL_COMPONENT_STNX:
		dStrain[node][0] = strs_val;
		break;
	case SLTSL_COMPONENT_STNYY:
	case SLTSL_COMPONENT_STNY:
		dStrain[node][1] = strs_val;
		break;
	case SLTSL_COMPONENT_STNZZ:
	case SLTSL_COMPONENT_STNZ:
		dStrain[node][2] = strs_val;
		break;
	case SLTSL_COMPONENT_STNXY:
	case SLTSL_COMPONENT_STNLXY:
		dStrain[node][3] = strs_val;
		break;
	case SLTSL_COMPONENT_STNYZ:
	case SLTSL_COMPONENT_STNLYZ:
		dStrain[node][4] = strs_val;
		break;
	case SLTSL_COMPONENT_STNXZ:
	case SLTSL_COMPONENT_STNLXZ:
		dStrain[node][5] = strs_val;
		break;
	case SLTSL_COMPONENT_STNP1:
		dStrain[node][6] = strs_val;
		break;
	case SLTSL_COMPONENT_STNP2:
		dStrain[node][7] = strs_val;
		break;
	case SLTSL_COMPONENT_STNP3:
		dStrain[node][8] = strs_val;
		break;
	case SLTSL_COMPONENT_SHRMAX:
		dStrain[node][9] = strs_val;
		break;

	case SLTSL_COMPONENT_COMP:
		Data.SdidD.dDamage[node][0] = strs_val;
		break;
	case SLTSL_COMPONENT_TENS:
		Data.SdidD.dDamage[node][1] = strs_val;
		break;
	case SLTSL_COMPONENT_TOTAL:
		Data.SdidD.dDamage[node][2] = strs_val;
		break;
	}

	if(m_SlstrnType!=2)
	{
		memcpy(m_SlstrnType==0? Data.GslsD.dStrain : Data.PslsD.dStrain, dStrain, sizeof(dStrain));
	}
}

double CStressEngine::GetMaxElemSlstrn(T_SLSTRN_OUTVAL_D& Data, int node_num)
{
	double		len, max=-DBL_MAX;

	if (m_SlstrnComponent == SLTSL_COMPONENT_VECTOR)
	{
		switch (m_SlstrnType)
		{
		case 0:
			for(int i=0; i<9; i++)
			{
				max = __max(max, Data.GslsD.dStrain[i][6]);
				max = __max(max, Data.GslsD.dStrain[i][7]);
				max = __max(max, Data.GslsD.dStrain[i][8]);
			}
			break;
		case 1:
			for(int i=0; i<9; i++)
			{
				max = __max(max, Data.PslsD.dStrain[i][6]);
				max = __max(max, Data.PslsD.dStrain[i][7]);
				max = __max(max, Data.PslsD.dStrain[i][8]);
			}
			break;
		case 2:
			break;

		default:
			break;
		}
	}
	else
	{
		for (int i=0;i<node_num;i++)
		{
			len = CalcSlstrnValue(Data, i+1);
			max = __max(max, len);
		}
	}

	return max;
}

double CStressEngine::GetMinElemSlstrn(T_SLSTRN_OUTVAL_D& Data, int node_num)
{
	double		len, min=DBL_MAX;

	if (m_SlstrnComponent == SLTSL_COMPONENT_VECTOR)
	{
		switch (m_SlstrnType)
		{
		case 0:
			for(int i=0; i<9; i++)
			{
				min = __min(min, Data.GslsD.dStrain[i][6]);
				min = __min(min, Data.GslsD.dStrain[i][7]);
				min = __min(min, Data.GslsD.dStrain[i][8]);
			}
			break;
		case 1:
			for(int i=0; i<9; i++)
			{
				min = __min(min, Data.PslsD.dStrain[i][6]);
				min = __min(min, Data.PslsD.dStrain[i][7]);
				min = __min(min, Data.PslsD.dStrain[i][8]);
			}
			break;
		case 2:
			break;

		default:
			break;
		}
	}
	else {
		for (int i=0;i<node_num;i++)
		{
			len = CalcSlstrnValue(Data, i+1);
			min = __min(min, len);
		}
	}

	return min;
}

BOOL CStressEngine::IsWithinRangeElemSlstrn(T_SLSTRN_OUTVAL_D& Data, int node_num,double& max_strs,double& min_strs)
{
	double len_max = GetMaxElemSlstrn(Data, node_num);
	double len_min = GetMinElemSlstrn(Data, node_num);

	if (len_min <= min_strs && len_max >= max_strs)
		return TRUE;
	if (len_min >= min_strs && len_min <= max_strs)
		return TRUE;
	if (len_max >= min_strs && len_max <= max_strs)
		return TRUE;

	return FALSE;
}

void CStressEngine::DrawSlstrnContour(CDC *pDC)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	
	int			i, elem_num;
	BOOL		fl_bak=gm->m_DOPT.DR.m_bFrameLine;
	T_ELEM_D	elem_d;
	CPen		elem_pen, *old_pen;
	CArray <int, int>				type_list;
	CArray <GRE_Atom, GRE_Atom&>		atom_list;
	BOOL bEscapePressed = FALSE;  
	T_MIRE_K mkey;
	
	/*
	if(!gm->m_bContour) 
	{
		gm->GPSDrawOriginal(pDC);
		return;
	}
	*/

	BOOL bExistResult = TRUE;
	if(!CGPSPostCtrl::IsMatlNonlinearAnalysis(gm->m_LoadCaseType)) bExistResult = FALSE;
	int nResVer = CDBLib::Get_BnDataFileVesion();
	if(nResVer<8750) bExistResult = FALSE;

	if(m_bOnCuttingPlane && gm->m_AnimEngine.m_bAnimateContour && gm->m_bAnimation)
	{
		gm->GetRangeModelOneType(&m_CutPlnMovingRangeMinPnt,&m_CutPlnMovingRangeMaxPnt,SOLID_EL);
		if(gm->m_nMovingDir == 3) // normal to Plane 
			MakeCutPlaneMovingPath();
	}
		
	if(m_SlstrnComponent == SLTSL_COMPONENT_VECTOR) InitVectorAdjustFactorSlstrn();

	if(m_bDeformedShapeContour) 
	{
		if(gm->m_pDeformEngine == NULL)return;
		type_list.Add(gm->m_MinOTID + OBJECT_TYPE_DEFORMED);

		// 변형된 그림에 Undeformed Shape을 같이 그릴 경우.
		if(gm->m_DOPT.DR.m_bDrawInactive && (m_SlstrnComponent==SLTSL_COMPONENT_VECTOR)) 
		{
			gm->m_DOPT.DR.m_bFrameLine = TRUE;
			gm->GPSDrawOriginal(pDC, TRUE);
		}
	}
	else 
	{
		type_list.Add(gm->m_MinOTID + OBJECT_TYPE_ORIGINAL);
	}

	elem_pen.CreatePen(PS_SOLID, gm->m_DOPT.DR.nElemHddn, m_pContourEngine->m_ElemColor);
	old_pen = (CPen *) pDC->SelectObject(&elem_pen);

	gm->m_pGPSCtrl->GetZSortedList(type_list, gm->m_EKeyListVisible_Mirror, atom_list);
	elem_num = atom_list.GetSize();

	//GTimeCheckStart();
	if((m_bOnCuttingPlane || m_bIsoSurface) && gm->m_bFreeEdgeOnly && !m_bIsFreeEdgeDataSet)
		MakeFreeEdgeData();
	else if(!gm->m_DOPT.RD.m_bShrink && !m_bIsFreeFaceDataSet && (m_SlstrnComponent != SLTSL_COMPONENT_VECTOR))
		MakeFreeFaceData();
 	//double t1=GTimeCheckEnd();

	//GTimeCheckStart();
	for(i=0;i<elem_num;i++) 
	{
		//if(gm->m_pGPSCtrl->WatchEscKeyPress()) bEscapePressed = TRUE;
		if(gm->m_pGPSCtrl->WatchEscKeyPress()) return;
		if(gm->m_pGPSCtrl->IsZoomAllState() ||
			gm->m_pGPSCtrl->IsObjectInClientWindow(atom_list[i].m_OType, atom_list[i].m_OKey)) {
			mkey.keymap = atom_list[i].m_OKey;
			m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d);
			if (bExistResult && m_pDoc->m_pAttrCtrl->IsSolidType(elem_d.eltyp) && (gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey)) && !bEscapePressed) 
			{
				if (m_SlstrnComponent == SLTSL_COMPONENT_VECTOR) 
				{
					//gm->m_bFrameLine = TRUE;		// Vector를 그릴 경우 Hidden을 끈다.
					if (m_bDeformedShapeContour)
						gm->m_pDeformEngine->DrawDeformedElement(pDC, atom_list[i].m_OKey);
					else
						gm->GPSDrawElement(pDC, atom_list[i].m_OKey);
					if(gm->m_bContour)
						DoSlstrnElementVector(pDC, atom_list[i].m_OKey);
				}
				else 
				{
					gm->m_DOPT.DR.m_bFrameLine = fl_bak;

					if(gm->m_bContour)
					{
					  if(m_bOnCuttingPlane)
						  DoSlstrnElementContourOnCuttingPlane(pDC, atom_list[i].m_OKey);
					  else if(m_bIsoSurface)
						  DoSlstrnElementIsoSurfaceContour(pDC,atom_list[i].m_OKey,gm->m_aIsoValues);
					  else
						  DoSlstrnElementContour(pDC, atom_list[i].m_OKey);
					}
					else
					{
						gm->GPSDrawElement(pDC, atom_list[i].m_OKey);   
					}
				}
				if(m_bHingeStatus)DrawNLHngeStatus(pDC,atom_list[i].m_OKey);
			}
			else 
			{
				if(m_SlstrnComponent == SLTSL_COMPONENT_VECTOR)
					;//gm->m_bFrameLine = TRUE;		// Vector를 그릴 경우 Hidden을 끈다.
				else
					gm->m_DOPT.DR.m_bFrameLine = fl_bak;
				if(m_bDeformedShapeContour)
					gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, atom_list[i].m_OKey);
				else
					gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
			}
		}
	}
 	//double t2=GTimeCheckEnd();
	//CString sTemp;
	//sTemp.Format("t1=%g, t2=%g", t1, t2);
	//GSaveHistoryFormatNF("DrawSLtslContour : makeFreeFace=%g, Draw=%g", t1, t2);

	gm->m_DOPT.DR.m_bFrameLine = fl_bak;

	// 변형된 그림에 Undeformed Shape을 같이 그릴 경우.
	if (m_bDeformedShapeContour && gm->m_DOPT.DR.m_bDrawInactive && (m_SlstrnComponent!=SLTSL_COMPONENT_VECTOR) && !bEscapePressed) {
		int	rf_bak=gm->m_DOPT.DR.m_RenderFlag;
		gm->m_DOPT.DR.m_RenderFlag = 2;
		gm->GPSDrawOriginal(pDC, TRUE);
		gm->m_DOPT.DR.m_RenderFlag = rf_bak;
	}

	pDC->SelectObject(old_pen);
	elem_pen.DeleteObject();


	//----------------------------------------------------------------------
	// UCS Icon Drawing
	//----------------------------------------------------------------------
	if( (m_SlstrnVal == PSTRS_VALUE_GLOBAL)  && gm->m_bVirtualMode && m_bPrintUCSAxis) 
	{
		double UCS_vector[3][3];
		GetUCSVector(m_NUCS,UCS_vector);
		DrawUCSPlaneIcon(pDC,UCS_vector);
	}
}

#if defined(__OLD_OUTPUT_VALUE)
void CStressEngine::OutputSlstrnNumbers(CDC *pDC)
{
	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;

	int				i, j, elem_num, node_in_elem;
	T_ELEM_K		ekey;
	T_ELEM_D		edata;
	T_NODE_D		node_d;
	T_SLSTRN_OUTVAL_D SlStrnD;
	C3DPoint		node[8],DrawPoint,Node;
	CPoint      DrawPoint2d;
	CPoint			text_p;
	TCHAR			fmt_str[10], text_str[512];
	CFont			ft, *old_ft;

	if (!m_bSlstrnDataSet)
		return;

	if (gm->m_DOPT.TX.m_bNumberOpaque)
		pDC->SetBkMode(OPAQUE);
	else
		pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
	pDC->SetBkColor(gm->m_DOPT.TX.m_NumberBackCol);
	pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);

	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T("%s%de"), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T("%s%df"), _T("%."), gm->m_NumberDecimalPoint);

	if (gm->m_DOPT.TX.m_bNumberSelOnly) {
	}
	else {
		//elem_num = gm->m_EKeyListActive.GetSize();
		BOOL bGrpFltMode=gm->m_pGPSCtrl->IsGroupFilterMode();
		if(!bGrpFltMode)elem_num = gm->m_EKeyListActive.GetSize();
		else            elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize(); 

		gm->SetNumberFontOrientation(0);
		ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
		old_ft = (CFont *) pDC->SelectObject(&ft);

		for (i=0;i<elem_num;i++) {
			//ekey = gm->m_EKeyListActive[i];
			if(!bGrpFltMode)ekey = gm->m_EKeyListActive[i];
			else            ekey = gm->m_pDispFilter->m_aGrpEKey[i]; 

			if(!gm->m_pGPSCtrl->IsActiveElem(ekey))
				continue;

			m_pDoc->m_pAttrCtrl->GetElem(ekey, edata);

			if (!m_pDoc->m_pAttrCtrl->IsSolidType(edata.eltyp))
				continue;
			node_in_elem = m_pDoc->m_pAttrCtrl->GetNumNode(edata.eltyp, edata.elnod);

			for (j=0;j<node_in_elem;j++) 
			{
				m_pDoc->m_pAttrCtrl->GetNode(edata.elnod[j], node_d);
				if (m_bDeformedShapeContour)
				{
					Node.x = node_d.x; Node.y = node_d.y; Node.z = node_d.z;
					node[j] = gm->m_pDeformEngine->GetDisplacedPoint(edata.elnod[j], Node);
				}
				else
					node[j].Set(node_d.x, node_d.y, node_d.z);
			}


			if(!GetSolidStrain(ekey, SlStrnD)) continue;

			for (j=0;j<node_in_elem-1;j++) {
				node[node_in_elem-1].x += node[j].x;
				node[node_in_elem-1].y += node[j].y;
				node[node_in_elem-1].z += node[j].z;
			}

			DrawPoint.x =  (node[node_in_elem-1].x/((double) node_in_elem));
			DrawPoint.y =  (node[node_in_elem-1].y/((double) node_in_elem));
			DrawPoint.z =  (node[node_in_elem-1].z/((double) node_in_elem));

			double MaxStr = GetMaxElemSlstrn(SlStrnD, node_in_elem);
			double MinStr = GetMinElemSlstrn(SlStrnD, node_in_elem);
			double dAbsMaxStr = (fabs(MaxStr) > fabs(MinStr))? MaxStr:MinStr;

			/////////////////////////////////////////////////////////////////////////////////////////////
			if(gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
			{
				double dLimit = (m_dMaxValue-m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;

				switch(gm->m_DOPT.TX.m_nOutputMinMaxType)
				{
				case 0: // Min & Max
					if((m_dMaxValue-MaxStr) <= dLimit)
						DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,MaxStr);
					else if((MinStr-m_dMinValue) <= dLimit)
						DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,MinStr);
					break;
				case 1: // Abs Max
					if(fabs(m_dMaxValue) >= fabs(m_dMinValue))
					{
						if( fabs(m_dMaxValue)-fabs(dAbsMaxStr) <= dLimit)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dAbsMaxStr);
					}
					else
					{
						if( fabs(m_dMinValue)-fabs(dAbsMaxStr) <= dLimit)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dAbsMaxStr);
					}
					break;
				case 2: // Max
					if((m_dMaxValue-MaxStr) <= dLimit)
						DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,MaxStr);
					break;
				case 3: // Min
					if((MinStr-m_dMinValue) <= dLimit)
						DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,MinStr);
					break;
				}
				//////////////////////////////////////////////////////////////////////////////////////
			}
			else
			{
				if (gm->m_bVirtualMode)
					text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(DrawPoint);
				else
					text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(DrawPoint);


				if (fabs(MaxStr) > fabs(MinStr))
					_stprintf(text_str, fmt_str, MaxStr);
				else
					_stprintf(text_str, fmt_str, MinStr);
				if(text_p.x>=0 && text_p.y>=0)
					pDC->TextOut(text_p.x, text_p.y, text_str);
			}
		}
		pDC->SelectObject(old_ft);
		ft.DeleteObject();
	}
}
#else
void CStressEngine::OutputSlstrnNumbers(CDC* pDC)
{
	I_GPSModel* gm = (I_GPSModel*)m_pGPSModel;

	int				i, j, elem_num, node_in_elem;
	T_ELEM_K		ekey;
	T_ELEM_D		edata;
	T_NODE_D		node_d;
	T_SLSTRN_OUTVAL_D SlStrnD;
	C3DPoint		node[8], DrawPoint, Node;
	CPoint      DrawPoint2d;
	CPoint			text_p;
	TCHAR			fmt_str[10], text_str[512];
	CFont			ft, * old_ft;

	if (!m_bSlstrnDataSet)
		return;

	GPostTextOut TextOutModel;
	TextOutModel.SetDC(pDC);
	TextOutModel.StartSolidStrainVal();
	TextOutModel.SettingSolidStrain(gm);

	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T("%s%de"), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T("%s%df"), _T("%."), gm->m_NumberDecimalPoint);

	if (gm->m_DOPT.TX.m_bNumberSelOnly) {
	}
	else {
		//elem_num = gm->m_EKeyListActive.GetSize();
		BOOL bGrpFltMode = gm->m_pGPSCtrl->IsGroupFilterMode();
		if (!bGrpFltMode)elem_num = gm->m_EKeyListActive.GetSize();
		else            elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize();

		TextOutModel.Font4SolidStrain(gm, 0);

		for (i = 0; i < elem_num; i++) {
			//ekey = gm->m_EKeyListActive[i];
			if (!bGrpFltMode)ekey = gm->m_EKeyListActive[i];
			else            ekey = gm->m_pDispFilter->m_aGrpEKey[i];

			if (!gm->m_pGPSCtrl->IsActiveElem(ekey))
				continue;

			m_pDoc->m_pAttrCtrl->GetElem(ekey, edata);

			if (!m_pDoc->m_pAttrCtrl->IsSolidType(edata.eltyp))
				continue;
			node_in_elem = m_pDoc->m_pAttrCtrl->GetNumNode(edata.eltyp, edata.elnod);

			for (j = 0; j < node_in_elem; j++)
			{
				m_pDoc->m_pAttrCtrl->GetNode(edata.elnod[j], node_d);
				if (m_bDeformedShapeContour)
				{
					Node.x = node_d.x; Node.y = node_d.y; Node.z = node_d.z;
					node[j] = gm->m_pDeformEngine->GetDisplacedPoint(edata.elnod[j], Node);
				}
				else
					node[j].Set(node_d.x, node_d.y, node_d.z);
			}


			if (!GetSolidStrain(ekey, SlStrnD)) continue;

			for (j = 0; j < node_in_elem - 1; j++) {
				node[node_in_elem - 1].x += node[j].x;
				node[node_in_elem - 1].y += node[j].y;
				node[node_in_elem - 1].z += node[j].z;
			}

			DrawPoint.x = (node[node_in_elem - 1].x / ((double)node_in_elem));
			DrawPoint.y = (node[node_in_elem - 1].y / ((double)node_in_elem));
			DrawPoint.z = (node[node_in_elem - 1].z / ((double)node_in_elem));

			double MaxStr = GetMaxElemSlstrn(SlStrnD, node_in_elem);
			double MinStr = GetMinElemSlstrn(SlStrnD, node_in_elem);
			double dAbsMaxStr = (fabs(MaxStr) > fabs(MinStr)) ? MaxStr : MinStr;

			/////////////////////////////////////////////////////////////////////////////////////////////
			if (gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
			{
				double dLimit = (m_dMaxValue - m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;

				switch (gm->m_DOPT.TX.m_nOutputMinMaxType)
				{
				case 0: // Min & Max
					if ((m_dMaxValue - MaxStr) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, MaxStr);
					else if ((MinStr - m_dMinValue) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, MinStr);
					break;
				case 1: // Abs Max
					if (fabs(m_dMaxValue) >= fabs(m_dMinValue))
					{
						if (fabs(m_dMaxValue) - fabs(dAbsMaxStr) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, dAbsMaxStr);
					}
					else
					{
						if (fabs(m_dMinValue) - fabs(dAbsMaxStr) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, dAbsMaxStr);
					}
					break;
				case 2: // Max
					if ((m_dMaxValue - MaxStr) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, MaxStr);
					break;
				case 3: // Min
					if ((MinStr - m_dMinValue) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, MinStr);
					break;
				}
				//////////////////////////////////////////////////////////////////////////////////////
			}
			else
			{
				if (gm->m_bVirtualMode)
					text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(DrawPoint);
				else
					text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(DrawPoint);


				if (fabs(MaxStr) > fabs(MinStr))
					_stprintf(text_str, fmt_str, MaxStr);
				else
					_stprintf(text_str, fmt_str, MinStr);
				if (text_p.x >= 0 && text_p.y >= 0)
					TextOutModel.TextOutSolidStrain(text_p.x, text_p.y, text_str);
			}
		}
		TextOutModel.DeleteFont();
	}
	TextOutModel.EndSolidStrainVal();
}
#endif

BOOL CStressEngine::GetSlstrnRangeDataList(double& dMaxRange, double& dMinRange, CArray<UINT,UINT>& aElemKeyList)
{
	aElemKeyList.RemoveAll();

	if (CTestEnvMgr::IsTestEnvST(_LSX(ProfilingSTL), _LSX(yes)))
	{
		M_PROFILE('GetSlstrnRangeDataList()');
	}

	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	int			  i, nie;
	T_ELEM_K	elem_key;
	T_ELEM_D	elem_data;
	T_SLSTRN_OUTVAL_D SlStrnD;
	BOOL      bWithSign = m_pDoc->m_pPostCtrl->GetSignFlag();

	BOOL bDR = IsDamageRatioComp_Solid();
	gm->m_pMyView->BeginWaitCursor();

	int elem_num = m_SltlsKeyList.GetSize();
	for(i=0;i<elem_num;i++) 
	{
		elem_key = m_SltlsKeyList[i];
		if(!m_mapSlStrnData.Lookup(elem_key, SlStrnD)) continue;

		elem_data.Initialize();
		m_pDoc->m_pAttrCtrl->GetElem(elem_key, elem_data);
		nie = m_pDoc->m_pAttrCtrl->GetNumNode(elem_data.eltyp, elem_data.elnod);

		if(!IsWithinRangeElemSlstrn(SlStrnD, nie, dMaxRange, dMinRange)) continue;

		aElemKeyList.Add(elem_key);
	}	

	gm->m_pMyView->EndWaitCursor();

	return TRUE;
}

void CStressEngine::GetAverageNodalDataListSlstrn(BOOL bInitCalc/*=TRUE*/)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	MakeSerialNodeMap();
	T_NODE_K serial_node;

	int			i, j, linked_elem_num, nodes_in_elem,
		node_num=m_pDoc->m_pAttrCtrl->GetCountNode(), elem_num=m_SltlsKeyList.GetSize();
	double		strs_val;
	T_ELEM_D	elem_data;
	T_SLSTRN_OUTVAL_D SlStrnD;
	CArray <double, double &> *elem_ptr;
	CArray <CArray <double, double &> *, CArray <double, double &> *>	elem_ptr_list;

	if(bInitCalc)
		if(m_SlstrnVal == PSTRS_VALUE_GLOBAL )
			if(m_SlstrnComponent == SLTSL_COMPONENT_STNP1 || 
				m_SlstrnComponent == SLTSL_COMPONENT_STNP2 ||
				m_SlstrnComponent == SLTSL_COMPONENT_STNP3 ||
				m_SlstrnComponent == SLTSL_COMPONENT_SHRMAX ||
				m_SlstrnComponent == SLTSL_COMPONENT_STNMAX)
	{
				int nBackSLtslComponent = m_SlstrnComponent;
		int nCompNum = 6;
				int nComponent[] = {  SLTSL_COMPONENT_STNXX, SLTSL_COMPONENT_STNYY, SLTSL_COMPONENT_STNZZ, 
					SLTSL_COMPONENT_STNXY, SLTSL_COMPONENT_STNYZ, SLTSL_COMPONENT_STNXZ };

		// Component별 Average
		for(i=0; i<nCompNum; i++)
		{
					m_SlstrnComponent = nComponent[i]; 
					GetAverageNodalDataListSlstrn(FALSE);
		}
		
		// von-Mises와 Tresca를 다시 계산한다. 
				if(m_SlstrnType!=2)
				{
		for(i=0; i<elem_num; i++)
		{
						m_mapSlStrnData.Lookup(m_SltlsKeyList[i],SlStrnD);

						double dStrain[9][21] = {0.,};
						memcpy(dStrain, m_SlstrnType==0? SlStrnD.GslsD.dStrain : SlStrnD.PslsD.dStrain, sizeof(dStrain));

						for(j=0; j<9; j++)
			{
							CDBDoc::GetDocPoint()->m_pPostCtrl->PRIN_SOL( &dStrain[j][0], &dStrain[j][6], (double(*)[3])(&dStrain[j][12]));
						}

						memcpy(m_SlstrnType==0? SlStrnD.GslsD.dStrain : SlStrnD.PslsD.dStrain, dStrain, sizeof(dStrain));

						m_mapSlStrnData.SetAt(m_SltlsKeyList[i],SlStrnD);
			}
		}
				m_SlstrnComponent = nBackSLtslComponent;
		return; 
	}


			for (i=0;i<node_num;i++) 
			{
		elem_ptr = new CArray <double, double &>;
		elem_ptr_list.Add(elem_ptr);
	}

			for (i=0;i<elem_num;i++)
			{
				m_pDoc->m_pAttrCtrl->GetElem(m_SltlsKeyList[i], elem_data);
				m_mapNodesInElem.Lookup(m_SltlsKeyList[i],nodes_in_elem);
				for (j=0;j<nodes_in_elem;j++)
				{
					if(!m_mapSlStrnData.Lookup(m_SltlsKeyList[i],SlStrnD)) continue;

					strs_val = CalcSlstrnValue(SlStrnD, j+1);
			if(!m_mapSerialNode.Lookup(elem_data.elnod[j],serial_node)) continue;
			elem_ptr_list[serial_node]->Add(strs_val);
		}
	}

	for (i=0;i<node_num;i++) {
		linked_elem_num = elem_ptr_list[i]->GetSize();
		if (linked_elem_num < 2)
			continue;
		strs_val = 0.0;
		for (j=0;j<linked_elem_num;j++) {
			strs_val += elem_ptr_list[i]->GetAt(j);
		}
		strs_val /= (double) linked_elem_num;
		elem_ptr_list[i]->SetAt(0, strs_val);
	}

			for (i=0;i<elem_num;i++)
			{
				m_pDoc->m_pAttrCtrl->GetElem(m_SltlsKeyList[i], elem_data);
				m_mapNodesInElem.Lookup(m_SltlsKeyList[i],nodes_in_elem);
				for (j=0;j<nodes_in_elem;j++)
				{
					if(!m_mapSlStrnData.Lookup(m_SltlsKeyList[i],SlStrnD)) continue;

			if(!m_mapSerialNode.Lookup(elem_data.elnod[j],serial_node)) continue;
			strs_val = elem_ptr_list[serial_node]->GetAt(0);
					SetSlstrnComponent(SlStrnD, j+1, strs_val);
					m_mapSlStrnData.SetAt(m_SltlsKeyList[i],SlStrnD);
		}
	}

	for (i=0;i<node_num;i++) {
		elem_ptr_list[i]->RemoveAll();
		delete elem_ptr_list[i];
	}
	elem_ptr_list.RemoveAll();
}

void CStressEngine::GetActiveSlstrnList()
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	
	int			i, elem_num;
	
	T_ELEM_K	elem_key;
	T_ELEM_D  elem_data;	
	m_SltlsKeyList.RemoveAll();
	elem_num = gm->m_EKeyListActive.GetSize(); 
	
	for (i=0;i<elem_num;i++) 
	{
		elem_key = gm->m_EKeyListActive[i];
		
		m_pDoc->m_pAttrCtrl->GetElem(elem_key, elem_data);
		if (m_pDoc->m_pAttrCtrl->IsSolid(elem_data.eltyp))
			m_SltlsKeyList.Add(elem_key);
	}
}

void CStressEngine::InitVectorAdjustFactorSlstrn()
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	C3DPoint	min_pm, max_pm, min_pe, max_pe;
	double		max_lm, max_le, max_l;

	if(m_bLockAdjFactor)
		return;

	if (!m_pDoc->m_pAttrCtrl->ExistElem(m_KeyMaxSlstrnElem)) {
		m_VectorAdjustFactor = 1.0;
		return;
	}

	// 전체 모델의 Range와 최대값이 발생한 요소의 Range를 동시에 고려한다.

/*	m_pDoc->calcRangeModel(min_pm.x, min_pm.y, min_pm.z,
								   max_pm.x, max_pm.y, max_pm.z,
								   NULL, NULL, TRUE, NULL, TRUE,
								   gm->m_bFrameThick||gm->m_bPlaneThick);*/
		
	gm->GetRangeModel(&min_pm,&max_pm);
	max_lm = max(max(max_pm.x-min_pm.x, max_pm.y-min_pm.y), max_pm.z-min_pm.z);

	gm->GetRangeElement(m_KeyMaxSlstrnElem, &min_pe, &max_pe);
	max_le = max(max(max_pe.x-min_pe.x, max_pe.y-min_pe.y), max_pe.z-min_pe.z);

	if (m_MaxAbsValue > -1e-15 && m_MaxAbsValue < 1e-15)
		m_MaxAbsValue = 1.0f;

	if ((max_le*0.35) < (max_lm/40.0)) {
		max_l = max_lm/40.0;
	}
	else {
		max_l = max_le*0.35;
	}

	m_VectorAdjustFactor = max_l / m_MaxAbsValue;
}

BOOL CStressEngine::MakeSlstrnDataList()
{
	if (CTestEnvMgr::IsTestEnvST(_LSX(ProfilingSTL), _LSX(yes)))
	{
		M_PROFILE('MakeSLtslDataList()');
	}

	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	if(!gm->m_bLoadDataSet)	return FALSE;

	BOOL bExistResult = TRUE;
	if(!CGPSPostCtrl::IsMatlNonlinearAnalysis(gm->m_LoadCaseType)) bExistResult = FALSE;
	int nResVer = CDBLib::Get_BnDataFileVesion();
	if(nResVer<8750) bExistResult = FALSE;

	int			  i, elem_num, nie;
	double		max_sltsl=-DBL_MAX, min_sltsl=DBL_MAX, len;
	double		max_sdid=-DBL_MAX, min_sdid=DBL_MAX;
	BOOL	  	has_content=FALSE;
	T_ELEM_K	elem_key;
	T_SLSTRN_OUTVAL_D SlStrnD;
	T_SLSTRN_OUTVAL_D SlStrnD_max, SlStrnD_min;
	BOOL      bWithSign = m_pDoc->m_pPostCtrl->GetSignFlag();

	gm->m_pMyView->BeginWaitCursor();

	m_SltlsKeyList.RemoveAll();
	m_mapSlStrnData.RemoveAll();

	if(bExistResult)
	{
		// Get the Original LoadCombination Data
		T_LCOM_D  LcomOrg=m_pDoc->m_pPostCtrl->GetLoadComb();

		if(m_bAverageNodalActiveOnly || (m_SlstrnAve != SLTSL_VALUE_AVENODAL))
			elem_num = gm->m_EKeyListActive.GetSize(); // Active된 요소에 대해서만 Average Nodal을 계산.
		else
			elem_num = gm->m_EKeyList.GetSize(); // Average Nodal이 가능하도록...전체 요소를 취한다.

		m_mapSlStrnData.InitHashTable(GF_GetHashSizeByCount(elem_num));

		if(m_SlstrnAve == SLTSL_VALUE_AVENODAL) MakeSerialNodeMap();

		CMapEx<T_ELEM_K,T_ELEM_K,T_SLSTRN_OUTVAL_D,T_SLSTRN_OUTVAL_D&> mapSLtslDataMax,mapSLtslDataMin;
		mapSLtslDataMax.InitHashTable(GF_GetHashSizeByCount(elem_num));
		mapSLtslDataMin.InitHashTable(GF_GetHashSizeByCount(elem_num));
		MakeSlstrnDataListLcom(LcomOrg,elem_num,1.0,mapSLtslDataMax,mapSLtslDataMin);

		for(i=0;i<m_SltlsKeyList.GetSize();i++) 
		{
			elem_key = m_SltlsKeyList[i];
			if(!mapSLtslDataMax.Lookup(elem_key, SlStrnD_max)) continue;
			if(!mapSLtslDataMin.Lookup(elem_key, SlStrnD_min)) continue;

			switch (gm->m_LoadMinMaxType) 
			{
			case LOADTYPE_NORMAL:
			case LOADTYPE_MAX:
				m_mapSlStrnData.SetAt(elem_key,SlStrnD_max);
				break;
			case LOADTYPE_MIN:
				m_mapSlStrnData.SetAt(elem_key,SlStrnD_min);
				break;
			case LOADTYPE_ALL:
				if(bWithSign)
					SlStrnD_max.AbsMaxwithSign(m_SlstrnType, SlStrnD_min);
				else
					SlStrnD_max.AbsMax(m_SlstrnType, SlStrnD_min);
				m_mapSlStrnData.SetAt(elem_key,SlStrnD_max);
				break;
			}
		}

		m_pDoc->m_pPostCtrl->ChangeLoadComb(LcomOrg);

		// 3. 필요시 각 노드별로 인접한 요소의 Solid Stress의 값의 평균값을 구한다.

		// 4. Solid Key List 중 현재 Active인 것들의 List를 구한다.
		if(!(m_bAverageNodalActiveOnly || (m_SlstrnAve != PSTRS_VALUE_AVENODAL)))
			GetActiveSlstrnList();

		// 5. 현재 Active Solid Key List에 대해 Loop를 돌며 최대/최소값을 갱신한다.
		//GTimeCheckStart();
		elem_num = m_SltlsKeyList.GetSize();
		if(elem_num) has_content = TRUE;
		m_MaxAbsValue = -DBL_MAX;
		for(i=0;i<elem_num;i++) 
		{
			if(!m_mapSlStrnData.Lookup(m_SltlsKeyList[i], SlStrnD)) continue;
			if(!m_mapNodesInElem.Lookup(m_SltlsKeyList[i],nie)) continue;

			len = GetMaxElemSlstrn(SlStrnD, nie);
			if (len > max_sltsl) 
			{
				max_sltsl = len;
				gm->m_nLgdMaxValKey = m_SltlsKeyList[i];
			}
			if (fabs(len) > m_MaxAbsValue) {
				m_MaxAbsValue = fabs(len);
				m_KeyMaxSlstrnElem = m_SltlsKeyList[i];
			}

			len = GetMinElemSlstrn(SlStrnD, nie);
			if (len < min_sltsl) 
			{
				min_sltsl = len;
				gm->m_nLgdMinValKey = m_SltlsKeyList[i];
			}
			if (fabs(len) > m_MaxAbsValue) {
				m_MaxAbsValue = fabs(len);
				m_KeyMaxSlstrnElem = m_SltlsKeyList[i];
			}
		}
	}

	if (!has_content) 
	{
		min_sltsl = max_sltsl = 0.0;
		gm->m_nLgdMaxValKey = 0;
		gm->m_nLgdMinValKey = 0;
	}

	m_dMaxValue = max_sltsl;
	m_dMinValue = min_sltsl;
	
	if (m_pContourEngine == NULL)
		m_pContourEngine = new CContourEngine(min_sltsl, max_sltsl);
	else
		m_pContourEngine->MakeRankMap(min_sltsl, max_sltsl);

	m_mapNodesInElem.RemoveAll();

	gm->m_pMyView->EndWaitCursor();

	m_bSlstrnDataSet = TRUE;
	return TRUE;
}

void CStressEngine::DoSlstrnElementContour(CDC *pDC, unsigned int ekey)
{
	T_MIRE_K mkey;
	mkey.keymap = ekey;

	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;
	
	int				i, j, poly_num, vtx_num, node_in_elem;
	double			plsh_val[4];
	BOOL			ef[4];
	T_ELEM_D		elem_d;
	T_SLSTRN_OUTVAL_D SlStrnD;
	
	CArray<int, int>* paFreeFace; 
	if(!m_mapFreeFacebyElemKey.Lookup(mkey.key.elem_k,paFreeFace) && !gm->m_DOPT.RD.m_bShrink)
		return;

	if ((gm->m_pDeformEngine==NULL) ||
		(m_pContourEngine==NULL) ||
		(!GetSolidStrain(mkey.key.elem_k, SlStrnD)) ) {
		return;
	}
	
	CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray <CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					edge_list;
	CArray <CArray <T_NODE_K, T_NODE_K> *, CArray <T_NODE_K, T_NODE_K> *>	VertexNode;
	CArray <int, int> aSort_index_list;

	// 1. 요소의 형상정보를 얻는다.
	m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d);
	node_in_elem = m_pDoc->m_pAttrCtrl->GetNumNode(elem_d.eltyp, elem_d.elnod);
	
	if(!gm->m_DOPT.RD.m_bShrink) // Free Face만 Contour with 배면 제거
	{
	  if (m_bDeformedShapeContour)
		  gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list, &VertexNode,NULL,&aSort_index_list);
	  else
		  gm->GetShapeElement(ekey, polygon_list, &edge_list, NULL, &VertexNode,NULL,&aSort_index_list);
	}
	else // 모든 요소를 Contour 단 배면은 제거...
	{
		if (m_bDeformedShapeContour)
		  gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list, &VertexNode,NULL,NULL);
	  else
		  gm->GetShapeElement(ekey, polygon_list, &edge_list, NULL, &VertexNode,NULL,NULL);
	}

	gm->GPS_XGL_Begin_Elem(mkey.key.elem_k,elem_d);
	poly_num = polygon_list.GetSize();
	for (i=0;i<poly_num;i++) 
	{
		
		if(!gm->m_DOPT.RD.m_bShrink && !IsFreeFace(paFreeFace,aSort_index_list[i])) // Solid인경우 FreeFace-only Contour 적용.
			continue;

		vtx_num = polygon_list[i]->GetCount();
		if (vtx_num == 2)
			continue;
		
		if(poly_num>1 && !gm->IsVisibleFace(polygon_list[i],vtx_num))
			 continue;
		
		
		// Fill+Outline의 경우 Contour를 수행하기 전의 Polygon의 Outline을 그림.// Line Only 일경우는 먼저그린다.
		if ((gm->m_DOPT.DR.m_RenderFlag == 3 || gm->m_DOPT.DR.m_RenderFlag == 2) && m_pContourEngine->m_nContourFill ==1)
		{
			//gm->DrawPolygon3DFill(pDC, *(polygon_list[i]), *(edge_list[i]), gm->m_ClientBackColor);
			gm->DrawPolygon3DFill(pDC, *(polygon_list[i]), *(edge_list[i]), gm->m_DOPT.CL.m_ClientBackColor);
			gm->GPSDrawPolygonEdge(pDC, polygon_list[i], edge_list[i]);
		}

		// 2. 요소의 형상을 이루는 polygon들의 각 Vertex에 해당 Solid Stress값을 부여한다.
		for (j=0;j<vtx_num;j++) {
			plsh_val[j] = CalcSlstrnValue(SlStrnD, GetNodeOrder(VertexNode[i]->GetAt(j), elem_d, node_in_elem)+1);
			if (gm->m_AnimEngine.m_bAnimateContour)
				plsh_val[j] = m_pContourEngine->GetSubFrameValue(plsh_val[j], gm->m_AnimEngine.GetAnimationFactor(TRUE));
			ef[j] = edge_list[i]->GetAt(j);
		}

		// 3. polygon별로 Contour를 실시하여 Solid Stress값에 따라 나뉘어진 sub-polygon list를 얻는다.
		// 4. sub-polygon들을 그린다.
		DoSubPolyContour(pDC, plsh_val, polygon_list[i], ef, FALSE);

		if ((gm->m_DOPT.DR.m_RenderFlag == 3 || gm->m_DOPT.DR.m_RenderFlag == 2) && m_pContourEngine->m_nContourFill ==0)
			gm->GPSDrawPolygonEdge(pDC, polygon_list[i],NULL);
	}
	gm->GPS_XGL_End_Elem();

	FreeMemoryPolyList(&polygon_list,&edge_list,&VertexNode); 
}

void CStressEngine::DoSlstrnElementContourOnCuttingPlane(CDC *pDC, unsigned int ekey)
{
	T_MIRE_K mkey;
	mkey.keymap = ekey;

	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;

	int		  i, j, poly_num, vtx_num, node_in_elem;
	double	sltsl_val[4],sltsl_val2[4];
	double  dCutStress;
	BOOL		ef[4],ef2[4];
	T_ELEM_D	elem_d;
	T_SLSTRN_OUTVAL_D SlStrnD;

	CArray<CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray<CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					edge_list;
	CArray<CArray <T_NODE_K, T_NODE_K> *, CArray <T_NODE_K, T_NODE_K> *>	VertexNode;
	CArray<C3DPoint,C3DPoint> aCutVertex;
	CArray<double,double>     aCutVertexVal;
	CArray<C3DPoint,C3DPoint> aUnSortedVertex;

	// 20100518 KIMJM, difference가 e-16으로 작게 나옴.
	double dTol = M_InitValueCurUnit(1.E-10, N, MM, D_UNITSYS_BASE_STRESS);
	if (dTol > 1.0e-7) dTol = 1.0e-7;   // dTol가 너무 커지는 경우가 있어서 좀더 줄여줌.. // MNET:XXXX-HSSHIM-20130807

	BOOL bDR = IsDamageRatioComp_Solid();

	if((gm->m_pDeformEngine==NULL) ||
		(m_pContourEngine==NULL) ||
		(!GetSolidStrain(mkey.key.elem_k, SlStrnD))) 
	{
		return;
	}

	// 1. 요소의 형상정보를 얻는다. // Mirror 안된 형상을 얻어서 cutting한후 mirror하도록 한다.
	m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d);
	node_in_elem = m_pDoc->m_pAttrCtrl->GetNumNode(elem_d.eltyp, elem_d.elnod);
	if(gm->m_bFreeEdgeOnly)
	{
		if(m_bDeformedShapeContour) 
			gm->m_pDeformEngine->GetDeformedShapeElement(mkey.key.elem_k, &polygon_list, &edge_list, &VertexNode,&aUnSortedVertex);
		else
			gm->GetShapeElement(mkey.key.elem_k, polygon_list, &edge_list, NULL, &VertexNode,&aUnSortedVertex);
	}
	else
	{
		if(m_bDeformedShapeContour)
			gm->m_pDeformEngine->GetDeformedShapeElement(mkey.key.elem_k, &polygon_list, &edge_list, &VertexNode);
		else
			gm->GetShapeElement(mkey.key.elem_k, polygon_list, &edge_list, NULL, &VertexNode);
	}

	poly_num = polygon_list.GetSize();

	int point1,point2;
	C3DPoint Point1,Point2,Vector,Point3;
	double dPoint1[3],dPoint3[3],dVector[3],dNormalVector[3];

	double d1,d2;
	CArray <T_NPLN_D,T_NPLN_D&> aCuttingPlane;
	T_NPLN_D CuttingPlane;
	int nSurface;
	PLANE_FUNC CuttingPlaneF;


	int nNumOfCutPlanes;

	if (gm->m_AnimEngine.m_bAnimateContour && gm->m_bAnimation)
	{
		nNumOfCutPlanes = 1; // Moving Plane에 대해서만 적용한다.
		if(gm->m_nMovingDir==3) 
		{
			if(!GetNPLN(gm->m_aCutPlanes[gm->m_nMovingPlane],CuttingPlane)) return; // Moving Plane 
		}
		else
		{ 
			CuttingPlane.Initialize();
			CuttingPlane.nPlaneType =1 ;
		}
		aCuttingPlane.Add(CuttingPlane);
	}
	else
	{
		nNumOfCutPlanes = gm->m_aCutPlanes.GetSize();
		for(int nKey = 0; nKey < nNumOfCutPlanes; nKey++)
		{
			if(GetNPLN(gm->m_aCutPlanes[nKey],CuttingPlane))
				aCuttingPlane.Add(CuttingPlane);
			else
			{
				nNumOfCutPlanes--;
				gm->m_aCutPlanes.RemoveAt(nKey);
				nKey--;
			}
		}
	}

	gm->GPS_XGL_Begin_Elem(mkey.key.elem_k,elem_d);    

	for(int nPLN = 0; nPLN < nNumOfCutPlanes; nPLN++)
	{
		CuttingPlane = aCuttingPlane[nPLN];
		if (gm->m_AnimEngine.m_bAnimateContour && gm->m_bAnimation)
			GetMovedCuttingPlane(CuttingPlane);

		GetPlaneFunction(CuttingPlane,CuttingPlaneF);

		dNormalVector[0] =CuttingPlaneF.a;
		dNormalVector[1] =CuttingPlaneF.b;
		dNormalVector[2] =CuttingPlaneF.c; // CuttingPlane Normal Vector

		aCutVertex.RemoveAll();
		aCutVertexVal.RemoveAll();

		poly_num = polygon_list.GetSize();
		for (i=0;i<poly_num;i++) 
		{
			vtx_num = polygon_list[i]->GetCount();
			if (vtx_num == 2) 
				continue;
			else 
			{
				if(poly_num >= 5) // 5면체 6면체에 대해서만 위 아랫 면을 계산에서 제외한다.(중복되므로)
				{
					nSurface = GetSolidSurface(elem_d, node_in_elem,VertexNode[i]); // 0: Top Surface , 1:Bot Surface, 2: Side Surface
					if(nSurface <2) continue;
				}
				// 2. 요소의 형상을 이루는 polygon들의 각 Vertex에 해당 Solid Stress값을 부여한다.
				for (j=0;j<vtx_num;j++) {
					sltsl_val[j] = CalcSlstrnValue(SlStrnD, GetNodeOrder(VertexNode[i]->GetAt(j), elem_d, node_in_elem)+1);
					ef[j] = edge_list[i]->GetAt(j);
				}


				POSITION pos = polygon_list[i]->GetHeadPosition();
				Point1= polygon_list[i]->GetNext(pos);
				for (j=0;j<vtx_num-1;j++) 
				{
					point1 = j; 
					point2=j+1;
					if(j>0) Point1 = Point2;

					Point2= polygon_list[i]->GetNext(pos);


					dVector[0] = Point2.x-Point1.x;
					dVector[1] = Point2.y-Point1.y;
					dVector[2] = Point2.z-Point1.z;


					d1 = CuttingPlaneF.a*Point1.x + CuttingPlaneF.b * Point1.y + CuttingPlaneF.c * Point1.z + CuttingPlaneF.h ;
					d2 = CuttingPlaneF.a*Point2.x + CuttingPlaneF.b * Point2.y + CuttingPlaneF.c * Point2.z + CuttingPlaneF.h ;

					if(fabs(d1) < dTol) d1 = 0.0;
					if(fabs(d2) < dTol) d2 = 0.0;				


					if(d1*d2<0.0)
					{
						dPoint1[0] = Point1.x;
						dPoint1[1] = Point1.y;
						dPoint1[2] = Point1.z;

						if(!CMathFunc::project_on_plane_vector_for_CuttingPlane(dPoint1,dVector,CuttingPlane.dPoint[0],
							CuttingPlane.dPoint[1],CuttingPlane.dPoint[2],dPoint3)) continue;
						Point3.Set(dPoint3[0],dPoint3[1],dPoint3[2]);

						aCutVertex.Add(Point3);

						d1 = CMathFunc::mathLength(Point3.x,Point3.y,Point3.z,
							Point1.x,Point1.y,Point1.z);
						d2 = CMathFunc::mathLength(Point3.x,Point3.y,Point3.z,
							Point2.x,Point2.y,Point2.z);

						dCutStress = sltsl_val[point1] + (sltsl_val[point2]-sltsl_val[point1])*d1/(d1+d2);
						aCutVertexVal.Add(dCutStress);
					}

					if(fabs(d1 - 0.0)<1e-18)
					{
						aCutVertex.Add(Point1);

						dCutStress = sltsl_val[point1] ;
						aCutVertexVal.Add(dCutStress);
					}

					if(fabs(d2 - 0.0)<1e-18)
					{
						aCutVertex.Add(Point2);

						dCutStress = sltsl_val[point2] ;
						aCutVertexVal.Add(dCutStress);
					}

				}

			}
		}

		/////////////////////////////////////////////////////////////////////////////////////////////////////
		// Draw Cut-plane polygon
		CList <C3DPoint, C3DPoint> cut_polygon_list;
		CList <C3DPoint, C3DPoint> cut_polygon_list2;//Polygon이 4개이상의 정점을 가질때 2개로 분할.
		if(aCutVertex.GetSize())
		{
			GetPolygon(aCutVertex,aCutVertexVal,CuttingPlaneF);// 정점들을 꼬이지 않은 CCW 폴리곤을 만들도록 재배열

			if(mkey.key.mirror_k)
				for(int i=0; i<aCutVertex.GetSize(); i++)
					gm->RE_GetMirroredPoint(mkey.key.mirror_k,&aCutVertex[i]);

			if(aCutVertex.GetSize() >4)
			{
				int nFistPolySize =4;
				for(int i=0; i<nFistPolySize; i++)
				{
					cut_polygon_list.AddTail(aCutVertex[i]);
					sltsl_val[i] = aCutVertexVal[i];
					ef[i] = FALSE;
				}

				cut_polygon_list2.AddTail(aCutVertex[0]);
				sltsl_val2[0] = aCutVertexVal[0];
				ef2[0] = FALSE;

				int nSecondPolySize =aCutVertex.GetSize()-4 +2 ;
				for( i=1; i<nSecondPolySize; i++)
				{
					cut_polygon_list2.AddTail(aCutVertex[2+i]);
					sltsl_val2[i] = aCutVertexVal[2+i];
					ef2[i] = FALSE;
				}

				DoSubPolyContour(pDC, sltsl_val, &cut_polygon_list, ef, FALSE);
				DoSubPolyContour(pDC, sltsl_val2, &cut_polygon_list2, ef2, FALSE);
			}
			else
			{
				for(int i=0; i<aCutVertex.GetSize(); i++)
				{
					cut_polygon_list.AddTail(aCutVertex[i]);
					sltsl_val[i] = aCutVertexVal[i];
					ef[i] = FALSE;
				}
				DoSubPolyContour(pDC, sltsl_val, &cut_polygon_list, ef, FALSE);
			}

		}
		cut_polygon_list.RemoveAll();
		cut_polygon_list2.RemoveAll();
		//////////////////////////////////////////////////////////////////////////////////////////////////////
	}

	gm->GPS_XGL_End_Elem();

	if(gm->m_bFreeEdgeOnly) //현재 항상 TRUE
		DrawSolidFreeEdge(pDC,ekey,aUnSortedVertex);
	else
	{
		// Fill+Outline의 경우 Contour를 수행하기 전의 Polygon의 Outline을 그림. 
		// Mirror가 고려안됨. 현재 무의미한 루틴...
		for (i=0;i<poly_num;i++) 
			if (gm->m_DOPT.DR.m_RenderFlag == 3 || gm->m_DOPT.DR.m_RenderFlag == 2)
				gm->GPSDrawPolygonEdge(pDC, polygon_list[i], edge_list[i]);
	}

	for(i=0;i<poly_num;i++) 
	{
		polygon_list[i]->RemoveAll();
		delete []polygon_list[i];
		edge_list[i]->RemoveAll();
		delete []edge_list[i];
		VertexNode[i]->RemoveAll();
		delete []VertexNode[i];
	}
	polygon_list.RemoveAll();
	edge_list.RemoveAll();
	VertexNode.RemoveAll();
}

void CStressEngine::DoSlstrnElementIsoSurfaceContour(CDC *pDC, unsigned int ekey,CArray <double,double>& aIsoValues)
{
	T_MIRE_K mkey;
	mkey.keymap = ekey;

	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;
	CClientDC			dc(gm->m_pMyView);
	int				i, j, poly_num, node_in_elem;
	double			sstrn_val[8];
	CArray <double,double> aIsoValues_val;

	T_ELEM_D		elem_d;
	T_NODE_D    node_d;
	T_SLSTRN_OUTVAL_D		SlStrnD;
	double dContourValue;
	double max,min;

	C3DPoint aVertexes[8];
	CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray <int, int>		sort_index_list;
	CArray <CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					edge_list;

	if ((gm->m_pDeformEngine==NULL) ||
		(m_pContourEngine==NULL) ||
		(!GetSolidStrain(mkey.key.elem_k, SlStrnD))) {
			return;
	}

	max = m_pContourEngine->m_MaxRange;
	min = m_pContourEngine->m_MinRange;

	// 1. 요소의 형상정보를 얻는다.
	m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d);
	node_in_elem = m_pDoc->m_pAttrCtrl->GetNumNode(elem_d.eltyp, elem_d.elnod);


	for (j=0;j<node_in_elem;j++) {
		sstrn_val[j] = CalcSlstrnValue(SlStrnD,j+1);
		m_pDoc->m_pAttrCtrl->GetNode(elem_d.elnod[j],node_d);
		aVertexes[j].Set(node_d.x,node_d.y,node_d.z);
		if(m_bDeformedShapeContour)
			aVertexes[j] = gm->m_pDeformEngine->GetDisplacedPoint(elem_d.elnod[j],aVertexes[j]);

		gm->RE_GetMirroredPoint(mkey.key.mirror_k,&aVertexes[j]);

	}

	int nNumIsoValue = aIsoValues.GetSize();

	if(gm->m_nIsoValueMode == 0)
	{
		for(i=0; i<nNumIsoValue; i++)
			aIsoValues_val.Add(min + (max-min)*aIsoValues[i]);
	}
	else
		aIsoValues_val.Copy(aIsoValues);

	if (gm->m_AnimEngine.m_bAnimateContour && gm->m_bAnimation) 
	{	// animation range setup
		// IsoValue가 없을때는 최대 최소, 1개 있을 때는 최대와 IsoValue[0], 2개 이상일때는 IsoValue중 최대 최소
		if(nNumIsoValue==1)
			min = aIsoValues_val[0];
		else if(nNumIsoValue>1)
		{
			double dValMax = aIsoValues_val[0];
			double dValMin = aIsoValues_val[0];
			for(int i=1; i<nNumIsoValue; i++)
			{
				if(dValMax<aIsoValues_val[i])
					dValMax = aIsoValues_val[i];
				if(dValMin>aIsoValues_val[i])
					dValMin = aIsoValues_val[i];
			}
			min = dValMin;
			max = dValMax;
		}
		nNumIsoValue = 1;
	}


	gm->GPS_XGL_Begin_Elem(mkey.key.elem_k, elem_d);

	int nDC = pDC->SaveDC();
	pDC->SelectStockObject(NULL_PEN);
	CPen elem_edgepen;
	elem_edgepen.CreatePen(PS_SOLID, 1, m_pContourEngine->m_ElemColor);
	for(int n=0; n<nNumIsoValue; n++)
	{

		if (gm->m_AnimEngine.m_bAnimateContour && gm->m_bAnimation)
			dContourValue = min + (max-min)*gm->m_AnimEngine.GetAnimationFactor(TRUE);
		else
		{	
			dContourValue = aIsoValues_val[n];
		}

		switch(node_in_elem)
		{
		case 4:
			GetTetraSolidContourPolys(dContourValue,sstrn_val,aVertexes,polygon_list, edge_list);
			break;
		case 6:
			GetWedgeSolidContourPolys(dContourValue,sstrn_val,aVertexes,polygon_list, edge_list);
			break;
		case 8:
			GetHexaSolidContourPolys(dContourValue,sstrn_val,aVertexes,polygon_list, edge_list);
			break;
		default:
			ASSERT(FALSE);
			return; // error
		}

		poly_num = polygon_list.GetSize();
		sort_index_list.RemoveAll();

		gm->m_pGPSCtrl->GetZSortPolygonList(polygon_list, sort_index_list);
		COLORREF color =m_pContourEngine->GetValueColor(dContourValue);

		for (i=0;i<poly_num;i++) 
		{
			if(gm->m_bVirtualMode) // 20060213 Chang-keun start
			{

				if(gm->m_pGPSCtrl->IsGLRenderer() && gm->m_bTransparent) // Virtual mode blending GLMode에서만 가능함. 
				{
					int Intensity = gm->m_nTransparentIntensity;// / 255.f * 100.f; //Max 255기준 --> max 100으로 변경. 
					gm->DrawBlendedPolygon3DFill(pDC,*polygon_list[sort_index_list[i]],color,Intensity,&dc);
				}
				else
				{
					gm->DrawPolygon3DFill(pDC, *polygon_list[sort_index_list[i]],color,&dc);
				}
			}   // 20060213 Chang-keun end
			else
			{
				if(gm->m_bTransparent)
				{ 
					int Intensity = gm->m_nTransparentIntensity;
					if(gm->m_pGPSCtrl->IsGLRenderer())
					{
						Intensity = gm->m_nTransparentIntensity;// / 255.f * 100.f; //Max 255기준  --> Max 100으로 변경.
					}

					gm->DrawBlendedPolygon3DFill(pDC, *polygon_list[sort_index_list[i]],color,Intensity,&dc);
				}
				else
				{
					gm->DrawPolygon3DFill(pDC, *polygon_list[sort_index_list[i]],color,&dc);
				}
			}

			if(gm->m_bDrawPolyOutLine)
			{
				pDC->SelectObject(&elem_edgepen);
				gm->GPSDrawPolygonEdge(pDC, polygon_list[sort_index_list[i]], edge_list[i]);
				pDC->SelectStockObject(NULL_PEN);
			}
		}


		for (i=0;i<poly_num;i++) {
			polygon_list[i]->RemoveAll();
			delete []polygon_list[i];
			edge_list[i]->RemoveAll();
			delete []edge_list[i];
		}
		polygon_list.RemoveAll();
		edge_list.RemoveAll();
	}
	pDC->RestoreDC(nDC);
	elem_edgepen.DeleteObject();

	gm->GPS_XGL_End_Elem();

	CArray <CArray <T_NODE_K, T_NODE_K> *, CArray <T_NODE_K, T_NODE_K> *>	VertexNode;
	CArray <C3DPoint, C3DPoint> aUnSortedVertex;

	if (m_bDeformedShapeContour) {
		gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list,NULL, NULL,&aUnSortedVertex);
	}
	else {
		gm->GetShapeElement(ekey, polygon_list, NULL, NULL, NULL,&aUnSortedVertex);
	}

	DrawSolidFreeEdge(pDC,ekey,aUnSortedVertex);

	poly_num = polygon_list.GetSize();
	for (i=0;i<poly_num;i++) {
		polygon_list[i]->RemoveAll();
		delete []polygon_list[i];

	}
	polygon_list.RemoveAll();
}

void CStressEngine::DoSlstrnElementVector(CDC *pDC, unsigned int ekey)
{
	T_MIRE_K mkey;
	mkey.keymap = ekey;

	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;
	CClientDC			dc(gm->m_pMyView);
	int				i, node_num;
	double			local_vec[3][3], node_p[8][3];
	T_SLSTRN_OUTVAL_D SlStrnD;
	T_ELEM_D		edata;
	CPen			p1_pen, p2_pen, p3_pen, *old_pen,*old_pen2;
	C3DPoint		pnt_p1, arr_p11, arr_p12,
					pnt_p2, arr_p21, arr_p22,
					pnt_p3, arr_p31, arr_p32,
					pnt_c;

	if ((gm->m_pDeformEngine==NULL) ||
		(m_pContourEngine==NULL) ||
		(!GetSolidStrain(mkey.key.elem_k, SlStrnD))) {
		return;
	}

	double dStrain[9][21] = {0.,};
	if(m_SlstrnType!=2)
	{
		memcpy(dStrain, m_SlstrnType==0? SlStrnD.GslsD.dStrain : SlStrnD.PslsD.dStrain, sizeof(dStrain));
	}

	gm->m_pGPSCtrl->XGL_Begin_Diagram(ekey,FALSE); // 20060224 Changkeun

	int nThkLine = GetVectorLineWidth();

	if (gm->m_bGradient) {
		p1_pen.CreatePen(PS_SOLID, nThkLine, m_pContourEngine->GetValueColorGrad(dStrain[0][6]));
		p2_pen.CreatePen(PS_SOLID, nThkLine, m_pContourEngine->GetValueColorGrad(dStrain[0][7]));
		p3_pen.CreatePen(PS_SOLID, nThkLine, m_pContourEngine->GetValueColorGrad(dStrain[0][8]));
	}
	else {
		p1_pen.CreatePen(PS_SOLID, nThkLine, m_pContourEngine->GetValueColor(dStrain[0][6]));
		p2_pen.CreatePen(PS_SOLID, nThkLine, m_pContourEngine->GetValueColor(dStrain[0][7]));
		p3_pen.CreatePen(PS_SOLID, nThkLine, m_pContourEngine->GetValueColor(dStrain[0][8]));
	}

	if (m_bDeformedShapeContour) {
		
		m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, edata);
		node_num = m_pDoc->m_pAttrCtrl->GetNumNode(edata.eltyp, edata.elnod);
		for (i=0;i<node_num;i++) {
			gm->m_pDeformEngine->GetDisplacedPoint(edata.elnod[i], node_p[i]);
		}
		/* 이거 아주 이상하다... 주응력 방향과 상관없이 요소의 로컬축 방향으로 벡터를  잡는다.
		if (node_num == 8)
			m_pDoc->calcPlaneLocalVector(4, node_p, local_vec);
		else
			m_pDoc->calcPlaneLocalVector(3, node_p, local_vec);
		*/
		local_vec[0][0] = dStrain[0][12];
		local_vec[0][1] = dStrain[0][13];
		local_vec[0][2] = dStrain[0][14];
		local_vec[1][0] = dStrain[0][15];
		local_vec[1][1] = dStrain[0][16];
		local_vec[1][2] = dStrain[0][17];
		local_vec[2][0] = dStrain[0][18];
		local_vec[2][1] = dStrain[0][19];
		local_vec[2][2] = dStrain[0][20];

		for (i=0;i<node_num-1;i++) {
			node_p[node_num-1][0] += node_p[i][0];
			node_p[node_num-1][1] += node_p[i][1];
			node_p[node_num-1][2] += node_p[i][2];
		}
		pnt_c.x = node_p[node_num-1][0] / ((double) node_num);
		pnt_c.y = node_p[node_num-1][1] / ((double) node_num);
		pnt_c.z = node_p[node_num-1][2] / ((double) node_num);
	}
	else {
		local_vec[0][0] = dStrain[0][12];
		local_vec[0][1] = dStrain[0][13];
		local_vec[0][2] = dStrain[0][14];
		local_vec[1][0] = dStrain[0][15];
		local_vec[1][1] = dStrain[0][16];
		local_vec[1][2] = dStrain[0][17];
		local_vec[2][0] = dStrain[0][18];
		local_vec[2][1] = dStrain[0][19];
		local_vec[2][2] = dStrain[0][20];

		m_pDoc->calcCenterElem(mkey.key.elem_k, pnt_c.x, pnt_c.y, pnt_c.z);

	}

	// Point 1
	CUtilFuncs::GetVectorDirectionPoint(local_vec[0], fabs(dStrain[0][6]),
										m_VectorAdjustFactor*m_VectorScaleFactor, pnt_c, pnt_p1);
	// Arrow Point 11
	CUtilFuncs::GetVectorDirectionPoint(local_vec[0], -dStrain[0][6]*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, pnt_p1, arr_p11);
	CUtilFuncs::GetVectorDirectionPoint(local_vec[1], fabs(dStrain[0][6])*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, arr_p11, arr_p11);
	// Arrow Point 12
	CUtilFuncs::GetVectorDirectionPoint(local_vec[0], -dStrain[0][6]*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, pnt_p1, arr_p12);
	CUtilFuncs::GetVectorDirectionPoint(local_vec[1], -fabs(dStrain[0][6])*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, arr_p12, arr_p12);

	// Point 2
	CUtilFuncs::GetVectorDirectionPoint(local_vec[1], fabs(dStrain[0][7]),
										m_VectorAdjustFactor*m_VectorScaleFactor, pnt_c, pnt_p2);
	// Arrow Point 21
	CUtilFuncs::GetVectorDirectionPoint(local_vec[1], -dStrain[0][7]*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, pnt_p2, arr_p21);
	CUtilFuncs::GetVectorDirectionPoint(local_vec[0], fabs(dStrain[0][7])*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, arr_p21, arr_p21);
	// Arrow Point 22
	CUtilFuncs::GetVectorDirectionPoint(local_vec[1], -dStrain[0][7]*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, pnt_p2, arr_p22);
	CUtilFuncs::GetVectorDirectionPoint(local_vec[0], -fabs(dStrain[0][7])*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, arr_p22, arr_p22);

	// Point 3
	CUtilFuncs::GetVectorDirectionPoint(local_vec[2], fabs(dStrain[0][8]),
										m_VectorAdjustFactor*m_VectorScaleFactor, pnt_c, pnt_p3);
	// Arrow Point 31
	CUtilFuncs::GetVectorDirectionPoint(local_vec[2], -dStrain[0][8]*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, pnt_p3, arr_p31);
	CUtilFuncs::GetVectorDirectionPoint(local_vec[1], -fabs(dStrain[0][8])*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, arr_p31, arr_p31);
	CUtilFuncs::GetVectorDirectionPoint(local_vec[0], fabs(dStrain[0][8])*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, arr_p31, arr_p31);
	// Arrow Point 32
	CUtilFuncs::GetVectorDirectionPoint(local_vec[2], -dStrain[0][8]*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, pnt_p3, arr_p32);
	CUtilFuncs::GetVectorDirectionPoint(local_vec[1], fabs(dStrain[0][8])*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, arr_p32, arr_p32);
	CUtilFuncs::GetVectorDirectionPoint(local_vec[0], -fabs(dStrain[0][8])*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, arr_p32, arr_p32);

	// Arrow of P1
	old_pen = (CPen *) pDC->SelectObject(&p1_pen);
	if(!gm->m_bVirtualMode&& !gm->m_bAnimation)
		old_pen2 = (CPen *) dc.SelectObject(&p1_pen);
	
	DrawVectorArrow(pDC,&dc,pnt_c,pnt_p1,arr_p11,arr_p12,mkey.key.mirror_k);

	// Arrow of P2
	pDC->SelectObject(&p2_pen);
	if(!gm->m_bVirtualMode&& !gm->m_bAnimation)
		dc.SelectObject(&p2_pen);

	DrawVectorArrow(pDC,&dc,pnt_c,pnt_p2,arr_p21,arr_p22,mkey.key.mirror_k);  

	// Arrow of P3
	pDC->SelectObject(&p3_pen);
	if(!gm->m_bVirtualMode&& !gm->m_bAnimation)
		dc.SelectObject(&p3_pen);

	DrawVectorArrow(pDC,&dc,pnt_c,pnt_p3,arr_p31,arr_p32,mkey.key.mirror_k);

	pDC->SelectObject(old_pen);
	if(!gm->m_bVirtualMode&& !gm->m_bAnimation)
		dc.SelectObject(old_pen);
	p1_pen.DeleteObject();
	p2_pen.DeleteObject();
	p3_pen.DeleteObject();

	gm->m_pGPSCtrl->XGL_End_Elem(FALSE); // 20060224 Changkeun
}

BOOL CStressEngine::IsDamageRatioComp_Solid()
{
	switch (m_SlstrnComponent)
	{
	case SLTSL_COMPONENT_COMP:
	case SLTSL_COMPONENT_TENS:
	case SLTSL_COMPONENT_TOTAL:
		return TRUE;
		break;
	}
	return FALSE;
}

// Plain Strain Stress 데이터를 만든다.
// 전체 Element List에 대해 Loop를 돌며
// 1. DB로 부터 해당 Element의 Plain Strain Stress 데이터를 얻고
// 2. Plain Strain Stress값 및 해당 Element번호 등을 CArray에 저장
// 3. 필요시 각 노드별로 인접한 요소의 Plain Strain Stress의 값의 평균값을 구한다.
// 4. Plain Strain Key List 중 현재 Active인 것들의 List를 구한다.
// 5. 현재 Active Plain Strain Key List에 대해 Loop를 돌며 최대/최소값을 갱신한다.
BOOL CStressEngine::MakePnStrsDataList()
{
	if (CTestEnvMgr::IsTestEnvST(_LSX(ProfilingSTL), _LSX(yes)))
	{
		M_PROFILE('MakePnStrsDataList()');
	}

	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	if(!gm->m_bLoadDataSet)	return FALSE;

	int		  	i, elem_num, nie;
	double		max_pnstrs=-DBL_MAX, min_pnstrs=DBL_MAX, len;
	BOOL	  	has_content=FALSE;
	T_ELEM_K	elem_key;
	T_STPN_D	pnstrs_d;
	T_STPN_D	pnstrn_max,pnstrn_min;
	BOOL   bWithSign = m_pDoc->m_pPostCtrl->GetSignFlag();


	gm->m_pMyView->BeginWaitCursor();

	m_PnKeyList.RemoveAll();
	m_mapPnStrsData.RemoveAll();

	// Get the Original LoadCombination Data
	T_LCOM_D  LcomOrg=m_pDoc->m_pPostCtrl->GetLoadComb();

	if(m_bAverageNodalActiveOnly || !(m_PnStrsAve == PSTRS_VALUE_AVENODAL))
	  elem_num = gm->m_EKeyListActive.GetSize(); // Active된 요소에 대해서만 Average Nodal을 계산.
	else
		elem_num = gm->m_EKeyList.GetSize(); // Average Nodal이 가능하도록...전체 요소를 취한다.

	if(m_PnStrsAve == PSTRS_VALUE_AVENODAL) MakeSerialNodeMap();
	
	CMap<T_ELEM_K,T_ELEM_K,T_STPN_D,T_STPN_D&> mapPnStrnDataMax,mapPnStrnDataMin;
	mapPnStrnDataMax.InitHashTable(HASHSIZEELEM);
	mapPnStrnDataMin.InitHashTable(HASHSIZEELEM);
	MakePnStrnDataListLcom(LcomOrg,elem_num,1.0,mapPnStrnDataMax,mapPnStrnDataMin);
	
	for(i=0;i<m_PnKeyList.GetSize();i++) 
	{
		elem_key = m_PnKeyList[i];
		mapPnStrnDataMax.Lookup(elem_key, pnstrn_max);
		mapPnStrnDataMin.Lookup(elem_key, pnstrn_min);
		
		switch (gm->m_LoadMinMaxType) 
		{
		case LOADTYPE_NORMAL:
		case LOADTYPE_MAX:
			m_mapPnStrsData.SetAt(elem_key,pnstrn_max);
			break;
		case LOADTYPE_MIN:
			m_mapPnStrsData.SetAt(elem_key,pnstrn_min);
			break;
		case LOADTYPE_ALL:
			if(bWithSign)
				pnstrn_max.AbsMaxwithSign(pnstrn_min);
			else
				pnstrn_max.AbsMax(pnstrn_min);
			m_mapPnStrsData.SetAt(elem_key,pnstrn_max);
			break;
		}
	}

	// Back to the Original LoadCombination Data
	m_pDoc->m_pPostCtrl->ChangeLoadComb(LcomOrg);

	// 3. 필요시 각 노드별로 인접한 요소의 Plain Strain Stress의 값의 평균값을 구한다.
	// 1번 단계에서 구하도록 한다. (버그수정)
	//if (m_PnStrsAve == PSTRS_VALUE_AVENODAL) { GetAverageNodalDataListPn(); }

	// 4. Plain Strain Key List 중 현재 Active인 것들의 List를 구한다.
	if(!(m_bAverageNodalActiveOnly || !(m_PnStrsAve == PSTRS_VALUE_AVENODAL)))
		GetActivePnList();

	// 5. 현재 Active Plain Strain Key List에 대해 Loop를 돌며 최대/최소값을 갱신한다.
	elem_num = m_PnKeyList.GetSize();
	if(elem_num) has_content = TRUE;

	m_MaxAbsValue = -DBL_MAX;
	for (i=0;i<elem_num;i++) 
	{
		GetPnStress(m_PnKeyList[i], pnstrs_d);
		m_mapNodesInElem.Lookup(m_PnKeyList[i],nie);

		len = GetMaxElemPnStrs(pnstrs_d, gm->m_bElemCenter, nie);
		if ((m_PnStrsComponent!=SSTRS_COMPONENT_VECTOR) || (m_bVectorPositive && m_bVectorNegative))
		{
			if (len > max_pnstrs) 
			{
				max_pnstrs = len;
				gm->m_nLgdMaxValKey = m_PnKeyList[i];
			}
		}
		else if ((m_bVectorPositive && len >0.) || (m_bVectorNegative && len < 0.))
		{
			if (len > max_pnstrs) 
			{
				max_pnstrs = len;
				gm->m_nLgdMaxValKey = m_PnKeyList[i];
			}
			if (len < min_pnstrs) 
			{
				min_pnstrs = len;
				gm->m_nLgdMinValKey = m_PnKeyList[i];
			}
		}

		if (fabs(len) > m_MaxAbsValue)
		{
			m_MaxAbsValue = fabs(len);
			m_KeyMaxPnStrsElem = m_PnKeyList[i];
		}

		len = GetMinElemPnStrs(pnstrs_d, gm->m_bElemCenter, nie);
		if ((m_PnStrsComponent!=SSTRS_COMPONENT_VECTOR) || (m_bVectorPositive && m_bVectorNegative))
		{
			if (len < min_pnstrs) 
			{
				min_pnstrs = len;
				gm->m_nLgdMinValKey = m_PnKeyList[i];
			}
		}
		else if ((m_bVectorPositive && len>0.) || (m_bVectorNegative && len<0))
		{
			if (len > max_pnstrs) 
			{
				max_pnstrs = len;
				gm->m_nLgdMaxValKey = m_PnKeyList[i];
			}
			if (len < min_pnstrs) 
			{
				min_pnstrs = len;
				gm->m_nLgdMinValKey = m_PnKeyList[i];
			}
		}

		if (fabs(len) > m_MaxAbsValue) 
		{
			m_MaxAbsValue = fabs(len);
			m_KeyMaxPnStrsElem = m_PnKeyList[i];
		}
	}

	if (fabs(max_pnstrs+DBL_MAX)<1.e-10) max_pnstrs=0.;
	if (fabs(min_pnstrs-DBL_MAX)<1.e-10) min_pnstrs=0.;

	if (!has_content) 
	{
		min_pnstrs = max_pnstrs = 0.0;
		gm->m_nLgdMaxValKey = 0;
		gm->m_nLgdMinValKey = 0;
	}

	m_dMaxValue = max_pnstrs;
	m_dMinValue = min_pnstrs;
	
	if (m_pContourEngine == NULL)
		m_pContourEngine = new CContourEngine(m_dMinValue, m_dMaxValue);
	else
		m_pContourEngine->MakeRankMap(m_dMinValue, m_dMaxValue);

	m_mapNodesInElem.RemoveAll();

	// MNET:XXXX-CJJEONG-20090413 (Tel : 2124) 
	if (m_bOnCuttingLine)
	{
		MakeCuttingLineDataPlaneStrain();
	}

	gm->m_pMyView->EndWaitCursor();

	m_bPnStrsDataSet = TRUE;
	return TRUE;
}

BOOL CStressEngine::GetPnStrsRangeDataList(double& dMaxRange, double& dMinRange, CArray<UINT,UINT>& aElemKeyList)
{
	aElemKeyList.RemoveAll();

	if (CTestEnvMgr::IsTestEnvST(_LSX(ProfilingSTL), _LSX(yes)))
	{
		M_PROFILE('GetPnStrsRangeDataList()');
	}

	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	int		  	i, nie;
	T_ELEM_K	elem_key;
	T_ELEM_D	elem_data;
	T_STPN_D	pnstrs_d;
	BOOL   bWithSign = m_pDoc->m_pPostCtrl->GetSignFlag();

	gm->m_pMyView->BeginWaitCursor();
	
	int elem_num = m_PnKeyList.GetSize();
	for (i=0;i<elem_num;i++) 
	{
		elem_key = m_PnKeyList[i];
		if(!GetPnStress(elem_key, pnstrs_d)) continue;

		elem_data.Initialize();
		m_pDoc->m_pAttrCtrl->GetElem(elem_key, elem_data);
		nie = m_pDoc->m_pAttrCtrl->GetNumNode(elem_data.eltyp, elem_data.elnod);

		if(!IsWithinRangeElemPnStrs(pnstrs_d, nie, dMaxRange, dMinRange)) continue;

		aElemKeyList.Add(elem_key);
	}

	gm->m_pMyView->EndWaitCursor();
	
	return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////
// Routines for Drawing Plane Strain Member Stress Contour         ///////////////////
////////////////////////////////////////////////////////////////////////////////////////
void CStressEngine::DrawPnStrsContour(CDC *pDC)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	T_MIRE_K mkey;
	
	int			  i, elem_num;
	BOOL		  fl_bak=gm->m_DOPT.DR.m_bFrameLine;
	T_ELEM_D	elem_d;
	CPen      elem_pen, *old_pen;
	CArray<int, int>				    type_list;
	CArray<GRE_Atom, GRE_Atom&>	atom_list;
	BOOL bEscapePressed = FALSE;

	/*
	if(!gm->m_bContour) 
	{
		gm->GPSDrawOriginal(pDC);
		return;
	}
	*/

	if(m_PnStrsComponent == SSTRS_COMPONENT_VECTOR)InitVectorAdjustFactorPn();

	if(m_bDeformedShapeContour) 
	{
		if(gm->m_pDeformEngine == NULL) 
		{
			return;
		}
		type_list.Add(gm->m_MinOTID + OBJECT_TYPE_DEFORMED);

		// 변형된 그림에 Undeformed Shape을 같이 그릴 경우.
		if (gm->m_DOPT.DR.m_bDrawInactive && (gm->m_DOPT.DR.m_bFrameLine||(gm->m_DOPT.DR.m_RenderFlag==2))) {
			int	rf_bak=gm->m_DOPT.DR.m_RenderFlag;
			gm->m_DOPT.DR.m_RenderFlag = 2;
			gm->GPSDrawOriginal(pDC, TRUE);
			gm->m_DOPT.DR.m_RenderFlag = rf_bak;
		}
	}
	else 
	{
		type_list.Add(gm->m_MinOTID + OBJECT_TYPE_ORIGINAL);
	}

	//elem_pen.CreatePen(PS_SOLID, gm->m_nLineWidth, m_pContourEngine->m_ElemColor);
	//elem_pen.CreatePen(PS_SOLID, gm->m_LnWd.nElemHddn, m_pContourEngine->m_ElemColor);
	elem_pen.CreatePen(PS_SOLID, gm->m_DOPT.DR.nElemHddn, m_pContourEngine->m_ElemColor);
	old_pen = (CPen *) pDC->SelectObject(&elem_pen);

	gm->m_pGPSCtrl->GetZSortedList(type_list, gm->m_EKeyListVisible_Mirror, atom_list);
	elem_num = atom_list.GetSize();
	for(i=0;i<elem_num;i++) 
	{
		//if(gm->m_pGPSCtrl->WatchEscKeyPress()) bEscapePressed = TRUE;
		if(gm->m_pGPSCtrl->WatchEscKeyPress()) return;
		if(gm->m_pGPSCtrl->IsZoomAllState() ||
			 gm->m_pGPSCtrl->IsObjectInClientWindow(atom_list[i].m_OType, atom_list[i].m_OKey)) 
		{
			mkey.keymap = atom_list[i].m_OKey;
			m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d);
			if(m_pDoc->m_pAttrCtrl->IsPlstrn(elem_d.eltyp) && (gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey)) && !bEscapePressed) 
			{
				if(m_PnStrsComponent == SSTRS_COMPONENT_VECTOR) 
				{
					// KYE-HONG-20020903 : Hidden Option살려달라고 요구 
					// gm->m_bFrameLine = TRUE;		// Vector를 그릴 경우 Hidden을 끈다.
				  if(m_bDeformedShapeContour)
						gm->m_pDeformEngine->DrawDeformedElement(pDC, atom_list[i].m_OKey);
					else
						gm->GPSDrawElement(pDC, atom_list[i].m_OKey);

					if(gm->m_bContour)
						DoPnStrsElementVector(pDC, atom_list[i].m_OKey);
				}
				else 
				{
					gm->m_DOPT.DR.m_bFrameLine = fl_bak;

					if(gm->m_bContour)
					  DoPnStrsElementContour(pDC, atom_list[i].m_OKey);
					else
						gm->GPSDrawElement(pDC,atom_list[i].m_OKey);
				}
				if(m_bHingeStatus)DrawNLHngeStatus(pDC,atom_list[i].m_OKey);
			}
			else 
			{
				// gm->m_bFrameLine = TRUE;
				if(m_bDeformedShapeContour)
					gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, atom_list[i].m_OKey);
				else
					gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
			}
		}
	}

	gm->m_pGPSCtrl->XGL_Begin_CuttingPLDiagram();
	if (m_bOnCuttingLine)
		DrawCuttingLineDiagrams(pDC);
	gm->m_pGPSCtrl->XGL_End_CuttingPLDiagram();

	gm->m_DOPT.DR.m_bFrameLine = fl_bak;

	// 변형된 그림에 Undeformed Shape을 같이 그릴 경우.
	if (m_bDeformedShapeContour && gm->m_DOPT.DR.m_bDrawInactive && (gm->m_DOPT.DR.m_bFrameLine || (gm->m_DOPT.DR.m_RenderFlag!=2)) && !bEscapePressed) {
		int	rf_bak=gm->m_DOPT.DR.m_RenderFlag;
		gm->m_DOPT.DR.m_RenderFlag = 2;
		gm->GPSDrawOriginal(pDC, TRUE);
		gm->m_DOPT.DR.m_RenderFlag = rf_bak;
	}

	pDC->SelectObject(old_pen);
	elem_pen.DeleteObject();

	//----------------------------------------------------------------------
	// UCS Icon Drawing
	//----------------------------------------------------------------------
	if( m_PnStrsVal == PSTRS_VALUE_GLOBAL&& gm->m_bVirtualMode && m_bPrintUCSAxis) 
	{
		double UCS_vector[3][3];
		GetUCSVector(m_NUCS,UCS_vector);
		DrawUCSPlaneIcon(pDC,UCS_vector);
	}  
}

// 주어진 요소의 Plane Strain Stress Contour를 그린다.
// 1. 요소의 형상정보를 얻는다.
// 2. 요소의 형상을 이루는 polygon들의 각 Vertex에 해당 Stress값을 부여한다.
// 3. polygon별로 Contour를 실시하여 Stress값에 따라 나뉘어진 sub-polygon list를 얻는다.
// 4. sub-polygon들을 그린다.
void CStressEngine::DoPnStrsElementContour(CDC *pDC, unsigned int ekey)
{
	T_MIRE_K mkey;
	mkey.keymap = ekey;
	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;
	
	int				i, j, poly_num, vtx_num, node_in_elem;
	double			pnstrs_val[4];
	BOOL			ef[4];
	T_ELEM_D		elem_d;
	T_STPN_D		pnstrs_d;

	CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray <CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					edge_list;
	CArray <CArray <T_NODE_K, T_NODE_K> *, CArray <T_NODE_K, T_NODE_K> *>	VertexNode;

	if ((gm->m_pDeformEngine==NULL) ||
		(m_pContourEngine==NULL) ||
		(!GetPnStress(mkey.key.elem_k, pnstrs_d))) {
		return;
	}

	// 1. 요소의 형상정보를 얻는다.
	m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d);
	node_in_elem = m_pDoc->m_pAttrCtrl->GetNumNode(elem_d.eltyp, elem_d.elnod);
	if (m_bDeformedShapeContour) {
		gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list, &VertexNode);
	}
	else {
		gm->GetShapeElement(ekey, polygon_list, &edge_list, NULL, &VertexNode);
	}

	gm->GPS_XGL_Begin_Elem(mkey.key.elem_k,elem_d);

	poly_num = polygon_list.GetSize();
	for (i=0;i<poly_num;i++) 
	{
		vtx_num = polygon_list[i]->GetCount();
		if (vtx_num == 2)
			continue;
		
		// 2. 요소의 형상을 이루는 polygon들의 각 Vertex에 해당 Stress값을 부여한다.
		for (j=0;j<vtx_num;j++) 
		{
			if(gm->m_bElemCenter)
			{
				pnstrs_val[j] = CalcPnStrsValue(pnstrs_d, 0);
			}
			else
			{
				pnstrs_val[j] = CalcPnStrsValue(pnstrs_d, GetNodeOrder(VertexNode[i]->GetAt(j), elem_d, node_in_elem)+1);
			}			
			if (gm->m_AnimEngine.m_bAnimateContour)
			{
				pnstrs_val[j] = m_pContourEngine->GetSubFrameValue(pnstrs_val[j], gm->m_AnimEngine.GetAnimationFactor(TRUE));
			}
			ef[j] = edge_list[i]->GetAt(j);
		}

		// 3. polygon별로 Contour를 실시하여 Stress값에 따라 나뉘어진 sub-polygon list를 얻는다.
		// 4. sub-polygon들을 그린다.
		DoSubPolyContour(pDC, pnstrs_val, polygon_list[i], ef, FALSE);

		// Fill+Outline의 경우 Contour를 수행하기 전의 Polygon의 Outline을 그림.
		if (gm->m_DOPT.DR.m_RenderFlag == 3 || gm->m_DOPT.DR.m_RenderFlag == 2)
			gm->GPSDrawPolygonEdge(pDC, polygon_list[i], edge_list[i]);
	
	}
	gm->GPS_XGL_End_Elem();
	FreeMemoryPolyList(&polygon_list,&edge_list,&VertexNode); 
	/*
	for (i=0;i<poly_num;i++) {
		polygon_list[i]->RemoveAll();
		delete polygon_list[i];
		edge_list[i]->RemoveAll();
		delete edge_list[i];
		VertexNode[i]->RemoveAll();
		delete VertexNode[i];
	}
	polygon_list.RemoveAll();
	edge_list.RemoveAll();
	VertexNode.RemoveAll();
	*/
}

void CStressEngine::DoPnStrsElementVector(CDC *pDC, unsigned int ekey)
{
	T_MIRE_K mkey;
	mkey.keymap = ekey;

	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;
	CClientDC			dc(gm->m_pMyView);
	int				i, node_num;
	double			local_vec[3][3], node_p[8][3];
	T_STPN_D		pnstrs_d;
	T_ELEM_D		edata;
	CPen			p1_pen, p2_pen, p3_pen, *old_pen,*old_pen2;
	C3DPoint		pnt_p1, arr_p11, arr_p12,
					pnt_p2, arr_p21, arr_p22,
					pnt_p3, arr_p31, arr_p32,
					pnt_c;

	if ((gm->m_pDeformEngine==NULL) ||
		(m_pContourEngine==NULL) ||
		(!GetPnStress(mkey.key.elem_k, pnstrs_d))) {
		return;
	}

	gm->m_pGPSCtrl->XGL_Begin_Diagram(ekey,FALSE); // 20060224 Changkeun

	int nThkLine = GetVectorLineWidth();

	if (gm->m_bGradient) {
		p1_pen.CreatePen(PS_SOLID, nThkLine, m_pContourEngine->GetValueColorGrad(pnstrs_d.dblStress[0][6]));
		p2_pen.CreatePen(PS_SOLID, nThkLine, m_pContourEngine->GetValueColorGrad(pnstrs_d.dblStress[0][7]));
		p3_pen.CreatePen(PS_SOLID, nThkLine, m_pContourEngine->GetValueColorGrad(pnstrs_d.dblStress[0][8]));
	}
	else {
		p1_pen.CreatePen(PS_SOLID, nThkLine, m_pContourEngine->GetValueColor(pnstrs_d.dblStress[0][6]));
		p2_pen.CreatePen(PS_SOLID, nThkLine, m_pContourEngine->GetValueColor(pnstrs_d.dblStress[0][7]));
		p3_pen.CreatePen(PS_SOLID, nThkLine, m_pContourEngine->GetValueColor(pnstrs_d.dblStress[0][8]));
	}

	if (m_bDeformedShapeContour) {
		m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, edata);
		node_num = m_pDoc->m_pAttrCtrl->GetNumNode(edata.eltyp, edata.elnod);
		for (i=0;i<node_num;i++) {
			gm->m_pDeformEngine->GetDisplacedPoint(edata.elnod[i], node_p[i]);
		}
		m_pDoc->calcPlaneLocalVector(node_num, node_p, edata.angle, local_vec);
		for (i=0;i<node_num-1;i++) {
			node_p[node_num-1][0] += node_p[i][0];
			node_p[node_num-1][1] += node_p[i][1];
			node_p[node_num-1][2] += node_p[i][2];
		}
		pnt_c.x = node_p[node_num-1][0] / ((double) node_num);
		pnt_c.y = node_p[node_num-1][1] / ((double) node_num);
		pnt_c.z = node_p[node_num-1][2] / ((double) node_num);
	}
	else {
		local_vec[0][0] = pnstrs_d.dblStress[0][12];
		local_vec[0][1] = pnstrs_d.dblStress[0][13];
		local_vec[0][2] = pnstrs_d.dblStress[0][14];
		local_vec[1][0] = pnstrs_d.dblStress[0][15];
		local_vec[1][1] = pnstrs_d.dblStress[0][16];
		local_vec[1][2] = pnstrs_d.dblStress[0][17];
		local_vec[2][0] = pnstrs_d.dblStress[0][18];
		local_vec[2][1] = pnstrs_d.dblStress[0][19];
		local_vec[2][2] = pnstrs_d.dblStress[0][20];

		m_pDoc->calcCenterElem(mkey.key.elem_k, pnt_c.x, pnt_c.y, pnt_c.z);
	}

	// Point 1
	CUtilFuncs::GetVectorDirectionPoint(local_vec[0], fabs(pnstrs_d.dblStress[0][6]),
										m_VectorAdjustFactor*m_VectorScaleFactor, pnt_c, pnt_p1);
	// Arrow Point 11
	CUtilFuncs::GetVectorDirectionPoint(local_vec[0], -pnstrs_d.dblStress[0][6]*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, pnt_p1, arr_p11);
	CUtilFuncs::GetVectorDirectionPoint(local_vec[1], fabs(pnstrs_d.dblStress[0][6])*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, arr_p11, arr_p11);
	// Arrow Point 12
	CUtilFuncs::GetVectorDirectionPoint(local_vec[0], -pnstrs_d.dblStress[0][6]*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, pnt_p1, arr_p12);
	CUtilFuncs::GetVectorDirectionPoint(local_vec[1], -fabs(pnstrs_d.dblStress[0][6])*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, arr_p12, arr_p12);

	// Point 2
	CUtilFuncs::GetVectorDirectionPoint(local_vec[1], fabs(pnstrs_d.dblStress[0][7]),
										m_VectorAdjustFactor*m_VectorScaleFactor, pnt_c, pnt_p2);
	// Arrow Point 21
	CUtilFuncs::GetVectorDirectionPoint(local_vec[1], -pnstrs_d.dblStress[0][7]*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, pnt_p2, arr_p21);
	CUtilFuncs::GetVectorDirectionPoint(local_vec[0], fabs(pnstrs_d.dblStress[0][7])*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, arr_p21, arr_p21);
	// Arrow Point 22
	CUtilFuncs::GetVectorDirectionPoint(local_vec[1], -pnstrs_d.dblStress[0][7]*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, pnt_p2, arr_p22);
	CUtilFuncs::GetVectorDirectionPoint(local_vec[0], -fabs(pnstrs_d.dblStress[0][7])*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, arr_p22, arr_p22);

	// Point 3
	CUtilFuncs::GetVectorDirectionPoint(local_vec[2], fabs(pnstrs_d.dblStress[0][8]),
										m_VectorAdjustFactor*m_VectorScaleFactor, pnt_c, pnt_p3);
	// Arrow Point 31
	CUtilFuncs::GetVectorDirectionPoint(local_vec[2], -pnstrs_d.dblStress[0][8]*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, pnt_p3, arr_p31);
	CUtilFuncs::GetVectorDirectionPoint(local_vec[1], -fabs(pnstrs_d.dblStress[0][8])*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, arr_p31, arr_p31);
	CUtilFuncs::GetVectorDirectionPoint(local_vec[0], fabs(pnstrs_d.dblStress[0][8])*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, arr_p31, arr_p31);
	// Arrow Point 32
	CUtilFuncs::GetVectorDirectionPoint(local_vec[2], -pnstrs_d.dblStress[0][8]*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, pnt_p3, arr_p32);
	CUtilFuncs::GetVectorDirectionPoint(local_vec[1], fabs(pnstrs_d.dblStress[0][8])*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, arr_p32, arr_p32);
	CUtilFuncs::GetVectorDirectionPoint(local_vec[0], -fabs(pnstrs_d.dblStress[0][8])*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, arr_p32, arr_p32);

		// Arrow of P1
	old_pen = (CPen *) pDC->SelectObject(&p1_pen);
	if(!gm->m_bVirtualMode&& !gm->m_bAnimation)
		old_pen2 = (CPen *) dc.SelectObject(&p1_pen);

	if (pnstrs_d.dblStress[0][6] < 1.e-10)
	{
		if (gm->m_pStressEngine->m_bVectorNegative)
	    DrawVectorArrow(pDC,&dc,pnt_c,pnt_p1,arr_p11,arr_p12,mkey.key.mirror_k);
	}
	else
	{
		if (gm->m_pStressEngine->m_bVectorPositive)
			DrawVectorArrow(pDC,&dc,pnt_c,pnt_p1,arr_p11,arr_p12,mkey.key.mirror_k);
	}	

	// Arrow of P2
	pDC->SelectObject(&p2_pen);
	if(!gm->m_bVirtualMode&& !gm->m_bAnimation)
		dc.SelectObject(&p2_pen);

	if (pnstrs_d.dblStress[0][7] < 1.e-10)
	{
		if (gm->m_pStressEngine->m_bVectorNegative)
			DrawVectorArrow(pDC,&dc,pnt_c,pnt_p2,arr_p21,arr_p22,mkey.key.mirror_k);
	}
	else
	{
		if (gm->m_pStressEngine->m_bVectorPositive)
			DrawVectorArrow(pDC,&dc,pnt_c,pnt_p2,arr_p21,arr_p22,mkey.key.mirror_k);
	}		
	
	// Arrow of P3
	pDC->SelectObject(&p3_pen);
	if(!gm->m_bVirtualMode&& !gm->m_bAnimation)
		dc.SelectObject(&p3_pen);

	if (pnstrs_d.dblStress[0][8] < 1.e-10)
	{
		if (gm->m_pStressEngine->m_bVectorNegative)
			DrawVectorArrow(pDC,&dc,pnt_c,pnt_p3,arr_p31,arr_p32,mkey.key.mirror_k);
	}
	else
	{
		if (gm->m_pStressEngine->m_bVectorPositive)
			DrawVectorArrow(pDC,&dc,pnt_c,pnt_p3,arr_p31,arr_p32,mkey.key.mirror_k);
	}	

	pDC->SelectObject(old_pen);
	if(!gm->m_bVirtualMode&& !gm->m_bAnimation)
		dc.SelectObject(old_pen2);
	p1_pen.DeleteObject();
	p2_pen.DeleteObject();
	p3_pen.DeleteObject();

	gm->m_pGPSCtrl->XGL_End_Elem(FALSE);
}

#if defined(__OLD_OUTPUT_VALUE)
void CStressEngine::OutputPnStrsNumbers(CDC *pDC)
{
	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;
	
	int				i, j, elem_num, node_in_elem;
	T_ELEM_K		ekey;
	T_ELEM_D		edata;
	T_NODE_D		node_d;
	T_STPN_D		pnstrs_d;
	C3DPoint		node[8],DrawPoint,Node;
	CPoint			text_p;
	TCHAR			fmt_str[10], text_str[512];
	CFont			ft, *old_ft;

	if (!m_bPnStrsDataSet)
		return;

	if (gm->m_DOPT.TX.m_bNumberOpaque)
		pDC->SetBkMode(OPAQUE);
	else
		pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
	pDC->SetBkColor(gm->m_DOPT.TX.m_NumberBackCol);
	pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);

	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T("%s%de"), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T("%s%df"), _T("%."), gm->m_NumberDecimalPoint);

	if (gm->m_DOPT.TX.m_bNumberSelOnly) {
	}
	else {
		//elem_num = gm->m_EKeyListActive.GetSize();
		BOOL bGrpFltMode=gm->m_pGPSCtrl->IsGroupFilterMode();
		if(!bGrpFltMode)elem_num = gm->m_EKeyListActive.GetSize();
		else            elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize(); 

		gm->SetNumberFontOrientation(0);
		ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
		old_ft = (CFont *) pDC->SelectObject(&ft);
		
		for (i=0;i<elem_num;i++) 
		{
			//ekey = gm->m_EKeyListActive[i];
			if(!bGrpFltMode)ekey = gm->m_EKeyListActive[i];
			else            ekey = gm->m_pDispFilter->m_aGrpEKey[i]; 

			if(!gm->m_pGPSCtrl->IsActiveElem(ekey))
				continue;

			m_pDoc->m_pAttrCtrl->GetElem(ekey, edata);

			if (!m_pDoc->m_pAttrCtrl->IsPlstrn(edata.eltyp))
				continue;
			node_in_elem = m_pDoc->m_pAttrCtrl->GetNumNode(edata.eltyp, edata.elnod);

			for (j=0;j<node_in_elem;j++) 
			{
				m_pDoc->m_pAttrCtrl->GetNode(edata.elnod[j], node_d);
			  if (m_bDeformedShapeContour)
				{
					Node.x = node_d.x; Node.y = node_d.y; Node.z = node_d.z;
					node[j] = gm->m_pDeformEngine->GetDisplacedPoint(edata.elnod[j], Node);
				}
				else
					node[j].Set(node_d.x, node_d.y, node_d.z);
			}

		
			GetPnStress(ekey, pnstrs_d);
			for (j=0;j<node_in_elem-1;j++) {
				node[node_in_elem-1].x += node[j].x;
				node[node_in_elem-1].y += node[j].y;
				node[node_in_elem-1].z += node[j].z;
			}
			
			DrawPoint.x =  (node[node_in_elem-1].x/((double) node_in_elem));
			DrawPoint.y =  (node[node_in_elem-1].y/((double) node_in_elem));
			DrawPoint.z =  (node[node_in_elem-1].z/((double) node_in_elem));

			double MaxStr, MinStr;
			if(gm->m_nValOpt == 1)
			{
				MaxStr = MinStr = CalcPnStrsValue(pnstrs_d, 0);
			}
			else
			{
				MaxStr = GetMaxElemPnStrs(pnstrs_d, gm->m_nValOpt == 1, node_in_elem);
				MinStr = GetMinElemPnStrs(pnstrs_d, gm->m_nValOpt == 1, node_in_elem);
			}

			double dAbsMaxStr = 0.;
			
			if ((m_PnStrsComponent!=SSTRS_COMPONENT_VECTOR) || (m_bVectorPositive && m_bVectorNegative))
				dAbsMaxStr = (fabs(MaxStr) > fabs(MinStr))? MaxStr:MinStr;
			else if (m_bVectorPositive)
				dAbsMaxStr = fabs(MaxStr);
			else if (m_bVectorNegative)
				dAbsMaxStr = fabs(MinStr);
		
			/////////////////////////////////////////////////////////////////////////////////////////////
			if(gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
			{
				double dLimit = (m_dMaxValue-m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;
				
				// MNET:XXXX-CJJEONG-20080508
				if ((m_PnStrsComponent!=SSTRS_COMPONENT_VECTOR) || (m_bVectorPositive && m_bVectorNegative))
				{
					switch(gm->m_DOPT.TX.m_nOutputMinMaxType)
					{
					case 0: // Min & Max
						if((m_dMaxValue-MaxStr) <= dLimit)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,MaxStr);
						else if((MinStr-m_dMinValue) <= dLimit)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,MinStr);
						break;
					case 1: // Abs Max
						if(fabs(m_dMaxValue) >= fabs(m_dMinValue))
						{
							if( fabs(m_dMaxValue)-fabs(dAbsMaxStr) <= dLimit)
								DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dAbsMaxStr);
						}
						else
						{
							if( fabs(m_dMinValue)-fabs(dAbsMaxStr) <= dLimit)
								DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dAbsMaxStr);
						}
						break;
					case 2: // Max
						if((m_dMaxValue-MaxStr) <= dLimit)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,MaxStr);
						break;
					case 3: // Min
						if((MinStr-m_dMinValue) <= dLimit)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,MinStr);
						break;
					}
				}
				else if (m_bVectorPositive && m_dMaxValue>0.)
				{
					switch(gm->m_DOPT.TX.m_nOutputMinMaxType)
					{
					case 0: // Min & Max
						if((m_dMaxValue-MaxStr) <= dLimit  && MaxStr>0.)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,MaxStr);
						else if((MinStr-m_dMinValue) <= dLimit && MinStr>0.)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,MinStr);
						break;
					case 1: // Abs Max
						if(fabs(m_dMaxValue)-fabs(dAbsMaxStr) <= dLimit)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dAbsMaxStr);
						break;
					case 2: // Max
						if((m_dMaxValue-MaxStr) <= dLimit && MaxStr>0.)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,MaxStr);
						break;
					case 3: // Min
						if ((MaxStr-m_dMinValue) <= dLimit && MaxStr>0.)                          
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,MaxStr);            
						break;
					}
				}
				else if (m_bVectorNegative && m_dMinValue<0.)
				{
					switch(gm->m_DOPT.TX.m_nOutputMinMaxType)
					{
					case 0: // Min & Max
						if((m_dMaxValue-MaxStr) <= dLimit  && MaxStr<0.)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,MaxStr);
						else if((MinStr-m_dMinValue) <= dLimit && MinStr<0.)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,MinStr);
						break;
					case 1: // Abs Max
						if( fabs(m_dMinValue)-fabs(dAbsMaxStr) <= dLimit)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dAbsMaxStr);
						break;
					case 2: // Max
						if((m_dMaxValue-MinStr) <= dLimit && MinStr<0.)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,MinStr);
						break;
					case 3: // Min
						if((MinStr-m_dMinValue) <= dLimit && MinStr<0.)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,MinStr);
						break;
					}
				} 
			//////////////////////////////////////////////////////////////////////////////////////
			}
			else
			{
				if (gm->m_bVirtualMode)
			    text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(DrawPoint);
		    else
			    text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(DrawPoint);

				// MNET:XXXX-CJJEONG-20080508
				BOOL bText = TRUE;
				if (m_bVectorPositive && m_bVectorNegative)
				{
					if (fabs(MaxStr) > fabs(MinStr))
						_stprintf(text_str, fmt_str, MaxStr);
					else
						_stprintf(text_str, fmt_str, MinStr);
				}
				else if (m_bVectorPositive && MaxStr>0.)
					_stprintf(text_str, fmt_str, MaxStr);
				else if (m_bVectorNegative && MinStr<0.)        
					_stprintf(text_str, fmt_str, MinStr);
				else bText = FALSE;
				
				if(text_p.x>=0 && text_p.y>=0 && bText)
					pDC->TextOut(text_p.x, text_p.y, text_str);
			}
		}
		pDC->SelectObject(old_ft);
		ft.DeleteObject();
	}
}
#else
void CStressEngine::OutputPnStrsNumbers(CDC* pDC)
{
	I_GPSModel* gm = (I_GPSModel*)m_pGPSModel;

	int				i, j, elem_num, node_in_elem;
	T_ELEM_K		ekey;
	T_ELEM_D		edata;
	T_NODE_D		node_d;
	T_STPN_D		pnstrs_d;
	C3DPoint		node[8], DrawPoint, Node;
	CPoint			text_p;
	TCHAR			fmt_str[10], text_str[512];
	CFont			ft, * old_ft;

	if (!m_bPnStrsDataSet)
		return;

	GPostTextOut TextOutModel;
	TextOutModel.SetDC(pDC);
	TextOutModel.StartPStrainStressVal();
	TextOutModel.SettingPStrainStress(gm);

	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T("%s%de"), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T("%s%df"), _T("%."), gm->m_NumberDecimalPoint);

	if (gm->m_DOPT.TX.m_bNumberSelOnly) {
	}
	else {
		//elem_num = gm->m_EKeyListActive.GetSize();
		BOOL bGrpFltMode = gm->m_pGPSCtrl->IsGroupFilterMode();
		if (!bGrpFltMode)elem_num = gm->m_EKeyListActive.GetSize();
		else            elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize();

		TextOutModel.Font4PStrainStress(gm, 0);

		for (i = 0; i < elem_num; i++)
		{
			//ekey = gm->m_EKeyListActive[i];
			if (!bGrpFltMode)ekey = gm->m_EKeyListActive[i];
			else            ekey = gm->m_pDispFilter->m_aGrpEKey[i];

			if (!gm->m_pGPSCtrl->IsActiveElem(ekey))
				continue;

			m_pDoc->m_pAttrCtrl->GetElem(ekey, edata);

			if (!m_pDoc->m_pAttrCtrl->IsPlstrn(edata.eltyp))
				continue;
			node_in_elem = m_pDoc->m_pAttrCtrl->GetNumNode(edata.eltyp, edata.elnod);

			for (j = 0; j < node_in_elem; j++)
			{
				m_pDoc->m_pAttrCtrl->GetNode(edata.elnod[j], node_d);
				if (m_bDeformedShapeContour)
				{
					Node.x = node_d.x; Node.y = node_d.y; Node.z = node_d.z;
					node[j] = gm->m_pDeformEngine->GetDisplacedPoint(edata.elnod[j], Node);
				}
				else
					node[j].Set(node_d.x, node_d.y, node_d.z);
			}


			GetPnStress(ekey, pnstrs_d);
			for (j = 0; j < node_in_elem - 1; j++) {
				node[node_in_elem - 1].x += node[j].x;
				node[node_in_elem - 1].y += node[j].y;
				node[node_in_elem - 1].z += node[j].z;
			}

			DrawPoint.x = (node[node_in_elem - 1].x / ((double)node_in_elem));
			DrawPoint.y = (node[node_in_elem - 1].y / ((double)node_in_elem));
			DrawPoint.z = (node[node_in_elem - 1].z / ((double)node_in_elem));

			double MaxStr, MinStr;
			if (gm->m_nValOpt == 1)
			{
				MaxStr = MinStr = CalcPnStrsValue(pnstrs_d, 0);
			}
			else
			{
				MaxStr = GetMaxElemPnStrs(pnstrs_d, gm->m_nValOpt == 1, node_in_elem);
				MinStr = GetMinElemPnStrs(pnstrs_d, gm->m_nValOpt == 1, node_in_elem);
			}

			double dAbsMaxStr = 0.;

			if ((m_PnStrsComponent != SSTRS_COMPONENT_VECTOR) || (m_bVectorPositive && m_bVectorNegative))
				dAbsMaxStr = (fabs(MaxStr) > fabs(MinStr)) ? MaxStr : MinStr;
			else if (m_bVectorPositive)
				dAbsMaxStr = fabs(MaxStr);
			else if (m_bVectorNegative)
				dAbsMaxStr = fabs(MinStr);

			/////////////////////////////////////////////////////////////////////////////////////////////
			if (gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
			{
				double dLimit = (m_dMaxValue - m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;

				// MNET:XXXX-CJJEONG-20080508
				if ((m_PnStrsComponent != SSTRS_COMPONENT_VECTOR) || (m_bVectorPositive && m_bVectorNegative))
				{
					switch (gm->m_DOPT.TX.m_nOutputMinMaxType)
					{
					case 0: // Min & Max
						if ((m_dMaxValue - MaxStr) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, MaxStr);
						else if ((MinStr - m_dMinValue) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, MinStr);
						break;
					case 1: // Abs Max
						if (fabs(m_dMaxValue) >= fabs(m_dMinValue))
						{
							if (fabs(m_dMaxValue) - fabs(dAbsMaxStr) <= dLimit)
								DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, dAbsMaxStr);
						}
						else
						{
							if (fabs(m_dMinValue) - fabs(dAbsMaxStr) <= dLimit)
								DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, dAbsMaxStr);
						}
						break;
					case 2: // Max
						if ((m_dMaxValue - MaxStr) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, MaxStr);
						break;
					case 3: // Min
						if ((MinStr - m_dMinValue) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, MinStr);
						break;
					}
				}
				else if (m_bVectorPositive && m_dMaxValue > 0.)
				{
					switch (gm->m_DOPT.TX.m_nOutputMinMaxType)
					{
					case 0: // Min & Max
						if ((m_dMaxValue - MaxStr) <= dLimit && MaxStr > 0.)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, MaxStr);
						else if ((MinStr - m_dMinValue) <= dLimit && MinStr > 0.)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, MinStr);
						break;
					case 1: // Abs Max
						if (fabs(m_dMaxValue) - fabs(dAbsMaxStr) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, dAbsMaxStr);
						break;
					case 2: // Max
						if ((m_dMaxValue - MaxStr) <= dLimit && MaxStr > 0.)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, MaxStr);
						break;
					case 3: // Min
						if ((MaxStr - m_dMinValue) <= dLimit && MaxStr > 0.)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, MaxStr);
						break;
					}
				}
				else if (m_bVectorNegative && m_dMinValue < 0.)
				{
					switch (gm->m_DOPT.TX.m_nOutputMinMaxType)
					{
					case 0: // Min & Max
						if ((m_dMaxValue - MaxStr) <= dLimit && MaxStr < 0.)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, MaxStr);
						else if ((MinStr - m_dMinValue) <= dLimit && MinStr < 0.)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, MinStr);
						break;
					case 1: // Abs Max
						if (fabs(m_dMinValue) - fabs(dAbsMaxStr) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, dAbsMaxStr);
						break;
					case 2: // Max
						if ((m_dMaxValue - MinStr) <= dLimit && MinStr < 0.)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, MinStr);
						break;
					case 3: // Min
						if ((MinStr - m_dMinValue) <= dLimit && MinStr < 0.)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, MinStr);
						break;
					}
				}
				//////////////////////////////////////////////////////////////////////////////////////
			}
			else
			{
				if (gm->m_bVirtualMode)
					text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(DrawPoint);
				else
					text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(DrawPoint);

				// MNET:XXXX-CJJEONG-20080508
				BOOL bText = TRUE;
				if (m_bVectorPositive && m_bVectorNegative)
				{
					if (fabs(MaxStr) > fabs(MinStr))
						_stprintf(text_str, fmt_str, MaxStr);
					else
						_stprintf(text_str, fmt_str, MinStr);
				}
				else if (m_bVectorPositive && MaxStr > 0.)
					_stprintf(text_str, fmt_str, MaxStr);
				else if (m_bVectorNegative && MinStr < 0.)
					_stprintf(text_str, fmt_str, MinStr);
				else bText = FALSE;

				if (text_p.x >= 0 && text_p.y >= 0 && bText)
					TextOutModel.TextOutPStrainStress(text_p.x, text_p.y, text_str);
			}
		}
		TextOutModel.DeleteFont();
	}
	TextOutModel.EndPStrainStressVal();
}
#endif
////////////////////////////////////////////////////////////////////////////////////////
// Initialization and Utility Routines for Axisymmetric Member Stress   ///////////////
////////////////////////////////////////////////////////////////////////////////////////
double CStressEngine::CalcAxStrsValue(T_STAX_D &axstrs_d, int node)
{
	double	len=0.0;

	switch (m_AxStrsComponent) {
		case SSTRS_COMPONENT_SIGXX:
		case SSTRS_COMPONENT_SIGX:
			len = axstrs_d.dblStress[node][0];
			break;
		case SSTRS_COMPONENT_SIGYY:
		case SSTRS_COMPONENT_SIGY:
			len = axstrs_d.dblStress[node][1];
			break;
		case SSTRS_COMPONENT_SIGZZ:
		case SSTRS_COMPONENT_SIGZ:
			len = axstrs_d.dblStress[node][2];
			break;
		case SSTRS_COMPONENT_LOCSIGXY:
		case SSTRS_COMPONENT_SIGXY:
		  len = axstrs_d.dblStress[node][3];
		  break;
		case SSTRS_COMPONENT_LOCSIGYZ:
		case SSTRS_COMPONENT_SIGYZ:
		  len = axstrs_d.dblStress[node][4];
		  break;
		case SSTRS_COMPONENT_SIGXZ:
			len = axstrs_d.dblStress[node][5];
			break;
		case SSTRS_COMPONENT_SIGP1:
			len = axstrs_d.dblStress[node][6];
			break;
		case SSTRS_COMPONENT_SIGP2:
			len = axstrs_d.dblStress[node][7];
			break;
		case SSTRS_COMPONENT_SIGP3:
			len = axstrs_d.dblStress[node][8];
			break;
		case SSTRS_COMPONENT_SHRMAX:
			len = axstrs_d.dblStress[node][9];
			break;
		case SSTRS_COMPONENT_SIGEFF:
			len = axstrs_d.dblStress[node][10];
			break;
		case SSTRS_COMPONENT_SIGMAX:
			if(fabs(axstrs_d.dblStress[node][6]) > fabs(axstrs_d.dblStress[node][7]))
				len = axstrs_d.dblStress[node][6];
			else
				len = axstrs_d.dblStress[node][7];
			if(fabs(len) < fabs(axstrs_d.dblStress[node][8]))
				len = axstrs_d.dblStress[node][8];

	}

	return len;
}

void CStressEngine::SetAxStrsComponent(T_STAX_D &axstrs_d, int node, double strs_val)
{
	switch (m_AxStrsComponent) {
		case SSTRS_COMPONENT_SIGXX:
		case SSTRS_COMPONENT_SIGX:
			axstrs_d.dblStress[node][0] = strs_val;
			break;
		case SSTRS_COMPONENT_SIGYY:
		case SSTRS_COMPONENT_SIGY:
			axstrs_d.dblStress[node][1] = strs_val;
			break;
		case SSTRS_COMPONENT_SIGZZ:
		case SSTRS_COMPONENT_SIGZ:
			axstrs_d.dblStress[node][2] = strs_val;
			break;
		case SSTRS_COMPONENT_LOCSIGXY:
		case SSTRS_COMPONENT_SIGXY:      
			axstrs_d.dblStress[node][3] = strs_val;
			break;
		case SSTRS_COMPONENT_LOCSIGYZ:
		case SSTRS_COMPONENT_SIGYZ:
			axstrs_d.dblStress[node][4] = strs_val;
			break; 
		case SSTRS_COMPONENT_LOCSIGXZ:
		case SSTRS_COMPONENT_SIGXZ:
			axstrs_d.dblStress[node][5] = strs_val;
			break;
		case SSTRS_COMPONENT_SIGP1:
			axstrs_d.dblStress[node][6] = strs_val;
			break;
		case SSTRS_COMPONENT_SIGP2:
			axstrs_d.dblStress[node][7] = strs_val;
			break;
		case SSTRS_COMPONENT_SIGP3:
			axstrs_d.dblStress[node][8] = strs_val;
			break;
		case SSTRS_COMPONENT_SHRMAX:
			axstrs_d.dblStress[node][9] = strs_val;
			break;
		case SSTRS_COMPONENT_SIGEFF:
			axstrs_d.dblStress[node][10] = strs_val;
			break;
	}
}

double CStressEngine::GetMaxElemAxStrs(T_STAX_D &axstrs_d, BOOL bCenter, int node_num)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	double		len, max=-DBL_MAX;

	if (m_AxStrsComponent == SSTRS_COMPONENT_VECTOR) 
	{
		if (max < axstrs_d.dblStress[0][6])
		{
			max = axstrs_d.dblStress[0][6];
		}
		if (max < axstrs_d.dblStress[0][7])
		{
			max = axstrs_d.dblStress[0][7];
		}
		if (max < axstrs_d.dblStress[0][8])
		{
			max = axstrs_d.dblStress[0][8];
		}
	}
	else
	{
		if(bCenter)
		{
			len = CalcAxStrsValue(axstrs_d, 0);
			if (max < len)
			{
				max = len;
			}
		}
		else
		{
			for (int i=0;i<node_num;i++) 
			{
				len = CalcAxStrsValue(axstrs_d, i+1);
				if (max < len)
				{
					max = len;
				}
			}
		}
	}

	return max;
}

double CStressEngine::GetMinElemAxStrs(T_STAX_D &axstrs_d, BOOL bCenter, int node_num)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	double		len, min=DBL_MAX;

	if (m_AxStrsComponent == SSTRS_COMPONENT_VECTOR)
	{
		if (min > axstrs_d.dblStress[0][6]) 
		{
			min = axstrs_d.dblStress[0][6];
		}
		if (min > axstrs_d.dblStress[0][7])
		{
			min = axstrs_d.dblStress[0][7];
		}
		if (min > axstrs_d.dblStress[0][8])
		{
			min = axstrs_d.dblStress[0][8];
		}
	}
	else 
	{
		if(bCenter)
		{
			len = CalcAxStrsValue(axstrs_d, 0);
			if (min > len) 
			{
				min = len;
			}
		}
		else
		{
			for (int i=0;i<node_num;i++) 
			{
				len = CalcAxStrsValue(axstrs_d, i+1);
				if (min > len) 
				{
					min = len;
				}
			}
		}
	}

	return min;
}

BOOL CStressEngine::IsWithinRangeElemAxStrs(T_STAX_D &StaxD,int node_num,double& max_stax,double& min_stax)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	double len_max = GetMaxElemAxStrs(StaxD, gm->m_bElemCenter, node_num);
	double len_min = GetMinElemAxStrs(StaxD, gm->m_bElemCenter, node_num);

	if (len_min <= min_stax && len_max >= max_stax)
		return TRUE;
	if (len_min >= min_stax && len_min <= max_stax)
		return TRUE;
	if (len_max >= min_stax && len_max <= max_stax)
		return TRUE;

	return FALSE;
}

// 각 노드별로 인접한 요소의 Stress 값의 평균값을 구한다.
void CStressEngine::GetAverageNodalDataListAx(BOOL bInitCalc/*=TRUE*/)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	MakeSerialNodeMap();
	T_NODE_K serial_node;
	
	int			i, j, linked_elem_num, nodes_in_elem,
				node_num=m_pDoc->m_pAttrCtrl->GetCountNode(), elem_num=m_AxKeyList.GetSize();
	double		strs_val;
	T_ELEM_D	elem_data;
	T_STAX_D  stax_d;
	CArray <double, double &>											*elem_ptr;
	CArray <CArray <double, double &> *, CArray <double, double &> *>	elem_ptr_list;

	// KYE-HONG-200605
	// Global인 경우 von-Mises와 Tresca는 
	// 각 Component별로 Average한 다음 
	// 각 응력 계산을 하고 그것을 Average한다. 
	if(bInitCalc)
	if(m_AxStrsVal == PSTRS_VALUE_GLOBAL)
	if(m_AxStrsComponent == SSTRS_COMPONENT_SIGP1 || 
		 m_AxStrsComponent == SSTRS_COMPONENT_SIGP2 ||
		 m_AxStrsComponent == SSTRS_COMPONENT_SIGP3 ||
		 m_AxStrsComponent == SSTRS_COMPONENT_SHRMAX ||
		 m_AxStrsComponent == SSTRS_COMPONENT_SIGEFF ||
		 m_AxStrsComponent == SSTRS_COMPONENT_SIGMAX)
	{
		int nBackSStrsComponent = m_AxStrsComponent;
		int nCompNum = 6;
		int nComponent[] = {  SSTRS_COMPONENT_SIGXX, SSTRS_COMPONENT_SIGYY, SSTRS_COMPONENT_SIGZZ, 
													SSTRS_COMPONENT_SIGXY, SSTRS_COMPONENT_SIGYZ, SSTRS_COMPONENT_SIGXZ };

		// Component별 Average
		for(i=0; i<nCompNum; i++)
		{
			m_AxStrsComponent = nComponent[i]; 
			GetAverageNodalDataListAx(FALSE);
		}
		
		// von-Mises와 Tresca를 다시 계산한다. 
		for(i=0; i<elem_num; i++)
		{
			m_mapAxStrsData.Lookup(m_AxKeyList[i],stax_d);

			for(j=0; j<5; j++)
			{
				CDBDoc::GetDocPoint()->m_pPostCtrl->PRIN_SOL( &stax_d.dblStress[j][0], 
																											&stax_d.dblStress[j][6], 
																											(double(*)[3])(&stax_d.dblStress[j][12]));
			}
			m_mapAxStrsData.SetAt(m_AxKeyList[i],stax_d);
		}
		m_AxStrsComponent = nBackSStrsComponent;
		// GetAverageNodalDataListS(FALSE);
		return; 
	}


	for (i=0;i<node_num;i++) {
		elem_ptr = new CArray <double, double &>;
		elem_ptr_list.Add(elem_ptr);
	}

	for (i=0;i<elem_num;i++) 
	{
		m_pDoc->m_pAttrCtrl->GetElem(m_AxKeyList[i], elem_data);
		m_mapNodesInElem.Lookup(m_AxKeyList[i],nodes_in_elem);
		for (j=0;j<nodes_in_elem;j++)
		{
			m_mapAxStrsData.Lookup(m_AxKeyList[i],stax_d);
			if(gm->m_bElemCenter)
			{
				strs_val = CalcAxStrsValue(stax_d, 0);
			}
			else
			{
				strs_val = CalcAxStrsValue(stax_d, j+1);
			}
			if(!m_mapSerialNode.Lookup(elem_data.elnod[j],serial_node)) continue;
			elem_ptr_list[serial_node]->Add(strs_val);
		}
	}

	for (i=0;i<node_num;i++) {
		linked_elem_num = elem_ptr_list[i]->GetSize();
		if (linked_elem_num < 2)
			continue;
		strs_val = 0.0;
		for (j=0;j<linked_elem_num;j++) {
			strs_val += elem_ptr_list[i]->GetAt(j);
		}
		strs_val /= (double) linked_elem_num;
		elem_ptr_list[i]->SetAt(0, strs_val);
	}

	for (i=0;i<elem_num;i++) {
		m_pDoc->m_pAttrCtrl->GetElem(m_AxKeyList[i], elem_data);
		m_mapNodesInElem.Lookup(m_AxKeyList[i],nodes_in_elem);
		for (j=0;j<nodes_in_elem;j++) {
			m_mapAxStrsData.Lookup(m_AxKeyList[i],stax_d);
			if(!m_mapSerialNode.Lookup(elem_data.elnod[j],serial_node)) continue;
			strs_val = elem_ptr_list[serial_node]->GetAt(0);
			SetAxStrsComponent(stax_d, j+1, strs_val);
			m_mapAxStrsData.SetAt(m_AxKeyList[i],stax_d);
		}
	}

	for (i=0;i<node_num;i++) {
		elem_ptr_list[i]->RemoveAll();
		delete elem_ptr_list[i];
	}
	elem_ptr_list.RemoveAll();
}

// Axisymmetric Key List 중 현재 Active인 것들의 List를 구한다.
void CStressEngine::GetActiveAxList()
{

	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	
	int			i, elem_num;
	
	T_ELEM_K	elem_key;
	T_ELEM_D  elem_data;	
	m_AxKeyList.RemoveAll();
	elem_num = gm->m_EKeyListActive.GetSize(); 
	
	for (i=0;i<elem_num;i++) 
	{
		elem_key = gm->m_EKeyListActive[i];
		
		m_pDoc->m_pAttrCtrl->GetElem(elem_key, elem_data);
		if (m_pDoc->m_pAttrCtrl->IsAxisym(elem_data.eltyp))
			m_AxKeyList.Add(elem_key);
	}

	
}

void CStressEngine::InitVectorAdjustFactorAx()
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	C3DPoint	min_pm, max_pm, min_pe, max_pe;
	double		max_lm, max_le, max_l;

	if(m_bLockAdjFactor)
		return;

	if (!m_pDoc->m_pAttrCtrl->ExistElem(m_KeyMaxAxStrsElem)) {
		m_VectorAdjustFactor = 1.0;
		return;
	}

	// 전체 모델의 Range와 최대값이 발생한 요소의 Range를 동시에 고려한다.

/*	m_pDoc->calcRangeModel(min_pm.x, min_pm.y, min_pm.z,
								   max_pm.x, max_pm.y, max_pm.z,
								   NULL, NULL, TRUE, NULL, TRUE,
								   gm->m_bFrameThick||gm->m_bPlaneThick);*/
		
	gm->GetRangeModel(&min_pm,&max_pm);
	max_lm = max(max(max_pm.x-min_pm.x, max_pm.y-min_pm.y), max_pm.z-min_pm.z);

	gm->GetRangeElement(m_KeyMaxAxStrsElem, &min_pe, &max_pe);
	max_le = max(max(max_pe.x-min_pe.x, max_pe.y-min_pe.y), max_pe.z-min_pe.z);

	if (m_MaxAbsValue > -1e-15 && m_MaxAbsValue < 1e-15)
		m_MaxAbsValue = 1.0f;

	if ((max_le*0.35) < (max_lm/40.0)) {
		max_l = max_lm/40.0;
	}
	else {
		max_l = max_le*0.35;
	}

	m_VectorAdjustFactor = max_l / m_MaxAbsValue;
}
 
// Axisymmetric Stress 데이터를 만든다.
// 전체 Element List에 대해 Loop를 돌며
// 1. DB로 부터 해당 Element의 Axisymmetric Stress 데이터를 얻고
// 2. Axisymmetric Stress값 및 해당 Element번호 등을 CArray에 저장
// 3. 필요시 각 노드별로 인접한 요소의 Axisymmetric Stress의 값의 평균값을 구한다.
// 4. Axisymmetric Key List 중 현재 Active인 것들의 List를 구한다.
// 5. 현재 Active Axisymmetric Key List에 대해 Loop를 돌며 최대/최소값을 갱신한다.
BOOL CStressEngine::MakeAxStrsDataList()
{
	if (CTestEnvMgr::IsTestEnvST(_LSX(ProfilingSTL), _LSX(yes)))
	{
		M_PROFILE('MakeAxStrsDataList()');
	}

	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	if(!gm->m_bLoadDataSet)	return FALSE;

	int			  i, elem_num, nie;
	double		max_axstrs=-DBL_MAX, min_axstrs=DBL_MAX, len;
	BOOL		  has_content=FALSE;
	T_ELEM_K	elem_key;
	T_STAX_D	axstrs_d;
	T_STAX_D	axstrs_max,axstrs_min;
	BOOL      bWithSign = m_pDoc->m_pPostCtrl->GetSignFlag();

	gm->m_pMyView->BeginWaitCursor();

	m_AxKeyList.RemoveAll();
	m_mapAxStrsData.RemoveAll();

	// Get the Original LoadCombination Data
	T_LCOM_D  LcomOrg=m_pDoc->m_pPostCtrl->GetLoadComb();

	if(m_bAverageNodalActiveOnly || !(m_AxStrsAve == PSTRS_VALUE_AVENODAL))
	  elem_num = gm->m_EKeyListActive.GetSize(); // Active된 요소에 대해서만 Average Nodal을 계산.
	else
		elem_num = gm->m_EKeyList.GetSize(); // Average Nodal이 가능하도록...전체 요소를 취한다.

	if(m_AxStrsAve == PSTRS_VALUE_AVENODAL) MakeSerialNodeMap();

	CMap<T_ELEM_K,T_ELEM_K,T_STAX_D,T_STAX_D&> mapAxStrsDataMax,mapAxStrsDataMin;
	mapAxStrsDataMax.InitHashTable(HASHSIZEELEM);
	mapAxStrsDataMin.InitHashTable(HASHSIZEELEM);
	MakeAxStrsDataListLcom(LcomOrg,elem_num,1.0,mapAxStrsDataMax,mapAxStrsDataMin);
	
	for(i=0;i<m_AxKeyList.GetSize();i++) 
	{
		elem_key = m_AxKeyList[i];
		mapAxStrsDataMax.Lookup(elem_key, axstrs_max);
		mapAxStrsDataMin.Lookup(elem_key, axstrs_min);
		
		switch (gm->m_LoadMinMaxType) 
		{
		case LOADTYPE_NORMAL:
		case LOADTYPE_MAX:
			m_mapAxStrsData.SetAt(elem_key,axstrs_max);
			break;
		case LOADTYPE_MIN:
			m_mapAxStrsData.SetAt(elem_key,axstrs_min);
			break;
		case LOADTYPE_ALL:
			if(bWithSign)
				axstrs_max.AbsMaxwithSign(axstrs_min);
			else
				axstrs_max.AbsMax(axstrs_min);
			m_mapAxStrsData.SetAt(elem_key,axstrs_max);
			break;
		}
	}
	
	// Back to the Original LoadCombination Data
	m_pDoc->m_pPostCtrl->ChangeLoadComb(LcomOrg);

	// 3. 필요시 각 노드별로 인접한 요소의 Axisymmetric Stress의 값의 평균값을 구한다.
	// 1번 단계에서 구하도록 한다. (버그수정)
	//if (m_AxStrsAve == PSTRS_VALUE_AVENODAL) { GetAverageNodalDataListAx(); }

	// 4. Axisymmetric Key List 중 현재 Active인 것들의 List를 구한다.
	if(!(m_bAverageNodalActiveOnly || !(m_AxStrsAve == PSTRS_VALUE_AVENODAL)))
		GetActiveAxList();

	// 5. 현재 Active Axisymmetric Key List에 대해 Loop를 돌며 최대/최소값을 갱신한다.
	elem_num = m_AxKeyList.GetSize();
	if(elem_num) has_content = TRUE;
	m_MaxAbsValue = -DBL_MAX;

	for (i=0;i<elem_num;i++) {
		m_mapAxStrsData.Lookup(m_AxKeyList[i], axstrs_d);
		m_mapNodesInElem.Lookup(m_AxKeyList[i],nie);
		len = GetMaxElemAxStrs(axstrs_d, gm->m_bElemCenter, nie);
		if (len > max_axstrs) 
		{
			max_axstrs = len;
			gm->m_nLgdMaxValKey = m_AxKeyList[i];
		}
		if (fabs(len) > m_MaxAbsValue) {
			m_MaxAbsValue = fabs(len);
			m_KeyMaxAxStrsElem = m_AxKeyList[i];
		}

		len = GetMinElemAxStrs(axstrs_d, gm->m_bElemCenter, nie);
		if (len < min_axstrs) 
		{
			min_axstrs = len;
			gm->m_nLgdMinValKey = m_AxKeyList[i];
		}
		if (fabs(len) > m_MaxAbsValue) {
			m_MaxAbsValue = fabs(len);
			m_KeyMaxAxStrsElem = m_AxKeyList[i];
		}
	}

	if (!has_content) 
	{
		min_axstrs = max_axstrs = 0.0;
		gm->m_nLgdMaxValKey = 0;
		gm->m_nLgdMinValKey = 0;
	}

	m_dMaxValue = max_axstrs;
	m_dMinValue = min_axstrs;

	if (m_pContourEngine == NULL)
		m_pContourEngine = new CContourEngine(min_axstrs, max_axstrs);
	else
		m_pContourEngine->MakeRankMap(min_axstrs, max_axstrs);

	m_mapNodesInElem.RemoveAll();

	gm->m_pMyView->EndWaitCursor();

	m_bAxStrsDataSet = TRUE;
	return TRUE;
}

BOOL CStressEngine::GetAxStrsRangeDataList(double& dMaxRange, double& dMinRange, CArray<UINT,UINT>& aElemKeyList)
{
	aElemKeyList.RemoveAll();

	if (CTestEnvMgr::IsTestEnvST(_LSX(ProfilingSTL), _LSX(yes)))
	{
		M_PROFILE('GetAxStrsRangeDataList()');
	}

	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	int			  i, nie;
	T_ELEM_K	elem_key;
	T_ELEM_D	elem_data;
	T_STAX_D	axstrs_d;
	BOOL      bWithSign = m_pDoc->m_pPostCtrl->GetSignFlag();

	gm->m_pMyView->BeginWaitCursor();

	// 5. 현재 Active Axisymmetric Key List에 대해 Loop를 돌며 최대/최소값을 갱신한다.
	int elem_num = m_AxKeyList.GetSize();
	for (i=0;i<elem_num;i++)
	{
		elem_key = m_AxKeyList[i];
		if(!m_mapAxStrsData.Lookup(elem_key, axstrs_d)) continue;

		elem_data.Initialize();
		m_pDoc->m_pAttrCtrl->GetElem(elem_key, elem_data);
		nie = m_pDoc->m_pAttrCtrl->GetNumNode(elem_data.eltyp, elem_data.elnod);

		if(!IsWithinRangeElemAxStrs(axstrs_d, nie, dMaxRange, dMinRange)) continue;

		aElemKeyList.Add(elem_key);
	}

	gm->m_pMyView->EndWaitCursor();
	
	return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////
// Routines for Drawing Axisymmetric Member Stress Contour         ////////////////////
////////////////////////////////////////////////////////////////////////////////////////

void CStressEngine::DrawAxStrsContour(CDC *pDC)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	
	int			i, elem_num;
	BOOL		fl_bak=gm->m_DOPT.DR.m_bFrameLine;
	T_ELEM_D	elem_d;
	CPen		elem_pen, *old_pen;
	CArray <int, int>				type_list;
	CArray <GRE_Atom, GRE_Atom>		atom_list;
	BOOL bEscapePressed = FALSE;
	T_MIRE_K mkey;

	/*
	if (!gm->m_bContour) {
		gm->GPSDrawOriginal(pDC);
		return;
	}
	*/

	if (m_AxStrsComponent == SSTRS_COMPONENT_VECTOR)
		InitVectorAdjustFactorAx();

	if (m_bDeformedShapeContour) {
		if (gm->m_pDeformEngine == NULL) {
			return;
		}
		type_list.Add(gm->m_MinOTID + OBJECT_TYPE_DEFORMED);
		if (gm->m_DOPT.DR.m_bDrawInactive && (gm->m_DOPT.DR.m_bFrameLine||(gm->m_DOPT.DR.m_RenderFlag==2))) {
			int	rf_bak=gm->m_DOPT.DR.m_RenderFlag;
			gm->m_DOPT.DR.m_RenderFlag = 2;
			gm->GPSDrawOriginal(pDC, TRUE);
			gm->m_DOPT.DR.m_RenderFlag = rf_bak;
		}
	}
	else {
		type_list.Add(gm->m_MinOTID + OBJECT_TYPE_ORIGINAL);
	}

	//elem_pen.CreatePen(PS_SOLID, gm->m_nLineWidth, m_pContourEngine->m_ElemColor);
	//elem_pen.CreatePen(PS_SOLID, gm->m_LnWd.nElemHddn, m_pContourEngine->m_ElemColor);
	elem_pen.CreatePen(PS_SOLID, gm->m_DOPT.DR.nElemHddn, m_pContourEngine->m_ElemColor);
	old_pen = (CPen *) pDC->SelectObject(&elem_pen);

	gm->m_pGPSCtrl->GetZSortedList(type_list, gm->m_EKeyListVisible_Mirror, atom_list);
	elem_num = atom_list.GetSize();
	for (i=0;i<elem_num;i++) {
		//if(gm->m_pGPSCtrl->WatchEscKeyPress()) bEscapePressed = TRUE;
		if(gm->m_pGPSCtrl->WatchEscKeyPress()) return;
		if(gm->m_pGPSCtrl->IsZoomAllState() ||
			gm->m_pGPSCtrl->IsObjectInClientWindow(atom_list[i].m_OType, atom_list[i].m_OKey)) {
			mkey.keymap = atom_list[i].m_OKey;
			m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d);
			if(m_pDoc->m_pAttrCtrl->IsAxisym(elem_d.eltyp) && (gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey)) && !bEscapePressed) 
			{
				if(m_AxStrsComponent == SSTRS_COMPONENT_VECTOR) 
				{
				  // KYE-HONG-20020903 : Hidden Option살려달라고 요구 
					//gm->m_bFrameLine = TRUE;		// Vector를 그릴 경우 Hidden을 끈다.
					if(m_bDeformedShapeContour)
						gm->m_pDeformEngine->DrawDeformedElement(pDC, atom_list[i].m_OKey);
					else
						gm->GPSDrawElement(pDC, atom_list[i].m_OKey);

					if(gm->m_bContour)
					  DoAxStrsElementVector(pDC, atom_list[i].m_OKey);
				}
				else 
				{
					gm->m_DOPT.DR.m_bFrameLine = fl_bak;
					if(gm->m_bContour)
					  DoAxStrsElementContour(pDC, atom_list[i].m_OKey);
					else
						gm->GPSDrawElement(pDC,atom_list[i].m_OKey);
				}
				if(m_bHingeStatus)DrawNLHngeStatus(pDC,atom_list[i].m_OKey);
			}
			else {
				// gm->m_bFrameLine = TRUE;
				if (m_bDeformedShapeContour)
					gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, atom_list[i].m_OKey);
				else
					gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
			}
		}
	}

	gm->m_DOPT.DR.m_bFrameLine = fl_bak;

	// 변형된 그림에 Undeformed Shape을 같이 그릴 경우.
	if (m_bDeformedShapeContour && gm->m_DOPT.DR.m_bDrawInactive && (gm->m_DOPT.DR.m_bFrameLine || (gm->m_DOPT.DR.m_RenderFlag!=2)) && !bEscapePressed) {
		int	rf_bak=gm->m_DOPT.DR.m_RenderFlag;
		gm->m_DOPT.DR.m_RenderFlag = 2;
		gm->GPSDrawOriginal(pDC, TRUE);
		gm->m_DOPT.DR.m_RenderFlag = rf_bak;
	}

	pDC->SelectObject(old_pen);
	elem_pen.DeleteObject();

	//----------------------------------------------------------------------
	// UCS Icon Drawing
	//----------------------------------------------------------------------
	if( m_AxStrsVal == PSTRS_VALUE_GLOBAL&& gm->m_bVirtualMode && m_bPrintUCSAxis) 
	{
		double UCS_vector[3][3];
		GetUCSVector(m_NUCS,UCS_vector);
		DrawUCSPlaneIcon(pDC,UCS_vector);
	}  
}

// 주어진 요소의 Axisymmetric Stress Contour를 그린다.
// 1. 요소의 형상정보를 얻는다.
// 2. 요소의 형상을 이루는 polygon들의 각 Vertex에 해당 Stress값을 부여한다.
// 3. polygon별로 Contour를 실시하여 Stress값에 따라 나뉘어진 sub-polygon list를 얻는다.
// 4. sub-polygon들을 그린다.
void CStressEngine::DoAxStrsElementContour(CDC *pDC, unsigned int ekey)
{
	T_MIRE_K mkey;
	mkey.keymap = ekey;
	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;
	
	int				i, j, poly_num, vtx_num, node_in_elem;
	double			axstrs_val[4];
	BOOL			ef[4];
	T_ELEM_D		elem_d;
	T_STAX_D		axstrs_d;

	CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray <CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					edge_list;
	CArray <CArray <T_NODE_K, T_NODE_K> *, CArray <T_NODE_K, T_NODE_K> *>	VertexNode;

	if ((gm->m_pDeformEngine==NULL) ||
		(m_pContourEngine==NULL) ||
		(!GetAxStress(mkey.key.elem_k, axstrs_d)))
	{
		return;
	}

	// 1. 요소의 형상정보를 얻는다.
	m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d);
	node_in_elem = m_pDoc->m_pAttrCtrl->GetNumNode(elem_d.eltyp, elem_d.elnod);
	if (m_bDeformedShapeContour) 
	{
		gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list, &VertexNode);
	}
	else 
	{
		gm->GetShapeElement(ekey, polygon_list, &edge_list, NULL, &VertexNode);
	}

	gm->GPS_XGL_Begin_Elem(mkey.key.elem_k,elem_d);
	poly_num = polygon_list.GetSize();
	for (i=0;i<poly_num;i++)
	{
		vtx_num = polygon_list[i]->GetCount();
		if (vtx_num == 2)
		{
			continue;
		}
		else
		{
			// 2. 요소의 형상을 이루는 polygon들의 각 Vertex에 해당 Stress값을 부여한다.
			for (j=0;j<vtx_num;j++)
			{
				if(gm->m_bElemCenter)
				{
					axstrs_val[j] = CalcAxStrsValue(axstrs_d, 0);
				}
				else
				{
					axstrs_val[j] = CalcAxStrsValue(axstrs_d, GetNodeOrder(VertexNode[i]->GetAt(j), elem_d, node_in_elem)+1);
				}
				if (gm->m_AnimEngine.m_bAnimateContour)
					axstrs_val[j] = m_pContourEngine->GetSubFrameValue(axstrs_val[j], gm->m_AnimEngine.GetAnimationFactor(TRUE));
				ef[j] = edge_list[i]->GetAt(j);
			}

			// 3. polygon별로 Contour를 실시하여 Stress값에 따라 나뉘어진 sub-polygon list를 얻는다.
			// 4. sub-polygon들을 그린다.
			DoSubPolyContour(pDC, axstrs_val, polygon_list[i], ef, FALSE);

			// Fill+Outline의 경우 Contour를 수행하기 전의 Polygon의 Outline을 그림.
			if (gm->m_DOPT.DR.m_RenderFlag == 3 || gm->m_DOPT.DR.m_RenderFlag == 2)
				gm->GPSDrawPolygonEdge(pDC, polygon_list[i], edge_list[i]);
		}
	}
	gm->GPS_XGL_End_Elem();
	FreeMemoryPolyList(&polygon_list,&edge_list,&VertexNode); 
	/*
	for (i=0;i<poly_num;i++) {
		polygon_list[i]->RemoveAll();
		delete polygon_list[i];
		edge_list[i]->RemoveAll();
		delete edge_list[i];
		VertexNode[i]->RemoveAll();
		delete VertexNode[i];
	}
	polygon_list.RemoveAll();
	edge_list.RemoveAll();
	VertexNode.RemoveAll();
	*/
}

void CStressEngine::DoAxStrsElementVector(CDC *pDC, unsigned int ekey)
{
	T_MIRE_K mkey;
	mkey.keymap = ekey;
		
	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;
	CClientDC			dc(gm->m_pMyView);
	int				i, node_num;
	double			local_vec[3][3], node_p[8][3];
	T_STAX_D		axstrs_d;
	T_ELEM_D		edata;
	CPen			p1_pen, p2_pen, p3_pen, *old_pen,*old_pen2;
	C3DPoint		pnt_p1, arr_p11, arr_p12,
					pnt_p2, arr_p21, arr_p22,
					pnt_p3, arr_p31, arr_p32,
					pnt_c;

	if ((gm->m_pDeformEngine==NULL) ||
		(m_pContourEngine==NULL) ||
		(!GetAxStress(mkey.key.elem_k, axstrs_d))) {
		return;
	}
	
	gm->m_pGPSCtrl->XGL_Begin_Diagram(ekey,FALSE); // 20060224 Changkeun

	int nThkLine = GetVectorLineWidth();

	if (gm->m_bGradient) 
	{
		p1_pen.CreatePen(PS_SOLID, nThkLine, m_pContourEngine->GetValueColorGrad(axstrs_d.dblStress[0][6]));
		p2_pen.CreatePen(PS_SOLID, nThkLine, m_pContourEngine->GetValueColorGrad(axstrs_d.dblStress[0][7]));
		p3_pen.CreatePen(PS_SOLID, nThkLine, m_pContourEngine->GetValueColorGrad(axstrs_d.dblStress[0][8]));
	}
	else {
		p1_pen.CreatePen(PS_SOLID, nThkLine, m_pContourEngine->GetValueColor(axstrs_d.dblStress[0][6]));
		p2_pen.CreatePen(PS_SOLID, nThkLine, m_pContourEngine->GetValueColor(axstrs_d.dblStress[0][7]));
		p3_pen.CreatePen(PS_SOLID, nThkLine, m_pContourEngine->GetValueColor(axstrs_d.dblStress[0][8]));
	}

	if (m_bDeformedShapeContour) {
		m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, edata);
		node_num = m_pDoc->m_pAttrCtrl->GetNumNode(edata.eltyp, edata.elnod);
		for (i=0;i<node_num;i++) {
			gm->m_pDeformEngine->GetDisplacedPoint(edata.elnod[i], node_p[i]);
		}
		m_pDoc->calcPlaneLocalVector(node_num, node_p, 0.0, local_vec);
		for (i=0;i<node_num-1;i++) {
			node_p[node_num-1][0] += node_p[i][0];
			node_p[node_num-1][1] += node_p[i][1];
			node_p[node_num-1][2] += node_p[i][2];
		}
		pnt_c.x = node_p[node_num-1][0] / ((double) node_num);
		pnt_c.y = node_p[node_num-1][1] / ((double) node_num);
		pnt_c.z = node_p[node_num-1][2] / ((double) node_num);
	}
	else {
		local_vec[0][0] = axstrs_d.dblStress[0][12];
		local_vec[0][1] = axstrs_d.dblStress[0][13];
		local_vec[0][2] = axstrs_d.dblStress[0][14];
		local_vec[1][0] = axstrs_d.dblStress[0][15];
		local_vec[1][1] = axstrs_d.dblStress[0][16];
		local_vec[1][2] = axstrs_d.dblStress[0][17];
		local_vec[2][0] = axstrs_d.dblStress[0][18];
		local_vec[2][1] = axstrs_d.dblStress[0][19];
		local_vec[2][2] = axstrs_d.dblStress[0][20];

		m_pDoc->calcCenterElem(mkey.key.elem_k, pnt_c.x, pnt_c.y, pnt_c.z);
	}

	// Point 1
	CUtilFuncs::GetVectorDirectionPoint(local_vec[0], fabs(axstrs_d.dblStress[0][6]),
										m_VectorAdjustFactor*m_VectorScaleFactor, pnt_c, pnt_p1);
	// Arrow Point 11
	CUtilFuncs::GetVectorDirectionPoint(local_vec[0], -axstrs_d.dblStress[0][6]*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, pnt_p1, arr_p11);
	CUtilFuncs::GetVectorDirectionPoint(local_vec[1], fabs(axstrs_d.dblStress[0][6])*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, arr_p11, arr_p11);
	// Arrow Point 12
	CUtilFuncs::GetVectorDirectionPoint(local_vec[0], -axstrs_d.dblStress[0][6]*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, pnt_p1, arr_p12);
	CUtilFuncs::GetVectorDirectionPoint(local_vec[1], -fabs(axstrs_d.dblStress[0][6])*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, arr_p12, arr_p12);

	// Point 2
	CUtilFuncs::GetVectorDirectionPoint(local_vec[1], fabs(axstrs_d.dblStress[0][7]),
										m_VectorAdjustFactor*m_VectorScaleFactor, pnt_c, pnt_p2);
	// Arrow Point 21
	CUtilFuncs::GetVectorDirectionPoint(local_vec[1], -axstrs_d.dblStress[0][7]*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, pnt_p2, arr_p21);
	CUtilFuncs::GetVectorDirectionPoint(local_vec[0], fabs(axstrs_d.dblStress[0][7])*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, arr_p21, arr_p21);
	// Arrow Point 22
	CUtilFuncs::GetVectorDirectionPoint(local_vec[1], -axstrs_d.dblStress[0][7]*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, pnt_p2, arr_p22);
	CUtilFuncs::GetVectorDirectionPoint(local_vec[0], -fabs(axstrs_d.dblStress[0][7])*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, arr_p22, arr_p22);

	// Point 3
	CUtilFuncs::GetVectorDirectionPoint(local_vec[2], fabs(axstrs_d.dblStress[0][8]),
										m_VectorAdjustFactor*m_VectorScaleFactor, pnt_c, pnt_p3);
	// Arrow Point 31
	CUtilFuncs::GetVectorDirectionPoint(local_vec[2], -axstrs_d.dblStress[0][8]*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, pnt_p3, arr_p31);
	CUtilFuncs::GetVectorDirectionPoint(local_vec[1], -fabs(axstrs_d.dblStress[0][8])*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, arr_p31, arr_p31);
	CUtilFuncs::GetVectorDirectionPoint(local_vec[0], fabs(axstrs_d.dblStress[0][8])*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, arr_p31, arr_p31);
	// Arrow Point 32
	CUtilFuncs::GetVectorDirectionPoint(local_vec[2], -axstrs_d.dblStress[0][8]*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, pnt_p3, arr_p32);
	CUtilFuncs::GetVectorDirectionPoint(local_vec[1], fabs(axstrs_d.dblStress[0][8])*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, arr_p32, arr_p32);
	CUtilFuncs::GetVectorDirectionPoint(local_vec[0], -fabs(axstrs_d.dblStress[0][8])*0.2,
										m_VectorAdjustFactor*m_VectorScaleFactor, arr_p32, arr_p32);

		// Arrow of P1
	old_pen = (CPen *) pDC->SelectObject(&p1_pen);
	if(!gm->m_bVirtualMode&& !gm->m_bAnimation)
		old_pen2 = (CPen *) dc.SelectObject(&p1_pen);

	DrawVectorArrow(pDC,&dc,pnt_c,pnt_p1,arr_p11,arr_p12,mkey.key.mirror_k);
	

	// Arrow of P2
	pDC->SelectObject(&p2_pen);
	if(!gm->m_bVirtualMode&& !gm->m_bAnimation)
		dc.SelectObject(&p2_pen);

	DrawVectorArrow(pDC,&dc,pnt_c,pnt_p2,arr_p21,arr_p22,mkey.key.mirror_k);
	
	// Arrow of P3
	pDC->SelectObject(&p3_pen);
	if(!gm->m_bVirtualMode&& !gm->m_bAnimation)
		dc.SelectObject(&p3_pen);

	DrawVectorArrow(pDC,&dc,pnt_c,pnt_p3,arr_p31,arr_p32,mkey.key.mirror_k);



	pDC->SelectObject(old_pen);
	if(!gm->m_bVirtualMode&& !gm->m_bAnimation)
		dc.SelectObject(old_pen2);
	p1_pen.DeleteObject();
	p2_pen.DeleteObject();
	p3_pen.DeleteObject();

	gm->m_pGPSCtrl->XGL_End_Elem(FALSE); // 20060224 Changkeun
}

#if defined(__OLD_OUTPUT_VALUE)
void CStressEngine::OutputAxStrsNumbers(CDC *pDC)
{
	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;
	
	int				i, j, elem_num, node_in_elem;
	T_ELEM_K		ekey;
	T_ELEM_D		edata;
	T_NODE_D		node_d;
	T_STAX_D		axstrs_d;
	C3DPoint		node[8],DrawPoint,Node;
	CPoint			text_p;
	TCHAR			fmt_str[10], text_str[512];
	CFont			ft, *old_ft;

	if (!m_bAxStrsDataSet)
		return;

	if (gm->m_DOPT.TX.m_bNumberOpaque)
		pDC->SetBkMode(OPAQUE);
	else
		pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
	pDC->SetBkColor(gm->m_DOPT.TX.m_NumberBackCol);
	pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);

	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T("%s%de"), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T("%s%df"), _T("%."), gm->m_NumberDecimalPoint);

	if (gm->m_DOPT.TX.m_bNumberSelOnly) {
	}
	else {
		gm->SetNumberFontOrientation(0);
		ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
		old_ft = (CFont *) pDC->SelectObject(&ft);

		//elem_num = gm->m_EKeyListActive.GetSize();
		BOOL bGrpFltMode=gm->m_pGPSCtrl->IsGroupFilterMode();
		if(!bGrpFltMode)elem_num = gm->m_EKeyListActive.GetSize();
		else            elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize(); 

		for (i=0;i<elem_num;i++) 
		{
			//ekey = gm->m_EKeyListActive[i];
			if(!bGrpFltMode)ekey = gm->m_EKeyListActive[i];
			else            ekey = gm->m_pDispFilter->m_aGrpEKey[i]; 

			if(!gm->m_pGPSCtrl->IsActiveElem(ekey))
				continue;

			m_pDoc->m_pAttrCtrl->GetElem(ekey, edata);

			if (!m_pDoc->m_pAttrCtrl->IsAxisym(edata.eltyp))
				continue;
			node_in_elem = m_pDoc->m_pAttrCtrl->GetNumNode(edata.eltyp, edata.elnod);

			
			for (j=0;j<node_in_elem;j++) 
			{
				m_pDoc->m_pAttrCtrl->GetNode(edata.elnod[j], node_d);
			  if (m_bDeformedShapeContour)
				{
					Node.x = node_d.x; Node.y = node_d.y; Node.z = node_d.z;
					node[j] = gm->m_pDeformEngine->GetDisplacedPoint(edata.elnod[j], Node);
				}
				else
					node[j].Set(node_d.x, node_d.y, node_d.z);
			}

		  GetAxStress(ekey, axstrs_d);

			for (j=0;j<node_in_elem-1;j++) {
				node[node_in_elem-1].x += node[j].x;
				node[node_in_elem-1].y += node[j].y;
				node[node_in_elem-1].z += node[j].z;
			}
			
			DrawPoint.x =  (node[node_in_elem-1].x/((double) node_in_elem));
			DrawPoint.y =  (node[node_in_elem-1].y/((double) node_in_elem));
			DrawPoint.z =  (node[node_in_elem-1].z/((double) node_in_elem));

			double MaxStr = GetMaxElemAxStrs(axstrs_d, gm->m_nValOpt == 1, node_in_elem);
			double MinStr = GetMinElemAxStrs(axstrs_d, gm->m_nValOpt == 1, node_in_elem);
			double dAbsMaxStr = (fabs(MaxStr) > fabs(MinStr))? MaxStr:MinStr;
		
			/////////////////////////////////////////////////////////////////////////////////////////////
			if(gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
			{
				double dLimit = (m_dMaxValue-m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;
		
				switch(gm->m_DOPT.TX.m_nOutputMinMaxType)
				{
				case 0: // Min & Max
					if((m_dMaxValue-MaxStr) <= dLimit)
						 DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,MaxStr);
					else if((MinStr-m_dMinValue) <= dLimit)
						 DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,MinStr);
					break;
				case 1: // Abs Max
					if(fabs(m_dMaxValue) >= fabs(m_dMinValue))
					{
						if( fabs(m_dMaxValue)-fabs(dAbsMaxStr) <= dLimit)
						DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dAbsMaxStr);
					}
					else
					{
						if( fabs(m_dMinValue)-fabs(dAbsMaxStr) <= dLimit)
						DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dAbsMaxStr);
					}
					break;
				case 2: // Max
					if((m_dMaxValue-MaxStr) <= dLimit)
						 DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,MaxStr);
					break;
				case 3: // Min
					if((MinStr-m_dMinValue) <= dLimit)
						 DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,MinStr);
					break;
				}
			//////////////////////////////////////////////////////////////////////////////////////
			}
			else
			{
				if (gm->m_bVirtualMode)
			    text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(DrawPoint);
		    else
			    text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(DrawPoint);

		    if (fabs(MaxStr) > fabs(MinStr))
				  _stprintf(text_str, fmt_str, MaxStr);
			  else
				  _stprintf(text_str, fmt_str, MinStr);
				if(text_p.x>=0 && text_p.y>=0)
			    pDC->TextOut(text_p.x, text_p.y, text_str);
			}
		}
		pDC->SelectObject(old_ft);
		ft.DeleteObject();
	}
}
#else
void CStressEngine::OutputAxStrsNumbers(CDC* pDC)
{
	I_GPSModel* gm = (I_GPSModel*)m_pGPSModel;

	int				i, j, elem_num, node_in_elem;
	T_ELEM_K		ekey;
	T_ELEM_D		edata;
	T_NODE_D		node_d;
	T_STAX_D		axstrs_d;
	C3DPoint		node[8], DrawPoint, Node;
	CPoint			text_p;
	TCHAR			fmt_str[10], text_str[512];

	if (!m_bAxStrsDataSet)
		return;

	GPostTextOut TextOutModel;
	TextOutModel.SetDC(pDC);
	TextOutModel.StartAxisSymStressVal();
	TextOutModel.SettingAxisSymStress(gm);

	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T("%s%de"), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T("%s%df"), _T("%."), gm->m_NumberDecimalPoint);

	if (gm->m_DOPT.TX.m_bNumberSelOnly) {
	}
	else {
		TextOutModel.Font4AxisSymStress(gm, 0);
		BOOL bGrpFltMode = gm->m_pGPSCtrl->IsGroupFilterMode();
		if (!bGrpFltMode)elem_num = gm->m_EKeyListActive.GetSize();
		else            elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize();

		for (i = 0; i < elem_num; i++)
		{
			if (!bGrpFltMode)ekey = gm->m_EKeyListActive[i];
			else            ekey = gm->m_pDispFilter->m_aGrpEKey[i];

			if (!gm->m_pGPSCtrl->IsActiveElem(ekey))
				continue;

			m_pDoc->m_pAttrCtrl->GetElem(ekey, edata);

			if (!m_pDoc->m_pAttrCtrl->IsAxisym(edata.eltyp))
				continue;
			node_in_elem = m_pDoc->m_pAttrCtrl->GetNumNode(edata.eltyp, edata.elnod);


			for (j = 0; j < node_in_elem; j++)
			{
				m_pDoc->m_pAttrCtrl->GetNode(edata.elnod[j], node_d);
				if (m_bDeformedShapeContour)
				{
					Node.x = node_d.x; Node.y = node_d.y; Node.z = node_d.z;
					node[j] = gm->m_pDeformEngine->GetDisplacedPoint(edata.elnod[j], Node);
				}
				else
					node[j].Set(node_d.x, node_d.y, node_d.z);
			}

			GetAxStress(ekey, axstrs_d);

			for (j = 0; j < node_in_elem - 1; j++) {
				node[node_in_elem - 1].x += node[j].x;
				node[node_in_elem - 1].y += node[j].y;
				node[node_in_elem - 1].z += node[j].z;
			}

			DrawPoint.x = (node[node_in_elem - 1].x / ((double)node_in_elem));
			DrawPoint.y = (node[node_in_elem - 1].y / ((double)node_in_elem));
			DrawPoint.z = (node[node_in_elem - 1].z / ((double)node_in_elem));

			double MaxStr = GetMaxElemAxStrs(axstrs_d, gm->m_nValOpt == 1, node_in_elem);
			double MinStr = GetMinElemAxStrs(axstrs_d, gm->m_nValOpt == 1, node_in_elem);
			double dAbsMaxStr = (fabs(MaxStr) > fabs(MinStr)) ? MaxStr : MinStr;

			/////////////////////////////////////////////////////////////////////////////////////////////
			if (gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
			{
				double dLimit = (m_dMaxValue - m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;

				switch (gm->m_DOPT.TX.m_nOutputMinMaxType)
				{
				case 0: // Min & Max
					if ((m_dMaxValue - MaxStr) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, MaxStr);
					else if ((MinStr - m_dMinValue) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, MinStr);
					break;
				case 1: // Abs Max
					if (fabs(m_dMaxValue) >= fabs(m_dMinValue))
					{
						if (fabs(m_dMaxValue) - fabs(dAbsMaxStr) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, dAbsMaxStr);
					}
					else
					{
						if (fabs(m_dMinValue) - fabs(dAbsMaxStr) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, dAbsMaxStr);
					}
					break;
				case 2: // Max
					if ((m_dMaxValue - MaxStr) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, MaxStr);
					break;
				case 3: // Min
					if ((MinStr - m_dMinValue) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, MinStr);
					break;
				}
				//////////////////////////////////////////////////////////////////////////////////////
			}
			else
			{
				if (gm->m_bVirtualMode)
					text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(DrawPoint);
				else
					text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(DrawPoint);

				if (fabs(MaxStr) > fabs(MinStr))
					_stprintf(text_str, fmt_str, MaxStr);
				else
					_stprintf(text_str, fmt_str, MinStr);
				if (text_p.x >= 0 && text_p.y >= 0)
					TextOutModel.TextOutAxisSymStress(text_p.x, text_p.y, text_str);
			}
		}
		TextOutModel.DeleteFont();
	}
}
#endif


int CStressEngine::GetTopBot(int nSurface, int nVertexNum) 
// for plate only;
// Where is the Vertex, On Top Surface or Bot. Surface?
{
	
	if(nSurface == 0)
	{
		return 0; // all vertexes are on the top
	}
	else if(nSurface == 1)
	{
		return 1; // all vertexes are on the bottom
	}
	else if(nSurface == 2)
	{
		if(nVertexNum <2)
			return 1; // the first two vertexes are on the bottom;
		else
			return 0;
	}
	return 0;
}


////////////////////////////////////////////////////////////////////////////////////////////////
// Solid Isosurface Contour Routines
////////////////////////////////////////////////////////////////////////////////////////////////


// 주어진 요소의 Solid Stress IsoSurface Contour를 그린다.
// 1. 요소의 형상정보를 얻는다.
// 2. 요소의 형상을 이루는 polygon들의 각 Vertex에 해당 Solid Stress값을 부여한다.
// 3. Marching Cube 알고리즘을 통해 ISOSUFACE를 이루는 triangle Polygon들을 얻는다.
// 4. polygon들을 그린다.
void CStressEngine::DoSStrsElementIsoSurfaceContour(CDC *pDC, unsigned int ekey,CArray <double,double>& aIsoValues)
{
	T_MIRE_K mkey;
	mkey.keymap = ekey;

	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;
	CClientDC			dc(gm->m_pMyView);
	int				i, j, poly_num, node_in_elem;
	double			sstrs_val[8];
	CArray <double,double> aIsoValues_val;
	
	T_ELEM_D		elem_d;
	T_NODE_D    node_d;
	T_STRS_D		sstrs_d;
	double dContourValue;
	double max,min;
	
	C3DPoint aVertexes[8];
	CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray <int, int>		sort_index_list;
	CArray <CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					edge_list;
	
	if ((gm->m_pDeformEngine==NULL) ||
		(m_pContourEngine==NULL) ||
		(!GetSolidStress(mkey.key.elem_k, sstrs_d)))
	{
		return;
	}
	
	max = m_pContourEngine->m_MaxRange;
	min = m_pContourEngine->m_MinRange;
	
	// 1. 요소의 형상정보를 얻는다.
	m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d);
	node_in_elem = m_pDoc->m_pAttrCtrl->GetNumNode(elem_d.eltyp, elem_d.elnod);


	for (j=0;j<node_in_elem;j++) 
	{
		if(gm->m_bElemCenter)
		{
			sstrs_val[j] = CalcSStrsValue(sstrs_d,0);
		}
		else
		{
			sstrs_val[j] = CalcSStrsValue(sstrs_d,j+1);
		}		
		m_pDoc->m_pAttrCtrl->GetNode(elem_d.elnod[j],node_d);
		aVertexes[j].Set(node_d.x,node_d.y,node_d.z);
		if(m_bDeformedShapeContour)
			aVertexes[j] = gm->m_pDeformEngine->GetDisplacedPoint(elem_d.elnod[j],aVertexes[j]);

		gm->RE_GetMirroredPoint(mkey.key.mirror_k,&aVertexes[j]);
		
	}

	int nNumIsoValue = aIsoValues.GetSize();
	
	if(gm->m_nIsoValueMode == 0)
	{
		for(i=0; i<nNumIsoValue; i++)
			aIsoValues_val.Add(min + (max-min)*aIsoValues[i]);
	}
	else
		aIsoValues_val.Copy(aIsoValues);

	if (gm->m_AnimEngine.m_bAnimateContour && gm->m_bAnimation) 
	{	// animation range setup
		// IsoValue가 없을때는 최대 최소, 1개 있을 때는 최대와 IsoValue[0], 2개 이상일때는 IsoValue중 최대 최소
		if(nNumIsoValue==1)
			min = aIsoValues_val[0];
		else if(nNumIsoValue>1)
		{
			double dValMax = aIsoValues_val[0];
			double dValMin = aIsoValues_val[0];
			for(int i=1; i<nNumIsoValue; i++)
			{
				if(dValMax<aIsoValues_val[i])
					dValMax = aIsoValues_val[i];
				if(dValMin>aIsoValues_val[i])
					dValMin = aIsoValues_val[i];
			}
			min = dValMin;
			max = dValMax;
		}
		nNumIsoValue = 1;
	}

	gm->GPS_XGL_Begin_Elem(mkey.key.elem_k, elem_d);

	int nDC = pDC->SaveDC();
	pDC->SelectStockObject(NULL_PEN);
	CPen elem_edgepen;
	elem_edgepen.CreatePen(PS_SOLID, 1, m_pContourEngine->m_ElemColor);
	for(int n=0; n<nNumIsoValue; n++)
	{
		
		if (gm->m_AnimEngine.m_bAnimateContour && gm->m_bAnimation)
			dContourValue = min + (max-min)*gm->m_AnimEngine.GetAnimationFactor(TRUE);
		else
		{	
			dContourValue = aIsoValues_val[n];
		}

		switch(node_in_elem)
		{
			case 4:
				GetTetraSolidContourPolys(dContourValue,sstrs_val,aVertexes,polygon_list, edge_list);
				break;
			case 6:
				GetWedgeSolidContourPolys(dContourValue,sstrs_val,aVertexes,polygon_list, edge_list);
				break;
			case 8:
				GetHexaSolidContourPolys(dContourValue,sstrs_val,aVertexes,polygon_list, edge_list);
				break;
			default:
				ASSERT(FALSE);
				return; // error
			}

		poly_num = polygon_list.GetSize();
		sort_index_list.RemoveAll();
		//if(gm->m_pGPSCtrl->IsGLRenderer())
		//  gm->m_pGPSCtrl->GetZ
		//else
		gm->m_pGPSCtrl->GetZSortPolygonList(polygon_list, sort_index_list);
		COLORREF color =m_pContourEngine->GetValueColor(dContourValue);
		
		for (i=0;i<poly_num;i++) 
		{
			
			// 4. polygon들을 그린다.
			//
			//if(gm->m_bVirtualMode || !gm->m_bTransparent) //Chang-keun수정 
			//{
			//  gm->DrawPolygon3DFill(pDC, *polygon_list[sort_index_list[i]],color,&dc);
			//}

			if(gm->m_bVirtualMode) // 20060213 Chang-keun start
			{
				
				if(gm->m_pGPSCtrl->IsGLRenderer() && gm->m_bTransparent) // Virtual mode blending GLMode에서만 가능함. 
				{
					int Intensity = gm->m_nTransparentIntensity;// / 255.f * 100.f; //Max 255기준 --> max 100으로 변경. 
					gm->DrawBlendedPolygon3DFill(pDC,*polygon_list[sort_index_list[i]],color,Intensity,&dc);
				}
				else
				{
					gm->DrawPolygon3DFill(pDC, *polygon_list[sort_index_list[i]],color,&dc);
				}
			}   // 20060213 Chang-keun end
			else
			{
				if(gm->m_bTransparent)
				{ 
					int Intensity = gm->m_nTransparentIntensity;
					if(gm->m_pGPSCtrl->IsGLRenderer())
					{
				    Intensity = gm->m_nTransparentIntensity;// / 255.f * 100.f; //Max 255기준  --> Max 100으로 변경.
					}
					
					gm->DrawBlendedPolygon3DFill(pDC, *polygon_list[sort_index_list[i]],color,Intensity,&dc);
				}
				else
				{
					gm->DrawPolygon3DFill(pDC, *polygon_list[sort_index_list[i]],color,&dc);
				}
			}
		  
			if(gm->m_bDrawPolyOutLine)
			{
				pDC->SelectObject(&elem_edgepen);
				gm->GPSDrawPolygonEdge(pDC, polygon_list[sort_index_list[i]], edge_list[i]);
				pDC->SelectStockObject(NULL_PEN);
			}
		}


		for (i=0;i<poly_num;i++) 
		{
			polygon_list[i]->RemoveAll();
			delete []polygon_list[i];
			edge_list[i]->RemoveAll();
			delete []edge_list[i];
		}
		polygon_list.RemoveAll();
		edge_list.RemoveAll();
	}
	pDC->RestoreDC(nDC);
	elem_edgepen.DeleteObject();

	gm->GPS_XGL_End_Elem();
	
	CArray <CArray <T_NODE_K, T_NODE_K> *, CArray <T_NODE_K, T_NODE_K> *>	VertexNode;
	CArray <C3DPoint, C3DPoint> aUnSortedVertex;
	
	if (m_bDeformedShapeContour) 
	{
		gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list,NULL, NULL,&aUnSortedVertex);
	}
	else
	{
		gm->GetShapeElement(ekey, polygon_list, NULL, NULL, NULL,&aUnSortedVertex);
	}
		
	DrawSolidFreeEdge(pDC,ekey,aUnSortedVertex);

	poly_num = polygon_list.GetSize();
	for (i=0;i<poly_num;i++)
	{
		polygon_list[i]->RemoveAll();
		delete []polygon_list[i];
		
	}
	polygon_list.RemoveAll();
	
	
	
}


BOOL CStressEngine::GetNodalValueforCutting(T_ELEM_K PlateKey,double& NodalVal1,int i, double& NodalVal2, int j)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	T_STRP_DG		pstrs_d;


	if(GetPlaneStress(PlateKey, pstrs_d))
	{
		NodalVal1 = CalcPStrsValue(pstrs_d, i+1, 0); // i:0= Center,/ Top or Bottom
		NodalVal2 = CalcPStrsValue(pstrs_d, j+1, 0); 
	}
	else
	{
		return FALSE; 
	}
	return TRUE; 
}

BOOL CStressEngine::GetNodalValueforCuttingPlane(T_ELEM_K PlaneKey,double& NodalVal1,int i, double& NodalVal2, int j)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	T_STPN_D		pstrs_d;
			
	if(GetPnStress(PlaneKey, pstrs_d))
	{
		NodalVal1 = CalcPnStrsValue(pstrs_d, i+1); // i:0= Center,/ Top or Bottom
		NodalVal2 = CalcPnStrsValue(pstrs_d, j+1); 
	}
	else
	{
		return FALSE; 
	}
	return TRUE; 
}

void CStressEngine::ResetEngine()
{
	CEngineBase::ResetEngine();

	m_InflScFc              = 1.0; 
	m_VectorAdjustFactor		= 1.0;
	m_VectorScaleFactor			= 1.0;
	m_bAverageNodalActiveOnly = FALSE; // Plate,Solid,Axisym,PlnStrn에 적용

// Truss Member
	m_bTStrsDataSet				= FALSE;
	m_TStrsComponent			= TSTRS_COMPONENT_ALL;
	m_TStrsOutputSection	= TSTRS_OUTPUT_ALL;
	
// Beam Member
	m_bBStrsDataSet				= FALSE;
	m_BStrsPart           = BSTRS_PART_I; 
	m_BStrsComponent			= BSTRS_COMPONENT_COMB;
	m_BStrsComponentSub   = BSTRS_COMPONENT_CBSUBMX;
	m_BStrsComponentSub2  = BSTRSDETAIL_COMP_POSMX;
	m_BStrsOutputSection	= BSTRS_OUTPUT_MAX;
	m_BStrsComponentType	= BSTRS_COMPONENT_NORMAL;
	m_BStrsComp7thDof     = BSTRS_COMPONENT_7th_SAX;
	m_bBStrsOutputMax			= TRUE;
	m_bBStrsOutputAll			= FALSE;
	m_bBStrsOutputI				= FALSE;
	m_bBStrsOutputC				= FALSE;
	m_bBStrsOutputJ				= FALSE;
	m_bBStrsOutputMinMax  = FALSE; 
	m_bBSfdBmdLineOnly	  = TRUE;
	m_bVerticalLineFill   = TRUE;
	m_bMaxMinDgrm         = TRUE; 
	m_nBForcPscPart       = 0;
	
// Plane/Plate Member
	m_bPStrsDataSet				= FALSE;
	m_PStrsVal					  = PSTRS_VALUE_GLOBAL;
	m_PStrsSurface				= PSTRS_SURFACE_TOP;
	m_PStrsAve					  = PSTRS_VALUE_AVENODAL;
	m_PStrsComponent			= PSTRS_COMPONENT_SIGEFF;
	m_NUCS.Initialize();
	m_bPrintUCSAxis       = FALSE; 
	

// Plane Strain Member
	m_bPnStrsDataSet			= FALSE;
	m_PnStrsVal					  = PSTRS_VALUE_GLOBAL;
	m_PnStrsAve					  = PSTRS_VALUE_AVENODAL;
	m_PnStrsComponent			= SSTRS_COMPONENT_SIGEFF;


// Axisymmetric Member
	m_bAxStrsDataSet			= FALSE;
	m_AxStrsVal					= PSTRS_VALUE_GLOBAL;
	m_AxStrsAve					= PSTRS_VALUE_AVENODAL;
	m_AxStrsComponent			= SSTRS_COMPONENT_SIGEFF;
	

// Solid Member
	m_bSStrsDataSet				= FALSE;
	m_bIsFreeEdgeDataSet  = FALSE;
	m_bIsFreeFaceDataSet  = FALSE;
	m_SStrsVal					  = PSTRS_VALUE_GLOBAL;
	m_SStrsAve					  = PSTRS_VALUE_AVENODAL;
	m_SStrsComponent			= SSTRS_COMPONENT_SIGEFF;
	m_bIsoSurface = FALSE;

	m_AxKeyList.RemoveAll();
	m_BeamKeyList.RemoveAll();
	m_TrussKeyList.RemoveAll();
	m_PlateKeyList.RemoveAll();
	m_PnKeyList.RemoveAll();
	m_SolidKeyList.RemoveAll();

	m_mapAxStrsData.RemoveAll();
	m_mapBStrsData.RemoveAll();
	m_mapBVmstData.RemoveAll();
	m_mapPnStrsData.RemoveAll();
	m_mapPlateStrsData.RemoveAll();
	m_mapSolidStrsData.RemoveAll();
	m_mapTStrsData.RemoveAll();
	m_mapBStssData.RemoveAll(); 
	m_mapPlStrnData.RemoveAll();
	m_mapSlStrnData.RemoveAll();
	m_mapIsoStrsData.RemoveAll();

// Influence Data
	m_bImpFc = FALSE; 
	m_BStrsAdjustFactor = 1.0; 
	m_SStrsPart = 0;
	m_bHingeStatus = FALSE; 
	m_bHingeStatusText = FALSE;
	m_bEnvelopeLC = FALSE;
	m_Mldt = 0;
	
	m_dThisTimeStep   = 0.0;
	m_nThisTimeIndex  = 0;
	m_bThisFunction   = 0;   
	m_nFunctionKey    = 0;

	m_mapSFDBMDMax.RemoveAll();

	m_BSfdBmdAdjustFactor = 1.0;
	m_BSfdBmdScFactor = 1.0;
	m_dUnitLength = 1.0;
	
	m_IsoStrsComponent = 0;
	m_IsoStrsRltComp = 0;
	m_IsoGBloadcaseK = m_IsoGBLoadType = m_IsoGBloadcaseK2 = m_IsoGBLoadType2 =0;
	m_IsoGBMaxMin = m_IsoGBMaxMin2 =0;

	m_nLoadCaseK=0;
	m_nLcomAnalType=0;
	m_PlstrnType = 0;
	m_SlstrnType = 0;
//   m_mapLRsultMax_Prn.RemoveAll();
//   m_mapLRsultMin_Prn.RemoveAll();
//   m_mapURsultMax_Prn.RemoveAll();
//   m_mapURsultMin_Prn.RemoveAll();
//   m_mapURsultMax_NotPrn.RemoveAll();
//   m_mapURsultMin_NotPrn.RemoveAll();
//   m_mapLRsultMax_Avg.RemoveAll();
//   m_mapLRsultMin_Avg.RemoveAll();
//   m_mapURsultMax_Avg.RemoveAll();
//   m_mapURsultMin_Avg.RemoveAll();
}

BOOL  CStressEngine::MakeMvlTrcBStrsDataListS(CDeformEngine *pDE)
{
	/*
	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;
	T_ELEM_D Elem_d;
	UINT nKeyElem;
	  
	if(!gm->m_bLoadDataSet)  return FALSE;
	
	m_pDoc->m_pAttrCtrl->GetElem(m_InflKeyElem,Elem_d);
	if(!m_pDoc->m_pAttrCtrl->IsBeam(Elem_d.eltyp))return FALSE;
	
	if(!m_pDoc->m_pPostCtrl->m_InflForcBeamElemKey.Lookup(m_InflKeyElem,nKeyElem)) // Moving해석된 것들중 시리얼한 요소번호
		return FALSE;
	
	int nComp= 30+(m_BStrsPart)*4+m_BStrsComponent+1; // 30번부터해서 50번까지= 5Part * 4Component;
	
	if(!MakeSurfMvlTrcData(4,nComp,nKeyElem)) return FALSE;

	int i;
	if(m_nPrdMoving==D_PRODUCT_MOVING_CH)
	{
		double dLaneW=0.0; 
		for(i=0; i<m_arMvlTrcDataCH.GetSize(); i++)
		if(m_arMvlTrcDataCH[i].nType==4) // 분포하중(Lane)    
		{
			dLaneW=m_arMvlTrcDataCH[i].MvhlD.dQq;
			m_arMvlTrcDataCH[i].dLaneW=dLaneW;
		}
		pDE->m_arMvlTrcDataCH.RemoveAll();
	  for(i=0; i<m_arMvlTrcDataCH.GetSize(); i++)
		  pDE->m_arMvlTrcDataCH.Add(m_arMvlTrcDataCH[i]);
	  pDE->m_dMVLTRCScaleFactor = m_dMVLTRCScaleFactor;
	}
	else
	{
	  pDE->m_arMvlTrcData.RemoveAll();
	  for(i=0; i<m_arMvlTrcData.GetSize(); i++)
		  pDE->m_arMvlTrcData.Add(m_arMvlTrcData[i]);
	  pDE->m_dMVLTRCScaleFactor = m_dMVLTRCScaleFactor;
	}
	
	int nLcase_bak = gm->m_LoadCaseKey;
	gm->m_LoadCaseKey = 0;// for All Lane
	MakeInflBStrsDataListS(pDE);
	gm->m_LoadCaseKey = nLcase_bak;

	//KYE-HONG-20020310
	pDE->m_bMvlTrcUsePLM = FALSE; 
	return TRUE; 
	*/
	return TRUE; 
}


//--------------------------------------------------------------------------------------------------
// DATE : 2003.7.5. by KYE-HONG
// FUNC : 재료비선형  Hinge Status를 그린다 
// DESC : 
//--------------------------------------------------------------------------------------------------
void CStressEngine::DrawNLHngeStatus(CDC *pDC,UINT ElemK)
{
	DECLARE_GPSMD();
	DECLARE_DBDOC();
	DECLARE_DPTDR();

	T_MIRE_K MKey;
	MKey.keymap = ElemK;

	if(!gm->m_bLoadDataSet)return;
	if(!CGPSPostCtrl::IsNonlinearAnalysis(gm->m_LoadCaseType))return;

	//---------------------------------------------------------------
	// 결과 있는지 확인 
	//---------------------------------------------------------------
	CArray<BOOL,BOOL> arGPHS; // Gauss Point Hinge Status
	if(!pDoc->m_pPostCtrl->GetNonLinearHingeStatus(ElemK,gm->m_LoadCaseKey,gm->m_nCurStep,arGPHS))
		return;

	//---------------------------------------------------------------
	// 요소 절점 위치 저장 
	//---------------------------------------------------------------
	CArray<GPS_3DPT_LISTP, GPS_3DPT_LISTP>	PolyList;
	CArray<GPS_UINT_ARRYP, GPS_UINT_ARRYP>	VertexNode;

	BOOL bBackWireFrame = pDR->m_bFrameLine;
	pDR->m_bFrameLine = TRUE; 
	if(m_bDeformedShapeContour) 
	{
		if(gm->m_pDeformEngine)gm->m_pDeformEngine->GetDeformedShapeElement(ElemK, &PolyList, NULL, &VertexNode);
		else                   gm->GetShapeElement(ElemK, PolyList, NULL, NULL, &VertexNode);
	}
	else 
	{
		gm->GetShapeElement(ElemK, PolyList, NULL, NULL, &VertexNode);
	}
	pDR->m_bFrameLine = bBackWireFrame; 
	
	T_ELEM_D  ElemD; 
	C3DPoint  Pt3D;
	double dElemCoord[8][3];
	
	m_pDoc->m_pAttrCtrl->GetElem(MKey.key.elem_k, ElemD);
	int nNodeN = m_pDoc->m_pAttrCtrl->GetNumNode(ElemD.eltyp, ElemD.elnod);

	int i,j,k; 
	POSITION nPos; 
	// 트러스요소 
	// 판,Plain Stress/Strain,Axisym 
	if(m_pDoc->m_pAttrCtrl->IsFrameType(ElemD.eltyp) || 
		m_pDoc->m_pAttrCtrl->IsPlaneType(ElemD.eltyp) )
	{
		nPos = PolyList[0]->GetHeadPosition();
		for(i=0; i<PolyList[0]->GetCount(); i++)
		{
			Pt3D = PolyList[0]->GetNext(nPos);
			dElemCoord[i][0] = Pt3D.x;  
			dElemCoord[i][1] = Pt3D.y;  
			dElemCoord[i][2] = Pt3D.z;
		}
		
	}
	// Solid
	else if(m_pDoc->m_pAttrCtrl->IsSolidType(ElemD.eltyp))
	{
		for(i=0; i<nNodeN; i++)
		{
			BOOL bFound=FALSE; 
			for(j=0; j<PolyList.GetSize(); j++)
			{
				nPos = PolyList[j]->GetHeadPosition();
				for(k=0; k<PolyList[j]->GetCount(); k++)
				{
					Pt3D = PolyList[j]->GetNext(nPos);
					if(VertexNode[j]->GetAt(k)==ElemD.elnod[i])
					{ bFound=TRUE;  break;}
				}
				if(bFound)break;
			}
			if(bFound){ dElemCoord[i][0] = Pt3D.x;dElemCoord[i][1] = Pt3D.y;dElemCoord[i][2] = Pt3D.z;          }
			else      { dElemCoord[i][0] = 0.0;   dElemCoord[i][1] = 0.0;   dElemCoord[i][2] = 0.0;  ASSERT(0); }
		}
	}
	else
	{
		FreeMemoryPolyList(&PolyList,NULL,&VertexNode);  
		return; 
	}
	FreeMemoryPolyList(&PolyList,NULL,&VertexNode);  

	//---------------------------------------------------------------
	// 가우스포인트 계산 
	//---------------------------------------------------------------
	int    nGaussPoint;
	double dElemGaussPos[8][3];
	double dDisplacement[8][3];

	for(i=0; i<8; i++)
	{
		memset(dElemGaussPos[i],0,sizeof(dElemGaussPos[i]));
		memset(dDisplacement[i],0,sizeof(dDisplacement[i]));
	}
	if(!CGPSPostCtrl::GetElemGaussPoint(nGaussPoint,dElemGaussPos,dElemCoord,dDisplacement,nNodeN,ElemD.eltyp)){return; }
	if(nGaussPoint!=arGPHS.GetSize()){ ASSERT(0); return; }
	
	//---------------------------------------------------------------
	// 가우스포인트  그리기 
	//---------------------------------------------------------------
	int nSaveDC=pDC->SaveDC();

	CPen Pen,*pOldPen;
	Pen.CreatePen(PS_SOLID, gm->m_nLineWidth*1.9, RGB(0,0,0));
	pOldPen = (CPen*)pDC->SelectObject(&Pen);

	double dUnitSize = pDC->GetDeviceCaps(LOGPIXELSX)*0.09;
	C3DPoint CtPt;
	for(i=0; i<nGaussPoint; i++)
	{
		if(!arGPHS[i])continue; 
		CtPt.x = dElemGaussPos[i][0];
		CtPt.y = dElemGaussPos[i][1];
		CtPt.z = dElemGaussPos[i][2];
		DrawCrossLine(pDC,CtPt,dUnitSize,0); 
	}

	if(m_pDoc->m_pAttrCtrl->IsPlate(ElemD.eltyp) 
		&& m_bHingeStatusText)
	{
		CString csGPHS;
		CString csOutput;
		CPoint pt2D;

		DECLARE_DPTTX();
		if(pTX->m_bNumberOpaque)	pDC->SetBkMode(OPAQUE);
		else		                pDC->SetBkMode(TRANSPARENT);
		pDC->SetTextColor(pTX->m_NumberTextColorC);
		pDC->SetBkColor(pTX->m_NumberBackCol);
		pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);

		CFont ft, *old_ft;
		ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
		old_ft = (CFont *) pDC->SelectObject(&ft);


		for(i=0; i<nGaussPoint; i++)
		{
			if(!arGPHS[i])continue; 
			csGPHS.Format(_T("%d"),arGPHS[i]);

			int nGPHSLen = csGPHS.GetLength();
			if(nGPHSLen > GPHS_MAX) { ASSERT(0); continue; }

			if(nGPHSLen==GPHS_MAX)
			{
				csOutput = csGPHS;
			}
			else
			{
				csOutput = _T("0000000");
				int nStartIndex = csOutput.GetLength()-1;
				for(int kk=nGPHSLen-1; kk>=0; kk--)
				{
					csOutput.SetAt(nStartIndex, csGPHS.GetAt(kk) );
					nStartIndex--;
				}
			}

			CtPt.x = dElemGaussPos[i][0];
			CtPt.y = dElemGaussPos[i][1];
			CtPt.z = dElemGaussPos[i][2];

			if (gm->m_bVirtualMode)       
				pt2D = gm->m_pGPSCtrl->GetWorldToWindowP2D(CtPt);      
			else
				pt2D = gm->m_pGPSCtrl->GetWorldToMemDCP2D(CtPt);

			pDC->TextOut(pt2D.x,pt2D.y-dUnitSize,csOutput);
		}

		pDC->SelectObject(old_ft);
		ft.DeleteObject();
	}
	//Brush.DeleteObject(); 
	//pDC->SelectObject(pOldBrush);
	pDC->SelectObject(pOldPen); 
	Pen.DeleteObject();

	pDC->RestoreDC(nSaveDC);
}

void CStressEngine::DrawNLHngeStatus_Text(CDC *pDC,UINT ElemK)
{
	DECLARE_GPSMD();
	DECLARE_DBDOC();
	DECLARE_DPTDR();

	T_MIRE_K MKey;
	MKey.keymap = ElemK;

	if(!gm->m_bLoadDataSet)return;
	if(!CGPSPostCtrl::IsNonlinearAnalysis(gm->m_LoadCaseType))return;

	T_ELEM_D  ElemD; 
	m_pDoc->m_pAttrCtrl->GetElem(MKey.key.elem_k, ElemD);
	
	// MNET:XXXX-HSSHIM-20091014
	// 현재는 Plate 요소만.
	// DrawNLHngeStatus_Text()가 Yield Point의 Text를 표시하기 위해서 추가되었기 때문임. 
	if (!m_pDoc->m_pAttrCtrl->IsPlate(ElemD.eltyp) || !m_bHingeStatusText)  return;


	//---------------------------------------------------------------
	// 결과 있는지 확인 
	//---------------------------------------------------------------
	CArray<BOOL,BOOL> arGPHS; // Gauss Point Hinge Status
	if(!pDoc->m_pPostCtrl->GetNonLinearHingeStatus(ElemK,gm->m_LoadCaseKey,gm->m_nCurStep,arGPHS))
		return;

	//---------------------------------------------------------------
	// 요소 절점 위치 저장 
	//---------------------------------------------------------------
	CArray<GPS_3DPT_LISTP, GPS_3DPT_LISTP>	PolyList;
	CArray<GPS_UINT_ARRYP, GPS_UINT_ARRYP>	VertexNode;

	BOOL bBackWireFrame = pDR->m_bFrameLine;
	pDR->m_bFrameLine = TRUE; 
	if(m_bDeformedShapeContour) 
	{
		if(gm->m_pDeformEngine)gm->m_pDeformEngine->GetDeformedShapeElement(ElemK, &PolyList, NULL, &VertexNode);
		else                   gm->GetShapeElement(ElemK, PolyList, NULL, NULL, &VertexNode);
	}
	else 
	{
		gm->GetShapeElement(ElemK, PolyList, NULL, NULL, &VertexNode);
	}
	pDR->m_bFrameLine = bBackWireFrame; 
	
	C3DPoint  Pt3D;
	double dElemCoord[8][3];
	
	int nNodeN = m_pDoc->m_pAttrCtrl->GetNumNode(ElemD.eltyp, ElemD.elnod);

	int i,j,k; 
	POSITION nPos; 
	// 트러스요소 
	// 판,Plain Stress/Strain,Axisym 
	if(m_pDoc->m_pAttrCtrl->IsFrameType(ElemD.eltyp) || 
		m_pDoc->m_pAttrCtrl->IsPlaneType(ElemD.eltyp) )
	{
		nPos = PolyList[0]->GetHeadPosition();
		for(i=0; i<PolyList[0]->GetCount(); i++)
		{
			Pt3D = PolyList[0]->GetNext(nPos);
			dElemCoord[i][0] = Pt3D.x;  
			dElemCoord[i][1] = Pt3D.y;  
			dElemCoord[i][2] = Pt3D.z;
		}
		
	}
	// Solid
	else if(m_pDoc->m_pAttrCtrl->IsSolidType(ElemD.eltyp))
	{
		for(i=0; i<nNodeN; i++)
		{
			BOOL bFound=FALSE; 
			for(j=0; j<PolyList.GetSize(); j++)
			{
				nPos = PolyList[j]->GetHeadPosition();
				for(k=0; k<PolyList[j]->GetCount(); k++)
				{
					Pt3D = PolyList[j]->GetNext(nPos);
					if(VertexNode[j]->GetAt(k)==ElemD.elnod[i])
					{ bFound=TRUE;  break;}
				}
				if(bFound)break;
			}
			if(bFound){ dElemCoord[i][0] = Pt3D.x;dElemCoord[i][1] = Pt3D.y;dElemCoord[i][2] = Pt3D.z;          }
			else      { dElemCoord[i][0] = 0.0;   dElemCoord[i][1] = 0.0;   dElemCoord[i][2] = 0.0;  ASSERT(0); }
		}
	}
	else
	{
		FreeMemoryPolyList(&PolyList,NULL,&VertexNode);  
		return; 
	}
	FreeMemoryPolyList(&PolyList,NULL,&VertexNode);  

	//---------------------------------------------------------------
	// 가우스포인트 계산 
	//---------------------------------------------------------------
	int    nGaussPoint;
	double dElemGaussPos[8][3];
	double dDisplacement[8][3];

	for(i=0; i<8; i++)
	{
		memset(dElemGaussPos[i],0,sizeof(dElemGaussPos[i]));
		memset(dDisplacement[i],0,sizeof(dDisplacement[i]));
	}
	if(!CGPSPostCtrl::GetElemGaussPoint(nGaussPoint,dElemGaussPos,dElemCoord,dDisplacement,nNodeN,ElemD.eltyp)){return; }
	if(nGaussPoint!=arGPHS.GetSize()){ ASSERT(0); return; }
	
	//---------------------------------------------------------------
	// 가우스포인트  그리기 
	//---------------------------------------------------------------
	int nSaveDC=pDC->SaveDC();

	CPen Pen,*pOldPen;
	Pen.CreatePen(PS_SOLID, gm->m_nLineWidth*1.9, RGB(0,0,0));
	pOldPen = (CPen*)pDC->SelectObject(&Pen);

	double dUnitSize = pDC->GetDeviceCaps(LOGPIXELSX)*0.09;
	C3DPoint CtPt;
//   for(i=0; i<nGaussPoint; i++)
//   {
//     if(!arGPHS[i])continue; 
//     CtPt.x = dElemGaussPos[i][0];
//     CtPt.y = dElemGaussPos[i][1];
//     CtPt.z = dElemGaussPos[i][2];
//     DrawCrossLine(pDC,CtPt,dUnitSize,0); 
//   }

	if(m_pDoc->m_pAttrCtrl->IsPlate(ElemD.eltyp) 
		&& m_bHingeStatusText)
	{
		CString csGPHS;
		CString csOutput;
		CPoint pt2D;

		DECLARE_DPTTX();
		if(pTX->m_bNumberOpaque)	pDC->SetBkMode(OPAQUE);
		else		                pDC->SetBkMode(TRANSPARENT);
		pDC->SetTextColor(pTX->m_NumberTextColorC);
		pDC->SetBkColor(pTX->m_NumberBackCol);
		pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);

		CFont ft, *old_ft;
		ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
		old_ft = (CFont *) pDC->SelectObject(&ft);


		for(i=0; i<nGaussPoint; i++)
		{
			if(!arGPHS[i])continue; 
			csGPHS.Format(_T("%d"),arGPHS[i]);

			int nGPHSLen = csGPHS.GetLength();
			if(nGPHSLen > GPHS_MAX) { ASSERT(0); continue; }

			if(nGPHSLen==GPHS_MAX)
			{
				csOutput = csGPHS;
			}
			else
			{
				csOutput = _T("0000000");
				int nStartIndex = csOutput.GetLength()-1;
				for(int kk=nGPHSLen-1; kk>=0; kk--)
				{
					csOutput.SetAt(nStartIndex, csGPHS.GetAt(kk) );
					nStartIndex--;
				}
			}

			CtPt.x = dElemGaussPos[i][0];
			CtPt.y = dElemGaussPos[i][1];
			CtPt.z = dElemGaussPos[i][2];

			if (gm->m_bVirtualMode)       
				pt2D = gm->m_pGPSCtrl->GetWorldToWindowP2D(CtPt);      
			else
				pt2D = gm->m_pGPSCtrl->GetWorldToMemDCP2D(CtPt);

			pDC->TextOut(pt2D.x,pt2D.y-dUnitSize,csOutput);
		}

		pDC->SelectObject(old_ft);
		ft.DeleteObject();
	}
	//Brush.DeleteObject(); 
	//pDC->SelectObject(pOldBrush);
	pDC->SelectObject(pOldPen); 
	Pen.DeleteObject();

	pDC->RestoreDC(nSaveDC);
}

void CStressEngine::ExportSolidData()
{
	CFile file;
	CString sFileName;
	CGPS_SOLID_RESULT SolidElem;
	T_GNODE_D gNode;
	

	CFileDialog fd(FALSE, _T(".gps"), NULL, OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_LONGNAMES,
								 _T("MIDAS GPS Output File (*.gps)|*.gps|All File(*.*)|*.*||"), NULL);
	if (fd.DoModal() == IDOK)
		sFileName = fd.GetFileName();
	else
		return; 
	
	InitEngine();
	
	file.Open(sFileName,CFile::modeCreate|CFile::modeWrite);
	CArchive ar(&file, CArchive::store);

	int			nElemCount,nNodeCount;
	CArray<T_NODE_K,T_NODE_K> arNodeKey;
	m_pDoc->m_pAttrCtrl->GetNodeKeyList(arNodeKey);
	CMap<T_NODE_K,T_NODE_K,BOOL,BOOL> mapNode;
	T_NODE_D node;
	
	T_ELEM_D elem;
	int nie;
	nElemCount = m_SolidKeyList.GetSize();
	for(int i=0; i<nElemCount; i++)
	{
		m_pDoc->m_pAttrCtrl->GetElem(m_SolidKeyList[i],elem);
		nie = m_pDoc->m_pAttrCtrl->GetNumNode(elem.eltyp, elem.elnod);
		for(int j=0; j<nie; j++)
			mapNode.SetAt(elem.elnod[j],TRUE);
	}
	
	nNodeCount=arNodeKey.GetSize();
	ar<<mapNode.GetCount();
	BOOL bExist;
	T_DISP_D disp;
	for(int i=0; i<nNodeCount; i++)
	{
		if(!mapNode.Lookup(arNodeKey[i],bExist)) continue;
		gNode.node_k = arNodeKey[i];
		m_pDoc->m_pAttrCtrl->GetNode(arNodeKey[i],node);
		gNode.x = node.x;
		gNode.y = node.y;
		gNode.z = node.z;
		
		if(!m_pDoc->m_pPostCtrl->GetDispNew(arNodeKey[i], &disp,NULL,NULL)) continue;
		for(int j=0; j<6; j++)
			gNode.disp[j] = disp.dblDisp[j];
					
		gNode.Serialize(ar);
	}
	
	
	T_STRS_D pStrs;
	ar<<nElemCount;// the number of elements
	for(int i=0; i<nElemCount; i++)
	{
		SolidElem.aNodes.RemoveAll();
		m_pDoc->m_pAttrCtrl->GetElem(m_SolidKeyList[i],elem);
		nie = m_pDoc->m_pAttrCtrl->GetNumNode(elem.eltyp, elem.elnod);
		
		SolidElem.nDataType = 1; //Stress
		for(int j=0; j<nie; j++)
			SolidElem.aNodes.Add(elem.elnod[j]);

		m_mapSolidStrsData.Lookup(m_SolidKeyList[i],pStrs);
		memcpy(SolidElem.dblStress,pStrs.dblStress,sizeof(SolidElem.dblStress));
		
		ar<<GPS_SOLID; // ElemType
		SolidElem.Serialize(ar);		
	}
	
	ar.Close();
	file.Close();
	
}

BOOL CStressEngine::MakeBStrsTimeHist()
{
	if (CTestEnvMgr::IsTestEnvST(_LSX(ProfilingSTL), _LSX(yes)))
	{
		M_PROFILE('MakeBStrsTimeHist()');
	}

	DECLARE_GPSMD();
	DECLARE_DBDOC();
	if(!gm->m_bLoadDataSet)return FALSE;
	pDoc->m_pPostCtrl->SelectThis(gm->m_LoadCaseKey);
	return MakeBStrsTimeHistByIndex(m_nThisTimeIndex);
}

BOOL CStressEngine::MakeBStrsTimeHistByIndex(int nTimeIndex)
{
	DECLARE_GPSMD();
	
	int			  i, ElemNum;
	double	  dMaxStrs=-DBL_MAX, dMinStrs=DBL_MAX,dLen;
	BOOL		  bHasContent=FALSE;
	T_ELEM_K	ElemK;
	T_ELEM_D	ElemD;
	T_STRB_D	StrbD;
	T_STRT_D	StrtD;

	if(!gm->m_bLoadDataSet)return FALSE;
	
	gm->m_pMyView->BeginWaitCursor();
	m_BeamKeyList.RemoveAll();
	m_TrussKeyList.RemoveAll(); 
	m_mapBStrsData.RemoveAll();
	m_mapTStrsData.RemoveAll();
	
	ElemNum = gm->m_EKeyListActive.GetSize();

	BOOL  bDesignatedDOF = FALSE;
	T_THRD_D ThrdD;

	if(m_bThisFunction)
	{
		bDesignatedDOF = CGPSPostCtrl::IsDesignatedDOFFunction(m_nFunctionKey,&ThrdD);
	}

	for (i=0;i<ElemNum;i++) 
	{
		ElemK = gm->m_EKeyListActive[i];
		m_pDoc->m_pAttrCtrl->GetElem(ElemK, ElemD);

		// Beam Result
		if(m_pDoc->m_pAttrCtrl->IsBeam(ElemD.eltyp))
		{
			int nStrbTimeIndex;
			// Designated D.O.F
			if(bDesignatedDOF)
			{
				ThrdD.nEntity       = ElemK;
				ThrdD.nStepFunction = 4; //Beam Force/Stress
				ThrdD.nSubType      = 1; //Force
				if(!CGPSPostCtrl::GetTimeStepIndexByFuncCondition(ThrdD,nStrbTimeIndex))nStrbTimeIndex = 0;
			}
			// Designated Step
			else 
				nStrbTimeIndex = nTimeIndex;

			if(!m_pDoc->m_pPostCtrl->GetStrbHistory(nStrbTimeIndex,ElemK,StrbD)){ continue;  }
			dLen  = GetMaxElemBStrs(StrbD); if(dLen>dMaxStrs){ dMaxStrs = dLen; gm->m_nLgdMaxValKey = ElemK; }
			dLen  = GetMinElemBStrs(StrbD); if(dLen<dMinStrs){ dMinStrs = dLen; gm->m_nLgdMinValKey = ElemK; }
			
			m_BeamKeyList.Add(ElemK);
		  m_mapBStrsData.SetAt(ElemK,StrbD);
		  bHasContent = TRUE;
		}

		// Truss Result
		if(m_BStrsComponent==BSTRS_COMPONENT_FX)
		if(m_pDoc->m_pAttrCtrl->IsTruss(ElemD.eltyp))
		{
			int nStrbTimeIndex;
			// Designated D.O.F
			if(bDesignatedDOF)
			{
				if(ThrdD.nPosition>2)   continue; // Middle
				if(ThrdD.nComponent!=1) continue; // Fx

				ThrdD.nEntity = ElemK;
				ThrdD.nStepFunction = 3; //Truss Force/Stress
				ThrdD.nSubType      = 1; //Force
				if(!CGPSPostCtrl::GetTimeStepIndexByFuncCondition(ThrdD,nStrbTimeIndex))nStrbTimeIndex = 0;
			}
			// Designated Step
			else 
				nStrbTimeIndex = nTimeIndex;

			if(!m_pDoc->m_pPostCtrl->GetStrtHistory(nStrbTimeIndex,ElemK,StrtD)){ continue;  }
		  dLen=GetMaxElemTStrs(StrtD);  if(dLen>dMaxStrs){ dMaxStrs = dLen; gm->m_nLgdMaxValKey = ElemK; }
		  dLen=GetMinElemTStrs(StrtD);  if(dLen<dMinStrs){ dMinStrs = dLen; gm->m_nLgdMinValKey = ElemK; }
			
			m_TrussKeyList.Add(ElemK);
		  m_mapTStrsData.SetAt(ElemK,StrtD);
		  bHasContent = TRUE; 
		}
	}
	
	if(!bHasContent) 
	{
		dMaxStrs = dMinStrs = 0.0;
		gm->m_nLgdMaxValKey=0;
		gm->m_nLgdMinValKey=0;
	}
	m_dMaxValue = dMaxStrs;
	m_dMinValue = dMinStrs;

	if(m_pContourEngine == NULL)  m_pContourEngine = new CContourEngine(dMinStrs, dMaxStrs);
	else		                      m_pContourEngine->MakeRankMap(dMinStrs, dMaxStrs);

	gm->m_pMyView->EndWaitCursor();

	m_bBStrsDataSet = TRUE;
	return TRUE; 
}

BOOL CStressEngine::GetBStrsTimeHistRangeDataList(double& dMaxRange, double& dMinRange, CArray<UINT,UINT>& aElemKeyList)
{
	aElemKeyList.RemoveAll();

	DECLARE_GPSMD();

	int			  i;
	T_ELEM_K	ElemK;
	T_ELEM_D	ElemD;
	T_STRB_D	StrbD;
	T_STRT_D	StrtD;

	gm->m_pMyView->BeginWaitCursor();

	BOOL  bDesignatedDOF = FALSE;
	T_THRD_D ThrdD;

	if(m_bThisFunction)
	{
		bDesignatedDOF = CGPSPostCtrl::IsDesignatedDOFFunction(m_nFunctionKey,&ThrdD);
	}

	int ElemNum = gm->m_EKeyListActive.GetSize();
	for (i=0;i<ElemNum;i++) 
	{
		ElemK = gm->m_EKeyListActive[i];
		m_pDoc->m_pAttrCtrl->GetElem(ElemK, ElemD);

		// Beam Result
		if(m_pDoc->m_pAttrCtrl->IsBeam(ElemD.eltyp))
		{
			int nStrbTimeIndex = m_nThisTimeIndex;
			if(bDesignatedDOF)
			{
				// Designated D.O.F
				ThrdD.nEntity       = ElemK;
				ThrdD.nStepFunction = 4; //Beam Force/Stress
				ThrdD.nSubType      = 1; //Force
				if(!CGPSPostCtrl::GetTimeStepIndexByFuncCondition(ThrdD,nStrbTimeIndex))nStrbTimeIndex = 0;
			}

			if(!m_pDoc->m_pPostCtrl->GetStrbHistory(nStrbTimeIndex,ElemK,StrbD)){ continue;  }


			if(!IsWithinRangeElemBStrs(StrbD,dMaxRange,dMinRange)) continue;

			aElemKeyList.Add(ElemK);
		}

		// Truss Result
		else if(m_BStrsComponent==BSTRS_COMPONENT_FX && m_pDoc->m_pAttrCtrl->IsTruss(ElemD.eltyp))
		{
			int nStrbTimeIndex = m_nThisTimeIndex;
			if(bDesignatedDOF)
			{
				// Designated D.O.F
				if(ThrdD.nPosition>2)   continue; // Middle
				if(ThrdD.nComponent!=1) continue; // Fx

				ThrdD.nEntity = ElemK;
				ThrdD.nStepFunction = 3; //Truss Force/Stress
				ThrdD.nSubType      = 1; //Force
				if(!CGPSPostCtrl::GetTimeStepIndexByFuncCondition(ThrdD,nStrbTimeIndex))nStrbTimeIndex = 0;
			}

			if(!m_pDoc->m_pPostCtrl->GetStrtHistory(nStrbTimeIndex,ElemK,StrtD)){ continue;  }

			if(!IsWithinRangeElemTStrs(StrtD,dMaxRange,dMinRange)) continue;

			aElemKeyList.Add(ElemK);
		}
	}

	gm->m_pMyView->EndWaitCursor();
	
	return TRUE; 
}

void CStressEngine::DrawBStrsTimeHist(CDC *pDC)
{
	DECLARE_GPSMD();

	int			  i,ElemNum;
	T_ELEM_D	ElemD;
	CPen		  ElemPen, *pOldPen;
	CArray<int, int>  TypeList;
	CArray<GRE_Atom, GRE_Atom&> AtomList;
	
	BOOL bEscapePressed = FALSE;
	T_MIRE_K mkey;

	if(!gm->m_bContour){ gm->GPSDrawOriginal(pDC); return; }

	if(m_bDeformedShapeContour) 
	{
		if(gm->m_pDeformEngine == NULL)return;
		TypeList.Add(gm->m_MinOTID + OBJECT_TYPE_DEFORMED);
	}
	else
		TypeList.Add(gm->m_MinOTID + OBJECT_TYPE_ORIGINAL);
	
	if(gm->m_DOPT.DR.m_bFrameLine) // wire frame
		ElemPen.CreatePen(PS_SOLID, gm->m_DOPT.DR.nElemWire*1.7, m_pContourEngine->m_ElemColor);
	else 
		ElemPen.CreatePen(PS_SOLID, gm->m_DOPT.DR.nElemHddn, m_pContourEngine->m_ElemColor);

	pOldPen = (CPen *) pDC->SelectObject(&ElemPen);

	gm->m_pGPSCtrl->GetZSortedList(TypeList, gm->m_EKeyListVisible_Mirror, AtomList);
	ElemNum = AtomList.GetSize();

	BOOL bExit = FALSE; 
	for (i=0;i<ElemNum;i++) 
	{
		if(gm->m_pGPSCtrl->WatchEscKeyPress()) 
		{
			bExit = TRUE; 
			break; 
		}
		
		if(gm->m_pGPSCtrl->IsZoomAllState() ||
			 gm->m_pGPSCtrl->IsObjectInClientWindow(AtomList[i].m_OType, AtomList[i].m_OKey)) 
		{
			mkey.keymap = AtomList[i].m_OKey;
			if(!m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, ElemD)) continue;

			if(m_pDoc->m_pAttrCtrl->IsBeam(ElemD.eltyp) && !bEscapePressed) 
			{
				if(gm->m_pGPSCtrl->IsActiveElem(AtomList[i].m_OKey))
					DoBStrsElementContour(pDC, AtomList[i].m_OKey);
				else
				{
					if(m_bDeformedShapeContour)gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, AtomList[i].m_OKey);
					else                       gm->GPSDrawInactiveElement(pDC, AtomList[i].m_OKey);
				}
			}
			else if(m_pDoc->m_pAttrCtrl->IsTruss(ElemD.eltyp)) 
			{
				if(gm->m_pGPSCtrl->IsActiveElem(AtomList[i].m_OKey) && !bEscapePressed)  
				{
					DoTStrsElementContour(pDC, AtomList[i].m_OKey);
				}
				else
				{
					if(m_bDeformedShapeContour) gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, AtomList[i].m_OKey);
					else                        gm->GPSDrawInactiveElement(pDC, AtomList[i].m_OKey);
				}       
			}
			else 
			{
				if(m_bDeformedShapeContour)
					gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, AtomList[i].m_OKey);
				else
					gm->GPSDrawInactiveElement(pDC, AtomList[i].m_OKey);
			}
		}
	}

	pDC->SelectObject(pOldPen);
	ElemPen.DeleteObject();

	if(bExit)return; 
	
	// 변형된 그림에 Undeformed Shape을 같이 그릴 경우.
	// Contour를 그릴 경우는 Hidden이 default
	// 따라서 Undeformed Shape은 무조건 나중에 그린다...
	if (m_bDeformedShapeContour && gm->m_DOPT.DR.m_bDrawInactive && !bEscapePressed) 
	{
		int	rf_bak=gm->m_DOPT.DR.m_RenderFlag;
		gm->m_DOPT.DR.m_RenderFlag = 2;
		gm->GPSDrawOriginal(pDC, TRUE);
		gm->m_DOPT.DR.m_RenderFlag = rf_bak;
	}
}

void CStressEngine::OutputBStrsTimeHist(CDC *pDC)
{
	OutputBStrsNumbers(pDC);
	OutputTStrsNumbers4Hist(pDC);
}

#if defined(__OLD_OUTPUT_VALUE)
void CStressEngine::OutputTStrsNumbers4Hist(CDC *pDC)
{
	DECLARE_GPSMD();
	DECLARE_DPTDR();
	DECLARE_DPTTX();
	
	int					i, j, elem_num, slope;
	T_ELEM_K		ekey;
	T_ELEM_D		edata;
	T_STRT_D		tstrs_d;
	C3DPoint		node3D_i, node3D_j,DrawPoint;
	CPoint		  text_p,node_2d_i, node_2d_j;
	TCHAR				fmt_str[10], text_str[256];
	CFont				ft, *old_ft;
	BOOL				fl_bak, is_inverse;

	CArray<CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray<CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					edge_list;

	//주의 
	if(!m_bBStrsDataSet)return;
	if(pTX->m_bNumberOpaque)pDC->SetBkMode(OPAQUE);
	else		                pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(pTX->m_NumberTextColorC);
	pDC->SetBkColor(pTX->m_NumberBackCol);
	pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);

	if(pTX->m_bNumberExponent)_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else		                  _stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);

	fl_bak = pDR->m_bFrameLine;
	pDR->m_bFrameLine = TRUE;

	if(pTX->m_bNumberSelOnly) 
	{
	}
	else 
	{
	
	  BOOL bGrpFltMode=gm->m_pGPSCtrl->IsGroupFilterMode();
		if(!bGrpFltMode)elem_num = gm->m_EKeyListActive.GetSize();
		else            elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize(); 

		for (i=0;i<elem_num;i++) 
		{
		  if(!bGrpFltMode)ekey = gm->m_EKeyListActive[i];
			else            ekey = gm->m_pDispFilter->m_aGrpEKey[i]; 

			if(!gm->m_pGPSCtrl->IsActiveElem(ekey))
				continue;

			m_pDoc->m_pAttrCtrl->GetElem(ekey, edata);

			if(!m_pDoc->m_pAttrCtrl->IsTruss(edata.eltyp))continue;
			if(!GetTrussStress(ekey, tstrs_d))continue; 

			if(m_bDeformedShapeContour)gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list);
			else                       gm->GetShapeElement(ekey, polygon_list, &edge_list);
			
			POSITION pos = polygon_list[0]->GetHeadPosition();
			node3D_i = polygon_list[0]->GetNext(pos);
			node3D_j = polygon_list[0]->GetNext(pos);
		  if (gm->m_bVirtualMode) 
			{
			  node_2d_i = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_i);
			  node_2d_j = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_j);
		  }
		  else 
			{
			  node_2d_i = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_i);
			  node_2d_j = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_j);
		  }
			
			if((node_2d_i.x >= 0 && node_2d_i.y >= 0 && node_2d_j.x >= 0 && node_2d_j.y >= 0))
			{
		  
				slope = (int) (atan2(node_2d_i.y-node_2d_j.y, node_2d_j.x-node_2d_i.x)*1800.0/3.14159);
			  slope = (slope+3600)%3600;
			  if ((900<slope) && (slope<=2700)) {
				  slope = (slope+1800)%3600;
				  is_inverse = TRUE;
			  }
			  else {
				  is_inverse = FALSE;
			  }

		 	  gm->SetNumberFontOrientation(slope);
			  ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
	  	  old_ft = (CFont *) pDC->SelectObject(&ft);

				if(pTX->m_bOutputMinMaxValueOnly)
				{
					double dLimit = (m_dMaxValue-m_dMinValue) * pTX->m_dOutputMinMaxLimit / 100.0;
				  double dTValue;
				
					for(int n=0; n<2; n++)
					{
				    if(n==0) // I단 또는 MAX
						{
							if(m_bBStrsOutputI || m_bBStrsOutputAll) 
							{
								if (is_inverse) pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
				        else					  pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
								DrawPoint = node3D_i;
								dTValue = CalcTStrsValue(tstrs_d, I_NODE);
							}
							else if(m_bBStrsOutputMax) 
							{
								pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);
								DrawPoint.x = (node3D_i.x + node3D_j.x)/2.0;
								DrawPoint.y = (node3D_i.y + node3D_j.y)/2.0;
								DrawPoint.z = (node3D_i.z + node3D_j.z)/2.0;
								dTValue = (fabs(CalcTStrsValue(tstrs_d, I_NODE)) >= fabs(CalcTStrsValue(tstrs_d, J_NODE)))? CalcTStrsValue(tstrs_d, I_NODE) : CalcTStrsValue(tstrs_d, J_NODE);
							}
						}
						else // J단
						{			  
							if(m_bBStrsOutputJ)
							{
				        if(is_inverse)pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
				        else					pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
								DrawPoint = node3D_j;
								dTValue = CalcTStrsValue(tstrs_d, J_NODE);
							}
						}
							
						switch(pTX->m_nOutputMinMaxType)
						{
						case 0: // Min & Max
							if((m_dMaxValue-dTValue) <= dLimit)
								 DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,dTValue);
							else if((dTValue-m_dMinValue) <= dLimit)
								 DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,dTValue);
							break;
						case 1: // Abs Max
							if(fabs(m_dMaxValue) >= fabs(m_dMinValue))
							{
								if( fabs(m_dMaxValue)-fabs(dTValue) <= dLimit)
								DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dTValue);
							}
							else
							{
								if( fabs(m_dMinValue)-fabs(dTValue) <= dLimit)
								DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dTValue);
							}
							break;
						case 2: // Max
							if((m_dMaxValue-dTValue) <= dLimit)
								 DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,dTValue);
							break;
						case 3: // Min
							if((dTValue-m_dMinValue) <= dLimit)
								 DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,dTValue);
							break;
						}
					}
				//////////////////////////////////////////////////////////////////////////////////////
				}      
				else      
				{
			    if (m_bBStrsOutputMax) 
					{
				    text_p.x = (int) ((node_2d_i.x+node_2d_j.x)/2.0);
				    text_p.y = (int) ((node_2d_i.y+node_2d_j.y)/2.0);
						double dAbsMax = (fabs(CalcTStrsValue(tstrs_d, I_NODE)) >= fabs(CalcTStrsValue(tstrs_d, J_NODE)))? CalcTStrsValue(tstrs_d, I_NODE) : CalcTStrsValue(tstrs_d, J_NODE);
				    _stprintf(text_str, fmt_str, GetMaxElemTStrs(tstrs_d));
				    pDC->TextOut(text_p.x, text_p.y, text_str);
			    }
					else
					{
			      if(m_bBStrsOutputI) 
						{
				      if(is_inverse)pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
				      else          pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
				      text_p.x = (int) node_2d_i.x;
				      text_p.y = (int) node_2d_i.y;
				      _stprintf(text_str, fmt_str, CalcTStrsValue(tstrs_d, I_NODE));
				      pDC->TextOut(text_p.x, text_p.y, text_str);
			      }
			      if(m_bBStrsOutputJ) 
						{
				      if(is_inverse)pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
				      else          pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
				      text_p.x = (int) node_2d_j.x;
				      text_p.y = (int) node_2d_j.y;
				      _stprintf(text_str, fmt_str, CalcTStrsValue(tstrs_d, J_NODE));
				      pDC->TextOut(text_p.x, text_p.y, text_str);
						}
					}
				}
				pDC->SelectObject(old_ft);
	  	  ft.DeleteObject();
			}

			for(j=0;j<polygon_list.GetSize();j++) 
			{
				polygon_list[j]->RemoveAll();
				delete polygon_list[j];
				edge_list[j]->RemoveAll();
				delete edge_list[j];
			}
			polygon_list.RemoveAll();
			edge_list.RemoveAll();
		}
	}
	gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}
#else
void CStressEngine::OutputTStrsNumbers4Hist(CDC* pDC)
{
	DECLARE_GPSMD();
	DECLARE_DPTDR();
	DECLARE_DPTTX();

	int					i, j, elem_num, slope;
	T_ELEM_K		ekey;
	T_ELEM_D		edata;
	T_STRT_D		tstrs_d;
	C3DPoint		node3D_i, node3D_j, DrawPoint;
	CPoint		  text_p, node_2d_i, node_2d_j;
	TCHAR				fmt_str[10], text_str[256];
	CFont				ft, * old_ft;
	BOOL				fl_bak, is_inverse;

	CArray<CList <C3DPoint, C3DPoint>*, CList <C3DPoint, C3DPoint>*>		polygon_list;
	CArray<CArray <BOOL, BOOL>*, CArray <BOOL, BOOL>*>					edge_list;

	//주의 
	if (!m_bBStrsDataSet)return;

	GPostTextOut TextOutModel;
	TextOutModel.SetDC(pDC);
	TextOutModel.StartTStrs4HistVal();
	TextOutModel.SettingTStrs4Hist(gm);

	if (pTX->m_bNumberExponent)_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else		                  _stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);

	fl_bak = pDR->m_bFrameLine;
	pDR->m_bFrameLine = TRUE;

	if (pTX->m_bNumberSelOnly)
	{
	}
	else
	{

		BOOL bGrpFltMode = gm->m_pGPSCtrl->IsGroupFilterMode();
		if (!bGrpFltMode)elem_num = gm->m_EKeyListActive.GetSize();
		else            elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize();

		for (i = 0; i < elem_num; i++)
		{
			if (!bGrpFltMode)ekey = gm->m_EKeyListActive[i];
			else            ekey = gm->m_pDispFilter->m_aGrpEKey[i];

			if (!gm->m_pGPSCtrl->IsActiveElem(ekey))
				continue;

			m_pDoc->m_pAttrCtrl->GetElem(ekey, edata);

			if (!m_pDoc->m_pAttrCtrl->IsTruss(edata.eltyp))continue;
			if (!GetTrussStress(ekey, tstrs_d))continue;

			if (m_bDeformedShapeContour)gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list);
			else                       gm->GetShapeElement(ekey, polygon_list, &edge_list);

			POSITION pos = polygon_list[0]->GetHeadPosition();
			node3D_i = polygon_list[0]->GetNext(pos);
			node3D_j = polygon_list[0]->GetNext(pos);
			if (gm->m_bVirtualMode)
			{
				node_2d_i = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_i);
				node_2d_j = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_j);
			}
			else
			{
				node_2d_i = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_i);
				node_2d_j = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_j);
			}

			if ((node_2d_i.x >= 0 && node_2d_i.y >= 0 && node_2d_j.x >= 0 && node_2d_j.y >= 0))
			{

				slope = (int)(atan2(node_2d_i.y - node_2d_j.y, node_2d_j.x - node_2d_i.x) * 1800.0 / 3.14159);
				slope = (slope + 3600) % 3600;
				if ((900 < slope) && (slope <= 2700)) {
					slope = (slope + 1800) % 3600;
					is_inverse = TRUE;
				}
				else {
					is_inverse = FALSE;
				}

				TextOutModel.Font4TStrs4Hist(gm, slope);

				if (pTX->m_bOutputMinMaxValueOnly)
				{
					double dLimit = (m_dMaxValue - m_dMinValue) * pTX->m_dOutputMinMaxLimit / 100.0;
					double dTValue;

					for (int n = 0; n < 2; n++)
					{
						if (n == 0) // I단 또는 MAX
						{
							if (m_bBStrsOutputI || m_bBStrsOutputAll)
							{
								if (is_inverse) TextOutModel.AlignTextBot(TA_RIGHT);
								else					  TextOutModel.AlignTextBot(TA_LEFT);
								DrawPoint = node3D_i;
								dTValue = CalcTStrsValue(tstrs_d, I_NODE);
							}
							else if (m_bBStrsOutputMax)
							{
								TextOutModel.AlignTextBot(TA_CENTER);
								DrawPoint.x = (node3D_i.x + node3D_j.x) / 2.0;
								DrawPoint.y = (node3D_i.y + node3D_j.y) / 2.0;
								DrawPoint.z = (node3D_i.z + node3D_j.z) / 2.0;
								dTValue = (fabs(CalcTStrsValue(tstrs_d, I_NODE)) >= fabs(CalcTStrsValue(tstrs_d, J_NODE))) ? CalcTStrsValue(tstrs_d, I_NODE) : CalcTStrsValue(tstrs_d, J_NODE);
							}
						}
						else // J단
						{
							if (m_bBStrsOutputJ)
							{
								if (is_inverse)		TextOutModel.AlignTextBot(TA_LEFT);
								else					TextOutModel.AlignTextBot(TA_RIGHT);
								DrawPoint = node3D_j;
								dTValue = CalcTStrsValue(tstrs_d, J_NODE);
							}
						}

						switch (pTX->m_nOutputMinMaxType)
						{
						case 0: // Min & Max
							if ((m_dMaxValue - dTValue) <= dLimit)
								DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, dTValue);
							else if ((dTValue - m_dMinValue) <= dLimit)
								DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, dTValue);
							break;
						case 1: // Abs Max
							if (fabs(m_dMaxValue) >= fabs(m_dMinValue))
							{
								if (fabs(m_dMaxValue) - fabs(dTValue) <= dLimit)
									DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, dTValue);
							}
							else
							{
								if (fabs(m_dMinValue) - fabs(dTValue) <= dLimit)
									DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, dTValue);
							}
							break;
						case 2: // Max
							if ((m_dMaxValue - dTValue) <= dLimit)
								DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, dTValue);
							break;
						case 3: // Min
							if ((dTValue - m_dMinValue) <= dLimit)
								DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, dTValue);
							break;
						}
					}
					//////////////////////////////////////////////////////////////////////////////////////
				}
				else
				{
					if (m_bBStrsOutputMax)
					{
						text_p.x = (int)((node_2d_i.x + node_2d_j.x) / 2.0);
						text_p.y = (int)((node_2d_i.y + node_2d_j.y) / 2.0);
						double dAbsMax = (fabs(CalcTStrsValue(tstrs_d, I_NODE)) >= fabs(CalcTStrsValue(tstrs_d, J_NODE))) ? CalcTStrsValue(tstrs_d, I_NODE) : CalcTStrsValue(tstrs_d, J_NODE);
						_stprintf(text_str, fmt_str, GetMaxElemTStrs(tstrs_d));
						TextOutModel.TextOutTStrs4Hist(text_p.x, text_p.y, text_str);
					}
					else
					{
						if (m_bBStrsOutputI)
						{
							if (is_inverse)	TextOutModel.AlignTextBot(TA_RIGHT);
							else					TextOutModel.AlignTextBot(TA_LEFT);
							text_p.x = (int)node_2d_i.x;
							text_p.y = (int)node_2d_i.y;
							_stprintf(text_str, fmt_str, CalcTStrsValue(tstrs_d, I_NODE));
							TextOutModel.TextOutTStrs4Hist(text_p.x, text_p.y, text_str);
						}
						if (m_bBStrsOutputJ)
						{
							if (is_inverse)		TextOutModel.AlignTextBot(TA_LEFT);
							else          TextOutModel.AlignTextBot(TA_RIGHT);
							text_p.x = (int)node_2d_j.x;
							text_p.y = (int)node_2d_j.y;
							_stprintf(text_str, fmt_str, CalcTStrsValue(tstrs_d, J_NODE));
							TextOutModel.TextOutTStrs4Hist(text_p.x, text_p.y, text_str);
						}
					}
				}
				TextOutModel.DeleteFont();
			}

			for (j = 0; j < polygon_list.GetSize(); j++)
			{
				polygon_list[j]->RemoveAll();
				delete polygon_list[j];
				edge_list[j]->RemoveAll();
				delete edge_list[j];
			}
			polygon_list.RemoveAll();
			edge_list.RemoveAll();
		}
	}
	TextOutModel.EndTStrs4HistVal();
	gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}
#endif

void CStressEngine::GetUCSVector(T_NUCS_D &NUCS, double UCSV[][3])
{
	double dVz[3];
	
	CMathFunc::mathCross(NUCS.dVx,NUCS.dVy,dVz);
	
	UCSV[0][0] = NUCS.dVx[0];
	UCSV[0][1] = NUCS.dVx[1];
	UCSV[0][2] = NUCS.dVx[2];
	UCSV[1][0] = NUCS.dVy[0];
	UCSV[1][1] = NUCS.dVy[1];
	UCSV[1][2] = NUCS.dVy[2];
	UCSV[2][0] = dVz[0];
	UCSV[2][1] = dVz[1];
	UCSV[2][2] = dVz[2];
	CMathFunc::mathNormalize(UCSV[0],UCSV[0]);
	CMathFunc::mathNormalize(UCSV[1],UCSV[1]);
	CMathFunc::mathNormalize(UCSV[2],UCSV[2]);
}

// MNET:XXXX-CJJEONG-20090413 (Tel : 2124) 
// Plane Strain 요소에 대한 Cutting Line Data 를 만들어줌
// 기존의 Plate 대한 함수를 General Engine 에 위치하고 있으나 
// Plane Strain에 대한 함수를 이곳에 만들어 사용

void CStressEngine::MakeCuttingLineDataPlaneStrain()
{
	I_GPSModel	*gm=(I_GPSModel *)m_pGPSModel;
	
	int	i,j;
	int node_in_elem,elem_num;

	T_ELEM_D	elem_d;
	T_CUTL_D  cutline;
	T_NODE_D	node_d1,node_d2;
	T_CUTL_K  KeyCutLine;
	T_CUTL_D  DataCutLine;
	T_CUTLINE_D CutLineData;
	T_CUTLINE_MINMAX_D CutLineMinMax;
	
	C3DPoint Point3d1,Point3d2,Point3d3;
	double dTolerance; 
	double dPoint1[3],dPoint2[3],dPoint3[3],dCutLineVector[2];
	double dCutLinePoint1[3],dCutLinePoint2[3];
	double dDistance,dCutValue,d1,d2;
	double dPlateCutVal1,dPlateCutVal2;
	CArray <C3DPoint,C3DPoint&> aCutPoints;
	CArray <double,double> aCutValues;
	CList <C3DPoint, C3DPoint> CutPointsList;
	CArray <T_CUTLINE_D,T_CUTLINE_D&> *paCutLineData;
	
	ResetCuttingLineData();

	// 1mm고정단위의 Tolerance를 구해옴 
	dTolerance=m_pDoc->m_pFlagCtrl->GetGeneralCoordinateToleranceCurrentUnit();

	// Cutting Line Data추가 
	m_aCutLines.RemoveAll();
	for( i=0; i<gm->m_aCutLineKeys.GetSize(); i++)
	{
		KeyCutLine = gm->m_aCutLineKeys[i];
		m_pDoc->m_pAttrCtrl->GetCutl(KeyCutLine,DataCutLine);
		m_aCutLines.Add(DataCutLine);
	}

	// Cutting Plane Data추가 
	m_aCutPlanes.Copy(gm->m_aCutPlanes);
	
	////////////////////////////////////////////////////////////
	// CUTTING LINE
	////////////////////////////////////////////////////////////
	int nNumCutLines = m_aCutLines.GetSize();
	for(int nCL=0; nCL<nNumCutLines; nCL++)
	{
		paCutLineData = new CArray<T_CUTLINE_D,T_CUTLINE_D&>;
		m_aCutLineData.Add(paCutLineData);
		double CutLineMax = -DBL_MAX;
		double CutLineMin =  DBL_MAX;

		cutline = m_aCutLines[nCL];
		
		dCutLinePoint1[0] = cutline.Point1[0];
		dCutLinePoint1[1] = cutline.Point1[1];
		dCutLinePoint1[2] = cutline.Point1[2];

		dCutLinePoint2[0] = cutline.Point2[0]; 
		dCutLinePoint2[1] = cutline.Point2[1]; 
		dCutLinePoint2[2] = cutline.Point2[2]; 

		//임시로 CutLine을 양단 방향으로 늘려준다. 이렇게 하는 
		//이유는 Cutting Line의 끝에서는 만나는 요소의 
		//한변에서 오차가 발생하는 경우가 있기때문이다. 

		dCutLineVector[0] = dCutLinePoint2[0] - dCutLinePoint1[0];
		dCutLineVector[1] = dCutLinePoint2[1] - dCutLinePoint1[1];

		C3DPoint ptTemp1,ptTemp2;
		double dVec[2][3];
		double dLeng;
		for(int ttt=0; ttt<3; ttt++)
		{
			dVec[0][ttt] = dCutLinePoint2[ttt]-dCutLinePoint1[ttt]; //P1->P2;
			dVec[1][ttt] = dCutLinePoint1[ttt]-dCutLinePoint2[ttt]; //P2->P1; 
		}
		dLeng = sqrt(pow(dCutLinePoint2[2]-dCutLinePoint1[2],2)+
								 pow(dCutLinePoint2[1]-dCutLinePoint1[1],2)+
								 pow(dCutLinePoint2[0]-dCutLinePoint1[0],2));  
		
		ptTemp1.x= dCutLinePoint2[0];
		ptTemp1.y= dCutLinePoint2[1];
		ptTemp1.z= dCutLinePoint2[2];
		CUtilFuncs::GetVectorDirectionPoint(dVec[0],dLeng/1000000. ,1, ptTemp1, ptTemp2);
		dCutLinePoint2[0] = ptTemp2.x;
		dCutLinePoint2[1] = ptTemp2.y;
		dCutLinePoint2[2] = ptTemp2.z;

		ptTemp1.x= dCutLinePoint1[0];
		ptTemp1.y= dCutLinePoint1[1];
		ptTemp1.z= dCutLinePoint1[2];
		CUtilFuncs::GetVectorDirectionPoint(dVec[1],dLeng/1000000. ,1, ptTemp1, ptTemp2);
		dCutLinePoint1[0] = ptTemp2.x;
		dCutLinePoint1[1] = ptTemp2.y;
		dCutLinePoint1[2] = ptTemp2.z;
		// Cutting Line늘리기 끝 

		// Active된 plate element를 돌면서 
		// Cutting Line과 만나는 점들의 위치를 구하고
		// 그 위치에서의 force값을 저장한다. 
		// 한요소를 지났을때.. 만일 Cutting Line에 
		// 걸리는 요소의 경우 반드시 Cutting Line과 
		// 두개의 교차점을 갖고 있어야 함 
		elem_num = m_PnKeyList.GetSize();
		for(int elem=0; elem<elem_num; elem++) 
		{
			aCutPoints.RemoveAll();
			aCutValues.RemoveAll();
			// Active된 plate element의 정보를 갖고옴 
			m_pDoc->m_pAttrCtrl->GetElem(m_PnKeyList[elem], elem_d);
							
			node_in_elem = m_pDoc->m_pAttrCtrl->GetNumNode(elem_d.eltyp, elem_d.elnod);
			for(i=0; i<node_in_elem; i++)
			{
				m_pDoc->m_pAttrCtrl->GetNode(elem_d.elnod[i],node_d1);
				j = (i==node_in_elem-1)? 0:(i+1);
				m_pDoc->m_pAttrCtrl->GetNode(elem_d.elnod[j],node_d2);

				
				dPoint1[0] = node_d1.x;
				dPoint1[1] = node_d1.y;
				dPoint1[2] = node_d1.z;

				dPoint2[0] = node_d2.x;
				dPoint2[1] = node_d2.y;
				dPoint2[2] = node_d2.z;

				BOOL bIntersect = CUtilFuncs::mathIntersectLine4GPS(dCutLinePoint1,dCutLinePoint2,dPoint1,dPoint2,dTolerance,dDistance,dPoint3);
				//if(CMathFunc::mathIntersectLine2(dCutLinePoint1,dCutLinePoint2,dPoint1,dPoint2,1e-7,dDistance,dPoint3))
				if(bIntersect)
				{
					
					if(!GetNodalValueforCuttingPlane(m_PnKeyList[elem],dPlateCutVal1,i,dPlateCutVal2,j))
						continue; // virtual
					
					d1 = CMathFunc::mathLength(dPoint3[0],dPoint3[1],dPoint3[2],
								dPoint1[0],dPoint1[1],dPoint1[2]);
					d2 = CMathFunc::mathLength(dPoint3[0],dPoint3[1],dPoint3[2],
								dPoint2[0],dPoint2[1],dPoint2[2]);
					
							
					dCutValue = dPlateCutVal1 + (dPlateCutVal2-dPlateCutVal1)*d1/(d1+d2);
					Point3d3.x = dPoint3[0];
					Point3d3.y = dPoint3[1];
					Point3d3.z = dPoint3[2];

					aCutPoints.Add(Point3d3);
					aCutValues.Add(dCutValue);

					/////////////////// test ////////////////////
					//CString sOut;
					//sOut.Format("요소:%d, 절점1:%d, 절점2:%d, D=%g, CuttingPt(%g,%g,%g)",
					//            m_PlateKeyList[elem],elem_d.elnod[i],elem_d.elnod[j],dDistance,Point3d3.x,Point3d3.y,Point3d3.z);
					//GSaveHistoryNF(sOut);    
					/////////////////// test ////////////////////
				}
				else
				{
					/////////////////// test ////////////////////
					//CString sOut;
					//sOut.Format("요소:%d, 절점1:%d, 절점2:%d, D=%g", 
					//            m_PlateKeyList[elem],elem_d.elnod[i],elem_d.elnod[j],dDistance);
					//GSaveHistoryNF(sOut);    
					/////////////////// test ////////////////////
				}
		  }
			
			
			// 같은 점이 있을 경우 없앤다.
			if(aCutPoints.GetSize()>1)
			{
				for( i =0; i<aCutPoints.GetSize()-1; i++)
					for( j=i+1; j<aCutPoints.GetSize(); j++)
					{
						if(IsSame3DPoint(aCutPoints[i],aCutPoints[j]))
						{
							aCutPoints.RemoveAt(j);
							aCutValues.RemoveAt(j);
							j--;
						}
					}	
			}
			else continue;
		
			if(aCutPoints.GetSize() != 2) //최종적으로 2개의 서로다른 점이 존재해야한다.
				continue;
	
			CutLineData.dPoint1Val = aCutValues[0];
			CutLineData.dPoint2Val = aCutValues[1];
			CutLineData.Point1 = aCutPoints[0];
			CutLineData.Point2 = aCutPoints[1];
			CutLineData.KeyElem = m_PnKeyList[elem];
			CutLineData.dDist1 = CMathFunc::mathLength(dCutLinePoint1[0],dCutLinePoint1[1],dCutLinePoint1[2],
								aCutPoints[0].x,aCutPoints[0].y,aCutPoints[0].z);
			CutLineData.dDist2 = CMathFunc::mathLength(dCutLinePoint1[0],dCutLinePoint1[1],dCutLinePoint1[2],
								aCutPoints[1].x,aCutPoints[1].y,aCutPoints[1].z);

			if(CutLineMax < aCutValues[0]) CutLineMax = aCutValues[0];
			if(CutLineMax < aCutValues[1]) CutLineMax = aCutValues[1];
			if(CutLineMin > aCutValues[0]) CutLineMin = aCutValues[0];
			if(CutLineMin > aCutValues[1]) CutLineMin = aCutValues[1];
	
			m_aCutLineData[nCL]->Add(CutLineData);

			/////////////////// test ////////////////////
			//CString sOut;
			//sOut.Format("P1:%g,%g,%g   P2:%g,%g,%g",
			//            aCutPoints[0].x,aCutPoints[0].y,aCutPoints[0].z,
			//            aCutPoints[1].x,aCutPoints[1].y,aCutPoints[1].z);
			//GSaveHistoryNF(sOut);    
			/////////////////// test ////////////////////
			
		}

		CutLineMinMax.Max = CutLineMax;
		CutLineMinMax.Min = CutLineMin;
		m_aCutLineMinMax.Add(CutLineMinMax);
	}

	////////////////////////////////////////////////////////////
	// CUTTING PLANE
	////////////////////////////////////////////////////////////

	CArray <T_CUTLINE_D,T_CUTLINE_D&> *paCutLineOnPlaneData;
	T_CUTLINE_MINMAX_D CutLineOnPlaneMinMax;
	T_CUTLINE_D				 CutLineOnPlaneData;

	C3DPoint Point1,Point2,Vector,Point3;
	double dVector[3],dNormalVector[3];
	
	CArray <T_NPLN_D,T_NPLN_D&> aCuttingPlane;
	T_NPLN_D CuttingPlane;
	PLANE_FUNC CuttingPlaneF;

	int nNumOfCutPlanes;
	
	nNumOfCutPlanes = m_aCutPlanes.GetSize();
	for(int nKey = 0; nKey < nNumOfCutPlanes; nKey++)
	{
	  if(GetNPLN(m_aCutPlanes[nKey],CuttingPlane))
			aCuttingPlane.Add(CuttingPlane);
		else
		{
			nNumOfCutPlanes--;
			m_aCutPlanes.RemoveAt(nKey);
			gm->m_aCutPlanes.RemoveAt(nKey);
			nKey--;
		}
	}

	for(int nPLN = 0; nPLN < nNumOfCutPlanes; nPLN++)
	{
		paCutLineOnPlaneData = new CArray<T_CUTLINE_D,T_CUTLINE_D&>;
		m_aCutLineOnPlaneData.Add(paCutLineOnPlaneData);
		double CutLineOnPlaneMax = -DBL_MAX;
		double CutLineOnPlaneMin =  DBL_MAX;

		CuttingPlane = aCuttingPlane[nPLN];
		GetPlaneFunction(CuttingPlane,CuttingPlaneF);
		
		dNormalVector[0] =CuttingPlaneF.a;
		dNormalVector[1] =CuttingPlaneF.b;
		dNormalVector[2] =CuttingPlaneF.c; // CuttingPlane Normal Vector

		//aCutVertex.RemoveAll();
		//aCutVertexVal.RemoveAll();

		elem_num = m_PnKeyList.GetSize();
		
		for (int elem=0;elem<elem_num;elem++) 
		{
			aCutPoints.RemoveAll();
			aCutValues.RemoveAll();
			m_pDoc->m_pAttrCtrl->GetElem(m_PnKeyList[elem], elem_d);
	
			node_in_elem = m_pDoc->m_pAttrCtrl->GetNumNode(elem_d.eltyp, elem_d.elnod);
			for(i=0; i<node_in_elem; i++)
			{
				m_pDoc->m_pAttrCtrl->GetNode(elem_d.elnod[i],node_d1);
				j = (i==node_in_elem-1)? 0:(i+1);
				m_pDoc->m_pAttrCtrl->GetNode(elem_d.elnod[j],node_d2);

			  Point1.x = node_d1.x;
				Point1.y = node_d1.y;
				Point1.z = node_d1.z;

				Point2.x = node_d2.x;
				Point2.y = node_d2.y;
				Point2.z = node_d2.z;
					  
			  dVector[0] = Point2.x-Point1.x;
			  dVector[1] = Point2.y-Point1.y;
			  dVector[2] = Point2.z-Point1.z;

			  
			  d1 = CuttingPlaneF.a*Point1.x + CuttingPlaneF.b * Point1.y + CuttingPlaneF.c * Point1.z + CuttingPlaneF.h ;
			  d2 = CuttingPlaneF.a*Point2.x + CuttingPlaneF.b * Point2.y + CuttingPlaneF.c * Point2.z + CuttingPlaneF.h ;
			  

			  if(d1*d2<0.0)
			  {
				  dPoint1[0] = Point1.x;
				  dPoint1[1] = Point1.y;
				  dPoint1[2] = Point1.z;

				  if(!CMathFunc::project_on_plane_vector_for_CuttingPlane(dPoint1,dVector,CuttingPlane.dPoint[0],
					  CuttingPlane.dPoint[1],CuttingPlane.dPoint[2],dPoint3)) continue;
				  Point3.Set(dPoint3[0],dPoint3[1],dPoint3[2]);

					double dist1 = CMathFunc::mathLength(Point3.x,Point3.y,Point3.z,
					  Point1.x,Point1.y,Point1.z);
				  double dist2 = CMathFunc::mathLength(Point3.x,Point3.y,Point3.z,
					  Point2.x,Point2.y,Point2.z);

					if(!GetNodalValueforCuttingPlane(m_PnKeyList[elem],dPlateCutVal1,i,dPlateCutVal2,j))
						continue;// virtual
					dCutValue = dPlateCutVal1 + (dPlateCutVal2-dPlateCutVal1)*dist1/(dist1+dist2);
				  				  
				  aCutValues.Add(dCutValue);
					aCutPoints.Add(Point3);
			  }
			  
			  if(fabs(d1 - 0.0)<1e-18)
			  {
				  if(!GetNodalValueforCuttingPlane(m_PnKeyList[elem],dPlateCutVal1,i,dPlateCutVal2,j))
						continue; // virtual
					dCutValue = dPlateCutVal1;
				  aCutValues.Add(dCutValue);
					aCutPoints.Add(Point1);
			  }
			  
			  if(fabs(d2 - 0.0)<1e-18)
			  {
				  if(!GetNodalValueforCuttingPlane(m_PnKeyList[elem],dPlateCutVal1,i,dPlateCutVal2,j))
						continue; // virtual
					dCutValue = dPlateCutVal2;
				  aCutValues.Add(dCutValue);
					aCutPoints.Add(Point2);
			  }

		  }
		  
			// 같은 점이 있을 경우 없앤다.
			if(aCutPoints.GetSize()>1)
			{
				for( i =0; i<aCutPoints.GetSize()-1; i++)
					for( j=i+1; j<aCutPoints.GetSize(); j++)
					{
						if(IsSame3DPoint(aCutPoints[i],aCutPoints[j]))
						{
							aCutPoints.RemoveAt(j);
							aCutValues.RemoveAt(j);
							j--;
						}
					}	
			}
			else continue;
		
			if(aCutPoints.GetSize() != 2) //최종적으로 2개의 서로다른 점이 존재해야한다.
				continue;
	
			CutLineOnPlaneData.dPoint1Val = aCutValues[0];
			CutLineOnPlaneData.dPoint2Val = aCutValues[1];
			CutLineOnPlaneData.Point1 = aCutPoints[0];
			CutLineOnPlaneData.Point2 = aCutPoints[1];
			CutLineOnPlaneData.KeyElem = m_PnKeyList[elem];

			if(CutLineOnPlaneMax < aCutValues[0]) CutLineOnPlaneMax = aCutValues[0];
			if(CutLineOnPlaneMax < aCutValues[1]) CutLineOnPlaneMax = aCutValues[1];
			if(CutLineOnPlaneMin > aCutValues[0]) CutLineOnPlaneMin = aCutValues[0];
			if(CutLineOnPlaneMin > aCutValues[1]) CutLineOnPlaneMin = aCutValues[1];
	
			m_aCutLineOnPlaneData[nPLN]->Add(CutLineOnPlaneData);
			
		}

		CutLineOnPlaneMinMax.Max = CutLineOnPlaneMax;
		CutLineOnPlaneMinMax.Min = CutLineOnPlaneMin;
		m_aCutLineOnPlaneMinMax.Add(CutLineOnPlaneMinMax);
	}
}

// MNET:3747-KIMJM-20101210 Beam Stress (PSC)는 사용하지 않음.
// MNET:3643-GYKIM-20101108
void CStressEngine::GetOffsetedPoint(T_ELEM_K ekey,C3DPoint Org_node_i, C3DPoint Org_node_j,
																		 C3DPoint &node_i, C3DPoint &node_j,int nComp)
{
	I_GPSModel					*gm=(I_GPSModel *) m_pGPSModel;
	
	T_CFMO_D						DataCFMO;
	
	
	/////////////////////////////////////////////////////////////////////////////////////////////////
	// Offset 설정 
	// [Xi,Xj,Zi,Zj,Yi,Yj] // 이 순서대로 사용하였음.
	
	if(m_pDoc->m_pPostCtrl->GetCfmo(ekey, DataCFMO))
	{
		DataCFMO.dOffset[0] = 0.0;
		DataCFMO.dOffset[1] = 0.0;
		
		//nOffsetType   0: global offset
		//nOffsetType   1: building control
		//nOffsetType   2: local offset
		//nOffsetType   3: Section offset
		
		//if(DataCFMO.nOffsetType == 0) // Type 0일 경우 무시한다.
		if(DataCFMO.nOffsetType==0 || DataCFMO.nOffsetType==3 ) // Type 0일 경우 무시한다.
		{
			DataCFMO.dOffset[2] = 0.0;
			DataCFMO.dOffset[3] = 0.0;
			DataCFMO.dOffset[4] = 0.0;
			DataCFMO.dOffset[5] = 0.0;
		}
	}
	else
	{
		DataCFMO.Initialize();
		DataCFMO.dLength = m_pDoc->calcLAVElem(ekey);         // 빔의 길이 
	}

	double dZeroLength = 1.0e-8;
	double dLength = CMathFunc::mathLength(Org_node_i.x, Org_node_i.y, Org_node_i.z, Org_node_j.x, Org_node_j.y, Org_node_j.z);  
	switch(nComp)
	{
	case BSTRS_COMPONENT_FX:
		node_i = Org_node_i;
		node_j = Org_node_j;
		break;
	case BSTRS_COMPONENT_FY:
	case BSTRS_COMPONENT_MY:  
		if(fabs(DataCFMO.dOffset[4]) > dLength || fabs(fabs(DataCFMO.dOffset[4])-dLength) <= dZeroLength)   node_i = Org_node_j;
		else CUtilFuncs::GetInnerLinePoint2(DataCFMO.dOffset[4], DataCFMO.dLength, Org_node_i, Org_node_j, node_i);
		if(fabs(DataCFMO.dOffset[5]) > dLength || fabs(fabs(DataCFMO.dOffset[5])-dLength) <= dZeroLength)   node_j = Org_node_i;
		else CUtilFuncs::GetInnerLinePoint2(DataCFMO.dLength-DataCFMO.dOffset[5], DataCFMO.dLength, Org_node_i, Org_node_j, node_j);
		break;
		
	case BSTRS_COMPONENT_FZ:
	case BSTRS_COMPONENT_MZ:
	case BSTRS_COMPONENT_COMB:
	case BSTRS_COMPONENT_7thDOF:
		if(fabs(DataCFMO.dOffset[2]) > dLength || fabs(fabs(DataCFMO.dOffset[2])-dLength) <= dZeroLength)   node_i = Org_node_j;
		else CUtilFuncs::GetInnerLinePoint2(DataCFMO.dOffset[2], DataCFMO.dLength, Org_node_i, Org_node_j, node_i);
		if(fabs(DataCFMO.dOffset[3]) > dLength || fabs(fabs(DataCFMO.dOffset[3])-dLength) <= dZeroLength)   node_j = Org_node_i;
		else CUtilFuncs::GetInnerLinePoint2(DataCFMO.dLength-DataCFMO.dOffset[3], DataCFMO.dLength, Org_node_i, Org_node_j, node_j);
		break;
	default:
		ASSERT(0);
		break;
	}  
}

void CStressEngine::MakeIsolationStrsDataList()
{
	//////////////////////////////////////////////////////////////////////////////////////////
	// Isolation GB 2022.7.4 - xuezc														//
	// NLNK IsolationGB																		// 
	//////////////////////////////////////////////////////////////////////////////////////////

	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;
	int			node_num;
	double		max_strs = -DBL_MAX, min_strs = DBL_MAX, len;
	BOOL		has_content = FALSE;
	T_NLNK_K	nlnk_key;
	if (!gm->m_bLoadDataSet)return;
	gm->m_pMyView->BeginWaitCursor();
	m_dMaxValue = -DBL_MAX;
	m_dMinValue = DBL_MAX;
	m_mapIsoStrsData.RemoveAll();
	node_num = gm->m_NKeyListActive.GetSize();
	CMap<T_NODE_K, T_NODE_K, bool, bool> mapNodeExist;
	for (int i = 0; i < node_num; i++)
	{
		mapNodeExist[gm->m_NKeyListActive[i]] = true;
	}
	CArray<T_ISO_RATIO, T_ISO_RATIO&> aIsoRatio;
	if (!IIsolatorTool::Instance()->GetNlnkIsolationData(aIsoRatio, m_IsoStrsComponent, m_IsoGBloadcaseK, m_IsoGBLoadType, m_IsoGBMaxMin,
		m_IsoGBloadcaseK2, m_IsoGBLoadType2, m_IsoGBMaxMin2))
		return;
	T_NLNK_D NlnkD;
	for (int i = 0; i < aIsoRatio.GetSize(); i++)
	{
		nlnk_key = aIsoRatio[i].nlnkK;
		if (!m_pDoc->m_pAttrCtrl->GetNlnk(nlnk_key, NlnkD))
		{
			ASSERT(FALSE);
			continue;
		}
		if (!gm->m_pGPSCtrl->IsActiveNode(NlnkD.Node1))continue;
		if (!gm->m_pGPSCtrl->IsActiveNode(NlnkD.Node2))continue;
		if (!mapNodeExist.PLookup(NlnkD.Node1) && !mapNodeExist.PLookup(NlnkD.Node2))
			continue;

		if (m_IsoStrsRltComp == 0)
		{
			len = aIsoRatio[i].dVal;
			if (len == 0.0)continue;
		}
		else if (m_IsoStrsRltComp == 1)
			len = aIsoRatio[i].dLimit;
		else if (m_IsoStrsRltComp == 2)
		{
			len = aIsoRatio[i].dRatio;
			if(len > 999998.99)
				continue;
		}
		if (len > max_strs) { max_strs = len; gm->m_nLgdMaxValKey = nlnk_key; }
		if (len < min_strs) { min_strs = len; gm->m_nLgdMinValKey = nlnk_key; }
		if (len > m_dMaxValue) { m_dMaxValue = len; gm->m_nLgdMaxValKey = nlnk_key; }
		if (len < m_dMinValue) { m_dMinValue = len; gm->m_nLgdMinValKey = nlnk_key; }

		has_content = TRUE;
		m_mapIsoStrsData.SetAt(nlnk_key, len);
	}

	if (!has_content)
	{
		max_strs = min_strs = 0.0;
		gm->m_nLgdMaxValKey = 0;
		gm->m_nLgdMinValKey = 0;
	}

	if (!m_pContourEngine)m_pContourEngine = new CContourEngine(min_strs, max_strs);
	else m_pContourEngine->MakeRankMap(min_strs, max_strs);
	gm->m_pMyView->EndWaitCursor();
}

void CStressEngine::OutputNlnkIsolationGBStrsNumbers(CDC *pDC)
{
	DECLARE_GPSMD();
	DECLARE_DPTTX();
	DECLARE_DPTDR();

	int		node_num;
	double	dvalue;
	//fl_bak = gm->m_DOPT.DR.m_bFrameLine;
	//gm->m_DOPT.DR.m_bFrameLine = TRUE;
	TCHAR		fmt_str[10], text_str[512];
	CPoint		text_p, node_2d_i, node_2d_j;
	C3DPoint	node3D_i, node3D_j, DrawPoint;
	if (gm->m_DOPT.TX.m_bNumberOpaque)
		pDC->SetBkMode(OPAQUE);
	else
		pDC->SetBkMode(TRANSPARENT);
	COLORREF ColorNG = RGB(255, 0, 0);
	CFont	ft, *old_ft;
	pDC->SetTextColor(pTX->m_NumberTextColorC);
	pDC->SetBkColor(pTX->m_NumberBackCol);
	pDC->SetTextAlign(TA_LEFT | TA_BOTTOM);
	gm->SetNumberFontNodeOrientation(0);
	ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
	old_ft = (CFont *)pDC->SelectObject(&ft);

	//pDC->SetTextAlign(TA_CENTER | TA_BOTTOM);
	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);
	node_num = gm->m_NKeyListActive.GetSize();
	CMap<T_NODE_K, T_NODE_K, bool, bool> mapNodeExist;
	CArray<T_NLNK_K, T_NLNK_K> aNlnkK;
	T_NLNK_D NlnkD;
	for (int i = 0; i < node_num; i++)
	{
		mapNodeExist[gm->m_NKeyListActive[i]] = true;
	}
	m_pDoc->m_pAttrCtrl->GetNlnkKeyList(aNlnkK);
	for (int i = 0; i < aNlnkK.GetSize(); i++)
	{
		if (!m_pDoc->m_pAttrCtrl->GetNlnk(aNlnkK[i], NlnkD))
		{
			ASSERT(FALSE);
			continue;
		}
		if (!gm->m_pGPSCtrl->IsActiveNode(NlnkD.Node1))continue;
		if (!gm->m_pGPSCtrl->IsActiveNode(NlnkD.Node2))continue;
		gm->RE_GetLabelPosNodeByKey(NlnkD.Node1, &node3D_i);
		gm->RE_GetLabelPosNodeByKey(NlnkD.Node2, &node3D_j);
		if (gm->m_bVirtualMode)
		{
			node_2d_i = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_i);
			node_2d_j = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_j);
		}
		else
		{
			node_2d_i = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_i);
			node_2d_j = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_j);
		}
		text_p.x = (int)((node_2d_i.x + node_2d_j.x) / 2.0);
		text_p.y = (int)((node_2d_i.y + node_2d_j.y) / 2.0);
		if (!m_mapIsoStrsData.Lookup(aNlnkK[i], dvalue))
		{
			dvalue = 0.0;
			_stprintf(text_str, _T("%s"), _T("-"));
		}
		else
			_stprintf(text_str, fmt_str, dvalue);
		if (m_IsoStrsRltComp == 2)
		{
			if(dvalue > 1.0)
				pDC->SetTextColor(ColorNG);
			else
				pDC->SetTextColor(pTX->m_NumberTextColorC);
		}
		pDC->TextOut(text_p.x, text_p.y, text_str);
	}
	pDC->SelectObject(old_ft);
	ft.DeleteObject();
	//gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}