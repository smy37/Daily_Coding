
#include "stdafx.h"
#include "wg_gps.h"
#include "DeformEngine.h"

#include "PostTools.h"
#include "GPSDisplayFilter.h"

#include "..\wg_base\wg_baseAllPPreview.h"
#include "..\wg_db\wg_db_AttrCtrl.h"
#include "..\wg_db\QSort.h"
#include "..\wg_db\wg_db_MathFunc.h"
#include "..\wg_db\wg_db_PoverInfo.h"
#include "..\wg_db\wg_db_StoryData.h"   // for CStoryData

#ifdef _TOWER
#include "..\wg_db\wg_db_TowerInfo.h"
#endif

#include <float.h>

#include "DRW_DATA.h"
#include "GPostTextOut.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////
/*
extern _T("C") { void __cdecl MOV_KRNL(char* filename, int fn_len, int type, int number, int component,
																	 int loadcase, int* N_lane, double* F_max, double* F_min, 
																	 int max_lane_array[1000], int min_lane_array[1000],int nProgType,
																	 double scfc_lane_array[20],double turuck_load_dist[20000]); }
extern _T("C") { void __cdecl MOV_KRNL_JAPAN(char* filename, int fn_len, int type, int number, int component,
																	 int loadcase, int* N_lane, double* F_max, double* F_min, 
																	 int max_load[100], int min_load[100],int nProgType); }
extern _T("C") { void __cdecl MOV_KRNL_CHINA(char* filename, int fn_len, int type, int number, int component,
																	 int loadcase, int* N_lane, double* F_max, double* F_min, 
																	 int max_lane_array[1000], int min_lane_array[1000],int nProgType,
																	 double *dimpact,double *simpact,double *scfc_lane_array,
																	 int nm_pmx1,int nm_smx1); }
*/

/////////////////////////////////////////////////////////////////////

#define DECLARE_GPSMD()  I_GPSModel *gm=(I_GPSModel *)m_pGPSModel
#define DECLARE_DPTDR()  T_GPS_DISP_OPT_DR *pDR = &(gm->m_DOPT.DR) 
#define DECLARE_DPTRD()  T_GPS_DISP_OPT_RD *pRD = &(gm->m_DOPT.RD)
#define DECLARE_DPTCL()  T_GPS_DISP_OPT_CL *pCL = &(gm->m_DOPT.CL)
#define DECLARE_DPTTX()  T_GPS_DISP_OPT_TX *pTX = &(gm->m_DOPT.TX)
#define DECLARE_DBDOC()  CDBDoc		  *pDoc=CDBDoc::GetDocPoint()
//#define __OLD_OUTPUT_VALUE false;


////////////////////////////////////////////////////////////////////////////////////////
// Routines for Drawing Deformed Shape                 /////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
void CDeformEngine::AddActiveHingeElemSum( unsigned int ekey, BOOL bYieldStatusBeam, BOOL bYieldStatusWall, BOOL bYieldStatusTruss, BOOL bYieldStatusLink )
{
	/*
	Active된 요소 중에서 현재 요소의 타입과 해당 요소의 힘의 방향으로 
	계산해야될 Active된 요소를 걸러낸다. - kspark
	*/
	T_INELASTICDYN_HINGE_INFO HingeInfo;
	if(m_pDoc->m_pPostCtrl->GetPoverInfo()->GetInelasticDynHngtDataElem(ekey,HingeInfo))
	{
		// 해당 Type이 active되어 있다면,
		if( (HingeInfo.nElemType == PSOV_INELASTIC_ELEM_TYPE_BEAM  && bYieldStatusBeam ) ||
				(HingeInfo.nElemType == PSOV_INELASTIC_ELEM_TYPE_WALL  && bYieldStatusWall ) ||
				(HingeInfo.nElemType == PSOV_INELASTIC_ELEM_TYPE_TRUSS && bYieldStatusTruss) ||
				(HingeInfo.nElemType == PSOV_INELASTIC_ELEM_TYPE_NLNK  && bYieldStatusLink ) )
		{
			int nCnt = HingeInfo.aInelasticDynHingeInfo.GetSize();
			BOOL IsCheck[4] = {0,};
			int nIdx = 0;
			// 해당 요소가 가지고 있는 힘의 방향에 대해 count를 올린다.
			// Fy/Fz와 My/Mz는 한번만 올린다.
			for (nIdx = 0; nIdx < nCnt; ++nIdx)
			{
				int nYieldDir = HingeInfo.aInelasticDynHingeInfo[nIdx].nHingeDirection;
				switch(nYieldDir)
				{
				case 0:					IsCheck[2] = TRUE; 	break; // 2: Fx
				case 1:	case 2:	IsCheck[3] = TRUE;	break; // 3: Fy, Fz
				case 4:	case 5:	IsCheck[1] = TRUE;	break; // 1: My,Mz
				}
			}
			
			for (nIdx = 0; nIdx < 4; ++nIdx)
			{
				if(IsCheck[nIdx]) CDeformEngine::m_nActiveElementSum[nIdx]++; 
			}
		}
	}
	else
	{
		CArray<T_ELEM_K, T_ELEM_K> ElemKeyList;
		T_ELEM_K RootKey = -1;
		T_ELEM_D ElemD;

		m_pDoc->m_pAttrCtrl->GetElem(ekey, ElemD);
		if(!m_pDoc->m_pAttrCtrl->IsWall(ElemD.eltyp)) return;

		m_pDoc->m_pAttrCtrl->GetKeyListBy_WallID_ByStor(ElemKeyList,ekey);
		m_pDoc->m_pAttrCtrl->GetRootWallElemKey(ElemKeyList, RootKey);

		if(!m_pDoc->m_pPostCtrl->GetPoverInfo()->GetInelasticDynHngtDataElem(RootKey,HingeInfo)) return;		
		AddActiveHingeElemSum(RootKey, bYieldStatusBeam, bYieldStatusWall, bYieldStatusTruss, bYieldStatusLink);
	}
}

void CDeformEngine::DrawDeformedElement(CDC *pDC, unsigned int ekey, BOOL bPOHingeShape/*=FALSE*/)
{
	T_MIRE_K  mkey;
	mkey.keymap=ekey;

	DECLARE_GPSMD();
	DECLARE_DPTDR();
	DECLARE_DPTRD();
	
	int	i,poly_num;
	T_ELEM_D	edata;
	COLORREF	rgb[2];
	CPen	pen, *old_pen,*old_pen2;
	CArray<GPS_BOOL_ARRYP,GPS_BOOL_ARRYP> edge_list;
	CArray<GPS_3DPT_LISTP,GPS_3DPT_LISTP>	polygon_list;

	CClientDC dc(gm->m_pMyView);
	BOOL bShade_bak = pRD->m_bShade;
	CPen SRCLinePen;
	//gm->GetSRCOutlinePen(&SRCLinePen);

	if(pDR->m_RenderFlag==2)pRD->m_bShade = FALSE;
	if(!m_bResultDataSet)return;

	m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, edata);
	//20060216 Chang-keun
	//gm->GetElemColor(edata, rgb);
	BOOL bBlend;
	double BlendFactor; // 0 ~ 1.0
	gm->_GetElemColor(edata,rgb,bBlend,BlendFactor,&ekey);
	
	int nScale = 1;
	CString strDir;
	if(gm->m_GPSInstruction==GPS_COMMAND_DEFORM && gm->m_bYieldStatus)
	{
		int nDir = -1;
		unsigned int RootKey = 0;
		int nRank = GetYieldStatusInfo(0, ekey, rgb[0], nDir, strDir, RootKey);
		if(nRank > 0)
		{
			nScale = 2;
			rgb[1] = rgb[0];

			if(RootKey != ekey)
			{
				if(!bPOHingeShape) CDeformEngine::m_nPOYieldStatusCurStep[nRank] += 1;
			}
		}

		if(!bPOHingeShape)AddActiveHingeElemSum(ekey, gm->m_bYieldStatusBeam, gm->m_bYieldStatusWall, gm->m_bYieldStatusTruss, gm->m_bYieldStatusLink);
	}

 	if(pDR->m_bFrameLine)pen.CreatePen(PS_SOLID, pDR->nElemWire*1.7*nScale, rgb[0]);  
	else 		             pen.CreatePen(PS_SOLID, pDR->nElemHddn, rgb[0]);
	
	old_pen=(CPen *) pDC->SelectObject(&pen);
	if(!gm->m_bVirtualMode && !gm->m_bAnimation)
	old_pen2 = (CPen *)dc.SelectObject(&pen);
	
	//XGLRenderer
	GPS_INTG_ARRY   Sort_index_list;
	GPS_INTG_ARRYP  paFreeFace = NULL; 
	BOOL is_solid = m_pDoc->m_pAttrCtrl->IsSolid(edata.eltyp);
	
	if(is_solid && !m_mapFreeFacebyElemKey.Lookup(mkey.key.elem_k,paFreeFace) && !pRD->m_bShrink)
		return;


	// 변형된 요소의 형상정보를 얻는다.
	if(m_bRealDeform && m_pDoc->m_pAttrCtrl->IsBeam(edata.eltyp)) 
	{	
		// Beam의 Real Deform
		if(!gm->m_pBeamDiagram) gm->m_pBeamDiagram = new CBeamDiagram;
		
		BOOL bSuccess;
		T_DISP_D Disp_I,Disp_J;
		GetDispData(edata.elnod[0],Disp_I);
		GetDispData(edata.elnod[1],Disp_J);
		if(gm->m_GPSMode ==GPS_COMMAND_EGMDSHP || gm->m_GPSMode ==GPS_COMMAND_BKMDSHP) 
			bSuccess = gm->m_pBeamDiagram->MakeBeamDispl(mkey.key.elem_k,Disp_I,Disp_J, 15, 2,m_dCubicFactor);
		else
			bSuccess = gm->m_pBeamDiagram->MakeBeamDispl(mkey.key.elem_k, gm->m_LoadCombi, 10, 2);
	
		if(bSuccess) GetBeamRealDeformedShape(ekey, &polygon_list, &edge_list);
	  else         GetDeformedShapeElement(ekey, &polygon_list, &edge_list);
	}
	else 
	{
		//XGLRenderer
		//GetDeformedShapeElement(ekey, &polygon_list, &edge_list);
		GetDeformedShapeElement(ekey,&polygon_list,&edge_list,NULL,NULL,&Sort_index_list);
	}

	poly_num = polygon_list.GetSize();

	T_SECT_D SectD;
	if(m_pDoc->m_pAttrCtrl->IsFrameType(edata.eltyp) && pDR->m_bFrameThick)
		 m_pDoc->m_pAttrCtrl->GetSect(edata.elpro,SectD);
	
	gm->GPS_XGL_Begin_Elem(mkey.key.elem_k,edata);

	for(i=0;i<poly_num;i++) 
	{
		// Hidden Mode가 아니거나 Hidden Option이 Outline만 그리는 것일 경우
		
		if(pDR->m_bFrameLine)
			gm->GPSDrawPolygonEdge(pDC, polygon_list[i], edge_list[i],TRUE);
	  else 
		{
			//XGLRenderer Deform Shape에 Solid Freeface적용...
			if(is_solid && !gm->m_DOPT.RD.m_bShrink)
			{
				if(!IsFreeFace(paFreeFace,Sort_index_list[i]))
			   continue;
			}

			int vtx_num = polygon_list[i]->GetCount();
			if(!gm->IsPossibleDrawingPoly(ekey,&edata,&SectD,poly_num,polygon_list[i],m_bRealDeform))continue; 

			if(pDR->m_RenderFlag == 1)
			{
				pDC->SelectStockObject(NULL_PEN);
				if(!gm->m_bAnimation && !gm->m_bVirtualMode)
					dc.SelectStockObject(NULL_PEN);
			}
			/* 20060216 Changkeun   
			if(pDR->m_RenderFlag==2 && vtx_num >2)
				gm->DrawPolygon3DFill(pDC, *(polygon_list[i]), *(edge_list[i]), gm->m_DOPT.CL.m_ClientBackColor,&dc);
			else if(vtx_num==2)
				gm->DrawPolygon3DFill(pDC, *(polygon_list[i]), *(edge_list[i]), rgb[0],&dc);
			else
				gm->DrawPolygon3DFill(pDC, *(polygon_list[i]), *(edge_list[i]), rgb[1],&dc);
			*/

			if(pDR->m_RenderFlag==2 && vtx_num >2)
			{
				if(!bBlend)
				  gm->DrawPolygon3DFill(pDC, *(polygon_list[i]), *(edge_list[i]), gm->m_DOPT.CL.m_ClientBackColor,&dc);
				else
				{
					int Intensity = BlendFactor * 255.f; // XGL Routine은 Intensity Max 100기준 이다. 
					gm->DrawBlendedPolygon3DFill(pDC,*(polygon_list[i]),*(edge_list[i]),rgb[0],rgb[1],Intensity,&dc);
				}           
			}
			else if(vtx_num==2)
			{
				gm->DrawPolygon3DFill(pDC, *(polygon_list[i]), *(edge_list[i]), rgb[0],&dc);
			}
			else
			{
				if(!bBlend)
				  gm->DrawPolygon3DFill(pDC, *(polygon_list[i]), *(edge_list[i]), rgb[1],&dc);
				else
				{
					int Intensity = BlendFactor * 255.f; // XGL Routine은 Intensity Max 100기준 이다. 
					gm->DrawBlendedPolygon3DFill(pDC,*(polygon_list[i]),*(edge_list[i]),rgb[0],rgb[1],Intensity,&dc);
				}
			}
		}
	}
	gm->GPS_XGL_End_Elem(bBlend);

	pDC->SelectObject(old_pen);
	if(!gm->m_bVirtualMode && !gm->m_bAnimation)dc.SelectObject(old_pen2);
	pen.DeleteObject();
	//SRCLinePen.DeleteObject();
	FreeMemoryPolyList(&polygon_list,&edge_list); 
	
	pRD->m_bShade = bShade_bak;

	// PUSH OVER HINGE
	if(gm->m_GPSMode      == GPS_COMMAND_DEFORM && gm->m_bContour && 
		 gm->m_LoadCaseType == D_LOADCASE_PUSHOVER)
	{
		T_GPS_HGST_D hgst_d;
		if(m_mapHgstFact.Lookup(ekey,hgst_d))
		{
			if(hgst_d.nHingeType==DUTL_HNGE_SECT)
			{
				//DoElementContourInElast(pDC,ekey);
				DrawHingeStatus_Sect_Elem(pDC, ekey, hgst_d);
			}
			else
			{
				if(m_pDoc->m_pAttrCtrl->IsFrameType(edata.eltyp))
					DrawHingeStatus_Frame(pDC,ekey);
				else if(m_pDoc->m_pAttrCtrl->IsWall(edata.eltyp))
					DrawHingeStatus_Wall(pDC,ekey);
			}
		}
	}

	// THEX,THAM,THPO HINGE
	if(gm->m_GPSMode      == GPS_COMMAND_DEFORM && gm->m_bContour && 
		 (gm->m_LoadCaseType == D_LOADCASE_THEX || 
			gm->m_LoadCaseType == D_LOADCASE_THAM || 
			gm->m_LoadCaseType == D_LOADCASE_THPO ))
	{
		
		T_EVTB_D EvtbD;
		T_EVTR_D EvtrD;
		if(m_pDoc->m_pAttrCtrl->IsBeam(edata.eltyp))
		if(m_mapEvtbD.Lookup(ekey,EvtbD))
		{
			DrawThexHingeElem(pDC,ekey,&EvtbD,NULL);
		}

		if(m_pDoc->m_pAttrCtrl->IsTruss(edata.eltyp))
		if(m_mapEvtrD.Lookup(ekey,EvtrD))
		{
			DrawThexHingeElem(pDC,ekey,NULL,&EvtrD);
		}
	}
}

// 현재 그리는 element type이 아닌 element를 그림.
// Active/Inactive 기능과 무관...
void CDeformEngine::DrawInactiveDeformedElement(CDC *pDC, unsigned int ekey)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	T_MIRE_K mkey;
	mkey.keymap = ekey;

	int	i,poly_num;
	T_ELEM_D	edata;
	CPen		pen, *old_pen;
	CBrush	brush, *old_brush;
	CArray<CArray<BOOL,BOOL>*,CArray<BOOL,BOOL>*> edge_list;
	CArray<CList<C3DPoint,C3DPoint>*,CList<C3DPoint,C3DPoint> *>	polygon_list;
	
	if(!m_bResultDataSet)return;

	m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, edata);
	if(m_bRealDeform && m_pDoc->m_pAttrCtrl->IsBeam(edata.eltyp)) 
	{
		if(!gm->m_pBeamDiagram)gm->m_pBeamDiagram = new CBeamDiagram;

		BOOL bSuccess;
		T_DISP_D Disp_I,Disp_J;
		GetDispData(edata.elnod[0],Disp_I);
		GetDispData(edata.elnod[1],Disp_J);
		if(gm->m_GPSMode ==GPS_COMMAND_EGMDSHP || gm->m_GPSMode ==GPS_COMMAND_BKMDSHP) 
			bSuccess = gm->m_pBeamDiagram->MakeBeamDispl(mkey.key.elem_k,Disp_I,Disp_J, 15, 2,m_dCubicFactor);
		else
			bSuccess = gm->m_pBeamDiagram->MakeBeamDispl(mkey.key.elem_k, gm->m_LoadCombi, 10, 2);
	
		if(bSuccess)GetBeamRealDeformedShape(ekey, &polygon_list, &edge_list);
	  else        GetDeformedShapeElement(ekey, &polygon_list, &edge_list);
	}
	else 
	{
		GetDeformedShapeElement(ekey, &polygon_list, &edge_list);
	}
	
	if(gm->m_DOPT.DR.m_bFrameLine) // wire frame
		pen.CreatePen(PS_SOLID, gm->m_nLineWidth*1.7, gm->m_DOPT.CL.m_InactiveCol);
	else 
		pen.CreatePen(PS_SOLID, gm->m_nLineWidth, gm->m_DOPT.CL.m_InactiveCol);

	brush.CreateSolidBrush(gm->m_DOPT.CL.m_InactiveCol);
	old_pen = (CPen *) pDC->SelectObject(&pen);
	old_brush = (CBrush *) pDC->SelectObject(&brush);

	gm->GPS_XGL_Begin_Elem(mkey.key.elem_k,edata);

	poly_num = polygon_list.GetSize();
	for (i=0;i<poly_num;i++) 
	{
//		if (gm->m_bFrameLine || (gm->m_RenderFlag==2)) {
			gm->GPSDrawPolygonEdge(pDC, polygon_list[i], edge_list[i],TRUE);
//		}
//		else {
//			if (gm->m_bVirtualMode)
//				gm->m_pGPSCtrl->DrawPolygon3DFillOnClientWindow(pDC, *(polygon_list[i]));
//			else
//				gm->m_pGPSCtrl->DrawPolygon3DFill(pDC, *(polygon_list[i]));
//		}
	}
	gm->GPS_XGL_End_Elem();

	pDC->SelectObject(old_pen);
	pDC->SelectObject(old_brush);
	pen.DeleteObject();
	brush.DeleteObject();

	FreeMemoryPolyList(&polygon_list,&edge_list); 
	/*
	for(i=0;i<poly_num;i++) 
	{
		polygon_list[i]->RemoveAll();
		delete polygon_list[i];
		edge_list[i]->RemoveAll();
		delete edge_list[i];
	}
	polygon_list.RemoveAll();
	edge_list.RemoveAll();
	*/
}

void CDeformEngine::DrawGrayDeformedElement(CDC *pDC, unsigned int ekey)
{
	T_MIRE_K  mkey;
	mkey.keymap=ekey;

	DECLARE_GPSMD();
	DECLARE_DPTDR();
	DECLARE_DPTRD();
	
	int	i,poly_num;
	T_ELEM_D	edata;
	CPen	pen, *old_pen,*old_pen2;
	CArray<GPS_BOOL_ARRYP,GPS_BOOL_ARRYP> edge_list;
	CArray<GPS_3DPT_LISTP,GPS_3DPT_LISTP>	polygon_list;

	CClientDC dc(gm->m_pMyView);
	BOOL bShade_bak = pRD->m_bShade;
	CPen SRCLinePen;

	if(pDR->m_RenderFlag==2)pRD->m_bShade = FALSE;
	if(!m_bResultDataSet)return;

	if(pDR->m_bFrameLine)
		pen.CreatePen(PS_SOLID, pDR->nElemWire*1.7, RGB(200,200,200));
	else
		pen.CreatePen(PS_SOLID, pDR->nElemWire*1.7, m_pContourEngine->m_ElemColor);

	old_pen=(CPen *) pDC->SelectObject(&pen);
	if(!gm->m_bVirtualMode && !gm->m_bAnimation)
	old_pen2 = (CPen *)dc.SelectObject(&pen);
	//XGLRenderer
	GPS_INTG_ARRY   Sort_index_list;
	GPS_INTG_ARRYP  paFreeFace = NULL; 

	m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, edata);
	BOOL is_solid = m_pDoc->m_pAttrCtrl->IsSolid(edata.eltyp);
	
	if(is_solid && !m_mapFreeFacebyElemKey.Lookup(mkey.key.elem_k,paFreeFace) && !pRD->m_bShrink)
		return;


	// 변형된 요소의 형상정보를 얻는다.
	if(m_bRealDeform && m_pDoc->m_pAttrCtrl->IsBeam(edata.eltyp)) 
	{	
		// Beam의 Real Deform
		if(!gm->m_pBeamDiagram) gm->m_pBeamDiagram = new CBeamDiagram;
		
		BOOL bSuccess;
		T_DISP_D Disp_I,Disp_J;
		GetDispData(edata.elnod[0],Disp_I);
		GetDispData(edata.elnod[1],Disp_J);
		if(gm->m_GPSMode ==GPS_COMMAND_EGMDSHP || gm->m_GPSMode ==GPS_COMMAND_BKMDSHP) 
			bSuccess = gm->m_pBeamDiagram->MakeBeamDispl(mkey.key.elem_k,Disp_I,Disp_J, 15, 2,m_dCubicFactor);
		else
			bSuccess = gm->m_pBeamDiagram->MakeBeamDispl(mkey.key.elem_k, gm->m_LoadCombi, 10, 2);
	
		if(bSuccess) GetBeamRealDeformedShape(ekey, &polygon_list, &edge_list);
	  else         GetDeformedShapeElement(ekey, &polygon_list, &edge_list);
	}
	else 
	{
		//XGLRenderer
		GetDeformedShapeElement(ekey,&polygon_list,&edge_list,NULL,NULL,&Sort_index_list);
	}

	poly_num = polygon_list.GetSize();

	T_SECT_D SectD;
	if(m_pDoc->m_pAttrCtrl->IsFrameType(edata.eltyp) && pDR->m_bFrameThick)
		 m_pDoc->m_pAttrCtrl->GetSect(edata.elpro,SectD);
	
	gm->GPS_XGL_Begin_Elem(mkey.key.elem_k,edata);
	for(i=0;i<poly_num;i++) 
	{
		// Hidden Mode가 아니거나 Hidden Option이 Outline만 그리는 것일 경우 
		if(pDR->m_bFrameLine)
			gm->GPSDrawPolygonEdge(pDC, polygon_list[i], edge_list[i],TRUE);
	  else 
		{
			//XGLRenderer Deform Shape에 Solid Freeface적용...
			if(is_solid && !gm->m_DOPT.RD.m_bShrink)
			{
				if(!IsFreeFace(paFreeFace,Sort_index_list[i]))
			   continue;
			}

			int vtx_num = polygon_list[i]->GetCount();
			if(!gm->IsPossibleDrawingPoly(ekey,&edata,&SectD,poly_num,polygon_list[i],m_bRealDeform))continue; 

			if(pDR->m_RenderFlag == 1)
			{
				pDC->SelectStockObject(NULL_PEN);
				if(!gm->m_bAnimation && !gm->m_bVirtualMode)
					dc.SelectStockObject(NULL_PEN);
			}

			if(pDR->m_RenderFlag==2 && vtx_num >2)
				gm->DrawPolygon3DFill(pDC, *(polygon_list[i]), *(edge_list[i]), gm->m_DOPT.CL.m_ClientBackColor,&dc);          
			else if(vtx_num==2)
				gm->DrawPolygon3DFill(pDC, *(polygon_list[i]), *(edge_list[i]), m_pContourEngine->m_ElemColor,&dc);
			else
				gm->DrawPolygon3DFill(pDC, *(polygon_list[i]), *(edge_list[i]), RGB(200,200,200),&dc);
		}
	}
	gm->GPS_XGL_End_Elem(FALSE);

	pDC->SelectObject(old_pen);
	if(!gm->m_bVirtualMode && !gm->m_bAnimation)dc.SelectObject(old_pen2);
	pen.DeleteObject();
	FreeMemoryPolyList(&polygon_list,&edge_list); 
	
	pRD->m_bShade = bShade_bak;
}

void CDeformEngine::DrawDeformedShape(CDC *pDC)
{
	
	BOOL bEscapePressed = FALSE;
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	if(!m_bResultDataSet)return;
	if(!m_bDeformedShapeContour) 
	{
		gm->GPSDrawOriginal(pDC);
		return;
	}

	// Pushover Hinge Status 같이 그리는 경우 필요하다
	if(gm->m_GPSMode == GPS_COMMAND_DEFORM && gm->m_LoadCaseType == D_LOADCASE_PUSHOVER  &&
		 (gm->m_bContour || gm->m_bYieldStatus))
	{
		DrawDeformedShapePsovHnge(pDC);
	}
	else
	{
		// Undeformed Shape를 같이 그리지 않을 경우
		if(!gm->m_DOPT.DR.m_bDrawInactive) 
		{
			DrawDeformedShapeSub(pDC);
		}
		// Undeformed Shape를 같이 그릴 경우
		// Undeformed Shape이 Deformed Shape을 가려서 혼란스럽거나(Hidden Mode일 경우)
		// 혹은 Deformed Shape에 가려져서 보이지 않게 되는 것을 피하기 위하여(Hidden Mode가 아닐 경우)
		// Hidden Mode가 아닐 경우에는 Undeformed Shape을 먼저 그리고
		// 그렇지 않을 경우엔 나중에 그린다.
		else 
		{
			if(gm->m_DOPT.DR.m_bFrameLine)
			{ 
				int	rf_bak=gm->m_DOPT.DR.m_RenderFlag;
				gm->m_DOPT.DR.m_RenderFlag = 2;
				gm->GPSDrawOriginal(pDC, TRUE);
				gm->m_DOPT.DR.m_RenderFlag = rf_bak;
			}
			DrawDeformedShapeSub(pDC);
			if(!gm->m_DOPT.DR.m_bFrameLine) 
			{ 
				int	rf_bak=gm->m_DOPT.DR.m_RenderFlag;
				gm->m_DOPT.DR.m_RenderFlag = 2;
				gm->GPSDrawOriginal(pDC, TRUE);
				gm->m_DOPT.DR.m_RenderFlag = rf_bak;
			}
		}
	}
}

void	CDeformEngine::DrawDeformedShapeSub(CDC *pDC)
{
	int	i, elem_num;
	CArray<int,int>	type_list;
	CArray<GRE_Atom,GRE_Atom&>atom_list;
	BOOL bEscapePressed = FALSE;
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	type_list.Add(gm->m_MinOTID + OBJECT_TYPE_DEFORMED);
				
	//XGLRenderer Deformed Shape Element에 free face적용하기 위해 추가 
	if(!gm->m_DOPT.RD.m_bShrink && !m_bIsFreeFaceDataSet)
		MakeFreeFaceData();
				
	if(gm->IsMirrorPossibleMode() && gm->m_bMirrorMode)
		gm->m_pGPSCtrl->GetZSortedList(type_list, gm->m_EKeyListVisible_Mirror, atom_list);
	else
		gm->m_pGPSCtrl->GetZSortedList(type_list, gm->m_EKeyListVisible, atom_list);
		

	//CDeformEngine::m_nPOHngeStatusSummation=0;    // Push Over Hinge Total 개수  
	//memset(CDeformEngine::m_nPOHngeStatusOccupancy,0,sizeof(CDeformEngine::m_nPOHngeStatusOccupancy)); // Push Over Hinge 각 등급별 개수  

	elem_num = atom_list.GetSize();
	if(gm->m_pGPSCtrl->IsZoomAllState()) 
	{
		for(i=0;i<elem_num;i++) 
		{
			//if(gm->m_pGPSCtrl->WatchEscKeyPress()) bEscapePressed = TRUE;
			if(gm->m_pGPSCtrl->WatchEscKeyPress()) return;

			BOOL bRedundant = FALSE;
#if defined(_TOWER)
			bRedundant = m_pDoc->m_pPostCtrl->GetTowerInfo()->IsRedundantElement(atom_list[i].m_OKey);
#endif
			if(gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey) && !bEscapePressed && !bRedundant)
				DrawDeformedElement(pDC, atom_list[i].m_OKey);
			else
				DrawInactiveDeformedElement(pDC, atom_list[i].m_OKey);
		}
	}
	else 
	{
		for(i=0;i<elem_num;i++) 
		{
			//if(gm->m_pGPSCtrl->WatchEscKeyPress()) bEscapePressed = TRUE;
			if(gm->m_pGPSCtrl->WatchEscKeyPress()) return;
			if(!gm->m_pGPSCtrl->IsObjectInClientWindow(atom_list[i].m_OType, atom_list[i].m_OKey))continue;  
			
			if(gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey) && !bEscapePressed)
				DrawDeformedElement(pDC, atom_list[i].m_OKey);
			else
				DrawInactiveDeformedElement(pDC, atom_list[i].m_OKey);
		}
	}


	// Push over Hinge를 출력하는 경우는 
	// General Link에 대해서 결과가 있는 경우 고려해 줘야 한다. 
	if(gm->m_GPSMode      == GPS_COMMAND_DEFORM && gm->m_bContour && 
		 gm->m_LoadCaseType == D_LOADCASE_PUSHOVER && m_mapHgstFactNlnk.GetCount())
	{
		//T_HGST_D HgstD;
		T_GPS_HGST_D HgstD;
		T_NLNK_D  NlnkD;
		CArray<T_NLNK_K,T_NLNK_K>arNllk;
		m_pDoc->m_pAttrCtrl->GetNlnkKeyList(arNllk);
		for (i=0; i<arNllk.GetSize();i++) 
		{
		  if(gm->m_pGPSCtrl->WatchEscKeyPress())break; 
			//if(!m_MapHingeStatusNlnk.Lookup(arNllk[i],HgstD))continue; 
			if(!m_mapHgstFactNlnk.Lookup(arNllk[i],HgstD))continue; 
			if(!m_pDoc->m_pAttrCtrl->GetNlnk(arNllk[i],NlnkD))continue; 
			if(!gm->m_pGPSCtrl->IsActiveNode(NlnkD.Node1))continue;
			if(!gm->m_pGPSCtrl->IsActiveNode(NlnkD.Node2))continue;

			DrawHingeStatus_Nlnk(pDC,arNllk[i],NlnkD.Node1,NlnkD.Node2,HgstD);
		}
		//m_nPOHngeStatusSummation += m_nPOHngeStatusSummationNlnk;
	}
}

void  CDeformEngine::DrawDeformedShapePsovHnge(CDC *pDC)
{
	DECLARE_GPSMD();
	DECLARE_DPTDR();  
	DECLARE_DPTRD();  
	DECLARE_DPTCL();
	
	int	  i, nElemN;
	CPen	ElemPen, *pOldPen;
	T_ELEM_D  ElemD;
	GPS_INTG_ARRY  TypeList;
	GPS_ATOM_ARRYR AtomList;
	T_GPS_HGST_D HgstD;
	
	BOOL bEscapePressed  = FALSE;
	BOOL bHaveHngeStatus = FALSE;
	if(gm->m_DOPT.DR.m_bDrawInactive) 
	{
		int	nRenderFlag=gm->m_DOPT.DR.m_RenderFlag;
	  gm->m_DOPT.DR.m_RenderFlag = 2;
		gm->GPSDrawOriginal(pDC, TRUE);
		gm->m_DOPT.DR.m_RenderFlag = nRenderFlag;
	}
		
	MakeSectTypeHingePos();

	ElemPen.CreatePen(PS_SOLID, pDR->nElemHddn, m_pContourEngine->m_ElemColor);
	pOldPen = (CPen *)pDC->SelectObject(&ElemPen);

	if(m_bDeformedShapeContour) TypeList.Add(gm->m_MinOTID + OBJECT_TYPE_DEFORMED);
	else		                    TypeList.Add(gm->m_MinOTID + OBJECT_TYPE_ORIGINAL);
	
	gm->m_pGPSCtrl->GetZSortedList(TypeList, gm->m_EKeyListVisible_Mirror, AtomList);
	nElemN = AtomList.GetSize();

	memset(CDeformEngine::m_nPOYieldStatusCurStep,0,sizeof(CDeformEngine::m_nPOYieldStatusCurStep));
	memset(CDeformEngine::m_nActiveElementSum,0,sizeof(CDeformEngine::m_nActiveElementSum));
	
	for (i=0; i<nElemN ;i++) 
	{
		if(gm->m_pGPSCtrl->WatchEscKeyPress())break; 
		if(gm->m_pGPSCtrl->IsZoomAllState() ||
			 gm->m_pGPSCtrl->IsObjectInClientWindow(AtomList[i].m_OType, AtomList[i].m_OKey)) 
		{
			if(!m_pDoc->m_pAttrCtrl->GetElem(AtomList[i].m_OKey,ElemD))continue; 
			// MNET:XXXX-JWKWON-20140429 : MQC 5646 & 7695
			int nScale = 1;
			CString strDir;
			if(gm->m_GPSInstruction==GPS_COMMAND_DEFORM && gm->m_bYieldStatus)
			{
				COLORREF rgb;
				int nDir = -1;
				unsigned int NotUsedThisKey = -1;
				int nRank = GetYieldStatusInfo(0, AtomList[i].m_OKey, rgb, nDir, strDir,NotUsedThisKey);
				if(nRank > 0)
				{
					nScale = 2;
					CDeformEngine::m_nPOYieldStatusCurStep[nRank] += 1;
				}

				AddActiveHingeElemSum(AtomList[i].m_OKey, gm->m_bYieldStatusBeam, gm->m_bYieldStatusWall, gm->m_bYieldStatusTruss, gm->m_bYieldStatusLink);
				if ( m_bDeformedShapeContour ) DrawDeformedElement(pDC, AtomList[i].m_OKey, TRUE);
				else                           gm->GPSDrawInactiveElement(pDC, AtomList[i].m_OKey);
			}
			else
			{
				T_ELEM_D ElemD;
				if ( !m_pDoc->m_pAttrCtrl->GetElem(AtomList[i].m_OKey, ElemD) )
				{
					ASSERT(0); continue;
				};

				bHaveHngeStatus = m_mapHgstFact.Lookup(AtomList[i].m_OKey, HgstD);
				if ( bHaveHngeStatus && HgstD.nHingeType==DUTL_HNGE_SECT )
				{
					DrawHingeStatus_Sect_Elem(pDC, AtomList[i].m_OKey, HgstD);
				}
				else
				{
					if ( m_pDoc->m_pAttrCtrl->IsWall(ElemD.eltyp) )
					{
						CArray<T_ELEM_K, T_ELEM_K> ElemKey;
						m_pDoc->m_pAttrCtrl->GetKeyListBy_WallID_ByStor(ElemKey, AtomList[i].m_OKey);
						for ( int j = 0; j<ElemKey.GetSize(); j++ )
						{
							if ( m_mapHgstFact.Lookup(ElemKey[j], HgstD) )
							{
								bHaveHngeStatus = true;
								break;
							}
						}
						if ( bHaveHngeStatus && HgstD.nHingeType==DUTL_HNGE_SECT )
						{
							DrawHingeStatus_Sect_Elem(pDC, AtomList[i].m_OKey, HgstD);
						}
						else
						{
							if ( m_bDeformedShapeContour ) DrawDeformedElement(pDC, AtomList[i].m_OKey, TRUE);
							else                           gm->GPSDrawInactiveElement(pDC, AtomList[i].m_OKey);
						}
					}
					else
					{
						if ( m_bDeformedShapeContour ) DrawDeformedElement(pDC, AtomList[i].m_OKey, TRUE);
						else                           gm->GPSDrawInactiveElement(pDC, AtomList[i].m_OKey);
					}
				}
			}

			if(!bHaveHngeStatus) continue; 
			if(!m_pDoc->m_pAttrCtrl->IsBeam(ElemD.eltyp)  && !m_pDoc->m_pAttrCtrl->IsTruss(ElemD.eltyp) &&
				 !m_pDoc->m_pAttrCtrl->IsWall(ElemD.eltyp))       continue; 

			if(gm->m_pGPSCtrl->IsActiveElem(AtomList[i].m_OKey) && !bEscapePressed &&
				 HgstD.nHingeType!=DUTL_HNGE_SECT && gm->m_bContour)
			{
				if(m_pDoc->m_pAttrCtrl->IsWall(ElemD.eltyp))
					DrawHingeStatus_Wall(pDC,AtomList[i].m_OKey);
				else
					DrawHingeStatus_Frame(pDC,AtomList[i].m_OKey);
			}
		}
	}
	
	// Nlnk
	T_NODE_D NodeD;
	C3DPoint Point1,Point2;
	CArray<BOOL,BOOL> EdgeList;
	CList<C3DPoint,C3DPoint> PolyList;

	T_NLNK_D  NlnkD;
	CArray<T_NLNK_K,T_NLNK_K>arNllk;
	m_pDoc->m_pAttrCtrl->GetNlnkKeyList(arNllk);
	
	for (i=0; i<arNllk.GetSize();i++) 
	{
	
		T_INELASTICDYN_HINGE_INFO HingeInfo;
		if(m_pDoc->m_pPostCtrl->GetPoverInfo()->GetInelasticDynHngtDataNlnk(arNllk[i],HingeInfo))
		{
			// 해당 Type이 active되어 있다면,
			if( (HingeInfo.nElemType == PSOV_INELASTIC_ELEM_TYPE_BEAM  && gm->m_bYieldStatusBeam ) ||
				(HingeInfo.nElemType == PSOV_INELASTIC_ELEM_TYPE_WALL  && gm->m_bYieldStatusWall ) ||
				(HingeInfo.nElemType == PSOV_INELASTIC_ELEM_TYPE_TRUSS && gm->m_bYieldStatusTruss) ||
				(HingeInfo.nElemType == PSOV_INELASTIC_ELEM_TYPE_NLNK  && gm->m_bYieldStatusLink ) )
			{
				int nCnt = HingeInfo.aInelasticDynHingeInfo.GetSize();
				BOOL IsCheck[4] = {0,};
				int nIdx = 0;
				// 해당 요소가 가지고 있는 힘의 방향에 대해 count를 올린다.
				// Fy/Fz와 My/Mz는 한번만 올린다.
				for (nIdx = 0; nIdx < nCnt; ++nIdx)
				{
					int nYieldDir = HingeInfo.aInelasticDynHingeInfo[nIdx].nHingeDirection;
					switch(nYieldDir)
					{
					case 0:					IsCheck[2] = TRUE; 	break; // 2: Fx
					case 1:	case 2:	IsCheck[3] = TRUE;	break; // 3: Fy, Fz
					case 4:	case 5:	IsCheck[1] = TRUE;	break; // 1: My,Mz
					}
				}
				
				for (nIdx = 0; nIdx < 4; ++nIdx)
				{
					if(IsCheck[nIdx]) CDeformEngine::m_nActiveElementSum[nIdx]++; 
				}
			}
		}
		if(gm->m_pGPSCtrl->WatchEscKeyPress())break; 
		if(!m_mapHgstFactNlnk.Lookup(arNllk[i],HgstD))continue; 
		if(!m_pDoc->m_pAttrCtrl->GetNlnk(arNllk[i],NlnkD))continue; 
		if(!gm->m_pGPSCtrl->IsActiveNode(NlnkD.Node1))continue;
		if(!gm->m_pGPSCtrl->IsActiveNode(NlnkD.Node2))continue;

		// General Link를 그린다
		EdgeList.RemoveAll();
		PolyList.RemoveAll();

		m_pDoc->m_pAttrCtrl->GetNode(NlnkD.Node1,NodeD);
		Point1.Set(NodeD.x,NodeD.y,NodeD.z);
		m_pDoc->m_pAttrCtrl->GetNode(NlnkD.Node2,NodeD);
		Point2.Set(NodeD.x,NodeD.y,NodeD.z);

		Point1 = GetDisplacedPoint(NlnkD.Node1,Point1);
		Point2 = GetDisplacedPoint(NlnkD.Node2,Point2);
		
		PolyList.AddTail(Point1);
		PolyList.AddTail(Point2);
		EdgeList.SetSize(2);
		EdgeList[0] = TRUE;
		EdgeList[1] = FALSE;
	
		COLORREF rgb = pCL->m_NlnkColor;
		int nScale = 1;
		CString strDir;
		if(gm->m_GPSInstruction==GPS_COMMAND_DEFORM && gm->m_bYieldStatus)
		{
			int nDir = -1;
			unsigned int NotUsedThisKey = -1;
			int nRank = GetYieldStatusInfo(1, arNllk[i], rgb, nDir, strDir, NotUsedThisKey);
			if(nRank > 0)
			{
				nScale = 2;
				CDeformEngine::m_nPOYieldStatusCurStep[nRank] += 1;
			}
		}

		CPen		pen, *old_pen;
		pen.CreatePen(PS_SOLID, gm->m_DOPT.DR.nElemWire*nScale, rgb);
		old_pen = (CPen *)pDC->SelectObject(&pen);

		gm->GPSDrawPolygonEdge(pDC, &PolyList, &EdgeList,FALSE);
		pDC->SelectObject(old_pen);
		pen.DeleteObject();

		// General Link Hinge Status를 그린다
		if(gm->m_bContour)
		  DrawHingeStatus_Nlnk(pDC,arNllk[i],NlnkD.Node1,NlnkD.Node2,HgstD);
	}

	// Nspr
	CArray<T_NSPR_K,T_NSPR_K>arNsprk;
	m_pDoc->m_pAttrCtrl->GetNsprKeyList(arNsprk);
	
	T_KEY NKey=NULL;
	for (i=0; i<arNsprk.GetSize();i++) 
	{
		if(gm->m_pGPSCtrl->WatchEscKeyPress())break;
		NKey = arNsprk[i].key.entity;
		if(!m_mapHgstFactNspr.Lookup(NKey,HgstD))continue; 
		if(!gm->m_pGPSCtrl->IsActiveNode(NKey))continue;    
		
		DrawHingeStatus_Nspr(pDC,arNsprk[i],HgstD);
	}
	
	pDC->SelectObject(pOldPen);
	ElemPen.DeleteObject();  
	RemoveSectTypeHingePos();
}

void CDeformEngine::DrawDispContour(CDC *pDC)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	int			i, elem_num;
	CPen		elem_pen, *old_pen;
	CArray <int, int>				type_list;
	CArray <GRE_Atom, GRE_Atom&>		atom_list;
	BOOL bEscapePressed=FALSE;

	if (!m_bResultDataSet) 
	{
		gm->GPSDrawOriginal(pDC);
		return;
	}

	//elem_pen.CreatePen(PS_SOLID, gm->m_nLineWidth, m_pContourEngine->m_ElemColor);
	//elem_pen.CreatePen(PS_SOLID, gm->m_nMdLineWidth, m_pContourEngine->m_ElemColor);
	//elem_pen.CreatePen(PS_SOLID, gm->m_LnWd.nElemHddn, m_pContourEngine->m_ElemColor);
	elem_pen.CreatePen(PS_SOLID, gm->m_DOPT.DR.nElemHddn, m_pContourEngine->m_ElemColor);
	old_pen = (CPen *) pDC->SelectObject(&elem_pen);

	if(m_bDeformedShapeContour) {
		type_list.Add(gm->m_MinOTID + OBJECT_TYPE_DEFORMED);
	}
	else {
		type_list.Add(gm->m_MinOTID + OBJECT_TYPE_ORIGINAL);
	}

	if(!gm->m_DOPT.RD.m_bShrink && !m_bIsFreeFaceDataSet)
		MakeFreeFaceData();

	gm->m_pGPSCtrl->GetZSortedList(type_list, gm->m_EKeyListVisible_Mirror, atom_list);
	elem_num = atom_list.GetSize();
	for (i=0;i<elem_num;i++) {

		//if(gm->m_pGPSCtrl->WatchEscKeyPress()) bEscapePressed = TRUE;
		if(gm->m_pGPSCtrl->WatchEscKeyPress()) return; 

		if (gm->m_pGPSCtrl->IsZoomAllState() ||
			gm->m_pGPSCtrl->IsObjectInClientWindow(atom_list[i].m_OType, atom_list[i].m_OKey)) {

			BOOL bRedundant = FALSE;
#if defined(_TOWER)
			bRedundant = m_pDoc->m_pPostCtrl->GetTowerInfo()->IsRedundantElement(atom_list[i].m_OKey);
#endif

			if(gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey) && !bEscapePressed && !bRedundant)
			{
				if(gm->m_bContour)
					DoElementContour(pDC, atom_list[i].m_OKey);
				else
					gm->GPSDrawElement(pDC, atom_list[i].m_OKey);
			}
			else
			{
				if(m_bDeformedShapeContour)
					DrawInactiveDeformedElement(pDC, atom_list[i].m_OKey);
				else
					gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
			}
		}
	}
	
	
	gm->m_pGPSCtrl->XGL_Begin_CuttingPLDiagram();
	if (m_bOnCuttingLine)
		DrawCuttingLineDiagrams(pDC);
	gm->m_pGPSCtrl->XGL_End_CuttingPLDiagram();
	

	
	// 변형된 그림에 Undeformed Shape을 같이 그릴 경우.
	// Contour를 그릴 경우는 Hidden이 default
	// 따라서 Undeformed Shape은 무조건 나중에 그린다...
	if (m_bDeformedShapeContour && gm->m_DOPT.DR.m_bDrawInactive && !bEscapePressed) {
		//int	rf_bak=gm->m_RenderFlag;
		int	rf_bak=gm->m_DOPT.DR.m_RenderFlag;
		//gm->m_RenderFlag = 2;
		gm->m_DOPT.DR.m_RenderFlag = 2;
		gm->GPSDrawOriginal(pDC, TRUE);
		//gm->m_RenderFlag = rf_bak;
		gm->m_DOPT.DR.m_RenderFlag = rf_bak;
	}

	pDC->SelectObject(old_pen);
	elem_pen.DeleteObject();

}



////////////////////////////////////////////////////////////////////////////////////////
#if defined(__OLD_OUTPUT_VALUE)
void CDeformEngine::OutputNumbers(CDC *pDC)
{
	I_GPSModel						*gm=(I_GPSModel *) m_pGPSModel;
	
	int								i, node_num;
	T_NODE_K						nkey;
	T_NODE_D						ndata;
	T_DISP_D						node_d;
	C3DPoint						node_p;
	CPoint							text_p;
	TCHAR							fmt_str[10], text_str[512];
	CFont							ft, *old_ft;
	CArray <T_NODE_K, T_NODE_K &>	nkey_list;
	CArray <C3DPoint, C3DPoint &>	node_list;
	BOOL              bIsMaxDrawn= FALSE,bIsMinDrawn=FALSE;
	if (!m_bResultDataSet) {
		return;
	}

	gm->SetNumberFontNodeOrientation(0);
	ft.CreatePointFontIndirect(&gm->m_NumberFontNode, pDC);
	old_ft = (CFont *) pDC->SelectObject(&ft);
	if (gm->m_DOPT.TX.m_bNumberOpaqueNode)
		pDC->SetBkMode(OPAQUE);
	else
		pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorNode);
	pDC->SetBkColor(gm->m_DOPT.TX.m_NumberBackColNode);
	pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);

	if (gm->m_DOPT.TX.m_bNumberSelOnly) {
	}
	else if(gm->m_bYieldStatus && gm->m_GPSInstruction==GPS_COMMAND_DEFORM)
	{
		CArray<int,int>	type_list;
	  CArray<GRE_Atom,GRE_Atom&>atom_list;
		type_list.Add(gm->m_MinOTID + OBJECT_TYPE_DEFORMED);

		if(gm->IsMirrorPossibleMode() && gm->m_bMirrorMode)
			gm->m_pGPSCtrl->GetZSortedList(type_list, gm->m_EKeyListVisible_Mirror, atom_list);
		else
		  gm->m_pGPSCtrl->GetZSortedList(type_list, gm->m_EKeyListVisible, atom_list);

		CDBDoc* pDoc = CDBDoc::GetDocPoint();
		//CStoryData StoryData(pDoc);
		//StoryData.MakeStoryData(1);
		CStoryData* pStoryData = pDoc->GetStoryData();

		int nElemSize = atom_list.GetSize();
		for(int i = 0; i < nElemSize; i++)
		{
			T_ELEM_K ElemK = atom_list[i].m_OKey;
			if(!gm->m_pGPSCtrl->IsZoomAllState() && !gm->m_pGPSCtrl->IsObjectInClientWindow(atom_list[i].m_OType, ElemK))   continue;
			if(!gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey))   continue;
		
			//int nScale, nDir;
			int nDir;
			CString strDir;
			COLORREF rgb;
			unsigned int NotUsedThisKey = -1;
			const BOOL bConsiderMemb = FALSE;
			if(GetYieldStatusInfo(0, ElemK, rgb, nDir, strDir, NotUsedThisKey, bConsiderMemb) < 1)   continue;

			T_ELEM_D ElemD;
			if(!m_pDoc->m_pAttrCtrl->GetElem(ElemK, ElemD)) continue;
			if(m_pDoc->m_pAttrCtrl->IsWall(ElemD.eltyp))
			{
				BOOL m_bDSCont = m_bDeformedShapeContour;
				CArray<T_ELEM_K,T_ELEM_K> ElemKeyList;
				m_pDoc->m_pAttrCtrl->GetKeyListBy_WallID_ByStor(ElemKeyList,ElemK, NULL, pStoryData);
				
				CPoint ElemPt;
				C3DPoint c3dPt;
				unsigned int FirstElemKey, LastElemKey;
				if(!m_pDoc->m_pAttrCtrl->GetWallIDFirstLastElem(ElemKeyList,FirstElemKey,LastElemKey,FALSE)) {ASSERT(FALSE); return;}

				gm->GetWallIDElementListCenterPos(TRUE, FirstElemKey,LastElemKey, &c3dPt);
				if(gm->m_bVirtualMode) ElemPt = gm->m_pGPSCtrl->GetWorldToWindowP2D(c3dPt);
				else                   ElemPt = gm->m_pGPSCtrl->GetWorldToMemDCP2D(c3dPt);
				pDC->TextOut(ElemPt.x, ElemPt.y, strDir); // 2d / 3
				break;
			}
			else
			{
				CArray<C3DPoint,C3DPoint> PosArray;

				T_MEMB_K MembK=0;
				if(gm->GetDrawPOHingeByMember() && pDoc->m_pAttrCtrl->GetMembAssigned(ElemK,MembK))
				{
					if(!GetMemberLabelCenterPos(MembK, PosArray))
						continue;
				}
				else
				{
					if(!gm->RE_GetLabelPosElemByKey(ElemK,&PosArray))   
						continue;    
				}

				CPoint text_p, text_p2;
				if(PosArray.GetSize() == 1)
				{
					if(gm->m_bVirtualMode)  text_p=gm->m_pGPSCtrl->GetWorldToWindowP2D(PosArray[0]);
					else 		                text_p=gm->m_pGPSCtrl->GetWorldToMemDCP2D(PosArray[0]);
					pDC->TextOut(text_p.x, text_p.y, strDir);
				}
				else if(PosArray.GetSize() == 2)
				{
					if(gm->m_bVirtualMode)  text_p=gm->m_pGPSCtrl->GetWorldToWindowP2D(PosArray[0]);
					else 		                text_p=gm->m_pGPSCtrl->GetWorldToMemDCP2D(PosArray[0]);
					if(gm->m_bVirtualMode)  text_p2=gm->m_pGPSCtrl->GetWorldToWindowP2D(PosArray[1]);
					else 		                text_p2=gm->m_pGPSCtrl->GetWorldToMemDCP2D(PosArray[1]);
					pDC->TextOut((text_p.x+text_p2.x)/2.0, (text_p.y+text_p2.y)/2.0, strDir);
				}  
			}
		}
		T_NLNK_D  NlnkD;
		CArray<T_NLNK_K,T_NLNK_K> aNlnkK;
		m_pDoc->m_pAttrCtrl->GetNlnkKeyList(aNlnkK);
		int nNlnkSize = aNlnkK.GetSize();
		for (i = 0; i < nNlnkSize; i++) 
		{
			T_NLNK_K NlnkK = aNlnkK[i];
			
			if(!m_pDoc->m_pAttrCtrl->GetNlnk(NlnkK,NlnkD))continue; 
			if(!gm->m_pGPSCtrl->IsActiveNode(NlnkD.Node1))continue;
			if(!gm->m_pGPSCtrl->IsActiveNode(NlnkD.Node2))continue;

			//int nScale, nDir;
			int nDir;
			CString strDir;
			COLORREF rgb;
			unsigned int NotUsedThisKey = -1;
			if(GetYieldStatusInfo(1, NlnkK, rgb, nDir, strDir, NotUsedThisKey) < 1)   continue;
			
			C3DPoint		node_p;
			CPoint text_p1, text_p2;
			gm->RE_GetLabelPosNodeByKey(NlnkD.Node1, &node_p);
			if (gm->m_bVirtualMode)        text_p1 = gm->m_pGPSCtrl->GetWorldToWindowP2D(node_p);
			else			                     text_p1 = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node_p);
			gm->RE_GetLabelPosNodeByKey(NlnkD.Node2, &node_p);
			if (gm->m_bVirtualMode)        text_p2 = gm->m_pGPSCtrl->GetWorldToWindowP2D(node_p);
			else			                     text_p2 = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node_p);

			pDC->TextOut((text_p1.x+text_p2.x)/2.0, (text_p1.y+text_p2.y)/2.0, strDir);
		}
		pDC->SelectObject(old_ft);
		ft.DeleteObject();
		return;
	}
	else {
		// 각 노드의 위치를 구한다.
		BOOL bGrpFltMode=gm->m_pGPSCtrl->IsGroupFilterMode();
		if(!bGrpFltMode)  node_num = m_NKeyList.GetSize();
		else              node_num = gm->m_pDispFilter->m_aGrpNKey.GetSize(); 
	
		for (i=0;i<node_num;i++) 
		{
			if(!bGrpFltMode)nkey = m_NKeyList[i];
			else            nkey = gm->m_pDispFilter->m_aGrpNKey[i];

			if(!gm->m_pGPSCtrl->IsActiveNode(nkey)) 
				continue; // Lable Hidden 처리를 위해 추가 

			m_pDoc->m_pAttrCtrl->GetNode(nkey, ndata);
			// 변형된 노드의 위치
			if ((gm->m_GPSInstruction==GPS_COMMAND_DEFORM) ||
				((gm->m_GPSInstruction==GPS_COMMAND_DCONTR)&&(m_bDeformedShapeContour))   ||
				((gm->m_GPSInstruction==GPS_COMMAND_SOIL_PRESSURE)&&(m_bDeformedShapeContour))   ||
				((gm->m_GPSInstruction==GPS_COMMAND_BKMDSHP)&&(m_bDeformedShapeContour))  ||
				((gm->m_GPSInstruction==GPS_COMMAND_EGMDSHP)&&(m_bDeformedShapeContour))  || 
				((gm->m_GPSInstruction==GPS_COMMAND_THISDISP)&&(m_bDeformedShapeContour)) ||
				((gm->m_GPSInstruction==GPS_COMMAND_NRRS)&&(m_bDeformedShapeContour)) )           // 060314  kyungha
			{
				
				GetDispData(nkey,node_d);
				switch (m_DispComponent) {
					case DISP_COMPONENT_DX:
						node_p.x = ndata.x+GetSubFrameValue(node_d.dblDisp[0]*m_DispAdjustFactor*m_DispScaleFactor, gm->m_AnimEngine.GetAnimationFactor());
						node_p.y = ndata.y;
						node_p.z = ndata.z;
						break;
					case DISP_COMPONENT_DY:
						node_p.x = ndata.x;
						node_p.y = ndata.y+GetSubFrameValue(node_d.dblDisp[1]*m_DispAdjustFactor*m_DispScaleFactor, gm->m_AnimEngine.GetAnimationFactor());
						node_p.z = ndata.z;
						break;
					case DISP_COMPONENT_DZ:
						node_p.x = ndata.x;
						node_p.y = ndata.y;
						node_p.z = ndata.z+GetSubFrameValue(node_d.dblDisp[2]*m_DispAdjustFactor*m_DispScaleFactor, gm->m_AnimEngine.GetAnimationFactor());
						break;
					case DISP_COMPONENT_DXYZ:
						node_p.x = ndata.x+GetSubFrameValue(node_d.dblDisp[0]*m_DispAdjustFactor*m_DispScaleFactor, gm->m_AnimEngine.GetAnimationFactor());
						node_p.y = ndata.y+GetSubFrameValue(node_d.dblDisp[1]*m_DispAdjustFactor*m_DispScaleFactor, gm->m_AnimEngine.GetAnimationFactor());
						node_p.z = ndata.z+GetSubFrameValue(node_d.dblDisp[2]*m_DispAdjustFactor*m_DispScaleFactor, gm->m_AnimEngine.GetAnimationFactor());
						break;
					case DISP_COMPONENT_PX:
						node_p.x = ndata.x+GetSubFrameValue(node_d.dblDisp[0]*m_DispAdjustFactor*m_DispScaleFactor, gm->m_AnimEngine.GetAnimationFactor());
						node_p.y = ndata.y;
						node_p.z = ndata.z;
						break;
					case DISP_COMPONENT_PY:
						node_p.x = ndata.x;
						node_p.y = ndata.y+GetSubFrameValue(node_d.dblDisp[1]*m_DispAdjustFactor*m_DispScaleFactor, gm->m_AnimEngine.GetAnimationFactor());
						node_p.z = ndata.z;
						break;
					case DISP_COMPONENT_PZ:
						node_p.x = ndata.x;
						node_p.y = ndata.y;
						node_p.z = ndata.z+GetSubFrameValue(node_d.dblDisp[2]*m_DispAdjustFactor*m_DispScaleFactor, gm->m_AnimEngine.GetAnimationFactor());
						break;
					case DISP_COMPONENT_DXY:
						node_p.x = ndata.x+GetSubFrameValue(node_d.dblDisp[0]*m_DispAdjustFactor*m_DispScaleFactor, gm->m_AnimEngine.GetAnimationFactor());
						node_p.y = ndata.y+GetSubFrameValue(node_d.dblDisp[1]*m_DispAdjustFactor*m_DispScaleFactor, gm->m_AnimEngine.GetAnimationFactor());
						node_p.z = ndata.z;
						break;
					case DISP_COMPONENT_DYZ:
						node_p.x = ndata.x;
						node_p.y = ndata.y+GetSubFrameValue(node_d.dblDisp[1]*m_DispAdjustFactor*m_DispScaleFactor, gm->m_AnimEngine.GetAnimationFactor());
						node_p.z = ndata.z+GetSubFrameValue(node_d.dblDisp[2]*m_DispAdjustFactor*m_DispScaleFactor, gm->m_AnimEngine.GetAnimationFactor());
						break;
					case DISP_COMPONENT_DXZ:
						node_p.x = ndata.x+GetSubFrameValue(node_d.dblDisp[0]*m_DispAdjustFactor*m_DispScaleFactor, gm->m_AnimEngine.GetAnimationFactor());
						node_p.y = ndata.y;
						node_p.z = ndata.z+GetSubFrameValue(node_d.dblDisp[2]*m_DispAdjustFactor*m_DispScaleFactor, gm->m_AnimEngine.GetAnimationFactor());
						break;
					default:
						node_p.Set(ndata.x, ndata.y, ndata.z);
						break;
				}
			}
			// 변형되지 않은 노드의 위치
			else {
				node_p.x = ndata.x;
				node_p.y = ndata.y;
				node_p.z = ndata.z;
			}
			nkey_list.Add(nkey);
			node_list.Add(node_p);
		}
	}

	// 지수형태로 출력인가?
	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T(" %s%de"), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T(" %s%df"), _T("%."), gm->m_NumberDecimalPoint);

	node_num = node_list.GetSize();
	T_DISP_D	dd;
	double dDispValue;
	for (i=0;i<node_num;i++) {
		if(!m_mapDispData.Lookup(nkey_list[i],dd)) // Relative 값이 오지 않도록 직접 읽는다.
			continue;

		if (m_DispComponent == DISP_COMPONENT_PX || m_DispComponent == DISP_COMPONENT_PY || m_DispComponent == DISP_COMPONENT_PZ)    
		{ 
			BOOL bExist = GetDispDataWithReac(nkey_list[i], dd); 
			//if (!bExist)  { ASSERT(0);  continue; }
			if (!bExist)  { dd.Initialize(); }
		}
		
		dDispValue = CalcDispValue(dd);

		// MNET:XXXX-HSSHIM-20130216. Soil Pressure Contour 단위 면적당 반력 계산 
		if (m_DispComponent == DISP_COMPONENT_PX || m_DispComponent == DISP_COMPONENT_PY || m_DispComponent == DISP_COMPONENT_PZ)  
		{ 
			double dEffArea = 0.0;
			if (m_mNode2EffAreaForSoilPressure.Lookup(nkey_list[i], dEffArea))  
			{
				if (fabs(dEffArea) >= 1.0e-9)     dDispValue = dDispValue/dEffArea;
				else                              dDispValue = 0.0; 
			}
		}
	
		if(gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
		{
			double dLimit = (m_dMaxValue-m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;
			
			switch(gm->m_DOPT.TX.m_nOutputMinMaxType)
			{
			case 0: // Min & Max
				if((m_dMaxValue-dDispValue) <= dLimit)
					 DrawMinMaxOutputValue(pDC,node_list[i],fmt_str,0,dDispValue);
				else if((dDispValue-m_dMinValue) <= dLimit)
					 DrawMinMaxOutputValue(pDC,node_list[i],fmt_str,1,dDispValue);
				break;
			case 1: // Abs Max
				if(fabs(m_dMaxValue) >= fabs(m_dMinValue))
				{
					if( fabs(m_dMaxValue)-fabs(dDispValue) <= dLimit)
					 DrawMinMaxOutputValue(pDC,node_list[i],fmt_str,2,dDispValue);
				}
				else
				{
					 if( fabs(m_dMinValue)-fabs(dDispValue) <= dLimit)
					 DrawMinMaxOutputValue(pDC,node_list[i],fmt_str,2,dDispValue);
				}
				break;
			case 2: // Max
				if((m_dMaxValue-dDispValue) <= dLimit)
					 DrawMinMaxOutputValue(pDC,node_list[i],fmt_str,0,dDispValue);
				break;
			case 3: // Min
				if((dDispValue-m_dMinValue) <= dLimit)
					 DrawMinMaxOutputValue(pDC,node_list[i],fmt_str,1,dDispValue);
				break;
			}

				
			continue;  
		}

		if (gm->m_bVirtualMode)
			text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(node_list[i]);
		else
			text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node_list[i]);
	  if(text_p.x<0 || text_p.y<0) continue;

		_stprintf(text_str, fmt_str,dDispValue );
		pDC->TextOut(text_p.x, text_p.y, text_str);
	}

	pDC->SelectObject(old_ft);
	ft.DeleteObject();

	nkey_list.RemoveAll();
	node_list.RemoveAll();
}
#else 
void CDeformEngine::OutputNumbers(CDC *pDC)
{
	I_GPSModel						*gm = (I_GPSModel *)m_pGPSModel;

	int								i, node_num;
	T_NODE_K						nkey;
	T_NODE_D						ndata;
	T_DISP_D						node_d;
	C3DPoint						node_p;
	CPoint							text_p;
	TCHAR							fmt_str[10], text_str[512];
	CArray <T_NODE_K, T_NODE_K &>	nkey_list;
	CArray <C3DPoint, C3DPoint &>	node_list;
	BOOL              bIsMaxDrawn = FALSE, bIsMinDrawn = FALSE;
	if (!m_bResultDataSet) {
		return;
	}

	GPostTextOut TextOutModel;
	TextOutModel.StartDeformVal();
	TextOutModel.SetDC(pDC);
	TextOutModel.SettingDeform(gm);

	if (gm->m_DOPT.TX.m_bNumberSelOnly) {
	}
	else if (gm->m_bYieldStatus && gm->m_GPSInstruction == GPS_COMMAND_DEFORM)
	{
		CArray<int, int>	type_list;
		CArray<GRE_Atom, GRE_Atom&>atom_list;
		type_list.Add(gm->m_MinOTID + OBJECT_TYPE_DEFORMED);

		if (gm->IsMirrorPossibleMode() && gm->m_bMirrorMode)
			gm->m_pGPSCtrl->GetZSortedList(type_list, gm->m_EKeyListVisible_Mirror, atom_list);
		else
			gm->m_pGPSCtrl->GetZSortedList(type_list, gm->m_EKeyListVisible, atom_list);

		CDBDoc* pDoc = CDBDoc::GetDocPoint();
		//CStoryData StoryData(pDoc);
		//StoryData.MakeStoryData(1);
		CStoryData* pStoryData = pDoc->GetStoryData();

		int nElemSize = atom_list.GetSize();
		for (int i = 0; i < nElemSize; i++)
		{
			T_ELEM_K ElemK = atom_list[i].m_OKey;
			if (!gm->m_pGPSCtrl->IsZoomAllState() && !gm->m_pGPSCtrl->IsObjectInClientWindow(atom_list[i].m_OType, ElemK))   continue;
			if (!gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey))   continue;

			//int nScale, nDir;
			int nDir;
			CString strDir;
			COLORREF rgb;
			unsigned int NotUsedThisKey = -1;
			const BOOL bConsiderMemb = FALSE;
			if (GetYieldStatusInfo(0, ElemK, rgb, nDir, strDir, NotUsedThisKey, bConsiderMemb) < 1)   continue;

			T_ELEM_D ElemD;
			if (!m_pDoc->m_pAttrCtrl->GetElem(ElemK, ElemD)) continue;
			if (m_pDoc->m_pAttrCtrl->IsWall(ElemD.eltyp))
			{
				BOOL m_bDSCont = m_bDeformedShapeContour;
				CArray<T_ELEM_K, T_ELEM_K> ElemKeyList;
				m_pDoc->m_pAttrCtrl->GetKeyListBy_WallID_ByStor(ElemKeyList, ElemK, NULL, pStoryData);

				CPoint ElemPt;
				C3DPoint c3dPt;
				unsigned int FirstElemKey, LastElemKey;
				if (!m_pDoc->m_pAttrCtrl->GetWallIDFirstLastElem(ElemKeyList, FirstElemKey, LastElemKey, FALSE)) { ASSERT(FALSE); return; }

				gm->GetWallIDElementListCenterPos(TRUE, FirstElemKey, LastElemKey, &c3dPt);
				if (gm->m_bVirtualMode) ElemPt = gm->m_pGPSCtrl->GetWorldToWindowP2D(c3dPt);
				else                   ElemPt = gm->m_pGPSCtrl->GetWorldToMemDCP2D(c3dPt);
				TextOutModel.TextOutDeform(ElemPt.x, ElemPt.y, strDir);
				break;
			}
			else
			{
				CArray<C3DPoint, C3DPoint> PosArray;

				T_MEMB_K MembK = 0;
				if (gm->GetDrawPOHingeByMember() && pDoc->m_pAttrCtrl->GetMembAssigned(ElemK, MembK))
				{
					if (!GetMemberLabelCenterPos(MembK, PosArray))
						continue;
				}
				else
				{
					if (!gm->RE_GetLabelPosElemByKey(ElemK, &PosArray))
						continue;
				}

				CPoint text_p, text_p2;
				if (PosArray.GetSize() == 1)
				{
					if (gm->m_bVirtualMode)  text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(PosArray[0]);
					else 		                text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(PosArray[0]);
					TextOutModel.TextOutDeform(text_p.x, text_p.y, strDir);
				}
				else if (PosArray.GetSize() == 2)
				{
					if (gm->m_bVirtualMode)  text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(PosArray[0]);
					else 		                text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(PosArray[0]);
					if (gm->m_bVirtualMode)  text_p2 = gm->m_pGPSCtrl->GetWorldToWindowP2D(PosArray[1]);
					else 		                text_p2 = gm->m_pGPSCtrl->GetWorldToMemDCP2D(PosArray[1]);
					TextOutModel.TextOutDeform((text_p.x + text_p2.x) / 2.0, (text_p.y + text_p2.y) / 2.0, strDir);
				}
			}
		}
		T_NLNK_D  NlnkD;
		CArray<T_NLNK_K, T_NLNK_K> aNlnkK;
		m_pDoc->m_pAttrCtrl->GetNlnkKeyList(aNlnkK);
		int nNlnkSize = aNlnkK.GetSize();
		for (i = 0; i < nNlnkSize; i++)
		{
			T_NLNK_K NlnkK = aNlnkK[i];

			if (!m_pDoc->m_pAttrCtrl->GetNlnk(NlnkK, NlnkD))continue;
			if (!gm->m_pGPSCtrl->IsActiveNode(NlnkD.Node1))continue;
			if (!gm->m_pGPSCtrl->IsActiveNode(NlnkD.Node2))continue;

			//int nScale, nDir;
			int nDir;
			CString strDir;
			COLORREF rgb;
			unsigned int NotUsedThisKey = -1;
			if (GetYieldStatusInfo(1, NlnkK, rgb, nDir, strDir, NotUsedThisKey) < 1)   continue;

			C3DPoint		node_p;
			CPoint text_p1, text_p2;
			gm->RE_GetLabelPosNodeByKey(NlnkD.Node1, &node_p);
			if (gm->m_bVirtualMode)        text_p1 = gm->m_pGPSCtrl->GetWorldToWindowP2D(node_p);
			else			                     text_p1 = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node_p);
			gm->RE_GetLabelPosNodeByKey(NlnkD.Node2, &node_p);
			if (gm->m_bVirtualMode)        text_p2 = gm->m_pGPSCtrl->GetWorldToWindowP2D(node_p);
			else			                     text_p2 = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node_p);

			TextOutModel.TextOutDeform((text_p1.x + text_p2.x) / 2.0, (text_p1.y + text_p2.y) / 2.0, strDir);
		}
		TextOutModel.EndDeformVal();
		return;
	}
	else {
		// 각 노드의 위치를 구한다.
		BOOL bGrpFltMode = gm->m_pGPSCtrl->IsGroupFilterMode();
		if (!bGrpFltMode)  node_num = m_NKeyList.GetSize();
		else              node_num = gm->m_pDispFilter->m_aGrpNKey.GetSize();

		for (i = 0; i < node_num; i++)
		{
			if (!bGrpFltMode)nkey = m_NKeyList[i];
			else            nkey = gm->m_pDispFilter->m_aGrpNKey[i];

			if (!gm->m_pGPSCtrl->IsActiveNode(nkey))
				continue; // Lable Hidden 처리를 위해 추가 

			m_pDoc->m_pAttrCtrl->GetNode(nkey, ndata);
			// 변형된 노드의 위치
			if ((gm->m_GPSInstruction == GPS_COMMAND_DEFORM) ||
				((gm->m_GPSInstruction == GPS_COMMAND_DCONTR) && (m_bDeformedShapeContour)) ||
				((gm->m_GPSInstruction == GPS_COMMAND_SOIL_PRESSURE) && (m_bDeformedShapeContour)) ||
				((gm->m_GPSInstruction == GPS_COMMAND_BKMDSHP) && (m_bDeformedShapeContour)) ||
				((gm->m_GPSInstruction == GPS_COMMAND_EGMDSHP) && (m_bDeformedShapeContour)) ||
				((gm->m_GPSInstruction == GPS_COMMAND_THISDISP) && (m_bDeformedShapeContour)) ||
				((gm->m_GPSInstruction == GPS_COMMAND_NRRS) && (m_bDeformedShapeContour)))           // 060314  kyungha
			{

				GetDispData(nkey, node_d);
				switch (m_DispComponent) {
				case DISP_COMPONENT_DX:
					node_p.x = ndata.x + GetSubFrameValue(node_d.dblDisp[0] * m_DispAdjustFactor*m_DispScaleFactor, gm->m_AnimEngine.GetAnimationFactor());
					node_p.y = ndata.y;
					node_p.z = ndata.z;
					break;
				case DISP_COMPONENT_DY:
					node_p.x = ndata.x;
					node_p.y = ndata.y + GetSubFrameValue(node_d.dblDisp[1] * m_DispAdjustFactor*m_DispScaleFactor, gm->m_AnimEngine.GetAnimationFactor());
					node_p.z = ndata.z;
					break;
				case DISP_COMPONENT_DZ:
					node_p.x = ndata.x;
					node_p.y = ndata.y;
					node_p.z = ndata.z + GetSubFrameValue(node_d.dblDisp[2] * m_DispAdjustFactor*m_DispScaleFactor, gm->m_AnimEngine.GetAnimationFactor());
					break;
				case DISP_COMPONENT_DXYZ:
					node_p.x = ndata.x + GetSubFrameValue(node_d.dblDisp[0] * m_DispAdjustFactor*m_DispScaleFactor, gm->m_AnimEngine.GetAnimationFactor());
					node_p.y = ndata.y + GetSubFrameValue(node_d.dblDisp[1] * m_DispAdjustFactor*m_DispScaleFactor, gm->m_AnimEngine.GetAnimationFactor());
					node_p.z = ndata.z + GetSubFrameValue(node_d.dblDisp[2] * m_DispAdjustFactor*m_DispScaleFactor, gm->m_AnimEngine.GetAnimationFactor());
					break;
				case DISP_COMPONENT_PX:
					node_p.x = ndata.x + GetSubFrameValue(node_d.dblDisp[0] * m_DispAdjustFactor*m_DispScaleFactor, gm->m_AnimEngine.GetAnimationFactor());
					node_p.y = ndata.y;
					node_p.z = ndata.z;
					break;
				case DISP_COMPONENT_PY:
					node_p.x = ndata.x;
					node_p.y = ndata.y + GetSubFrameValue(node_d.dblDisp[1] * m_DispAdjustFactor*m_DispScaleFactor, gm->m_AnimEngine.GetAnimationFactor());
					node_p.z = ndata.z;
					break;
				case DISP_COMPONENT_PZ:
					node_p.x = ndata.x;
					node_p.y = ndata.y;
					node_p.z = ndata.z + GetSubFrameValue(node_d.dblDisp[2] * m_DispAdjustFactor*m_DispScaleFactor, gm->m_AnimEngine.GetAnimationFactor());
					break;
				case DISP_COMPONENT_DXY:
					node_p.x = ndata.x + GetSubFrameValue(node_d.dblDisp[0] * m_DispAdjustFactor*m_DispScaleFactor, gm->m_AnimEngine.GetAnimationFactor());
					node_p.y = ndata.y + GetSubFrameValue(node_d.dblDisp[1] * m_DispAdjustFactor*m_DispScaleFactor, gm->m_AnimEngine.GetAnimationFactor());
					node_p.z = ndata.z;
					break;
				case DISP_COMPONENT_DYZ:
					node_p.x = ndata.x;
					node_p.y = ndata.y + GetSubFrameValue(node_d.dblDisp[1] * m_DispAdjustFactor*m_DispScaleFactor, gm->m_AnimEngine.GetAnimationFactor());
					node_p.z = ndata.z + GetSubFrameValue(node_d.dblDisp[2] * m_DispAdjustFactor*m_DispScaleFactor, gm->m_AnimEngine.GetAnimationFactor());
					break;
				case DISP_COMPONENT_DXZ:
					node_p.x = ndata.x + GetSubFrameValue(node_d.dblDisp[0] * m_DispAdjustFactor*m_DispScaleFactor, gm->m_AnimEngine.GetAnimationFactor());
					node_p.y = ndata.y;
					node_p.z = ndata.z + GetSubFrameValue(node_d.dblDisp[2] * m_DispAdjustFactor*m_DispScaleFactor, gm->m_AnimEngine.GetAnimationFactor());
					break;
				default:
					node_p.Set(ndata.x, ndata.y, ndata.z);
					break;
				}
			}
			// 변형되지 않은 노드의 위치
			else {
				node_p.x = ndata.x;
				node_p.y = ndata.y;
				node_p.z = ndata.z;
			}
			nkey_list.Add(nkey);
			node_list.Add(node_p);
		}
	}

	// 지수형태로 출력인가?
	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T(" %s%de"), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T(" %s%df"), _T("%."), gm->m_NumberDecimalPoint);

	node_num = node_list.GetSize();
	T_DISP_D	dd;
	double dDispValue;
	for (i = 0; i < node_num; i++) {
		if (!m_mapDispData.Lookup(nkey_list[i], dd)) // Relative 값이 오지 않도록 직접 읽는다.
			continue;

		if (m_DispComponent == DISP_COMPONENT_PX || m_DispComponent == DISP_COMPONENT_PY || m_DispComponent == DISP_COMPONENT_PZ)
		{
			BOOL bExist = GetDispDataWithReac(nkey_list[i], dd);
			//if (!bExist)  { ASSERT(0);  continue; }
			if (!bExist) { dd.Initialize(); }
		}

		dDispValue = CalcDispValue(dd);

		// MNET:XXXX-HSSHIM-20130216. Soil Pressure Contour 단위 면적당 반력 계산 
		if (m_DispComponent == DISP_COMPONENT_PX || m_DispComponent == DISP_COMPONENT_PY || m_DispComponent == DISP_COMPONENT_PZ)
		{
			double dEffArea = 0.0;
			if (m_mNode2EffAreaForSoilPressure.Lookup(nkey_list[i], dEffArea))
			{
				if (fabs(dEffArea) >= 1.0e-9)     dDispValue = dDispValue / dEffArea;
				else                              dDispValue = 0.0;
			}
		}

		if (gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
		{
			double dLimit = (m_dMaxValue - m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;

			switch (gm->m_DOPT.TX.m_nOutputMinMaxType)
			{
			case 0: // Min & Max
				if ((m_dMaxValue - dDispValue) <= dLimit)
					DrawMinMaxOutputValue(pDC, node_list[i], fmt_str, 0, dDispValue);
				else if ((dDispValue - m_dMinValue) <= dLimit)
					DrawMinMaxOutputValue(pDC, node_list[i], fmt_str, 1, dDispValue);
				break;
			case 1: // Abs Max
				if (fabs(m_dMaxValue) >= fabs(m_dMinValue))
				{
					if (fabs(m_dMaxValue) - fabs(dDispValue) <= dLimit)
						DrawMinMaxOutputValue(pDC, node_list[i], fmt_str, 2, dDispValue);
				}
				else
				{
					if (fabs(m_dMinValue) - fabs(dDispValue) <= dLimit)
						DrawMinMaxOutputValue(pDC, node_list[i], fmt_str, 2, dDispValue);
				}
				break;
			case 2: // Max
				if ((m_dMaxValue - dDispValue) <= dLimit)
					DrawMinMaxOutputValue(pDC, node_list[i], fmt_str, 0, dDispValue);
				break;
			case 3: // Min
				if ((dDispValue - m_dMinValue) <= dLimit)
					DrawMinMaxOutputValue(pDC, node_list[i], fmt_str, 1, dDispValue);
				break;
			}


			continue;
		}

		if (gm->m_bVirtualMode)
			text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(node_list[i]);
		else
			text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node_list[i]);
		if (text_p.x < 0 || text_p.y < 0) continue;

		_stprintf(text_str, fmt_str, dDispValue);
		TextOutModel.TextOutDeform(text_p.x, text_p.y, text_str);
	}

	TextOutModel.EndDeformVal();
	nkey_list.RemoveAll();
	node_list.RemoveAll();
}
#endif

void CDeformEngine::DrawPickedNodes(CDC *pDC)
{
	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;
	
	int				i, node_num=m_PickedNodeList.GetSize();
	C3DPoint		node_p;
	CPoint			text_p;
	CString			text_str;
	CFont			ft, *old_ft;
	COLORREF		node_col, focus_col;

	if (node_num <= 0)
		return;

	if (gm->m_bVirtualMode) {
		node_col = RGB(0, 0, 0);
		focus_col = RGB(0, 0, 0);
	}
	else {
		node_col = gm->m_DOPT.TX.m_NumberTextColorNode;
		focus_col = gm->m_DOPT.TX.m_NumberTextColorNode;
	}

	gm->SetNumberFontNodeOrientation(0);
	ft.CreatePointFontIndirect(&gm->m_NumberFontNode, pDC);
	old_ft = (CFont *) pDC->SelectObject(&ft);
	if (gm->m_DOPT.TX.m_bNumberOpaqueNode) {
		pDC->SetBkMode(OPAQUE);
	}
	else {
		pDC->SetBkMode(TRANSPARENT);
	}
	pDC->SetTextColor(node_col);
	pDC->SetBkColor(gm->m_DOPT.TX.m_NumberBackColNode);
	pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);

	for (i=0;i<node_num-1;i++) {
		gm->RE_GetLabelPosNodeByKey(m_PickedNodeList[i], &node_p);
		if (gm->m_bVirtualMode)
			text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(node_p);
		else
			text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node_p);
		text_str.Format(_T("%d"), m_PickedNodeList[i]);
		pDC->TextOut(text_p.x, text_p.y, text_str);

		if (gm->m_bVirtualMode)
			gm->m_pGPSCtrl->DrawNodeInClientWindow(pDC, node_p);
		else
			gm->m_pGPSCtrl->DrawNode(pDC, node_p);
	}

	pDC->SetTextColor(focus_col);
	gm->RE_GetLabelPosNodeByKey(m_PickedNodeList[i], &node_p);
	if (gm->m_bVirtualMode)
		text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(node_p);
	else
		text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node_p);
	text_str.Format(_T("%d"), m_PickedNodeList[i]);
	pDC->TextOut(text_p.x, text_p.y, text_str);
	if (gm->m_bVirtualMode)
		gm->m_pGPSCtrl->DrawNodeInClientWindow(pDC, node_p);
	else
		gm->m_pGPSCtrl->DrawNode(pDC, node_p);

	pDC->SelectObject(old_ft);
	ft.DeleteObject();
}

void CDeformEngine::DrawPickedNodesOnClientWnd(CDC *pDC)
{
	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;
	
	int				i, node_num=m_PickedNodeList.GetSize();
	C3DPoint		node_p;
	CPoint			text_p;
	CString			text_str;
	CFont			ft, *old_ft;
	COLORREF		node_col, focus_col;

	if (node_num <= 0)
		return;

	node_col = gm->m_DOPT.TX.m_NumberTextColorNode;
	focus_col = gm->m_DOPT.TX.m_NumberTextColorNode;
	
	gm->m_NumberFontNode.lfEscapement = gm->m_NumberFontNode.lfOrientation = 0;
	ft.CreatePointFontIndirect(&gm->m_NumberFontNode, pDC);
	old_ft = (CFont *) pDC->SelectObject(&ft);
	if (gm->m_DOPT.TX.m_bNumberOpaqueNode) {
		pDC->SetBkMode(OPAQUE);
	}
	else {
		pDC->SetBkMode(TRANSPARENT);
	}
	pDC->SetTextColor(node_col);
	pDC->SetBkColor(gm->m_DOPT.TX.m_NumberBackColNode);
	pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);

	for (i=0;i<node_num-1;i++) {
		gm->RE_GetLabelPosNodeByKey(m_PickedNodeList[i], &node_p);
		text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(node_p);
		text_str.Format(_T("%d"), m_PickedNodeList[i]);
		pDC->TextOut(text_p.x, text_p.y, text_str);

		gm->m_pGPSCtrl->DrawNodeInClientWindow(pDC, node_p);
		
	}

	pDC->SetTextColor(focus_col);
	gm->RE_GetLabelPosNodeByKey(m_PickedNodeList[i], &node_p);
	text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(node_p);
	text_str.Format(_T("%d"), m_PickedNodeList[i]);
	pDC->TextOut(text_p.x, text_p.y, text_str);
	gm->m_pGPSCtrl->DrawNodeInClientWindow(pDC, node_p);
	
	pDC->SelectObject(old_ft);
	ft.DeleteObject();
}




void CDeformEngine::DrawContourList(CArray <int, int> &vnum_list, CArray <VtxInfo, VtxInfo> &vtx_list, CArray <GGPS_Poly, GGPS_Poly &> *subpoly_list)
{
	int			i, j, k=0, poly_num=vnum_list.GetSize();
	GGPS_Poly	sub_poly;

	if (m_pContourEngine == NULL)
		return;

	k = 0;
	for(i=0;i<poly_num;i++) 
	{
		sub_poly.m_pVList     = new CList <C3DPoint, C3DPoint>;
		sub_poly.m_pEFlagList = new CList <BOOL, BOOL>;
		sub_poly.m_FillColor = m_pContourEngine->GetValueColor(vtx_list[k].val);
		for(j=0;j<vnum_list[i];j++) 
		{
			sub_poly.m_pVList->AddTail(vtx_list[k+j].vtx);
			sub_poly.m_pEFlagList->AddTail(vtx_list[k+j].ef);
		}
		subpoly_list->Add(sub_poly);
		k += vnum_list[i];
	}
	sub_poly.m_pEFlagList = NULL;
	sub_poly.m_pVList = NULL;
}

void CDeformEngine::DrawThexHingeElem(CDC *pDC,T_ELEM_K ElemK,T_EVTB_D *pEvtbD,T_EVTR_D *pEvtrD)
{
	DECLARE_GPSMD();
	DECLARE_DPTDR();

	int nIVal=0,nJVal=0;
	if(!pEvtbD && !pEvtrD) return;

	int nDOF;

	if(m_nTranOrRotDOF) nDOF = 0;
	else                nDOF = 3;

	// Beam
	if(pEvtbD)
	{
		switch(m_DispComponent) 
		{
		case DISP_COMPONENT_DX: nIVal = pEvtbD->nEvent[0][0+nDOF]; nJVal = pEvtbD->nEvent[1][0+nDOF];   break;
	  case DISP_COMPONENT_DY: nIVal = pEvtbD->nEvent[0][1+nDOF]; nJVal = pEvtbD->nEvent[1][1+nDOF];   break;
	  case DISP_COMPONENT_DZ: nIVal = pEvtbD->nEvent[0][2+nDOF]; nJVal = pEvtbD->nEvent[1][2+nDOF];   break;
		default: nIVal = 0; nJVal = 0; break;
		}
	}

	// Truss
	if(pEvtrD)
	{
		switch(m_DispComponent) 
		{
		case DISP_COMPONENT_DX: nIVal = pEvtrD->nEvent[0]; nJVal = pEvtrD->nEvent[1];   break;
		default: nIVal = 0; nJVal = 0; break;
		}
	}

	BOOL			fl_bak;
	T_ELEM_D	edata;
	C3DPoint	node3D_i, node3D_j,node3D_i2,node3D_j2,node3D_cnt;
	
	POSITION pos;
	CArray<GPS_3DPT_LISTP,GPS_3DPT_LISTP>	polygon_list;
	CArray<GPS_BOOL_ARRYP,GPS_BOOL_ARRYP> edge_list;

	fl_bak = pDR->m_bFrameLine;
	pDR->m_bFrameLine = TRUE;
	
	m_pDoc->m_pAttrCtrl->GetElem(ElemK, edata);
	GetDeformedShapeElement(ElemK, &polygon_list, &edge_list);
	
	pos = polygon_list[0]->GetHeadPosition();
	node3D_i = polygon_list[0]->GetNext(pos);
	node3D_j = polygon_list[0]->GetNext(pos);

	DrawThexHingeStatus(pDC,nIVal,nJVal,node3D_i,node3D_j);

	FreeMemoryPolyList(&polygon_list,&edge_list);
	pDR->m_bFrameLine = fl_bak;

}

void CDeformEngine::DrawThexHingeStatus(CDC *pDC,int nIVal,int nJVal,C3DPoint &IPos,C3DPoint &JPos)
{
	DECLARE_GPSMD();
	DECLARE_DPTDR();

	C3DPoint node3D_i2,node3D_j2;

	CUtilFuncs::GetInnerLinePoint(0.1,0.9,IPos,JPos,node3D_i2);
	CUtilFuncs::GetInnerLinePoint(0.9,0.1,IPos,JPos,node3D_j2);
	double dUnitLength = pDC->GetDeviceCaps(LOGPIXELSX)*0.12;

	int nSaveDC = pDC->SaveDC();
	if(nIVal>0)
	{
		CBrush RankBrush,*pOldBrush;
		RankBrush.CreateSolidBrush(m_pContourEngine->GetRankColor(nIVal));
		pOldBrush = pDC->SelectObject(&RankBrush);
		DrawPoint(pDC,node3D_i2,dUnitLength);
		pDC->SelectObject(pOldBrush);
	}
	if(nJVal>0)
	{
		CBrush RankBrush,*pOldBrush;
		RankBrush.CreateSolidBrush(m_pContourEngine->GetRankColor(nJVal));
		pOldBrush = pDC->SelectObject(&RankBrush);
		DrawPoint(pDC,node3D_j2,dUnitLength);
		pDC->SelectObject(pOldBrush);
	}
	pDC->RestoreDC(nSaveDC);
}

void CDeformEngine::DrawHingeStatus_Frame(CDC *pDC,T_ELEM_K ekey)
{
	DECLARE_GPSMD();
	DECLARE_DPTDR();
	
	BOOL			fl_bak;
	T_ELEM_D	edata;
	C3DPoint	node3D_i, node3D_j,node3D_i2,node3D_j2,node3D_cnt;
	
	POSITION pos;
	CArray<GPS_3DPT_LISTP,GPS_3DPT_LISTP>	polygon_list,polygon_list_J;
	CArray<GPS_BOOL_ARRYP,GPS_BOOL_ARRYP> edge_list,edge_list_J;

	fl_bak = pDR->m_bFrameLine;
	pDR->m_bFrameLine = TRUE;
	
	m_pDoc->m_pAttrCtrl->GetElem(ekey, edata);
	
	T_MEMB_K MembK=0; 
	if(gm->GetDrawPOHingeByMember() && m_pDoc->m_pAttrCtrl->GetMembAssigned(ekey, MembK))
	{
		// [PMS 5388] 내진성능평가 - 멤버별 힌지 결과출력
		T_MEMB_D MembD;
		m_pDoc->m_pAttrCtrl->GetMemb(MembK, MembD);

		T_ELEM_K ElemK_I = MembD.aElemList[0];
		T_ELEM_K ElemK_J = MembD.aElemList[MembD.aElemList.GetSize()-1];
		GetDeformedShapeElement(ElemK_I, &polygon_list, &edge_list);
		GetDeformedShapeElement(ElemK_J, &polygon_list_J, &edge_list_J);

		polygon_list[0]->RemoveTail();
		polygon_list[0]->AddTail(polygon_list_J[0]->GetTail());
	}
	else
	{
		GetDeformedShapeElement(ekey, &polygon_list, &edge_list);
	}
	
	pos = polygon_list[0]->GetHeadPosition();
	node3D_i = polygon_list[0]->GetNext(pos);
	node3D_j = polygon_list[0]->GetNext(pos);
	
	T_GPS_HGST_D hgst_d; 
	if(!m_mapHgstFact.Lookup(ekey,hgst_d)) return;
	DrawHingeStatus(pDC,node3D_i,node3D_j,hgst_d);
	
	FreeMemoryPolyList(&polygon_list,&edge_list);
	FreeMemoryPolyList(&polygon_list_J,&edge_list_J);
	pDR->m_bFrameLine = fl_bak;
}

void CDeformEngine::DrawHingeStatus_Wall(CDC *pDC,T_ELEM_K ekey)
{
	DECLARE_GPSMD();
	DECLARE_DPTDR();
	
	CArray<T_ELEM_K,T_ELEM_K> ElemKey;
	m_pDoc->m_pAttrCtrl->GetKeyListBy_WallID_ByStor(ElemKey,ekey);
	C3DPoint bc_3D,tc_3D;

	T_GPS_HGST_D hgst_d; 
	if(!m_mapHgstFact.Lookup(ekey,hgst_d)) return;

	C3DPoint DrawPtBottomFirstElemLeft;
	C3DPoint DrawPtTopFirstElemLeft;
	C3DPoint DrawPtBottomLastElemRight;
	C3DPoint DrawPtTopLastElemRight;

	BOOL m_bDSCont = m_bDeformedShapeContour;
	unsigned int FirstElemKey, LastElemKey;
	m_pDoc->m_pAttrCtrl->GetWallIDFirstLastElem(ElemKey, FirstElemKey, LastElemKey, FALSE);
	for(int i=0; i<ElemKey.GetSize(); i++)
	{
		int				order1, order2;
		T_ELEM_D	edata;
		C3DPoint	bi_3D, bj_3D, ti_3D, tj_3D,bc_3D2,tc_3D2,DrawPoint;
		CPoint		text_p, top, bot, cnt;

		POSITION		pos;
		CArray<GPS_3DPT_LISTP, GPS_3DPT_LISTP>	polygon_list;
		CArray<GPS_BOOL_ARRYP, GPS_BOOL_ARRYP>  edge_list;
		CArray<GPS_UINT_ARRYP, GPS_UINT_ARRYP>	VertexNode;

		BOOL  fl_bak=pDR->m_bFrameLine;
		pDR->m_bFrameLine = TRUE;

		m_pDoc->m_pAttrCtrl->GetElem(ElemKey[i], edata);
		GetDeformedShapeElement(ElemKey[i], &polygon_list, &edge_list, &VertexNode);

		order1 = GetNodeOrder(VertexNode[0]->GetAt(0), edata, 4);
		order2 = GetNodeOrder(VertexNode[0]->GetAt(1), edata, 4);

		pos = polygon_list[0]->GetHeadPosition();

		bi_3D = polygon_list[0]->GetNext(pos);
		bj_3D = polygon_list[0]->GetNext(pos);
		tj_3D = polygon_list[0]->GetNext(pos);
		ti_3D = polygon_list[0]->GetNext(pos);

		if(ElemKey[i] == FirstElemKey)
		{
			DrawPtBottomFirstElemLeft = bi_3D;
			DrawPtTopFirstElemLeft = ti_3D;
		}

		if(ElemKey[i] == LastElemKey)
		{
			DrawPtBottomLastElemRight = bj_3D;
			DrawPtTopLastElemRight = tj_3D;
		}

		FreeMemoryPolyList(&polygon_list,&edge_list,&VertexNode);
		pDR->m_bFrameLine = fl_bak;
	}

	C3DPoint BottmPt, TopPt;
	BottmPt.Set((DrawPtBottomFirstElemLeft.x+DrawPtBottomLastElemRight.x)/2.0, 
		(DrawPtBottomFirstElemLeft.y+DrawPtBottomLastElemRight.y)/2.0, 
		(DrawPtBottomFirstElemLeft.z+DrawPtBottomLastElemRight.z)/2.0);

	TopPt.Set((DrawPtTopFirstElemLeft.x +DrawPtTopLastElemRight.x)/2.0,
		(DrawPtTopFirstElemLeft.y +DrawPtTopLastElemRight.y)/2.0, 
		(DrawPtTopFirstElemLeft.z +DrawPtTopLastElemRight.z)/2.0);	
	

	DrawHingeStatus(pDC,BottmPt,TopPt,hgst_d);
}

void CDeformEngine::DrawHingeStatus_Sect(CDC *pDC,T_ELEM_K ekey)
{
	T_GPS_HGST_D hgst_d; 
	if(!m_mapHgstFact.Lookup(ekey,hgst_d)) return;

	DrawHingeStatus_Sect_Elem(pDC, ekey, hgst_d);

	return;
}

void CDeformEngine::DrawHingeStatus_Nlnk(CDC *pDC,T_NLNK_K key,T_NODE_K NodeK1,T_NODE_K NodeK2,T_GPS_HGST_D& HgstD)
{
	DECLARE_GPSMD();
	DECLARE_DPTDR();
	DECLARE_DPTCL();
	
	T_NODE_D NodeD1,NodeD2;
	C3DPoint	node3D_i, node3D_j;

	if(!m_pDoc->m_pAttrCtrl->GetNode(NodeK1,NodeD1)){ ASSERT(0); return; }
	if(!m_pDoc->m_pAttrCtrl->GetNode(NodeK2,NodeD2)){ ASSERT(0); return; }
	
	node3D_i.Set(NodeD1.x,NodeD1.y,NodeD1.z);
	node3D_j.Set(NodeD2.x,NodeD2.y,NodeD2.z);
	node3D_i = GetDisplacedPoint(NodeK1, node3D_i);
	node3D_j = GetDisplacedPoint(NodeK2, node3D_j);
	
	CArray<BOOL,BOOL> EdgeList;
	CList<C3DPoint,C3DPoint> PolyList;

	PolyList.AddTail(node3D_i);
	PolyList.AddTail(node3D_j);
	EdgeList.SetSize(2);
	EdgeList[0] = TRUE;
	EdgeList[1] = FALSE;
	
	// Nlnk를 그린다 
	CPen		pen, *old_pen;
	pen.CreatePen(PS_SOLID, gm->m_DOPT.DR.nElemWire, pCL->m_NlnkColor);
	old_pen = (CPen *)pDC->SelectObject(&pen);
	gm->GPSDrawPolygonEdge(pDC, &PolyList, &EdgeList,FALSE);
	pDC->SelectObject(old_pen);
	pen.DeleteObject();

	DrawHingeStatus(pDC,node3D_i,node3D_j,HgstD);
}

void CDeformEngine::DrawHingeStatus_Nspr(CDC *pDC,T_NSPR_K key,T_GPS_HGST_D& HgstD)
{
	DECLARE_GPSMD();
	DECLARE_DPTDR();
	DECLARE_DPTCL();
	
	//T_NODE_D NodeD1,NodeD2;
	T_NODE_D NodeD1;
	C3DPoint	node3D_i, node3D_j;
	T_NODE_K NodeK1 = key.key.entity;

	if(!m_pDoc->m_pAttrCtrl->GetNode(NodeK1,NodeD1)){ ASSERT(0); return; }
	
	node3D_i.Set(NodeD1.x,NodeD1.y,NodeD1.z);
	node3D_i = GetDisplacedPoint(NodeK1, node3D_i);

	DrawHingeStatus(pDC,node3D_i,HgstD);
}

#include "..\wg_db\wg_db_DispOptSizeObj.h"
#include "..\wg_db\wg_db_DispOptMgr.h"
void CDeformEngine::DrawHingeStatus(CDC* pDC,C3DPoint& node3D_i,C3DPoint& node3D_j,T_GPS_HGST_D& HgstD)
{
	DECLARE_GPSMD();
	C3DPoint node3D_i2,node3D_j2,node3D_cnt;

	//!@#$ MNET:2331 20060810 LBI
	// Display Option > Size > Label Symbol에서 크기 조정 50을 기준으로 함... 
	CDispOptMgr* pDispOpt = CDBDoc::GetDocPoint()->m_pDispOpt;
	COptSizeObjNames CSON;   
	CDispOptSizeObj* pGLabelFactor = pDispOpt->GetSize(CSON.m_LabelSymbol);
	ASSERT(pGLabelFactor);
	double dLoadSymbolSize = (double)pGLabelFactor->m_CurVal;
	//!@#$double dUnitLength = pDC->GetDeviceCaps(LOGPIXELSX)*0.12;
	double dUnitLength = pDC->GetDeviceCaps(LOGPIXELSX)*0.12*dLoadSymbolSize/50.0;

	CUtilFuncs::GetInnerLinePoint(0.1,0.9,node3D_i,node3D_j,node3D_i2);
	CUtilFuncs::GetInnerLinePoint(0.9,0.1,node3D_i,node3D_j,node3D_j2);
	CUtilFuncs::GetInnerLinePoint(0.5,0.5,node3D_i,node3D_j,node3D_cnt);	
	
	int I_status,J_status,C_status;
	I_status = HgstD.arValue[0];
	J_status = HgstD.arValue[1];
	C_status = HgstD.arValue[2];

	int nSaveDC = pDC->SaveDC();
	if(I_status>0)
	{
		CBrush RankBrush,*pOldBrush;
		RankBrush.CreateSolidBrush(m_pContourEngine->GetRankColor(I_status));
		pOldBrush = pDC->SelectObject(&RankBrush);
		DrawPoint(pDC,node3D_i2,dUnitLength);
		pDC->SelectObject(pOldBrush);
	}
	if(J_status>0)
	{
		CBrush RankBrush,*pOldBrush;
		RankBrush.CreateSolidBrush(m_pContourEngine->GetRankColor(J_status));
		pOldBrush = pDC->SelectObject(&RankBrush);
		DrawPoint(pDC,node3D_j2,dUnitLength);
		pDC->SelectObject(pOldBrush);
	}
	if(C_status>0)
	{
		CBrush RankBrush,*pOldBrush;
		RankBrush.CreateSolidBrush(m_pContourEngine->GetRankColor(C_status));
		pOldBrush = pDC->SelectObject(&RankBrush);
		DrawPoint(pDC,node3D_cnt,dUnitLength);
		pDC->SelectObject(pOldBrush);
	}
	pDC->RestoreDC(nSaveDC);
}

void CDeformEngine::DrawHingeStatus(CDC* pDC,C3DPoint& node3D,T_GPS_HGST_D& HgstD)
{
	DECLARE_GPSMD();

	//!@#$ MNET:2331 20060810 LBI
	// Display Option > Size > Label Symbol에서 크기 조정 50을 기준으로 함... 
	CDispOptMgr* pDispOpt = CDBDoc::GetDocPoint()->m_pDispOpt;
	COptSizeObjNames CSON;   
	CDispOptSizeObj* pGLabelFactor = pDispOpt->GetSize(CSON.m_LabelSymbol);
	ASSERT(pGLabelFactor);
	double dLoadSymbolSize = (double)pGLabelFactor->m_CurVal;
	//!@#$double dUnitLength = pDC->GetDeviceCaps(LOGPIXELSX)*0.12;
	double dUnitLength = pDC->GetDeviceCaps(LOGPIXELSX)*0.12*dLoadSymbolSize/50.0;
	
	int I_status = HgstD.arValue[0];

	int nSaveDC = pDC->SaveDC();
	if(I_status>0)
	{
		CBrush RankBrush,*pOldBrush;
		RankBrush.CreateSolidBrush(m_pContourEngine->GetRankColor(I_status));
		pOldBrush = pDC->SelectObject(&RankBrush);
		DrawPoint(pDC,node3D,dUnitLength);
		pDC->SelectObject(pOldBrush);
	}
	pDC->RestoreDC(nSaveDC);
}

// nType - 0 : Elem,    1: Nlnk
// RootKey 파라미터는 Wall Type일 경우에만 사용한다. (요소 단위가 아니라 동일 Wall ID 벽체 단위로 처리 하기 위해서..)
int CDeformEngine::GetYieldStatusInfo(int nType, T_KEY Key, COLORREF& rgb, int& nDir, CString& strDir, T_ELEM_K& RootKey, BOOL bConsiderMemb/*=TRUE*/)
{
	DECLARE_DBDOC();
	DECLARE_GPSMD();

	T_INELASTICDYN_HINGE_INFO HingeInfo;
	int nYieldStep, nYieldDir;
	CArray<unsigned int, unsigned int> ElemKeyList;

	RootKey = Key;
	T_ELEM_D ElemD;
	m_pDoc->m_pAttrCtrl->GetElem(Key, ElemD);
	if(m_pDoc->m_pAttrCtrl->IsWall(ElemD.eltyp))
	{
		RootKey = 0;
		m_pDoc->m_pAttrCtrl->GetKeyListBy_WallID_ByStor(ElemKeyList,Key);
		m_pDoc->m_pAttrCtrl->GetRootWallElemKey(ElemKeyList,RootKey);
	}
	else if(m_pDoc->m_pAttrCtrl->IsBeam(ElemD.eltyp) && bConsiderMemb && gm->GetDrawPOHingeByMember())
	{
		// [PMS 5388] Member 별 힌지할당 시 결과출력
		T_MEMB_K MembK=0; 
		if(m_pDoc->m_pAttrCtrl->GetMembAssigned(Key, MembK))
			RootKey = m_pDoc->m_pAttrCtrl->GetFirstElemKInMemb(Key);
	}

	if(nType == 0)    // Elem
	{
		if(!pDoc->m_pPostCtrl->GetPoverInfo()->GetInelasticDynHngtDataElem(RootKey,HingeInfo)) return 0;
		if(!m_mYieldStatusElem2Step.Lookup(RootKey, nYieldStep))   return 0;
		if(!m_mYieldStatusElem2Dir.Lookup(RootKey, nYieldDir))   return 0;
	}
	else if(nType == 1)   // Nlnk
	{
		if(!pDoc->m_pPostCtrl->GetPoverInfo()->GetInelasticDynHngtDataNlnk(RootKey,HingeInfo)) return 0;
		if(!m_mYieldStatusNlnk2Step.Lookup(RootKey, nYieldStep))   return 0;
		if(!m_mYieldStatusNlnk2Dir.Lookup(RootKey, nYieldDir))   return 0;
	}
	else   {  ASSERT(0);		return FALSE;	}

	if( (HingeInfo.nElemType == PSOV_INELASTIC_ELEM_TYPE_BEAM  && !gm->m_bYieldStatusBeam ) ||
			(HingeInfo.nElemType == PSOV_INELASTIC_ELEM_TYPE_WALL  && !gm->m_bYieldStatusWall ) ||
			(HingeInfo.nElemType == PSOV_INELASTIC_ELEM_TYPE_TRUSS && !gm->m_bYieldStatusTruss) ||
			(HingeInfo.nElemType == PSOV_INELASTIC_ELEM_TYPE_NLNK  && !gm->m_bYieldStatusLink ) )   return 0;
	
	if(nYieldStep > gm->m_nCurStep)   return 0;

	int nRank = 0;
	switch(nYieldDir)
	{
	case 0:           nRank = 2;    strDir = _LSX(Fx);    break;
	case 1:           nRank = 3;    strDir = _LSX(Fy);    break;
	case 2:           nRank = 3;    strDir = _LSX(Fz);    break;
	case 3:           return 0;
	case 4:           nRank = 1;    strDir = _LSX(My);    break;
	case 5:           nRank = 1;    strDir = _LSX(Mz);    break;
	default:    ASSERT(0);    break;
	}

	rgb = m_pContourEngine->GetRankColor(nRank);
	nDir = nYieldDir;
	return nRank;
}

// 멤버별 출력 시 중간 좌표 얻음
// 위치 상 정확한 가운데는 아니고.. 멤버 내 요소를 개수로 카운트해서 가운데 요소의 위치임
BOOL CDeformEngine::GetMemberLabelCenterPos(T_MEMB_K MembK, CArray<C3DPoint,C3DPoint>& PosArray)
{
	DECLARE_GPSMD();
	PosArray.RemoveAll();
	if(!gm->GetDrawPOHingeByMember()) { ASSERT(0); return FALSE; }

	T_MEMB_D MembD;
	if(!m_pDoc->m_pAttrCtrl->GetMemb(MembK,MembD)) { ASSERT(0); return FALSE; }
	
	const auto nElemCount = MembD.aElemList.GetSize();
	if(nElemCount%2 == 0) 
	{
		// 짝수일 때 : 가운데 절점 하나만 넘김
		if(!gm->RE_GetLabelPosElemByKey(MembD.aElemList[nElemCount/2-1],&PosArray))   
			return FALSE;

		ASSERT(PosArray.GetSize()==2);
		PosArray.RemoveAt(0);
	}
	else
	{
		// 홀수일 때 : 가운데 요소의 가운데 점만 넘김
		CArray<C3DPoint,C3DPoint> PosArray_dummy;
		if(!gm->RE_GetLabelPosElemByKey(MembD.aElemList[nElemCount/2],&PosArray_dummy))   
			return FALSE;

		ASSERT(PosArray_dummy.GetSize()==2);
		const auto x = (PosArray_dummy[0].x+PosArray_dummy[1].x) / 2.0;
		const auto y = (PosArray_dummy[0].y+PosArray_dummy[1].y) / 2.0;
		const auto z = (PosArray_dummy[0].z+PosArray_dummy[1].z) / 2.0;
		PosArray.Add(C3DPoint(x,y,z));
	}

	return TRUE;
}