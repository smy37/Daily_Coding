// GeneralEngine.cpp: implementation of the CGeneralEngine class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "wg_gps.h"
#include "GeneralEngine.h"
#include "DeformEngine.h"
#include "GPSBarContainer.h"
#include "I_GPSModel.h"
#include "BDEngine.h"
#include "MvlTrcSurfCH.h"
#include "MvlTrcSurfKR.h"
#include "GPSPostCtrl.h"
#include "GPSInflGridBase.h"
#include "MvlTrcCommonBase.h"
#include "GPostTextOut.h"

#include "..\wg_db\wg_db_AttrCtrl.h"
#include "..\wg_db\wg_db_PostCtrl.h"
#include "..\wg_db\wg_db_MathFunc.h"
#include "..\wg_db\wg_db_UnitCtrl.h"
#include "..\wg_db\wg_db_FlagCtrl.h"

#include "..\wg_db\qsort.h"
#include "..\wg_base\wg_baseAllPPreview.h"

//#include "MVL_EngBase.h"

//XGLRenderer
#include "Func_GPS_Draw.h"

#include <float.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

#define UCS_XY 100000 
#define UCS_XZ 100001
#define UCS_YZ 100002

/////////////////////////////////////////////////////////////////////
/*
extern _T("C") { void __cdecl MOV_KRNL(char* filename, int fn_len, int type, int number, int component,
																	 int loadcase, int* N_lane, double* F_max, double* F_min, 
																	 int max_lane_array[1000], int min_lane_array[1000],int nProgType,
																	 double scfc_lane_array[20],double turuck_load_dist[20000]); }
extern _T("C") { void __cdecl MOV_KRNL_JAPAN(char* filename, int fn_len, int type, int number, int component,
																	 int loadcase, int* N_lane, double* F_max, double* F_min, 
																	 int max_load[100], int min_load[100],int nProgType); }
extern _T("C") { void __cdecl MOV_KRNL_CHINA(char* filename, int fn_len, int type, int number, int component,
																	 int loadcase, int* N_lane, double* F_max, double* F_min, 
																	 int max_lane_array[1000], int min_lane_array[1000],int nProgType,
																	 double *dimpact,double *simpact,double *scfc_lane_array,
																	 int nm_pmx1,int nm_smx1); }
																	 */
/////////////////////////////////////////////////////////////////////
#include "..\wg_base\wg_base_LightDlg.h" 

double CEngineBase::m_dVectorThkScale=2.0;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CEngineBase::CEngineBase()
{
	m_pContourEngine  = NULL;
	m_pInflGrid       = NULL;
		
	m_mapBeamPosToValueforValueOut.InitHashTable(HASHSIZEELEM);
	m_mapBeamPosToVertexforValueOut.InitHashTable(HASHSIZEELEM);
	m_mapNodesInElem.InitHashTable(HASHSIZEELEM);
	m_mapSerialNode.InitHashTable(HASHSIZENODE);

	ResetEngine();

	//m_nPrdMoving=CProduct::GetMovingType(); 
}


CEngineBase::~CEngineBase()
{
	if(m_pContourEngine && (m_pContourEngine != &(CGPSBarContainer::m_ContourEngine)))
		delete m_pContourEngine;

	RemoveInflGrid();
	ResetCuttingLineData();
	m_mapBeamPosToValueforValueOut.RemoveAll();
	m_mapBeamPosToVertexforValueOut.RemoveAll();

}

// 두 개의 방향벡터 중 어느 것이 (z축 방향에서) 앞인가를 판단
BOOL CEngineBase::IsFar(double *this_vector, double *comp_vector)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	C3DPoint	this_p, comp_p, this_pw, comp_pw;

	this_p.x = this_vector[0];
	this_p.y = this_vector[1];
	this_p.z = this_vector[2];
	comp_p.x = comp_vector[0];
	comp_p.y = comp_vector[1];
	comp_p.z = comp_vector[2];
	this_pw = gm->m_pGPSCtrl->GetWorldToWindowP3D(this_p);
	comp_pw = gm->m_pGPSCtrl->GetWorldToWindowP3D(comp_p);

	if (this_pw.z >= comp_pw.z)
		return TRUE;
	return FALSE;
}

////////////////////////////////////////////////////////////////////////////////////////
// General Routines for Drawing Contour                            ////////////////////
////////////////////////////////////////////////////////////////////////////////////////

// 각 Vertex의 위치, edge flag, 해당 Value가 정해진 하나의 polygon을 Contour하여
// 얻어진 sub-polygon list를 그림.
void CEngineBase::DoSubPolyContour(CDC *pDC, double *ForcVal, CList <C3DPoint, C3DPoint> *Vertex, BOOL *EdgeFlag, 
								   BOOL is_frame )
{
	I_GPSModel					*gm=(I_GPSModel *) m_pGPSModel;
	int							i, vertex_num=Vertex->GetCount();
	POSITION					pos;
	C3DPoint					*p[4];
	C3DPoint					p2[4];
	CArray <int, int>			vnum_list;
	CArray <double, double>	aShadeFactor_list;
	CArray <double, double>	aSpecShadeFactor_list;
	CArray <VtxInfo, VtxInfo>	vtx_list;

	pos = Vertex->GetHeadPosition();
	if(is_frame)
		for (i=0;i<vertex_num;i++)
			p2[i] = (Vertex->GetNext(pos));
	else
		for (i=0;i<vertex_num;i++)
			p[i] = &(Vertex->GetNext(pos));

	if (is_frame) {
		m_pContourEngine->ContourFramePoly(p2, ForcVal, vertex_num, vnum_list, vtx_list,
																				&aShadeFactor_list,&aSpecShadeFactor_list);
	}
	else if (vertex_num == 3) {
		m_pContourEngine->ContourTriangle(ForcVal[0], ForcVal[1], ForcVal[2],
											*p[0], *p[1], *p[2],
											EdgeFlag[0], EdgeFlag[1], EdgeFlag[2],
											vnum_list,
											vtx_list,&aShadeFactor_list,&aSpecShadeFactor_list);
	}
	else if (vertex_num == 4) {
		m_pContourEngine->ContourRectangle(ForcVal[0], ForcVal[1], ForcVal[2], ForcVal[3],
											 *p[0], *p[1], *p[2], *p[3],
											 EdgeFlag[0], EdgeFlag[1], EdgeFlag[2], EdgeFlag[3],
											 vnum_list,
											 vtx_list,&aShadeFactor_list,&aSpecShadeFactor_list);
	}

	
	if (gm->m_bGradient) {
		DrawContourListGrad(pDC, vnum_list, vtx_list,&aShadeFactor_list,&aSpecShadeFactor_list);
	}
	else {
		DrawContourList(pDC, vnum_list, vtx_list,&aShadeFactor_list,&aSpecShadeFactor_list);
	}

	vnum_list.RemoveAll();
	vtx_list.RemoveAll();
	aShadeFactor_list.RemoveAll();
	aSpecShadeFactor_list.RemoveAll();

}

void CEngineBase::DrawContourList(CDC *pDC, CArray <int, int> &vnum_list, CArray <VtxInfo, VtxInfo> &vtx_list, 
																	CArray <double, double>* aShadeFactor_list,
																	CArray <double, double>* aSpecShadeFactor_list)
{
	int							i, j, k, poly_num=vnum_list.GetSize();
	I_GPSModel					*gm=(I_GPSModel *) m_pGPSModel;
	CList <C3DPoint, C3DPoint>	vlist;
	CPen						edge_pen, *old_pen,*old_pen2;
	CClientDC		ClientDC(((I_GPSModel*)m_pGPSModel)->m_pMyView);
	C3DPoint P1,P2,Pcent,P11,P22;
	CPoint P2D_annot;
	CString sContAnnot;
	CHAR cAnnotStart = 'A';
	int nAnnoRow,nAnnoCol;
	CPoint ClientZero,MemZero;
	ClientZero.x = 0;	ClientZero.y = 0;
	double dOffsetX=0,dOffsetY=0;
	int nRank;

	
	if (m_pContourEngine == NULL) {
		return;
	}

	k = 0;
	if(!gm->m_bVirtualMode)
	{
		gm->m_pGPSCtrl->GetClientToMemDC(ClientZero,MemZero);
		dOffsetX = MemZero.x;
		dOffsetY = MemZero.y;
	}

	if(m_pContourEngine->m_nContourFill == 0) // Contour Fill
	{
	  for (i=0;i<poly_num;i++) {
		  for (j=0;j<vnum_list[i];j++) {
			  vlist.AddTail(vtx_list[k+j].vtx);
		  }

			COLORREF color =m_pContourEngine->GetValueColor(vtx_list[k].val);
			
			if(gm->m_DOPT.RD.m_bShade && aShadeFactor_list && aSpecShadeFactor_list)
				color = GetShadeFactoredColor(color,aShadeFactor_list->GetAt(i),aSpecShadeFactor_list->GetAt(i));
			
		  if (gm->m_bVirtualMode)
			  gm->m_pGPSCtrl->DrawPolygon3DFillOnClientWindow(pDC, vlist, color);
		  else
			{
			  if (!gm->m_bAnimation)
					gm->m_pGPSCtrl->DrawPolygon3DFillOnClientWindow(&ClientDC, vlist, color);
			  gm->m_pGPSCtrl->DrawPolygon3DFill(pDC, vlist, color);
			}
		  vlist.RemoveAll();
		  k += vnum_list[i];
	  }

		if (m_pContourEngine->m_bDrawContourEdge)  //이건 꼭 함께 그릴 필요가 없으므로 OnClient는 병행하지 않는다.
		{  
			k = 0;

			edge_pen.CreatePen(PS_SOLID, gm->m_nLineWidth, m_pContourEngine->m_EdgeColor);
		  old_pen = (CPen *) pDC->SelectObject(&edge_pen);
			
			for (i=0;i<poly_num;i++) 
			{
				for (j=0;j<vnum_list[i];j++) {
					if (vtx_list[k+j].ef) {
						nRank = abs(m_pContourEngine->GetUpperRank(vtx_list[k].val));
						
						P1 = vtx_list[k+(j%vnum_list[i])].vtx;
						P2 =  vtx_list[k+((j+1)%vnum_list[i])].vtx;
											
						if(gm->m_bContourAnnotation)
						{	// Set Annotation Data
							ContAnnotData AnnotData;
							Pcent.Set((P1.x+P2.x)/2.0,(P1.y+P2.y)/2.0,(P1.z+P2.z)/2.0);
													//XGLRenderer Contour rountine바깥으로 빼냄.
													if(!(gm->m_pGPSCtrl->IsGLRenderer() && gm->m_pGPSCtrl->IsXGRMode()))
													{
							if (gm->m_bVirtualMode)	
							{
								P2D_annot = gm->m_pGPSCtrl->GetWorldToWindowP2D(Pcent);
								nAnnoCol = floor( (double)P2D_annot.x/(double)gm->m_nContAnnotSpan_X);
								nAnnoRow = floor( (double)P2D_annot.y/(double)gm->m_nContAnnotSpan_Y);
							}
							else
							{
								P2D_annot = gm->m_pGPSCtrl->GetWorldToMemDCP2D(Pcent);
								nAnnoCol = floor( (double)(P2D_annot.x-dOffsetX)/(double)gm->m_nContAnnotSpan_X);
								nAnnoRow = floor( (double)(P2D_annot.y-dOffsetY)/(double)gm->m_nContAnnotSpan_Y);
							}
							AnnotData.nAnnotCol = nAnnoCol;
							AnnotData.nAnnotRow = nAnnoRow;
							AnnotData.Pannot = P2D_annot;
													} 

							AnnotData.sAnnot.Format(_T("%c"),cAnnotStart +nRank-1);
							AnnotData.P1 = P1;
							AnnotData.P2 = P2;
							AnnotData.Pcent = Pcent;
							AnnotData.nRank = nRank;
							
													
							gm->m_arContAnnotDataList.Add(AnnotData);
						}
						
						if (gm->m_bVirtualMode)	
							gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, P1, P2);
						else
							gm->m_pGPSCtrl->DrawLine3D(pDC, P1, P2);
						
					}
				}
				k += vnum_list[i];
			}
			pDC->SelectObject(old_pen);
		  edge_pen.DeleteObject();
		}

	}
	else // Contour Line Only
	{
 		
		for (i=0;i<poly_num;i++) 
		{
			for (j=0;j<vnum_list[i];j++) {
				if (vtx_list[k+j].ef) {
					edge_pen.CreatePen(PS_SOLID, gm->m_nLineWidth*1.8, m_pContourEngine->GetValueColor(vtx_list[k].val));
		      old_pen = (CPen *) pDC->SelectObject(&edge_pen);
					nRank = abs(m_pContourEngine->GetUpperRank(vtx_list[k].val));
					
					if(!gm->m_bAnimation && !gm->m_bVirtualMode)
						old_pen2 = (CPen *) ClientDC.SelectObject(&edge_pen);
				
					P1 = vtx_list[k+(j%vnum_list[i])].vtx;
					P2 =  vtx_list[k+((j+1)%vnum_list[i])].vtx;
										
					if(gm->m_bContourAnnotation)
					{	// Set Annotation Data
						ContAnnotData AnnotData;
						Pcent.Set((P1.x+P2.x)/2.0,(P1.y+P2.y)/2.0,(P1.z+P2.z)/2.0);
											//XGLRenderer Contour rountine바깥으로 빼냄.
											if(!(gm->m_pGPSCtrl->IsGLRenderer() && gm->m_pGPSCtrl->IsXGRMode()))
											{
						if (gm->m_bVirtualMode)	
						{
							P2D_annot = gm->m_pGPSCtrl->GetWorldToWindowP2D(Pcent);
							nAnnoCol = floor( (double)P2D_annot.x/(double)gm->m_nContAnnotSpan_X);
							nAnnoRow = floor( (double)P2D_annot.y/(double)gm->m_nContAnnotSpan_Y);
						}
						else
						{
							P2D_annot = gm->m_pGPSCtrl->GetWorldToMemDCP2D(Pcent);
							nAnnoCol = floor( (double)(P2D_annot.x-dOffsetX)/(double)gm->m_nContAnnotSpan_X);
							nAnnoRow = floor( (double)(P2D_annot.y-dOffsetY)/(double)gm->m_nContAnnotSpan_Y);
						}
						
						AnnotData.nAnnotCol = nAnnoCol;
						AnnotData.nAnnotRow = nAnnoRow;
												AnnotData.Pannot    = P2D_annot;
											}
						AnnotData.sAnnot.Format(_T("%c"),cAnnotStart +nRank-1);
						AnnotData.P1 = P1;
						AnnotData.P2 = P2;
						AnnotData.Pcent = Pcent;
						AnnotData.nRank = nRank;
												
						gm->m_arContAnnotDataList.Add(AnnotData);
					}
					
					if (gm->m_bVirtualMode)	
						gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, P1, P2);
					else
					{	
						if (!gm->m_bAnimation)
							gm->m_pGPSCtrl->DrawLine3DOnClientWindow(&ClientDC, P1, P2);
						gm->m_pGPSCtrl->DrawLine3D(pDC, P1, P2);
					}
								
					pDC->SelectObject(old_pen);
					if(!gm->m_bAnimation && !gm->m_bVirtualMode)
						ClientDC.SelectObject(old_pen2);
		      edge_pen.DeleteObject();
				}
			}
			k += vnum_list[i];
		}
	}
}




void CEngineBase::DrawContourListGrad(CDC *pDC, CArray <int, int> &vnum_list, CArray <VtxInfo, VtxInfo> &vtx_list,
																			CArray <double, double>* aShadeFactor_list,
																			CArray <double, double>* aSpecShadeFactor_list)
{
	int							i, j, k=0, poly_num=vnum_list.GetSize();
	I_GPSModel					*gm=(I_GPSModel *) m_pGPSModel;
	CPoint						p1, p2;
	COLORREF					col;
	CPen						edge_pen, *old_pen;

	CArray <C3DPoint, C3DPoint &>	vtx_input;
	CArray <CPoint, CPoint &>		vtx_output;
	CArray <COLORREF, COLORREF &>	col_input, col_output;
	CClientDC		ClientDC(((I_GPSModel*)m_pGPSModel)->m_pMyView);
		C3DPoint P1,P2,Pcent,P11,P22;
	CPoint P2D_annot;
	CString sContAnnot;
	CHAR cAnnotStart = 'A';
	int nAnnoRow,nAnnoCol;
	CPoint ClientZero,MemZero;
	ClientZero.x = 0;	ClientZero.y = 0;
	double dOffsetX=0,dOffsetY=0;
	int nRank;

	
	if (m_pContourEngine == NULL) {
		return;
	}

	k = 0;
	if(!gm->m_bVirtualMode)
	{
		gm->m_pGPSCtrl->GetClientToMemDC(ClientZero,MemZero);
		dOffsetX = MemZero.x;
		dOffsetY = MemZero.y;
	}

	if(m_pContourEngine->m_nContourFill == 0) // Contour Fill
	{
		 
	  k = 0;
	  for (i=0;i<poly_num;i++) {
		  vtx_input.RemoveAll();
		  col_input.RemoveAll();
		  for (j=0;j<vnum_list[i];j++) {
			  vtx_input.Add(vtx_list[k+j].vtx);
			  col = m_pContourEngine->GetValueColorGrad(vtx_list[k+j].val);
				
				if(gm->m_DOPT.RD.m_bShade && aShadeFactor_list && aSpecShadeFactor_list)
					col = GetShadeFactoredColor(col,aShadeFactor_list->GetAt(i),aSpecShadeFactor_list->GetAt(i));
					
			  col_input.Add(col);
		  }
		  k += vnum_list[i];
		  
			if (!gm->m_bAnimation)
				if(gm->GetClippedVtxList(vtx_input, vtx_output, col_input, col_output,TRUE))
					CGradientDrawing::GradientPolygon(&ClientDC, col_output.GetData(), vtx_output.GetData(), vtx_output.GetSize());
			if(gm->GetClippedVtxList(vtx_input, vtx_output, col_input, col_output))
			  CGradientDrawing::GradientPolygon(pDC, col_output.GetData(), vtx_output.GetData(), vtx_output.GetSize());
			
	  }

		if (m_pContourEngine->m_bDrawContourEdge)  //이건 꼭 함께 그릴 필요가 없으므로 OnClient는 병행하지 않는다.
		{  
			k = 0;

			edge_pen.CreatePen(PS_SOLID, gm->m_nLineWidth, m_pContourEngine->m_EdgeColor);
		  old_pen = (CPen *) pDC->SelectObject(&edge_pen);
			
			for (i=0;i<poly_num;i++) 
			{
				for (j=0;j<vnum_list[i];j++) {
					if (vtx_list[k+j].ef) {
						nRank = abs(m_pContourEngine->GetUpperRank(vtx_list[k].val));
						
						P1 = vtx_list[k+(j%vnum_list[i])].vtx;
						P2 =  vtx_list[k+((j+1)%vnum_list[i])].vtx;
											
						if(gm->m_bContourAnnotation)
						{	// Set Annotation Data
							ContAnnotData AnnotData;
							Pcent.Set((P1.x+P2.x)/2.0,(P1.y+P2.y)/2.0,(P1.z+P2.z)/2.0);
													//XGLRenderer Contour rountine바깥으로 빼냄.
													if(!(gm->m_pGPSCtrl->IsGLRenderer() && gm->m_pGPSCtrl->IsXGRMode()))
													{
							if (gm->m_bVirtualMode)	
							{
								P2D_annot = gm->m_pGPSCtrl->GetWorldToWindowP2D(Pcent);
								nAnnoCol = floor( (double)P2D_annot.x/(double)gm->m_nContAnnotSpan_X);
								nAnnoRow = floor( (double)P2D_annot.y/(double)gm->m_nContAnnotSpan_Y);
							}
							else
							{
								P2D_annot = gm->m_pGPSCtrl->GetWorldToMemDCP2D(Pcent);
								nAnnoCol = floor( (double)(P2D_annot.x-dOffsetX)/(double)gm->m_nContAnnotSpan_X);
								nAnnoRow = floor( (double)(P2D_annot.y-dOffsetY)/(double)gm->m_nContAnnotSpan_Y);
							}
							
							AnnotData.nAnnotCol = nAnnoCol;
							AnnotData.nAnnotRow = nAnnoRow;
														AnnotData.Pannot = P2D_annot;
													}

							AnnotData.sAnnot.Format(_T("%c"),cAnnotStart +nRank-1);
							AnnotData.P1 = P1;
							AnnotData.P2 = P2;
							AnnotData.Pcent = Pcent;
							AnnotData.nRank = nRank;
							
													
							gm->m_arContAnnotDataList.Add(AnnotData);
						}
						
						if (gm->m_bVirtualMode)	
							gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, P1, P2);
						else
							gm->m_pGPSCtrl->DrawLine3D(pDC, P1, P2);
						
					}
				}
				k += vnum_list[i];
			}
			pDC->SelectObject(old_pen);
		  edge_pen.DeleteObject();
		}
	}
	else // Contour Line Only , Gradient가 무의미하다.
		DrawContourList(pDC,vnum_list,vtx_list,aShadeFactor_list,aSpecShadeFactor_list);

}

void CEngineBase::DrawContourLine(CDC *pDC, CArray <C3DPoint, C3DPoint> &vtx_list, CArray <double, double> &val_list)
{
	int				i, poly_num=vtx_list.GetSize();
	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;
	C3DPoint		p1, p2;
	CPen			RankPen, *old_pen,*old_pen2;
	CClientDC	dc(gm->m_pMyView);
	if (m_pContourEngine == NULL) {
		return;
	}

	for(i=0;i<poly_num-1;i++) 
	{
		if(m_pContourEngine->ExcludePolyOutofRangeGlobal(val_list[i]) || 
			 m_pContourEngine->ExcludePolyOutofRangeGlobal(val_list[i+1]) )continue; 

		int nWidth = gm->m_nLineWidth * 1.7;

		//if (nWidth <= 4)
		//	nWidth = 4;

		RankPen.CreatePen(PS_SOLID, nWidth, m_pContourEngine->GetRankColor(abs(m_pContourEngine->GetUpperRank(val_list[i]))));
		old_pen = (CPen *) pDC->SelectObject(&RankPen);
		if(!gm->m_bAnimation && !gm->m_bVirtualMode)
			old_pen2 = (CPen *) dc.SelectObject(&RankPen);

		p1 = vtx_list[i];
		p2 = vtx_list[i+1];
		if (gm->m_bVirtualMode)
			gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, p1, p2);
		else
		{
			if(!gm->m_bAnimation)
				gm->m_pGPSCtrl->DrawLine3DOnClientWindow(&dc, p1, p2);
			gm->m_pGPSCtrl->DrawLine3D(pDC, p1, p2);
		}

		pDC->SelectObject(old_pen);
		if(!gm->m_bAnimation && !gm->m_bVirtualMode)
			dc.SelectObject(old_pen2);
		RankPen.DeleteObject();
	}
}

void CEngineBase::DrawContourLine(CDC *pDC, CArray <C3DPoint, C3DPoint> &vtx_list, CArray <double, double> &val_list,int nLineWidth)
{
		int				i, poly_num=vtx_list.GetSize();
	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;
	C3DPoint		p1, p2;
	CPen			RankPen, *old_pen,*old_pen2;
	CClientDC	dc(gm->m_pMyView);
	if (m_pContourEngine == NULL) {
		return;
	}

	for (i=0;i<poly_num-1;i++) 
	{
		if(m_pContourEngine->ExcludePolyOutofRangeGlobal(val_list[i]) || 
			 m_pContourEngine->ExcludePolyOutofRangeGlobal(val_list[i+1]) )continue; 
		
		int nWidth = nLineWidth * 1.7;
		
		//if (nLineWidth <= 4)
			//nWidth = 4;
		
		RankPen.CreatePen(PS_SOLID, nWidth , m_pContourEngine->GetRankColor(abs(m_pContourEngine->GetUpperRank(val_list[i]))));
		old_pen = (CPen *) pDC->SelectObject(&RankPen);
		if(!gm->m_bAnimation && !gm->m_bVirtualMode)
			old_pen2 = (CPen *) dc.SelectObject(&RankPen);

		p1 = vtx_list[i];
		p2 = vtx_list[i+1];
		if (gm->m_bVirtualMode)
			gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, p1, p2);
		else
		{
			if(!gm->m_bAnimation)
				gm->m_pGPSCtrl->DrawLine3DOnClientWindow(&dc, p1, p2);
			gm->m_pGPSCtrl->DrawLine3D(pDC, p1, p2);
		}

		pDC->SelectObject(old_pen);
		if(!gm->m_bAnimation && !gm->m_bVirtualMode)
			dc.SelectObject(old_pen2);
		RankPen.DeleteObject();
	}
}

// 두 점에 의해 정해진 선을 Contour하여 나누고 나뉜 선들을 그린다.
void CEngineBase::DrawInflLineContour(CDC *pDC, C3DPoint p1, C3DPoint p2, double val1, double val2)
{
	I_GPSModel						*gm=(I_GPSModel *) m_pGPSModel;
	CArray <C3DPoint, C3DPoint>		rvtx_list;
	CArray <double, double>			rval_list;

	if (gm->m_AnimEngine.m_bAnimateContour) {
		val1 = m_pContourEngine->GetSubFrameValue(val1, gm->m_AnimEngine.GetAnimationFactor(TRUE));
		val2 = m_pContourEngine->GetSubFrameValue(val2, gm->m_AnimEngine.GetAnimationFactor(TRUE));
	}
	if (val1 > val2) {
		rvtx_list.Add(p1);
		rval_list.Add(val1);
		m_pContourEngine->GetRankVertices(p1, p2, val1, val2, rvtx_list, rval_list, NULL);
		rvtx_list.Add(p2);
		rval_list.Add(val2);
	}
	else {
		rvtx_list.Add(p2);
		rval_list.Add(val2);
		m_pContourEngine->GetRankVertices(p2, p1, val2, val1, rvtx_list, rval_list, NULL);
		rvtx_list.Add(p1);
		rval_list.Add(val1);
	}

	DrawContourLine(pDC, rvtx_list, rval_list);

	rvtx_list.RemoveAll();
	rval_list.RemoveAll();
}



void CEngineBase::GetPlaneFunction(T_NPLN_D& CuttingPlane,PLANE_FUNC& CuttingPlaneF)
{
	double dCoord;
	
	if(CuttingPlane.nPlaneType == 1)
		CMathFunc::mathPlaneEquation(CuttingPlane.dPoint[0],CuttingPlane.dPoint[1],CuttingPlane.dPoint[2],
																	CuttingPlaneF.a,CuttingPlaneF.b,CuttingPlaneF.c,CuttingPlaneF.h);
	else if(CuttingPlane.nPlaneType == 2)
	{
		dCoord = CuttingPlane.dCoor;
		CuttingPlane.dPoint[0][0] = 0.0;
		CuttingPlane.dPoint[0][1] = 0.0;
		CuttingPlane.dPoint[0][2] = dCoord;

		CuttingPlane.dPoint[1][0] = 10.0;
		CuttingPlane.dPoint[1][1] = 0.0;
		CuttingPlane.dPoint[1][2] = dCoord;
		
		CuttingPlane.dPoint[2][0] = 0.0;
		CuttingPlane.dPoint[2][1] = 10.0;
		CuttingPlane.dPoint[2][2] = dCoord;

		CMathFunc::mathPlaneEquation(CuttingPlane.dPoint[0],CuttingPlane.dPoint[1],CuttingPlane.dPoint[2],
													 			CuttingPlaneF.a,CuttingPlaneF.b,CuttingPlaneF.c,CuttingPlaneF.h);
	}
	else if(CuttingPlane.nPlaneType == 3)
	{
		dCoord = CuttingPlane.dCoor;
		CuttingPlane.dPoint[0][0] = 0.0;
		CuttingPlane.dPoint[0][1] = dCoord;
		CuttingPlane.dPoint[0][2] = 0.0;

		CuttingPlane.dPoint[1][0] = 10.0;
		CuttingPlane.dPoint[1][1] = dCoord;
		CuttingPlane.dPoint[1][2] = 0.0;
		
		CuttingPlane.dPoint[2][0] = 0.0;
		CuttingPlane.dPoint[2][1] = dCoord;
		CuttingPlane.dPoint[2][2] = 10.0;

		CMathFunc::mathPlaneEquation(CuttingPlane.dPoint[0],CuttingPlane.dPoint[1],CuttingPlane.dPoint[2],
													 			CuttingPlaneF.a,CuttingPlaneF.b,CuttingPlaneF.c,CuttingPlaneF.h);
	}
	else if(CuttingPlane.nPlaneType == 4)
	{
		dCoord = CuttingPlane.dCoor;
		CuttingPlane.dPoint[0][0] = dCoord;
		CuttingPlane.dPoint[0][1] = 0.0;
		CuttingPlane.dPoint[0][2] = 0.0;

		CuttingPlane.dPoint[1][0] = dCoord;
		CuttingPlane.dPoint[1][1] = 10.0;
		CuttingPlane.dPoint[1][2] = 0.0;
		
		CuttingPlane.dPoint[2][0] = dCoord;
		CuttingPlane.dPoint[2][1] = 0.0;
		CuttingPlane.dPoint[2][2] = 10.0;
		
		CMathFunc::mathPlaneEquation(CuttingPlane.dPoint[0],CuttingPlane.dPoint[1],CuttingPlane.dPoint[2],
																	CuttingPlaneF.a,CuttingPlaneF.b,CuttingPlaneF.c,CuttingPlaneF.h);
	}

	return;
}

void CEngineBase::ResetCuttingLineData()
{
	for(int i=0; i<m_aCutLineData.GetSize(); i++)
		delete [] m_aCutLineData[i];

	for(int i=0; i<m_aCutLineOnPlaneData.GetSize(); i++)
		delete [] m_aCutLineOnPlaneData[i];
	
	m_aCutLineData.RemoveAll();
	m_aCutLineMinMax.RemoveAll();
	m_aCutLineOnPlaneData.RemoveAll();
	m_aCutLineOnPlaneMinMax.RemoveAll();
}

void CEngineBase::ImportEngine(CEngineBase *eg)
{
	if(eg->m_pContourEngine) 
	{
		if(!m_pContourEngine)m_pContourEngine=new CContourEngine();
		*m_pContourEngine = *(eg->m_pContourEngine);
		
		if(m_pContourEngine->m_CurrentColorTable<0 || m_pContourEngine->m_CurrentColorTable>3)
			m_pContourEngine->m_CurrentColorTable = COLOR_TABLE_RGB;

		if(m_pContourEngine->m_ColorTableOld<0 || m_pContourEngine->m_ColorTableOld>3)
			m_pContourEngine->m_ColorTableOld = COLOR_TABLE_RGB;
	}

	// Influence Grid Class
	if(eg->m_pInflGrid)
	{
		if(!m_pInflGrid)m_pInflGrid = CGPSInflGridBase::CreateInflGrid(eg->m_pInflGrid->GetInflGridType(),this);
		m_pInflGrid->Import(eg->m_pInflGrid);
	}
	
	if(!m_pGPSModel && eg->m_pGPSModel)m_pGPSModel=eg->m_pGPSModel;
	m_InflValType   = eg->m_InflValType; 
	m_InflKeyNode		= eg->m_InflKeyNode;
	m_bInflDataSet  = eg->m_bInflDataSet;
	m_InflKeyElem   = eg->m_InflKeyElem;
	m_InflKeyNlnk   = eg->m_InflKeyNlnk;
	m_InflKeyElnk   = eg->m_InflKeyElnk;
	m_dMaxValue     = eg->m_dMaxValue;
	m_dMinValue     = eg->m_dMinValue;
	m_MaxInflEKey		= eg->m_MaxInflEKey;
	m_MinInflEKey		= eg->m_MinInflEKey;
	m_MaxInflPart		= eg->m_MaxInflPart;
	m_MinInflPart		= eg->m_MinInflPart;
	m_MaxInflVal		= eg->m_MaxInflVal;
	m_MinInflVal		= eg->m_MinInflVal;
	m_bLockAdjFactor= eg->m_bLockAdjFactor;  
	m_bDeformedShapeContour = eg->m_bDeformedShapeContour;

	m_dInflScaleFc  = eg->m_dInflScaleFc; 
	m_dInflAdjstFc  = eg->m_dInflAdjstFc;

	m_arLaneInfoNew.RemoveAll();
	for(int i=0; i<eg->m_arLaneInfoNew.GetSize(); i++)
		m_arLaneInfoNew.Add(eg->m_arLaneInfoNew[i]);

	m_arLaneInfoNew_Special.RemoveAll();
	for(int i=0; i<eg->m_arLaneInfoNew_Special.GetSize(); i++)
		m_arLaneInfoNew_Special.Add(eg->m_arLaneInfoNew_Special[i]);
	
	m_arMvlTrcData.RemoveAll();
	for(int i=0; i<eg->m_arMvlTrcData.GetSize(); i++)
		m_arMvlTrcData.Add(eg->m_arMvlTrcData[i]);
	
	m_dMVLTRCScaleFactor  = eg->m_dMVLTRCScaleFactor;
	m_bDrawMVLTRCLoad     = eg->m_bDrawMVLTRCLoad;
	m_bMVLTRCValue        = eg->m_bMVLTRCValue;
	m_nMVLTRCValueType    = eg->m_nMVLTRCValueType;
	m_nMVLTRCValueDePt    = eg->m_nMVLTRCValueDePt;
	m_dMaxModelLength     = eg->m_dMaxModelLength;
		
	m_bMvlTrcCF   = eg->m_bMvlTrcCF;    //  원심력하중고려여부 
	m_dMvlTrcCF   = eg->m_dMvlTrcCF;    //  원심력하중의 ratio
	m_dMvlTrcCF_H = eg->m_dMvlTrcCF_H;//  원심력하중의 작용높이 

	m_arImpFct.RemoveAll();       m_arImpFct.Copy(eg->m_arImpFct); 
	m_arInflInfo.RemoveAll();     m_arInflInfo.Copy(eg->m_arInflInfo); 
	m_arNewInflInfo.RemoveAll();  m_arNewInflInfo.Copy(eg->m_arNewInflInfo); 
	//m_arLaneKey.RemoveAll();      m_arLaneKey.Copy(eg->m_arLaneKey);
	//m_InflDistList.RemoveAll();   m_InflDistList.Copy(eg->m_InflDistList);
	//m_EccenList.RemoveAll();      m_EccenList.Copy(eg->m_EccenList);
	//m_InflLaneElemKeyList.RemoveAll(); m_InflLaneElemKeyList.Copy(eg->m_InflLaneElemKeyList);
	
	//m_MvlTrc_max_load.RemoveAll();
	//m_MvlTrc_max_load.Copy(eg->m_MvlTrc_max_load);
	//m_MvlTrc_min_load.RemoveAll(); 
	//m_MvlTrc_min_load.Copy(eg->m_MvlTrc_min_load);

	m_arMvlTrcDataJP.RemoveAll(); 
	m_arMvlTrcDataJP.Copy(eg->m_arMvlTrcDataJP);
	m_arMvlTrcDataCH.RemoveAll(); 
	m_arMvlTrcDataCH.Copy(eg->m_arMvlTrcDataCH);
	m_arMvlTrcDataIN.RemoveAll();
	m_arMvlTrcDataIN.Copy(eg->m_arMvlTrcDataIN);
	m_arMvlTrcDataBS.RemoveAll();
	m_arMvlTrcDataBS.Copy(eg->m_arMvlTrcDataBS);
	m_arMvlTrcDataTR.RemoveAll();
	m_arMvlTrcDataTR.Copy(eg->m_arMvlTrcDataTR);
	m_arMvlTrcDataERBS.RemoveAll();
	m_arMvlTrcDataERBS.Copy(eg->m_arMvlTrcDataERBS);
	m_arMvlTrcDataRus.RemoveAll();
	m_arMvlTrcDataRus.Copy(eg->m_arMvlTrcDataRus);
	m_arMvlTrcDataAfrica.RemoveAll();
	m_arMvlTrcDataAfrica.Copy(eg->m_arMvlTrcDataAfrica);
	m_arMvlTrcDataFR.RemoveAll();
	m_arMvlTrcDataFR.Copy(eg->m_arMvlTrcDataFR);


	m_MvlTrc_F_max  = eg->m_MvlTrc_F_max;
	m_MvlTrc_F_min  = eg->m_MvlTrc_F_min;
	
	// Cutting Line
	ResetCuttingLineData();
	m_bOnCuttingLine = eg->m_bOnCuttingLine;
	m_PlateKeyList.RemoveAll();
	m_PlateKeyList.Copy(eg->m_PlateKeyList);
	m_aCutLines.Copy(eg->m_aCutLines);
	m_aCutPlanes.Copy(eg->m_aCutPlanes);
	m_aCutLineMinMax.Copy(eg->m_aCutLineMinMax);
	CArray<T_CUTLINE_D,T_CUTLINE_D&>* paCutLineData;
	for(int i= 0; i<eg->m_aCutLineData.GetSize(); i++)
	{
		paCutLineData = new CArray<T_CUTLINE_D,T_CUTLINE_D&>;
		m_aCutLineData.Add(paCutLineData);
		m_aCutLineData[i]->Copy(*(eg->m_aCutLineData[i]));
	}
	m_aCutLineOnPlaneMinMax.Copy(eg->m_aCutLineOnPlaneMinMax);
	CArray<T_CUTLINE_D,T_CUTLINE_D&>* paCutLineOnPlaneData;
	for(int i= 0; i<eg->m_aCutLineOnPlaneData.GetSize(); i++)
	{
		paCutLineOnPlaneData = new CArray<T_CUTLINE_D,T_CUTLINE_D&>;
		m_aCutLineOnPlaneData.Add(paCutLineOnPlaneData);
		m_aCutLineOnPlaneData[i]->Copy(*(eg->m_aCutLineOnPlaneData[i]));
	}

	m_dAnimStTime   = eg->m_dAnimStTime;
	m_dAnimEdTime   = eg->m_dAnimEdTime;
	m_dAnimIncTime  = eg->m_dAnimIncTime;
}

//ChangKeun --> Cutting Line Output 을 저장하기 위한 크기를 예측 할 수 있을까. ?

class TempDrawCuttingLMode
{
protected:
	I_GPSModel* _pIGPSM;  
public:
	TempDrawCuttingLMode( I_GPSModel* pIGPSM)
	{
		_pIGPSM = pIGPSM;
		_pIGPSM->m_pGPSCtrl->XGL_Begin_CuttingPLDiagram();
	}
	~TempDrawCuttingLMode()
	{
		_pIGPSM->m_pGPSCtrl->XGL_End_CuttingPLDiagram();
	}
};


void CEngineBase::DrawCuttingLineDiagrams(CDC* pDC)
{

	//XGL_Renderer
	//if(CEngineBase::IsMakeVSDDataMode_ST())
	//{
		/*
		int poly_num=vtx_list.GetSize();
		for(int i = 0; i < poly_num -1 ; ++i)
		{

		}
		*/
		
		//return;
	//}
	
	T_ELEM_D elem_d;
	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;
							 
	int i;
	int nNumDatas;
	T_CUTLINE_D cutlinedata;
	double   local_vector[3][3];
	T_CUTL_D cutline;
	double   DiagVector[3],LineVector[3];
	double   dCutLinePoint1[3];
	double   dCutLinePoint2[3];
	
	double total_max = -DBL_MAX;
	double total_min = DBL_MAX;
	double AbsMax = 0.0;
	double dCutLineAdjustFactor;
		
	for(int nCL = 0; nCL<m_aCutLineMinMax.GetSize(); nCL++) 
	{
		if(total_max<m_aCutLineMinMax[nCL].Max) total_max = m_aCutLineMinMax[nCL].Max;
		if(total_min>m_aCutLineMinMax[nCL].Min) total_min = m_aCutLineMinMax[nCL].Min;
	}
	for(int nCL = 0; nCL<m_aCutLineOnPlaneMinMax.GetSize(); nCL++)
	{
		if(total_max<m_aCutLineOnPlaneMinMax[nCL].Max) total_max = m_aCutLineOnPlaneMinMax[nCL].Max;
		if(total_min>m_aCutLineOnPlaneMinMax[nCL].Min) total_min = m_aCutLineOnPlaneMinMax[nCL].Min;
	}
	AbsMax = __max(fabs(total_max),fabs(total_min));
	InitCutLineAdjustFactor(AbsMax,dCutLineAdjustFactor);
	
	if(m_aCutLines.GetSize() != m_aCutLineMinMax.GetSize() || m_aCutLines.GetSize() != m_aCutLineData.GetSize())  
		ASSERT(0);        
	else
	{     
		/*
		// [2009-11-10] Kim, Geun Young (Tel: 2042, gykim@midasit.com)    
		BOOL bHaveData_Line  = FALSE;  
		for(nCL=0; nCL<m_aCutLineData.GetSize(); nCL++)
		{
			if(m_aCutLineData[nCL]->GetSize() > 0) 
			{
				bHaveData_Line = TRUE;
				break;
			}    
		} 
		if(!bHaveData_Line && m_aCutLineData.GetSize() > 0)     
			GSaveHistoryNF(_LS(IDS_WG_GPS_Warning_Not_Exist_Cutting_Diagram_Result));
		else*/
		{
			// Cutting Line Drawing
			//--------------------------------------------------------------------
	    if(gm->m_nCutLineOrPlane==0)
	    for(int nCL = 0; nCL<m_aCutLines.GetSize(); nCL++)
	    {    
	      cutline = m_aCutLines[nCL];
	    
	      dCutLinePoint1[0] = cutline.Point1[0];
	      dCutLinePoint1[1] = cutline.Point1[1];
	      dCutLinePoint1[2] = cutline.Point1[2];

	      dCutLinePoint2[0] = cutline.Point2[0]; 
	      dCutLinePoint2[1] = cutline.Point2[1]; 
	      dCutLinePoint2[2] = cutline.Point2[2]; 

	      LineVector[0] = dCutLinePoint2[0]-dCutLinePoint1[0];
	      LineVector[1] = dCutLinePoint2[1]-dCutLinePoint1[1];
	      LineVector[2] = dCutLinePoint2[2]-dCutLinePoint1[2];
				
	      int ntype,etype;
	      gm->RE_GetNode_ElemTypeByCDBDocSelection(ntype,etype);
	      nNumDatas = m_aCutLineData[nCL]->GetSize();
	      for(i = 0; i < nNumDatas; i++)
	      {
		      cutlinedata = m_aCutLineData[nCL]->GetAt(i);
		      m_pDoc->m_pAttrCtrl->GetElem(cutlinedata.KeyElem, elem_d);
		      if ( !( gm->m_pGPSCtrl->IsZoomAllState() ||
					    gm->m_pGPSCtrl->IsObjectInClientWindow(etype, cutlinedata.KeyElem)))
		      continue;

					//gm->m_pGPSCtrl->XGL_Begin_Diagram(cutlinedata.KeyElem,
					gm->m_pGPSCtrl->XGL_Begin_Diagram(cutlinedata.KeyElem,FALSE); // 20060224 Changkeun

		      m_pDoc->calcPlaneLocalVector(cutlinedata.KeyElem, local_vector);

		      if(gm->m_nCuttingLineDir == 0) // vertical
		      {
			      DiagVector[0] = local_vector[2][0];
			      DiagVector[1] = local_vector[2][1];
			      DiagVector[2] = local_vector[2][2];
		      }
		      else
		      {
			      CMathFunc::mathCross(LineVector,local_vector[2],DiagVector);
			      CMathFunc::mathNormalize(DiagVector,DiagVector);
		      }

		      if(gm->m_bCutLineReverse)
		      {
			      DiagVector[0] = -DiagVector[0];
			      DiagVector[1] = -DiagVector[1];
			      DiagVector[2] = -DiagVector[2];
		      }

					if(gm->IsMeshDesignMode())
					{
						DiagVector[0] = -DiagVector[0];
						DiagVector[1] = -DiagVector[1];
			      DiagVector[2] = -DiagVector[2];
					}
		    
		      C3DPoint	ps, pss, pe, pee,pm;
		      double dVal1,dVal2;

		      ps = cutlinedata.Point1;
		      pe = cutlinedata.Point2;
		      dVal1 = cutlinedata.dPoint1Val;
		      dVal2 = cutlinedata.dPoint2Val;
		      if (gm->m_AnimEngine.m_bAnimateContour)
		      {
			      dVal1 *= gm->m_AnimEngine.GetAnimationFactor(TRUE);
			      dVal2 *= gm->m_AnimEngine.GetAnimationFactor(TRUE);
		      }
		    
		      CUtilFuncs::GetVectorDirectionPoint(DiagVector,dVal1,gm->m_bCutLineScaleFactor*dCutLineAdjustFactor,ps,pss );
		      CUtilFuncs::GetVectorDirectionPoint(DiagVector,dVal2,gm->m_bCutLineScaleFactor*dCutLineAdjustFactor,pe,pee );
						    
		      ///////////////////////////////////////////////////////////////////////////		
		      CPen pen,*old_pen;
		      pen.CreatePen(PS_SOLID, gm->m_nLineWidth*1.0, gm->m_CuttinLineColor);
	    
		      old_pen = (CPen *) pDC->SelectObject(&pen);

		      if (gm->m_bVirtualMode)
		      {
			      gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, ps, pss);
			      gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, pe, pee);
		      }
		      else
		      { 
			      gm->m_pGPSCtrl->DrawLine3D(pDC, ps, pss);
			      gm->m_pGPSCtrl->DrawLine3D(pDC, pe, pee);

						//-----------------------------------------------------------------------
						// Cutting Line Diagram을 별도로 Rendering 하기 위한 처리 
						//
						gm->m_pGPSCtrl->XGL_AddLine3D_CuttingPLDiagram(
						ps,pss ,gm->m_nLineWidth*1.0,gm->m_CutPlaneColor);

						gm->m_pGPSCtrl->XGL_AddLine3D_CuttingPLDiagram(
						pe,pee ,gm->m_nLineWidth*1.0,gm->m_CutPlaneColor);
						//
						//-----------------------------------------------------------------------
		      }

		      pDC->SelectObject(old_pen);
		      pen.DeleteObject();

		      pen.CreatePen(PS_SOLID, gm->m_nLineWidth*2.0, gm->m_CuttinLineColor);
	    
		      old_pen = (CPen *) pDC->SelectObject(&pen);

		      if (gm->m_bVirtualMode)
		      {
			      gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, pss, pee);
			      gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, ps, pe);
		      }
		      else
		      {
			      gm->m_pGPSCtrl->DrawLine3D(pDC, pss, pee);		
			      gm->m_pGPSCtrl->DrawLine3D(pDC, ps, pe);

						//-----------------------------------------------------------------------
						// Cutting Line Diagram을 별도로 Rendering 하기 위한 처리 
						//
						gm->m_pGPSCtrl->XGL_AddLine3D_CuttingPLDiagram(
						pss,pee ,gm->m_nLineWidth*1.0,gm->m_CutPlaneColor);

						gm->m_pGPSCtrl->XGL_AddLine3D_CuttingPLDiagram(
						ps,pe ,gm->m_nLineWidth*1.0,gm->m_CutPlaneColor);
						//
						//-----------------------------------------------------------------------
		      }
	    
		      pDC->SelectObject(old_pen);
		      pen.DeleteObject();

					gm->m_pGPSCtrl->XGL_End_Elem(FALSE); //20060224 Changkeun
		      ///////////////////////////////////////////////////////////////////////////

					if(gm->m_bCutLineOutputMinMax && gm->m_bCutLineMinMaxOutOnly)
					{
						if(fabs(dVal1-m_aCutLineMinMax[nCL].Max) < 1e-8) 
							OutputCutLineNumber(pDC,&pss,dVal1);
						else if(fabs(dVal1-m_aCutLineMinMax[nCL].Min) < 1e-8) 
							OutputCutLineNumber(pDC,&pss,dVal1);
						if(fabs(dVal2-m_aCutLineMinMax[nCL].Max) < 1e-8) 
							OutputCutLineNumber(pDC,&pee,dVal2);
						else if(fabs(dVal2-m_aCutLineMinMax[nCL].Min) < 1e-8) 
							OutputCutLineNumber(pDC,&pee,dVal2);
		      }
					else if(gm->m_bCutLineOutputMinMax && !gm->m_bCutLineMinMaxOutOnly)
					{
		 	      OutputCutLineNumber(pDC,&pss,dVal1);
						OutputCutLineNumber(pDC,&pee,dVal2);
					}
	      }
			}
		}
	}

	////////////////////////////////////////////////////////////////////////////////////////////
	// Cutting Plane Diagram
	
	CArray <T_NPLN_D,T_NPLN_D&> aCuttingPlane;
	CArray <C3DPoint,C3DPoint&> a_ps;
	CArray <C3DPoint,C3DPoint&> a_pss;
	CArray <C3DPoint,C3DPoint&> a_pe;
	CArray <C3DPoint,C3DPoint&> a_pee;
	CArray <double,double> a_val_s;
	CArray <double,double> a_val_e;

	T_NPLN_D CuttingPlane;
	PLANE_FUNC CuttingPlaneF;
	double dPlaneNormalVector[3],dRotationVector[3],dPlateNormalVector[3];

	int nNumOfCutPlanes;
	
	nNumOfCutPlanes = m_aCutPlanes.GetSize();
	for(int nKey = 0; nKey < nNumOfCutPlanes; nKey++)
	{
	  GetNPLN(m_aCutPlanes[nKey],CuttingPlane);
		aCuttingPlane.Add(CuttingPlane);
	}
	 
	if(gm->m_nCutLineOrPlane==1)
	for(int nPLN = 0; nPLN < nNumOfCutPlanes; nPLN++)
	{
		CuttingPlane = aCuttingPlane[nPLN];
		GetPlaneFunction(CuttingPlane,CuttingPlaneF);
		
		dPlaneNormalVector[0] =CuttingPlaneF.a;
		dPlaneNormalVector[1] =CuttingPlaneF.b;
		dPlaneNormalVector[2] =CuttingPlaneF.c; // CuttingPlane Normal Vector --> Cutting Plane면에 그리는 옵션
	
		a_ps.RemoveAll();
		a_pe.RemoveAll();
		a_pss.RemoveAll();
		a_pee.RemoveAll();
		a_val_s.RemoveAll();
		a_val_e.RemoveAll();

		int ntype,etype;
		gm->RE_GetNode_ElemTypeByCDBDocSelection(ntype,etype);
		nNumDatas = m_aCutLineOnPlaneData[nPLN]->GetSize();
		for(i = 0; i < nNumDatas; i++)
		{
			cutlinedata = m_aCutLineOnPlaneData[nPLN]->GetAt(i);
			m_pDoc->m_pAttrCtrl->GetElem(cutlinedata.KeyElem, elem_d);
			if ( !( gm->m_pGPSCtrl->IsZoomAllState() ||
						gm->m_pGPSCtrl->IsObjectInClientWindow(etype, cutlinedata.KeyElem)))
			continue;

			m_pDoc->calcPlaneLocalVector(cutlinedata.KeyElem, local_vector);

			dPlateNormalVector[0] = local_vector[2][0];
			dPlateNormalVector[1] = local_vector[2][1];
			dPlateNormalVector[2] = local_vector[2][2];
			
			double dAngle;
			if(gm->m_nCutPlaneHorizVert == 1) // Horizontal to Cutting Plane
			{
				dAngle = CMathFunc::mathCrossAngle(dPlaneNormalVector,dPlateNormalVector);
				if(dAngle > 90.0+1e-8) 
				{
					CMathFunc::mathCross(dPlateNormalVector,dPlaneNormalVector,dRotationVector);
					dAngle = dAngle -90.0;
				}
				else
				{
					CMathFunc::mathCross(dPlaneNormalVector,dPlateNormalVector,dRotationVector);
					dAngle = 90.0-dAngle;
				}
				CMathFunc::mathNormalize(dRotationVector,dRotationVector);
			}

			if(gm->m_bCutLineReverse)
			{
				dPlateNormalVector[0] = -dPlateNormalVector[0];
				dPlateNormalVector[1] = -dPlateNormalVector[1];
				dPlateNormalVector[2] = -dPlateNormalVector[2];
			}
						
			
			C3DPoint	ps, pss, pe, pee;
			double dVal1,dVal2;

			ps = cutlinedata.Point1;
			pe = cutlinedata.Point2;
			dVal1 = cutlinedata.dPoint1Val;
			dVal2 = cutlinedata.dPoint2Val;
			if (gm->m_AnimEngine.m_bAnimateContour)
			{
				dVal1 *= gm->m_AnimEngine.GetAnimationFactor(TRUE);
				dVal2 *= gm->m_AnimEngine.GetAnimationFactor(TRUE);
			}
			
			CUtilFuncs::GetVectorDirectionPoint(dPlateNormalVector,dVal1,gm->m_bCutLineScaleFactor*dCutLineAdjustFactor,ps,pss );
			CUtilFuncs::GetVectorDirectionPoint(dPlateNormalVector,dVal2,gm->m_bCutLineScaleFactor*dCutLineAdjustFactor,pe,pee );
			
			if(gm->m_nCutPlaneHorizVert == 1) // Horizontal to Cutting Plane
			{
				CMathFunc::mathRotate(dAngle ,ps.x, ps.y, ps.z, dRotationVector[0],dRotationVector[1],dRotationVector[2],
				  		   pss.x, pss.y, pss.z); //임의 축에 대한 회전, angle:회전각[deg], px,py,pz:회전축상의 한점, ux,uy,uz:회전축 벡터, rx,ry,rz:회전대상 좌표 
				CMathFunc::mathRotate(dAngle ,pe.x, pe.y, pe.z, dRotationVector[0],dRotationVector[1],dRotationVector[2],
				  		   pee.x, pee.y, pee.z); //임의 축에 대한 회전, angle:회전각[deg], px,py,pz:회전축상의 한점, ux,uy,uz:회전축 벡터, rx,ry,rz:회전대상 좌표 
			}

		  

			a_ps.Add(ps);
			a_pss.Add(pss);
			a_pe.Add(pe);
			a_pee.Add(pee);
			a_val_s.Add(dVal1);
			a_val_e.Add(dVal2);

		}
 
		if(gm->m_bDrawPolyLine)
		{
			//////////////////////////////////////////////////////////////////////////////
			// 같은 점들에 대한 평균 단위 벡터를 구한다. 
			// 각 시점과 끝점은 아무 규칙도 없이 배열되어있다.

			C3DPoint unit_vector,vector;
			double dUnit_vector[3];
			double vec1[3],vec2[3];
			CMap <C3DPoint*, C3DPoint*,BOOL,BOOL> mapProcessedPoints;
			CArray <C3DPoint*, C3DPoint*> aPoints;
			CArray <C3DPoint*, C3DPoint*> aEndPoints;
			CArray <C3DPoint, C3DPoint> aVectors;
			

			CArray <double, double> aValues;
			BOOL bValue;
		
			C3DPoint	*prs,*pre,*ps,*pe; // 기준점 pr
			for(i = 0; i < a_ps.GetSize()-1; i++)
			{
				prs = &a_ps[i];
				if(mapProcessedPoints.Lookup(prs,bValue)) continue;
			
				vec1[0] = a_pss[i].x - a_ps[i].x;
				vec1[1] = a_pss[i].y - a_ps[i].y;
				vec1[2] = a_pss[i].z - a_ps[i].z;

				aPoints.RemoveAll();
				aEndPoints.RemoveAll();
				aValues.RemoveAll();
				aVectors.RemoveAll();
			
				for(int j = i+1; j < a_ps.GetSize(); j++)
		    {
							
					ps = &a_ps[j];
					pe = &a_pe[j];

					if(!mapProcessedPoints.Lookup(ps,bValue))
						if(IsSame3DPoint(*prs,*ps)) 
						{
							vec2[0] = a_pss[j].x - a_ps[j].x;
							vec2[1] = a_pss[j].y - a_ps[j].y;
							vec2[2] = a_pss[j].z - a_ps[j].z;

							if(CUtilFuncs::GetCosFrom2Vec(vec1,vec2) > 0.866025)//  cos 30
							{
								aPoints.Add(ps);
								aEndPoints.Add(&a_pss[j]);
								aValues.Add(a_val_s[j]);
								mapProcessedPoints.SetAt(ps,TRUE);

								aPoints.Add(prs);
								aEndPoints.Add(&a_pss[i]);
								aValues.Add(a_val_s[i]);
								mapProcessedPoints.SetAt(prs,TRUE);
							}
						}

					if(!mapProcessedPoints.Lookup(pe,bValue))
						if(IsSame3DPoint(*prs,*pe)) 
						{
							vec2[0] = a_pee[j].x - a_pe[j].x;
							vec2[1] = a_pee[j].y - a_pe[j].y;
							vec2[2] = a_pee[j].z - a_pe[j].z;

							if(CUtilFuncs::GetCosFrom2Vec(vec1,vec2) > 0.866025)//  cos 30
							{
								aPoints.Add(pe);
								aEndPoints.Add(&a_pee[j]);
								aValues.Add(a_val_e[j]);
								mapProcessedPoints.SetAt(pe,TRUE);

								aPoints.Add(prs);
								aEndPoints.Add(&a_pss[i]);
								aValues.Add(a_val_s[i]);
								mapProcessedPoints.SetAt(prs,TRUE);
							}
						}
				}
			
				if(!aPoints.GetSize()) continue;
				for(int j=0; j<aPoints.GetSize(); j++)
				{
					int nSign = 1;
					if(aValues[j] < 0.0) 
						nSign = -1;
							 
					vector.x = nSign*(aEndPoints[j]->x - aPoints[j]->x);
					vector.y = nSign*(aEndPoints[j]->y - aPoints[j]->y);
					vector.z = nSign*(aEndPoints[j]->z - aPoints[j]->z);
				
					CMathFunc::mathNormalize(vector.x, vector.y, vector.z, vector.x, vector.y, vector.z);  //단위벡터로 변환(3d)
					aVectors.Add(vector);
				}

				unit_vector.Init();
				CMathFunc::mathNormalize(unit_vector.x, unit_vector.y, unit_vector.z, unit_vector.x, unit_vector.y, unit_vector.z);  //단위벡터로 변환(3d)
			
				for(int j=0; j<aPoints.GetSize(); j++)
				{
					unit_vector.x += aVectors[j].x;
					unit_vector.y += aVectors[j].y;
					unit_vector.z += aVectors[j].z;
					CMathFunc::mathNormalize(unit_vector.x, unit_vector.y, unit_vector.z, unit_vector.x, unit_vector.y, unit_vector.z);  //단위벡터로 변환(3d)
				}
			
				dUnit_vector[0] = unit_vector.x;
				dUnit_vector[1] = unit_vector.y;
				dUnit_vector[2] = unit_vector.z;
				for(int j=0; j<aPoints.GetSize(); j++)
				{
					CUtilFuncs::GetVectorDirectionPoint(dUnit_vector,aValues[j],gm->m_bCutLineScaleFactor*dCutLineAdjustFactor,*aPoints[j],*aEndPoints[j] );
				}
			}

			for(i = 0; i < a_pe.GetSize()-1; i++)
			{
				pre = &a_pe[i];
				if(mapProcessedPoints.Lookup(pre,bValue)) continue;

				vec1[0] = a_pee[i].x - a_pe[i].x;
				vec1[1] = a_pee[i].y - a_pe[i].y;
				vec1[2] = a_pee[i].z - a_pe[i].z;
			
				aPoints.RemoveAll();
				aEndPoints.RemoveAll();
				aValues.RemoveAll();
				aVectors.RemoveAll();
			
				for(int j = i+1; j < a_ps.GetSize(); j++)
		    {
									
					ps = &a_ps[j];
					pe = &a_pe[j];

					if(!mapProcessedPoints.Lookup(ps,bValue))
						if(IsSame3DPoint(*pre,*ps)) 
						{
							vec2[0] = a_pss[j].x - a_ps[j].x;
							vec2[1] = a_pss[j].y - a_ps[j].y;
							vec2[2] = a_pss[j].z - a_ps[j].z;

							if(CUtilFuncs::GetCosFrom2Vec(vec1,vec2) > 0.866025)//  cos 30
							{
								aPoints.Add(ps);
								aEndPoints.Add(&a_pss[j]);
								aValues.Add(a_val_s[j]);
								mapProcessedPoints.SetAt(ps,TRUE);

								aPoints.Add(pre);
								aEndPoints.Add(&a_pee[i]);
								aValues.Add(a_val_e[i]);
								mapProcessedPoints.SetAt(pre,TRUE);
							}
						}
						

					if(!mapProcessedPoints.Lookup(pe,bValue))
						if(IsSame3DPoint(*pre,*pe)) 
						{
							vec2[0] = a_pee[j].x - a_pe[j].x;
							vec2[1] = a_pee[j].y - a_pe[j].y;
							vec2[2] = a_pee[j].z - a_pe[j].z;

							if(CUtilFuncs::GetCosFrom2Vec(vec1,vec2) > 0.866025)//  cos 30
							{
								aPoints.Add(pe);
								aEndPoints.Add(&a_pee[j]);
								aValues.Add(a_val_e[j]);
								mapProcessedPoints.SetAt(pe,TRUE);

								aPoints.Add(pre);
								aEndPoints.Add(&a_pee[i]);
								aValues.Add(a_val_e[i]);
								mapProcessedPoints.SetAt(pre,TRUE);
							}
						}
						
				}
			
				if(!aPoints.GetSize()) continue;
				for(int j=0; j<aPoints.GetSize(); j++)
				{
					int nSign = 1;
					if(aValues[j] < 0.0) 
						nSign = -1;
				
				
					vector.x = nSign*(aEndPoints[j]->x - aPoints[j]->x);
					vector.y = nSign*(aEndPoints[j]->y - aPoints[j]->y);
					vector.z = nSign*(aEndPoints[j]->z - aPoints[j]->z);
				

					CMathFunc::mathNormalize(vector.x, vector.y, vector.z, vector.x, vector.y, vector.z);  //단위벡터로 변환(3d)
					aVectors.Add(vector);
				}

				unit_vector.Init();
				CMathFunc::mathNormalize(unit_vector.x, unit_vector.y, unit_vector.z, unit_vector.x, unit_vector.y, unit_vector.z);  //단위벡터로 변환(3d)
			
				for(int j=0; j<aPoints.GetSize(); j++)
				{
					unit_vector.x += aVectors[j].x;
					unit_vector.y += aVectors[j].y;
					unit_vector.z += aVectors[j].z;
					CMathFunc::mathNormalize(unit_vector.x, unit_vector.y, unit_vector.z, unit_vector.x, unit_vector.y, unit_vector.z);  //단위벡터로 변환(3d)
				}
			
				dUnit_vector[0] = unit_vector.x;
				dUnit_vector[1] = unit_vector.y;
				dUnit_vector[2] = unit_vector.z;
				for(int j=0; j<aPoints.GetSize(); j++)
				{
					CUtilFuncs::GetVectorDirectionPoint(dUnit_vector,aValues[j],gm->m_bCutLineScaleFactor*dCutLineAdjustFactor,*aPoints[j],*aEndPoints[j] );
				}
			}
		

		}
			
	  ///////////////////////////////////////////////////////////////////////////		
		/// Draw It !

		C3DPoint	Pmax,Pmin; // 인접한 두개의 값이 겹쳐서 나타나는 것을 방지하기 위함 ...
		double    bMaxSame,bMinSame;
		for(i = 0; i < a_ps.GetSize(); i++)
		{
			CPen pen,*old_pen;
			pen.CreatePen(PS_SOLID, gm->m_nLineWidth*1.0, gm->m_CutPlaneColor);
	
			old_pen = (CPen *) pDC->SelectObject(&pen);

			if (gm->m_bVirtualMode)
			{
				gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, a_ps[i], a_pss[i]);
				gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, a_pe[i], a_pee[i]);
			}
			else
			{
				gm->m_pGPSCtrl->DrawLine3D(pDC, a_ps[i], a_pss[i]);
				gm->m_pGPSCtrl->DrawLine3D(pDC, a_pe[i], a_pee[i]);

				//-----------------------------------------------------------------------
				// Cutting Line Diagram을 별도로 Rendering 하기 위한 처리 
				//
				gm->m_pGPSCtrl->XGL_AddLine3D_CuttingPLDiagram(
				a_ps[i], a_pss[i],gm->m_nLineWidth*2.0,gm->m_CutPlaneColor);

				gm->m_pGPSCtrl->XGL_AddLine3D_CuttingPLDiagram(
				a_pe[i], a_pee[i],gm->m_nLineWidth*2.0,gm->m_CutPlaneColor);
				//
				//-----------------------------------------------------------------------
			}

			pDC->SelectObject(old_pen);
			pen.DeleteObject();

			pen.CreatePen(PS_SOLID, gm->m_nLineWidth*2.0, gm->m_CutPlaneColor);
	
			old_pen = (CPen *) pDC->SelectObject(&pen);

			if (gm->m_bVirtualMode)
			{
				gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, a_pss[i], a_pee[i]);
				gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, a_ps[i], a_pe[i]);
			}
			else
			{
				gm->m_pGPSCtrl->DrawLine3D(pDC, a_pss[i], a_pee[i]);		
				gm->m_pGPSCtrl->DrawLine3D(pDC, a_ps[i], a_pe[i]);

				//-----------------------------------------------------------------------
				// Cutting Line Diagram을 별도로 Rendering 하기 위한 처리 
				//
				gm->m_pGPSCtrl->XGL_AddLine3D_CuttingPLDiagram(
				a_pss[i], a_pee[i],gm->m_nLineWidth*2.0,gm->m_CutPlaneColor);

				gm->m_pGPSCtrl->XGL_AddLine3D_CuttingPLDiagram(
				a_ps[i], a_pe[i],gm->m_nLineWidth*2.0,gm->m_CutPlaneColor);
				//
				//-----------------------------------------------------------------------
			}
	
			pDC->SelectObject(old_pen);
			pen.DeleteObject();
			///////////////////////////////////////////////////////////////////////////

			if(gm->m_bCutLineOutputMinMax && gm->m_bCutLineMinMaxOutOnly)
			{
				bMaxSame = IsSame3DPoint(Pmax,a_ps[i]);
				bMinSame = IsSame3DPoint(Pmin,a_ps[i]);

				if(gm->m_bDrawPolyLine)
				{ 
					bMaxSame = FALSE;
					bMinSame = FALSE;
				}
				
				
				if(fabs(a_val_s[i]-m_aCutLineOnPlaneMinMax[nPLN].Max) < 1e-8 && !bMaxSame) 
				{
					OutputCutLineNumber(pDC,&a_pss[i],a_val_s[i]);
					Pmax = a_ps[i];
				}
				else if(fabs(a_val_s[i]-m_aCutLineOnPlaneMinMax[nPLN].Min) < 1e-8 && !bMinSame) 
				{
					OutputCutLineNumber(pDC,&a_pss[i],a_val_s[i]);
					Pmin = a_ps[i];
				}

				bMaxSame = IsSame3DPoint(Pmax,a_pe[i]);
				bMinSame = IsSame3DPoint(Pmin,a_pe[i]);

				if(gm->m_bDrawPolyLine)
				{ 
					bMaxSame = FALSE;
					bMinSame = FALSE;
				}
							 	
				if(fabs(a_val_e[i]-m_aCutLineOnPlaneMinMax[nPLN].Max) < 1e-8 && !bMaxSame) 
				{
					OutputCutLineNumber(pDC,&a_pee[i],a_val_e[i]);
					Pmax = a_pe[i];
				}
				else if(fabs(a_val_e[i]-m_aCutLineOnPlaneMinMax[nPLN].Min) < 1e-8 && !bMinSame) 
				{
					OutputCutLineNumber(pDC,&a_pee[i],a_val_e[i]);
					Pmin = a_pe[i];
				}
			}
			else if(gm->m_bCutLineOutputMinMax && !gm->m_bCutLineMinMaxOutOnly)
			{
				OutputCutLineNumber(pDC,&a_pss[i],a_val_s[i]);
				OutputCutLineNumber(pDC,&a_pee[i],a_val_e[i]);
			}
		}
	}

	
}

#if defined(__OLD_OUTPUT_VALUE)
void CEngineBase::OutputCutLineNumber(CDC* pDC,C3DPoint *txt_pnt,double dValue)
{
	
	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;

	if(!gm->m_bVirtualMode && gm->m_pGPSCtrl->IsGLRenderer() && gm->m_pGPSCtrl->IsXGRMode())
	{
		gm->m_pXGR_GPSDrawMgr->m_OutputCutLineNumber.Add_OutputCutLineNumber(&(txt_pnt->x),dValue);
		return;
	}

	TCHAR							fmt_str[10], text_str[512];
	CPoint							text_p;
	CFont							ft, *old_ft;

	if (gm->m_DOPT.TX.m_bNumberOpaque)
		pDC->SetBkMode(OPAQUE);
	else
		pDC->SetBkMode(TRANSPARENT);

	pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
	pDC->SetBkColor(gm->m_DOPT.TX.m_NumberBackCol);
	
	pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);

	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);

		
	CRect	rct;
	gm->m_pMyView->GetClientRect(&rct);

	gm->SetNumberFontOrientation(0);
	ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
	old_ft = (CFont *) pDC->SelectObject(&ft);
	
	/*
	if (gm->m_bVirtualMode)
		gm->m_pGPSCtrl->DrawNodeInClientWindow(pDC, *txt_pnt);
	else
		gm->m_pGPSCtrl->DrawNode(pDC, *txt_pnt);
		*/

	if (gm->m_bVirtualMode) {
		text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(*txt_pnt);
	}
	else {
		text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(*txt_pnt);
	}
	
	
	_stprintf(text_str, fmt_str,dValue);
		
	if(text_p.x >0 && text_p.y>0) 
	  pDC->TextOut(text_p.x, text_p.y, text_str);
	
	pDC->SelectObject(old_ft);
	ft.DeleteObject();

}
#else
void CEngineBase::OutputCutLineNumber(CDC* pDC, C3DPoint *txt_pnt, double dValue)
{

	I_GPSModel		*gm = (I_GPSModel *)m_pGPSModel;

	if (!gm->m_bVirtualMode && gm->m_pGPSCtrl->IsGLRenderer() && gm->m_pGPSCtrl->IsXGRMode())
	{
		gm->m_pXGR_GPSDrawMgr->m_OutputCutLineNumber.Add_OutputCutLineNumber(&(txt_pnt->x), dValue);
		return;
	}

	TCHAR							fmt_str[10], text_str[512];
	CPoint							text_p;
	CFont							ft, *old_ft;

	GPostTextOut TextOutModel;
	TextOutModel.SetDC(pDC);

	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);


	CRect	rct;
	gm->m_pMyView->GetClientRect(&rct);

	/*
	if (gm->m_bVirtualMode)
		gm->m_pGPSCtrl->DrawNodeInClientWindow(pDC, *txt_pnt);
	else
		gm->m_pGPSCtrl->DrawNode(pDC, *txt_pnt);
		*/

	if (gm->m_bVirtualMode) {
		text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(*txt_pnt);
	}
	else {
		text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(*txt_pnt);
	}


	_stprintf(text_str, fmt_str, dValue);

	if (text_p.x > 0 && text_p.y > 0)
		TextOutModel.TextOutCutLine(gm, text_p.x, text_p.y, text_str);

	TextOutModel.DeleteFont();

}
#endif

/*
protected:
	CArray<double,double> m_XGL_SavedCuttingLineData; // x,y,z,value , x,y,z,value ...으로 구성...
	void XGL_InitSavedCuttingLienData();
protected:
	void XGL_DrawSavedCuttingLineData(CDC* pDC); // SavedCuttingLineData가 있을때만 Rendering한다.
*/

void CEngineBase::InitCutLineAdjustFactor(double dMax,double& dCutLineAdjustFactor)
{
	C3DPoint	min_p, max_p;
	double		max_l;

//	((I_GPSModel *) m_pGPSModel)->m_pGPSCtrl->GetModelBoundary(min_p, max_p);
//	((I_GPSModel *) m_pGPSModel)->GetDBDoc()->calcRangeModel(min_p.x, min_p.y, min_p.z, max_p.x, max_p.y, max_p.z,
//															 NULL, NULL, TRUE, NULL, TRUE,
//															 ((I_GPSModel *) m_pGPSModel)->m_bFrameThick||((I_GPSModel *) m_pGPSModel)->m_bPlaneThick);
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	gm->GetRangeModel(&min_p,&max_p);
	max_l = max(max(max_p.x-min_p.x, max_p.y-min_p.y), max_p.z-min_p.z);

	if (dMax > -1e-15 && dMax < 1e-15)
		dMax = 1.0f;

	// 최대값이 전체모델의 1/15의 크기로 나오도록...
	dCutLineAdjustFactor = max_l / fabs(dMax) / 15.0;
}


BOOL CEngineBase::IsSame3DPoint(C3DPoint &p1, C3DPoint &p2)
{
	const double dTolerance = 1e-8;
	if( fabs(p1.x-p2.x) > dTolerance) return FALSE;
	if( fabs(p1.y-p2.y) > dTolerance) return FALSE;
	if( fabs(p1.z-p2.z) > dTolerance) return FALSE;

	return TRUE;

}

BOOL CEngineBase::GetNPLN(T_NPLN_K NplnKey, T_NPLN_D &NplnData)
{
	NplnData.Initialize();
 
	switch(NplnKey)
	{
	case UCS_XY: // UCS X-Y
		NplnData.PlaneName = _LS(IDS_WG_GPS_Current_UCS_x_y_Plane);
		break;
	case UCS_XZ: // UCS X-Z
		NplnData.PlaneName = _LS(IDS_WG_GPS_Current_UCS_x_z_Plane);
		break;
	case UCS_YZ: // UCS Y-Z
		NplnData.PlaneName = _LS(IDS_WG_GPS_Current_UCS_y_z_Plane);
		break;
	default:
	return m_pDoc->m_pAttrCtrl->GetNpln(NplnKey,NplnData);
	}

	// UCS Planes Setting;

	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;

	C3DPoint OriginPoint,UCSXVect,UCSYVect,UCSZVect;
	C3DPoint Point0,Point1,Point2;
	C3DPoint wPoint0,wPoint1,wPoint2;
	gm->m_pGPSCtrl->GetCurUcsData(OriginPoint,UCSXVect,UCSYVect,UCSZVect);

	NplnData.nPlaneType = 1;

	Point0.x = 0.0;
	Point0.y = 0.0;
	Point0.z = 0.0;
	// get start point in UCS
	switch(NplnKey)
	{
		case UCS_XY: 
		Point1.x = 0.0;
		Point1.y = 10.0;
		Point1.z = 0.0;
	
		Point2.x = 10.0;
		Point2.y = 0.0;
		Point2.z = 0.0;
		 break;
		 case UCS_YZ:
		
		Point1.x = 0.0;
		Point1.y = 0.0;
		Point1.z = 10.0;
	
		Point2.x = 0.0;
		Point2.y = 10.0;
		Point2.z = 0.0;
		break;
		case UCS_XZ: 
		Point1.x = 10.0;
		Point1.y = 0.0;
		Point1.z = 0.0;
	
		Point2.x = 0.0;
		Point2.y = 0.0;
		Point2.z = 10.0;
			break;
	}

	
	gm->m_pGPSCtrl->CalcFromUcsToWcs(Point0,wPoint0);
	gm->m_pGPSCtrl->CalcFromUcsToWcs(Point1,wPoint1);
	gm->m_pGPSCtrl->CalcFromUcsToWcs(Point2,wPoint2);

	NplnData.dPoint[0][0] = wPoint0.x;
	NplnData.dPoint[0][1] = wPoint0.y;
	NplnData.dPoint[0][2] = wPoint0.z;
	
	NplnData.dPoint[1][0] = wPoint1.x;
	NplnData.dPoint[1][1] = wPoint1.y;
	NplnData.dPoint[1][2] = wPoint1.z;
	
	NplnData.dPoint[2][0] = wPoint2.x;
	NplnData.dPoint[2][1] = wPoint2.y;
	NplnData.dPoint[2][2] = wPoint2.z;

	
	return TRUE;
	
}

#if defined(__OLD_OUTPUT_VALUE)
void CEngineBase::DrawMinMaxOutputValue(CDC *pDC, C3DPoint point, TCHAR * fmt_str,int nMaxMin,double dValue)
{
	I_GPSModel						*gm=(I_GPSModel *) m_pGPSModel;
	
	int pos=0;
	CPoint text_p;

	TCHAR text_str[255];
	if (gm->m_bVirtualMode)
		 text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(point);
	else
	   text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(point);
	if(text_p.x <0 || text_p.y<0) return;
	
	if(nMaxMin == 0) // max
		pos = _stprintf(text_str, _LS(IDS_WG_GPS_Max_));
	else if(nMaxMin == 1) // min
		pos = _stprintf(text_str, _LS(IDS_WG_GPS_Min_));
	else if(nMaxMin == 2) // abs max
		pos = _stprintf(text_str, _LS(IDS_WG_GPS_MAX_));
 
	_stprintf(text_str+pos, fmt_str,dValue );
	pDC->TextOut(text_p.x, text_p.y, text_str);

	CPen pen;
	pen.CreatePen(PS_SOLID,2,gm->m_DOPT.TX.m_NumberTextColorC);
	
	int dc_save = pDC->SaveDC();
	pDC->SelectObject(&pen);
	if (gm->m_bVirtualMode)
		gm->m_pGPSCtrl->DrawCrossInClientWindow(pDC, point,8);
	else
		gm->m_pGPSCtrl->DrawCross(pDC, point,8);

	pDC->RestoreDC(dc_save);
	pen.DeleteObject();

}
#else
void CEngineBase::DrawMinMaxOutputValue(CDC *pDC, C3DPoint point, TCHAR * fmt_str, int nMaxMin, double dValue)
{
	I_GPSModel						*gm = (I_GPSModel *)m_pGPSModel;

	int pos = 0;
	CPoint text_p;

	TCHAR text_str[255];
	if (gm->m_bVirtualMode)
		text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(point);
	else
		text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(point);
	if (text_p.x < 0 || text_p.y < 0) return;

	if (nMaxMin == 0) // max
		pos = _stprintf(text_str, _LS(IDS_WG_GPS_Max_));
	else if (nMaxMin == 1) // min
		pos = _stprintf(text_str, _LS(IDS_WG_GPS_Min_));
	else if (nMaxMin == 2) // abs max
		pos = _stprintf(text_str, _LS(IDS_WG_GPS_MAX_));

	_stprintf(text_str + pos, fmt_str, dValue);
	GPostTextOut TextOutModel;
	TextOutModel.SetDC(pDC);
	TextOutModel.TextOutMinMax(text_p.x, text_p.y, text_str);

	CPen pen;
	pen.CreatePen(PS_SOLID, 2, gm->m_DOPT.TX.m_NumberTextColorC);

	int dc_save = pDC->SaveDC();
	pDC->SelectObject(&pen);
	if (gm->m_bVirtualMode)
		gm->m_pGPSCtrl->DrawCrossInClientWindow(pDC, point, 8);
	else
		gm->m_pGPSCtrl->DrawCross(pDC, point, 8);

	pDC->RestoreDC(dc_save);
	pen.DeleteObject();

}
#endif

int CEngineBase::GetCountLlan4Inf()
{
	// 일반 Lane + 최적옵션시 추가Lane
	CArray<T_LLAN_K, T_LLAN_K> KeyList; KeyList.RemoveAll();
	m_pDoc->m_pAttrCtrl->GetLlanKeyList(KeyList);

	T_LLAN_D rData; rData.Initialize();
	int nSizeLlan4Inf = 0;
	for(int i=0; i<KeyList.GetSize(); i++ )
	{
		nSizeLlan4Inf +=1;

		T_LLAN_K Key =  KeyList[i];
		rData.Initialize();
		m_pDoc->m_pAttrCtrl->GetLlan(Key, rData);

		if(rData.bAutoOptimize) nSizeLlan4Inf +=2;

	}

	return nSizeLlan4Inf;
}

int CEngineBase::GetCountSlan4Inf()
{
	// 일반 Lane + 최적옵션시 추가Lane
	CArray<T_SLAN_K, T_SLAN_K> KeyList; KeyList.RemoveAll();
	m_pDoc->m_pAttrCtrl->GetSlanKeyList(KeyList);

	T_SLAN_D rData; rData.Initialize();
	int nSizeLlan4Inf = 0;
	for(int i=0; i<KeyList.GetSize(); i++ )
	{
		nSizeLlan4Inf +=1;

		T_SLAN_K Key =  KeyList[i];
		rData.Initialize();
		m_pDoc->m_pAttrCtrl->GetSlan(Key, rData);

		if(rData.bAutoOptimize) nSizeLlan4Inf +=2;
	}

	return nSizeLlan4Inf;

}

/////////////////////////////////////////////////////////////////////
/* OLD
void CEngineBase::moving_load_tracer(char* filename,int fn_len,int type, int number, int component, int loadcase, int* N_lane, double* F_max, double* F_min, int max_lane[100][10], int min_lane[100][10])
// * INPUT VALUE
// filename: full path name without extension
// type - 1: displacement
//      - 2: reaction
//      - 3: truss
//      - 4: beam
//      - 5: plate
//      - 6: skewed reaction
// number: number (serial number in type)
// component
// loadcase: load case number
// * OUTPUT VALUE
// N_lane: number of lanes
// F_max, F_min
// max_lane, min_lane
{
	//int max_lane_array[100*5], min_lane_array[100*5];
	int max_lane_array[100*10], min_lane_array[100*10]; // 행:lane 열:하중유형
#ifdef _CIVIL
	int nProgType = 1;
#else
	int nProgType = 0;
#endif

	//MOV_KRNL(filename, fn_len, type, number, component, loadcase, N_lane, F_max, F_min, max_lane_array, min_lane_array,nProgType);
	//MOV_KRNL(filename, fn_len, type, number, component, loadcase, N_lane, F_max, F_min, max_lane_array, min_lane_array,nProgType);
 
	I_GPSModel *gm=(I_GPSModel *) m_pGPSModel;
	gm->m_pMyView->BeginWaitCursor();

	//MOV_KRNL(filename, fn_len, type, number, component, loadcase, N_lane, F_max, F_min, max_lane_array, min_lane_array,nProgType);
	int index = 0;
	for (int l=0; l<(*N_lane); l++)
	{
		//for (int k=0; k<5; k++)
		for (int k=0; k<10; k++)
		{
			max_lane[l][k] = max_lane_array[index];
			min_lane[l][k] = min_lane_array[index];
			index++;
		}
	}
	gm->m_pMyView->EndWaitCursor();

} // end: moving_load_tracer()
*/
/////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////////////
// MOVING LOAD TRACER ROUTINES

// MOVING LOAD TRACER 데이터를 만든다.
BOOL CEngineBase::MakeMvlTrcDataPreparation(int nGPSInstruction)
{
	// virtual 
	return TRUE;
}

void CEngineBase::DrawMvltrcSurfDistLoads(CDC *pDC, CArray<C3DPoint,C3DPoint&>& arPoints,CArray<double,double>& arValues)
{
	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;
	
	int dpi = (int) ((double) pDC->GetDeviceCaps(LOGPIXELSX)/10.0);
	CPoint Point,Point_e;
	C3DPoint Point3d,Point3d_e,Point3d_s;
	CPen load_pen,*old_pen;
	double dMax = 1e-15;
	CPoint NumberPoint;
	CPoint Triangle[3];
	
	
 	//load_pen.CreatePen(PS_SOLID, gm->m_nLineWidth*1.5, gm->m_MVLTRCDistColor);
	load_pen.CreatePen(PS_SOLID, gm->m_nLineWidth*1.5, gm->m_DOPT.CL.m_MVLTRCDistColor);
	old_pen = (CPen *) pDC->SelectObject(&load_pen);
	

	// Values를 Maximum값으로 Normalize
	for(int i=0; i<arValues.GetSize(); i++)
		if(fabs(arValues[i])>dMax) dMax = arValues[i];

	if(dMax == 0.0) dMax = 1;
	double dMvlTrcAdjustFactor = m_dMaxModelLength/12.0;// 가장 큰 값이 모델 Range의 1/10의 크기가 되게 한다.
	for(int i=0; i<arPoints.GetSize(); i++)
	{

		if(arValues[i] == 0.0) continue;
		
		Point3d = arPoints[i];
		Point3d_s = Point3d_e = Point3d;
		Point3d_e.z = Point3d.z + dMvlTrcAdjustFactor*arValues[i]*m_dMVLTRCScaleFactor/dMax;
		
		if (gm->m_bVirtualMode)
		{
		  Point = gm->m_pGPSCtrl->GetWorldToWindowP2D(Point3d);
			Point_e = gm->m_pGPSCtrl->GetWorldToWindowP2D(Point3d_e);
		}
	  else 
		{
			Point = gm->m_pGPSCtrl->GetWorldToMemDCP2D(Point3d);
			Point_e = gm->m_pGPSCtrl->GetWorldToMemDCP2D(Point3d_e);
		}
		
		if(Point.x >=0 && Point.y >= 0)
		{
			// Draw Load Arrow
			(CPen *) pDC->SelectObject(&load_pen);
			if (gm->m_bVirtualMode)
			  gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, Point3d_s, Point3d_e);
		  else
			  gm->m_pGPSCtrl->DrawLine3D(pDC, Point3d_s, Point3d_e);

	    DrawPoint(pDC,Point3d_e,dpi*0.3,1);
			DrawPoint(pDC,Point3d,dpi*0.8);
			NumberPoint.x = Point_e.x;
			NumberPoint.y = Point_e.y - dpi;

			//XGLRenderer
			//if(m_bMVLTRCValue) OutputNumberOn2DPoint(pDC,NumberPoint,arValues[i],TRUE);
			if(m_bMVLTRCValue)
			{
				CString csValue,csFmt;
				if(m_nMVLTRCValueType == 0) csFmt.Format(_T("%s%de"), _T("%."), m_nMVLTRCValueDePt);
	      else		                    csFmt.Format(_T("%s%df"), _T("%."), m_nMVLTRCValueDePt);
				csValue.Format(csFmt,arValues[i]);
				//OutputNumberOn2DPoint(pDC,Point3d_e,arValues[i],-dpi,TRUE);
				OutputStringOn2DPoint(pDC,Point3d_e,csValue,-dpi,TRUE);
			}
		}

	}
	
	pDC->SelectObject(old_pen);
	load_pen.DeleteObject();
	
}


//void CEngineBase::OutputNumberOn2DPoint(CDC *pDC,CPoint point,double dValue,BOOL bVertical)
void CEngineBase::OutputNumberOn2DPoint(CDC *pDC,C3DPoint& point3d,double dValue,int yOffset,BOOL bVertical)
{// for MVLTRC Load Value
	I_GPSModel				*gm=(I_GPSModel *) m_pGPSModel;
	
	//XGLRenderer
	if(!gm->m_bVirtualMode && gm->m_pGPSCtrl->IsGLRenderer() && gm->m_pGPSCtrl->IsXGRMode())
	{
		gm->m_pXGR_GPSDrawMgr->m_DrawOutputNumberOn2DPoint.Add_DrawOutputNumberOn2DPoint(&(point3d.x),dValue,yOffset,bVertical);
		return;
	}
	
	CPoint point;
	if (gm->m_bVirtualMode)
	  point = gm->m_pGPSCtrl->GetWorldToWindowP2D(point3d);
	else 
		point = gm->m_pGPSCtrl->GetWorldToMemDCP2D(point3d);
	
	point.y += yOffset;
	//XGLRenderer end
	
	TCHAR							text_str[512];
	CFont							ft, *old_ft;

	if(point.x < 0 || point.y< 0 ) return;
	if(bVertical)
	  	gm->SetNumberFontOrientation(900);
	else
			gm->SetNumberFontOrientation(0);
	ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
	old_ft = (CFont *) pDC->SelectObject(&ft);
	if (gm->m_DOPT.TX.m_bNumberOpaque)
		pDC->SetBkMode(OPAQUE);
	else
		pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
	pDC->SetBkColor(gm->m_DOPT.TX.m_NumberBackCol);
	if(bVertical)
		pDC->SetTextAlign(TA_LEFT|TA_TOP);
	else
		pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);

	
	_stprintf(text_str,_T("%.8g"),dValue );
	pDC->TextOut(point.x, point.y, text_str);
	

	pDC->SelectObject(old_ft);
	ft.DeleteObject();

	gm->m_NumberFont.lfEscapement = gm->m_NumberFont.lfOrientation = 0;
}

//void CEngineBase::OutputStringOn2DPoint(CDC *pDC,CPoint point,CString sValue,BOOL bVertical)
void CEngineBase::OutputStringOn2DPoint(CDC *pDC,C3DPoint& point3d,CString sValue,int yOffset,BOOL bVertical)
{
	I_GPSModel				*gm=(I_GPSModel *) m_pGPSModel;
	
	//XGLRenderer
	if(!gm->m_bVirtualMode && gm->m_pGPSCtrl->IsGLRenderer() && gm->m_pGPSCtrl->IsXGRMode())
	{
		gm->m_pXGR_GPSDrawMgr->m_DrawOutputStringOn2DPoint.Add_DrawOutputStringOn2DPoint(&(point3d.x),sValue,yOffset,bVertical);
		return;
	}
	
	CPoint point;
	if (gm->m_bVirtualMode)
	  point = gm->m_pGPSCtrl->GetWorldToWindowP2D(point3d);
	else 
		point = gm->m_pGPSCtrl->GetWorldToMemDCP2D(point3d);
	
	point.y += yOffset;
	
	TCHAR							text_str[512];
	CFont							ft, *old_ft;

	if(point.x < 0 || point.y< 0 ) return;
	if(bVertical)
	  	gm->SetNumberFontOrientation(900);
	else
			gm->SetNumberFontOrientation(0);
	ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
	old_ft = (CFont *) pDC->SelectObject(&ft);
	if (gm->m_DOPT.TX.m_bNumberOpaque)
		pDC->SetBkMode(OPAQUE);
	else
		pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
	pDC->SetBkColor(gm->m_DOPT.TX.m_NumberBackCol);
	if(bVertical)
		pDC->SetTextAlign(TA_LEFT|TA_TOP);
	else
		pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);

	
	_stprintf(text_str,_T("%s"),(LPCTSTR)sValue);
	pDC->TextOut(point.x, point.y, text_str);
	

	pDC->SelectObject(old_ft);
	ft.DeleteObject();

	gm->m_NumberFont.lfEscapement = gm->m_NumberFont.lfOrientation = 0;
}

#if defined(__OLD_OUTPUT_VALUE)
void CEngineBase::OutputInflLineNumbers(CDC *pDC)
{
	I_GPSModel						*gm=(I_GPSModel *) m_pGPSModel;
	
	int     						key;
	C3DPoint						point3d;
	CPoint							text_p;
	TCHAR							fmt_str[10], text_str[512];
	CFont							ft, *old_ft;

	if(m_mapBeamPosToValueforValueOut.GetCount() == 0) return;

	gm->SetNumberFontNodeOrientation(0);
	ft.CreatePointFontIndirect(&gm->m_NumberFontNode, pDC);
	old_ft = (CFont *) pDC->SelectObject(&ft);
	if (gm->m_DOPT.TX.m_bNumberOpaqueNode)
		pDC->SetBkMode(OPAQUE);
	else
		pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorNode);
	pDC->SetBkColor(gm->m_DOPT.TX.m_NumberBackColNode);
	pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);

	// 지수형태로 출력인가?
	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);

	
	double dValue;
	
	POSITION pos = m_mapBeamPosToValueforValueOut.GetStartPosition();
	while(pos!=NULL) {
		m_mapBeamPosToValueforValueOut.GetNextAssoc(pos,key,dValue);
		m_mapBeamPosToVertexforValueOut.Lookup(key,point3d);
		
		if(gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
		{
			double dLimit = (m_dMaxValue-m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;
			
			switch(gm->m_DOPT.TX.m_nOutputMinMaxType)
			{
			case 0: // Min & Max
				if((m_dMaxValue-dValue) <= dLimit)
					 DrawMinMaxOutputValue(pDC,point3d,fmt_str,0,dValue);
				else if((dValue-m_dMinValue) <= dLimit)
					 DrawMinMaxOutputValue(pDC,point3d,fmt_str,1,dValue);
				break;
			case 1: // Abs Max
				if(fabs(m_dMaxValue) >= fabs(m_dMinValue))
				{
					if( fabs(m_dMaxValue)-fabs(dValue) <= dLimit)
					 DrawMinMaxOutputValue(pDC,point3d,fmt_str,2,dValue);
				}
				else
				{
					 if( fabs(m_dMinValue)-fabs(dValue) <= dLimit)
					 DrawMinMaxOutputValue(pDC,point3d,fmt_str,2,dValue);
				}
				break;
			case 2: // Max
				if((m_dMaxValue-dValue) <= dLimit)
					 DrawMinMaxOutputValue(pDC,point3d,fmt_str,0,dValue);
				break;
			case 3: // Min
				if((dValue-m_dMinValue) <= dLimit)
					 DrawMinMaxOutputValue(pDC,point3d,fmt_str,1,dValue);
				break;
			}

				
			continue;  
		}

		if (gm->m_bVirtualMode)
			text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(point3d);
		else
			text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(point3d);

		if(text_p.x<0 || text_p.y<0) continue;	  
		_stprintf(text_str, fmt_str,dValue );
		pDC->TextOut(text_p.x, text_p.y, text_str);
	}

	pDC->SelectObject(old_ft);
	ft.DeleteObject();

	
}
#else
void CEngineBase::OutputInflLineNumbers(CDC* pDC)
{
	I_GPSModel* gm = (I_GPSModel*)m_pGPSModel;

	int     						key;
	C3DPoint						point3d;
	CPoint							text_p;
	TCHAR							fmt_str[10], text_str[512];
	CFont							ft, * old_ft;

	if (m_mapBeamPosToValueforValueOut.GetCount() == 0) return;

	GPostTextOut TextOutModel;
	TextOutModel.SetDC(pDC);
	TextOutModel.StartInflLineVal();
	TextOutModel.SettingInflLine(gm);

	// 지수형태로 출력인가?
	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);


	double dValue;

	POSITION pos = m_mapBeamPosToValueforValueOut.GetStartPosition();
	while (pos != NULL) {
		m_mapBeamPosToValueforValueOut.GetNextAssoc(pos, key, dValue);
		m_mapBeamPosToVertexforValueOut.Lookup(key, point3d);

		if (gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
		{
			double dLimit = (m_dMaxValue - m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;

			switch (gm->m_DOPT.TX.m_nOutputMinMaxType)
			{
			case 0: // Min & Max
				if ((m_dMaxValue - dValue) <= dLimit)
					DrawMinMaxOutputValue(pDC, point3d, fmt_str, 0, dValue);
				else if ((dValue - m_dMinValue) <= dLimit)
					DrawMinMaxOutputValue(pDC, point3d, fmt_str, 1, dValue);
				break;
			case 1: // Abs Max
				if (fabs(m_dMaxValue) >= fabs(m_dMinValue))
				{
					if (fabs(m_dMaxValue) - fabs(dValue) <= dLimit)
						DrawMinMaxOutputValue(pDC, point3d, fmt_str, 2, dValue);
				}
				else
				{
					if (fabs(m_dMinValue) - fabs(dValue) <= dLimit)
						DrawMinMaxOutputValue(pDC, point3d, fmt_str, 2, dValue);
				}
				break;
			case 2: // Max
				if ((m_dMaxValue - dValue) <= dLimit)
					DrawMinMaxOutputValue(pDC, point3d, fmt_str, 0, dValue);
				break;
			case 3: // Min
				if ((dValue - m_dMinValue) <= dLimit)
					DrawMinMaxOutputValue(pDC, point3d, fmt_str, 1, dValue);
				break;
			}


			continue;
		}

		if (gm->m_bVirtualMode)
			text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(point3d);
		else
			text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(point3d);

		if (text_p.x < 0 || text_p.y < 0) continue;
		_stprintf(text_str, fmt_str, dValue);
		TextOutModel.TextOutInflLine(text_p.x, text_p.y, text_str);
	}
	TextOutModel.DeleteFont();
	TextOutModel.EndInflLineVal();
}
#endif


void CEngineBase::GetFlatShadingFactor(int nVertex, C3DPoint Vertex[],double& dDiffuse,double& dSpecular)
{
	((I_GPSModel*)m_pGPSModel)->GetFlatShadingFactor(nVertex,Vertex,dDiffuse,dSpecular);
}



//----------------------------------------------------------------------
// DATE : 2002.05.25  by KYE-HONG
// DESC : Cutting Line데이타와 Cutting Plane데이타를 갖고 
//        와서 Active된 Plate요소중 Cutting되는 점의 좌표와 
//        Force값을 구하여 Drawing Data를 구성하는 함수 
//----------------------------------------------------------------------
void CEngineBase::MakeCuttingLineData(CArray<CArray <T_CUTLINE_D,T_CUTLINE_D&> *, CArray <T_CUTLINE_D,T_CUTLINE_D&> *>& raCutLineData)
{
	I_GPSModel	*gm=(I_GPSModel *)m_pGPSModel;
	
	int	i,j;
	int node_in_elem,elem_num;

	T_ELEM_D	elem_d;
	T_CUTL_D  cutline;
	T_NODE_D	node_d1,node_d2;
	T_CUTL_K  KeyCutLine;
	T_CUTL_D  DataCutLine;
	T_CUTLINE_D CutLineData;
	T_CUTLINE_MINMAX_D CutLineMinMax;
	
	C3DPoint Point3d3;
	double dTolerance; 
	double dPoint1[3],dPoint2[3],dPoint3[3],dCutLineVector[2];
	double dCutLinePoint1[3],dCutLinePoint2[3];
	double dDistance,dCutValue,d1,d2;
	double dPlateCutVal1,dPlateCutVal2;
	CArray <C3DPoint,C3DPoint&> aCutPoints;
	CArray <double,double> aCutValues;
	CList <C3DPoint, C3DPoint> CutPointsList;
	CArray <T_CUTLINE_D,T_CUTLINE_D&> *paCutLineData;
	
	ResetCuttingLineData();

	// 1mm고정단위의 Tolerance를 구해옴 
	dTolerance=m_pDoc->m_pFlagCtrl->GetGeneralCoordinateToleranceCurrentUnit();

	// Cutting Line Data추가 
	m_aCutLines.RemoveAll();
	for( i=0; i<gm->m_aCutLineKeys.GetSize(); i++)
	{
		KeyCutLine = gm->m_aCutLineKeys[i];
		m_pDoc->m_pAttrCtrl->GetCutl(KeyCutLine,DataCutLine);
		m_aCutLines.Add(DataCutLine);
	}

	// Cutting Plane Data추가 
	m_aCutPlanes.Copy(gm->m_aCutPlanes);
	
	////////////////////////////////////////////////////////////
	// CUTTING LINE
	////////////////////////////////////////////////////////////
	int nNumCutLines = m_aCutLines.GetSize();
	for(int nCL=0; nCL<nNumCutLines; nCL++)
	{
		paCutLineData = new CArray<T_CUTLINE_D,T_CUTLINE_D&>;
		raCutLineData.Add(paCutLineData);
		double CutLineMax = -DBL_MAX;
		double CutLineMin =  DBL_MAX;

		cutline = m_aCutLines[nCL];
		
		dCutLinePoint1[0] = cutline.Point1[0];
		dCutLinePoint1[1] = cutline.Point1[1];
		dCutLinePoint1[2] = cutline.Point1[2];

		dCutLinePoint2[0] = cutline.Point2[0]; 
		dCutLinePoint2[1] = cutline.Point2[1]; 
		dCutLinePoint2[2] = cutline.Point2[2]; 

		
		//임시로 CutLine을 양단 방향으로 늘려준다. 이렇게 하는 
		//이유는 Cutting Line의 끝에서는 만나는 요소의 
		//한변에서 오차가 발생하는 경우가 있기때문이다. 

		dCutLineVector[0] = dCutLinePoint2[0] - dCutLinePoint1[0];
		dCutLineVector[1] = dCutLinePoint2[1] - dCutLinePoint1[1];

		C3DPoint ptTemp1,ptTemp2;
		double dVec[2][3];
		double dLeng;
		for(int ttt=0; ttt<3; ttt++)
		{
			dVec[0][ttt] = dCutLinePoint2[ttt]-dCutLinePoint1[ttt]; //P1->P2;
			dVec[1][ttt] = dCutLinePoint1[ttt]-dCutLinePoint2[ttt]; //P2->P1; 
		}
		dLeng = sqrt(pow(dCutLinePoint2[2]-dCutLinePoint1[2],2)+
								 pow(dCutLinePoint2[1]-dCutLinePoint1[1],2)+
								 pow(dCutLinePoint2[0]-dCutLinePoint1[0],2));  
		
		ptTemp1.x= dCutLinePoint2[0];
		ptTemp1.y= dCutLinePoint2[1];
		ptTemp1.z= dCutLinePoint2[2];
		CUtilFuncs::GetVectorDirectionPoint(dVec[0],dLeng/1000000. ,1, ptTemp1, ptTemp2);
		dCutLinePoint2[0] = ptTemp2.x;
		dCutLinePoint2[1] = ptTemp2.y;
		dCutLinePoint2[2] = ptTemp2.z;

		ptTemp1.x= dCutLinePoint1[0];
		ptTemp1.y= dCutLinePoint1[1];
		ptTemp1.z= dCutLinePoint1[2];
		CUtilFuncs::GetVectorDirectionPoint(dVec[1],dLeng/1000000. ,1, ptTemp1, ptTemp2);
		dCutLinePoint1[0] = ptTemp2.x;
		dCutLinePoint1[1] = ptTemp2.y;
		dCutLinePoint1[2] = ptTemp2.z;
		// Cutting Line늘리기 끝 
		

		// Active된 plate element를 돌면서 
		// Cutting Line과 만나는 점들의 위치를 구하고
		// 그 위치에서의 force값을 저장한다. 
		// 한요소를 지났을때.. 만일 Cutting Line에 
		// 걸리는 요소의 경우 반드시 Cutting Line과 
		// 두개의 교차점을 갖고 있어야 함 
		elem_num = m_PlateKeyList.GetSize();
		for(int elem=0; elem<elem_num; elem++) 
		{
			aCutPoints.RemoveAll();
			aCutValues.RemoveAll();
			// Active된 plate element의 정보를 갖고옴 
			m_pDoc->m_pAttrCtrl->GetElem(m_PlateKeyList[elem], elem_d);
							
			node_in_elem = m_pDoc->m_pAttrCtrl->GetNumNode(elem_d.eltyp, elem_d.elnod);
			for(i=0; i<node_in_elem; i++)
			{
				m_pDoc->m_pAttrCtrl->GetNode(elem_d.elnod[i],node_d1);
				j = (i==node_in_elem-1)? 0:(i+1);
				m_pDoc->m_pAttrCtrl->GetNode(elem_d.elnod[j],node_d2);

				
				dPoint1[0] = node_d1.x;
				dPoint1[1] = node_d1.y;
				dPoint1[2] = node_d1.z;

				dPoint2[0] = node_d2.x;
				dPoint2[1] = node_d2.y;
				dPoint2[2] = node_d2.z;

				BOOL bIntersect = CMathFunc::mathIntersectLine2(dCutLinePoint1,dCutLinePoint2,dPoint1,dPoint2,dTolerance,dDistance,dPoint3);
				if(bIntersect)
				{
					
					if(!GetNodalValueforCutting(m_PlateKeyList[elem],dPlateCutVal1,i,dPlateCutVal2,j))
						continue; // virtual
					
					d1 = CMathFunc::mathLength(dPoint3[0],dPoint3[1],dPoint3[2],
								dPoint1[0],dPoint1[1],dPoint1[2]);
					d2 = CMathFunc::mathLength(dPoint3[0],dPoint3[1],dPoint3[2],
								dPoint2[0],dPoint2[1],dPoint2[2]);
					
							
					dCutValue = dPlateCutVal1 + (dPlateCutVal2-dPlateCutVal1)*d1/(d1+d2);
					Point3d3.x = dPoint3[0];
					Point3d3.y = dPoint3[1];
					Point3d3.z = dPoint3[2];

					aCutPoints.Add(Point3d3);
					aCutValues.Add(dCutValue);

					/////////////////// test ////////////////////
					//CString sOut;
					//sOut.Format("요소:%d, 절점1:%d, 절점2:%d, D=%g, CuttingPt(%g,%g,%g)",
					//            m_PlateKeyList[elem],elem_d.elnod[i],elem_d.elnod[j],dDistance,Point3d3.x,Point3d3.y,Point3d3.z);
					//GSaveHistoryNF(sOut);    
					/////////////////// test ////////////////////
				}
				else
				{
					/////////////////// test ////////////////////
					//CString sOut;
					//sOut.Format("요소:%d, 절점1:%d, 절점2:%d, D=%g", 
					//            m_PlateKeyList[elem],elem_d.elnod[i],elem_d.elnod[j],dDistance);
					//GSaveHistoryNF(sOut);    
					/////////////////// test ////////////////////
				}
		  }
			
			
			// 같은 점이 있을 경우 없앤다.
			if(aCutPoints.GetSize()>1)
			{
				for( i =0; i<aCutPoints.GetSize()-1; i++)
					for( j=i+1; j<aCutPoints.GetSize(); j++)
					{
						if(IsSame3DPoint(aCutPoints[i],aCutPoints[j]))
						{
							aCutPoints.RemoveAt(j);
							aCutValues.RemoveAt(j);
							j--;
						}
					}	
			}
			else continue;
		
			if(aCutPoints.GetSize() != 2) //최종적으로 2개의 서로다른 점이 존재해야한다.
				continue;
	
			CutLineData.dPoint1Val = aCutValues[0];
			CutLineData.dPoint2Val = aCutValues[1];
			CutLineData.Point1 = aCutPoints[0];
			CutLineData.Point2 = aCutPoints[1];
			CutLineData.KeyElem = m_PlateKeyList[elem];
			CutLineData.dDist1 = CMathFunc::mathLength(dCutLinePoint1[0],dCutLinePoint1[1],dCutLinePoint1[2],
								aCutPoints[0].x,aCutPoints[0].y,aCutPoints[0].z);
			CutLineData.dDist2 = CMathFunc::mathLength(dCutLinePoint1[0],dCutLinePoint1[1],dCutLinePoint1[2],
								aCutPoints[1].x,aCutPoints[1].y,aCutPoints[1].z);

			if(CutLineMax < aCutValues[0]) CutLineMax = aCutValues[0];
			if(CutLineMax < aCutValues[1]) CutLineMax = aCutValues[1];
			if(CutLineMin > aCutValues[0]) CutLineMin = aCutValues[0];
			if(CutLineMin > aCutValues[1]) CutLineMin = aCutValues[1];
	
			raCutLineData[nCL]->Add(CutLineData);

			/////////////////// test ////////////////////
			//CString sOut;
			//sOut.Format("P1:%g,%g,%g   P2:%g,%g,%g",
			//            aCutPoints[0].x,aCutPoints[0].y,aCutPoints[0].z,
			//            aCutPoints[1].x,aCutPoints[1].y,aCutPoints[1].z);
			//GSaveHistoryNF(sOut);    
			/////////////////// test ////////////////////
			
		}

		CutLineMinMax.Max = CutLineMax;
		CutLineMinMax.Min = CutLineMin;
		m_aCutLineMinMax.Add(CutLineMinMax);
	}

	////////////////////////////////////////////////////////////
	// CUTTING PLANE
	////////////////////////////////////////////////////////////

	CArray <T_CUTLINE_D,T_CUTLINE_D&> *paCutLineOnPlaneData;
	T_CUTLINE_MINMAX_D CutLineOnPlaneMinMax;
	T_CUTLINE_D				 CutLineOnPlaneData;

	C3DPoint Point1,Point2,Vector,Point3;
	double dVector[3],dNormalVector[3];
	
	CArray <T_NPLN_D,T_NPLN_D&> aCuttingPlane;
	T_NPLN_D CuttingPlane;
	PLANE_FUNC CuttingPlaneF;

	int nNumOfCutPlanes;
	
	nNumOfCutPlanes = m_aCutPlanes.GetSize();
	for(int nKey = 0; nKey < nNumOfCutPlanes; nKey++)
	{
	  if(GetNPLN(m_aCutPlanes[nKey],CuttingPlane))
			aCuttingPlane.Add(CuttingPlane);
		else
		{
			nNumOfCutPlanes--;
			m_aCutPlanes.RemoveAt(nKey);
			gm->m_aCutPlanes.RemoveAt(nKey);
			nKey--;
		}
	}

	for(int nPLN = 0; nPLN < nNumOfCutPlanes; nPLN++)
	{
		paCutLineOnPlaneData = new CArray<T_CUTLINE_D,T_CUTLINE_D&>;
		m_aCutLineOnPlaneData.Add(paCutLineOnPlaneData);
		double CutLineOnPlaneMax = -DBL_MAX;
		double CutLineOnPlaneMin =  DBL_MAX;

		CuttingPlane = aCuttingPlane[nPLN];
		GetPlaneFunction(CuttingPlane,CuttingPlaneF);
		
		dNormalVector[0] =CuttingPlaneF.a;
		dNormalVector[1] =CuttingPlaneF.b;
		dNormalVector[2] =CuttingPlaneF.c; // CuttingPlane Normal Vector

		//aCutVertex.RemoveAll();
		//aCutVertexVal.RemoveAll();

		elem_num = m_PlateKeyList.GetSize();
		
		for (int elem=0;elem<elem_num;elem++) 
		{
			aCutPoints.RemoveAll();
			aCutValues.RemoveAll();
			m_pDoc->m_pAttrCtrl->GetElem(m_PlateKeyList[elem], elem_d);
	
			node_in_elem = m_pDoc->m_pAttrCtrl->GetNumNode(elem_d.eltyp, elem_d.elnod);
			for(i=0; i<node_in_elem; i++)
			{
				m_pDoc->m_pAttrCtrl->GetNode(elem_d.elnod[i],node_d1);
				j = (i==node_in_elem-1)? 0:(i+1);
				m_pDoc->m_pAttrCtrl->GetNode(elem_d.elnod[j],node_d2);

			  Point1.x = node_d1.x;
				Point1.y = node_d1.y;
				Point1.z = node_d1.z;

				Point2.x = node_d2.x;
				Point2.y = node_d2.y;
				Point2.z = node_d2.z;
					  
			  dVector[0] = Point2.x-Point1.x;
			  dVector[1] = Point2.y-Point1.y;
			  dVector[2] = Point2.z-Point1.z;

			  
			  d1 = CuttingPlaneF.a*Point1.x + CuttingPlaneF.b * Point1.y + CuttingPlaneF.c * Point1.z + CuttingPlaneF.h ;
			  d2 = CuttingPlaneF.a*Point2.x + CuttingPlaneF.b * Point2.y + CuttingPlaneF.c * Point2.z + CuttingPlaneF.h ;
			  

			  if(d1*d2<0.0)
			  {
				  dPoint1[0] = Point1.x;
				  dPoint1[1] = Point1.y;
				  dPoint1[2] = Point1.z;

				  if(!CMathFunc::project_on_plane_vector_for_CuttingPlane(dPoint1,dVector,CuttingPlane.dPoint[0],
					  CuttingPlane.dPoint[1],CuttingPlane.dPoint[2],dPoint3)) continue;
				  Point3.Set(dPoint3[0],dPoint3[1],dPoint3[2]);

					double dist1 = CMathFunc::mathLength(Point3.x,Point3.y,Point3.z,
					  Point1.x,Point1.y,Point1.z);
				  double dist2 = CMathFunc::mathLength(Point3.x,Point3.y,Point3.z,
					  Point2.x,Point2.y,Point2.z);

					if(!GetNodalValueforCutting(m_PlateKeyList[elem],dPlateCutVal1,i,dPlateCutVal2,j))
						continue;// virtual
					dCutValue = dPlateCutVal1 + (dPlateCutVal2-dPlateCutVal1)*dist1/(dist1+dist2);
				  				  
				  aCutValues.Add(dCutValue);
					aCutPoints.Add(Point3);
			  }
			  
				// [2010-07-01] Kim, Geun Young (Tel: 2042, gykim@midasit.com) - MQC:3488
				// Tolerance가 너무 작아서 Diagram이 안그려지는 문제 
			  if(fabs(d1 - 0.0)<1e-15)
			  {
				  if(!GetNodalValueforCutting(m_PlateKeyList[elem],dPlateCutVal1,i,dPlateCutVal2,j))
						continue; // virtual
					dCutValue = dPlateCutVal1;
				  aCutValues.Add(dCutValue);
					aCutPoints.Add(Point1);
			  }
			  
			  if(fabs(d2 - 0.0)<1e-15)
			  {
				  if(!GetNodalValueforCutting(m_PlateKeyList[elem],dPlateCutVal1,i,dPlateCutVal2,j))
						continue; // virtual
					dCutValue = dPlateCutVal2;
				  aCutValues.Add(dCutValue);
					aCutPoints.Add(Point2);
			  }

		  }
		  
		
			// 같은 점이 있을 경우 없앤다.
			if(aCutPoints.GetSize()>1)
			{
				for( i =0; i<aCutPoints.GetSize()-1; i++)
					for( j=i+1; j<aCutPoints.GetSize(); j++)
					{
						if(IsSame3DPoint(aCutPoints[i],aCutPoints[j]))
						{
							aCutPoints.RemoveAt(j);
							aCutValues.RemoveAt(j);
							j--;
						}
					}	
			}
			else continue;
		
			if(aCutPoints.GetSize() != 2) //최종적으로 2개의 서로다른 점이 존재해야한다.
				continue;
	
			CutLineOnPlaneData.dPoint1Val = aCutValues[0];
			CutLineOnPlaneData.dPoint2Val = aCutValues[1];
			CutLineOnPlaneData.Point1 = aCutPoints[0];
			CutLineOnPlaneData.Point2 = aCutPoints[1];
			CutLineOnPlaneData.KeyElem = m_PlateKeyList[elem];

			if(CutLineOnPlaneMax < aCutValues[0]) CutLineOnPlaneMax = aCutValues[0];
			if(CutLineOnPlaneMax < aCutValues[1]) CutLineOnPlaneMax = aCutValues[1];
			if(CutLineOnPlaneMin > aCutValues[0]) CutLineOnPlaneMin = aCutValues[0];
			if(CutLineOnPlaneMin > aCutValues[1]) CutLineOnPlaneMin = aCutValues[1];
	
			m_aCutLineOnPlaneData[nPLN]->Add(CutLineOnPlaneData);
			
		}

		CutLineOnPlaneMinMax.Max = CutLineOnPlaneMax;
		CutLineOnPlaneMinMax.Min = CutLineOnPlaneMin;
		m_aCutLineOnPlaneMinMax.Add(CutLineOnPlaneMinMax);
	}
}

void CEngineBase::MakeCuttingLineData()
{
	MakeCuttingLineData(m_aCutLineData);
}

BOOL CEngineBase::GetNodalValueforCutting(T_ELEM_K PlateKey,double& NodalVal1,int i, double& NodalVal2, int j)
{
	return TRUE; 
}

//XGLRenderer
//void CEngineBase::DrawPositionWidget(CDC *pDC, CPoint pnt, double scale)
void CEngineBase::DrawPositionWidget(CDC *pDC, C3DPoint &pnt3d, double scale)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	
	
	if(!gm->m_bVirtualMode && gm->m_pGPSCtrl->IsGLRenderer() && gm->m_pGPSCtrl->IsXGRMode())
	{
		LOGPEN logpen;
		pDC->GetCurrentPen()->GetLogPen(&logpen);
		gm->m_pXGR_GPSDrawMgr->m_DrawPositionWidget.Add_DrawPositionWidget(&(pnt3d.x),scale,logpen.lopnColor);
		return;
	}
	
	CPoint pnt;
	if(gm->m_bVirtualMode)  pnt=gm->m_pGPSCtrl->GetWorldToWindowP2D(pnt3d);
	else 		                pnt=gm->m_pGPSCtrl->GetWorldToMemDCP2D(pnt3d);
	if(pnt.x < 0 || pnt.y < 0 )return;

	CPen *old_pen,CirclePen,CirclePen2,CrossPen,CrossPen2;
	CBrush *old_brush;
	int nOffset=gm->m_nLineWidth*1;
	CirclePen.CreatePen(PS_SOLID, gm->m_nLineWidth*2, RGB(255, 0, 0));
	CirclePen2.CreatePen(PS_SOLID, gm->m_nLineWidth*2, RGB(200,200, 200));
	CrossPen.CreatePen(PS_SOLID, gm->m_nLineWidth*2, RGB(255, 0, 0));
	CrossPen2.CreatePen(PS_SOLID, gm->m_nLineWidth*2, RGB(200, 200, 200));
	
	scale/=1.1;

	old_pen = (CPen *) pDC->SelectObject(&CrossPen2);
	
	old_brush= (CBrush*) pDC->SelectStockObject(NULL_BRUSH);
//	CRect rect(pnt.x-scale+nOffset,pnt.y-scale+nOffset,pnt.x+scale+nOffset,pnt.y+scale+nOffset);
//	pDC->Ellipse(&rect);
	
//	pDC->MoveTo(pnt.x+nOffset, pnt.y-scale+nOffset);
//	pDC->LineTo(pnt.x+nOffset, pnt.y+scale+nOffset);
//  pDC->MoveTo(pnt.x-scale+nOffset, pnt.y+nOffset);
//  pDC->LineTo(pnt.x+scale+nOffset, pnt.y+nOffset);
	
	pDC->SelectObject(&CrossPen);

	pDC->MoveTo(pnt.x, pnt.y-scale);
	pDC->LineTo(pnt.x, pnt.y+scale);
	pDC->MoveTo(pnt.x-scale, pnt.y);
	pDC->LineTo(pnt.x+scale, pnt.y);
	

	
	pDC->SelectObject(&CirclePen);
	CRect rect2(pnt.x-scale,pnt.y-scale,pnt.x+scale,pnt.y+scale);
	pDC->Ellipse(&rect2);
	

	pDC->SelectObject(old_pen);
	pDC->SelectObject(old_brush);
	CirclePen.DeleteObject();
	CrossPen.DeleteObject();
	CrossPen2.DeleteObject();
}

//XGLRenderer
void CEngineBase::DrawInflLineMinWidget(CDC *pDC, C3DPoint& pnt3d, double scale,COLORREF clr)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	if(!gm->m_bVirtualMode && gm->m_pGPSCtrl->IsGLRenderer() && gm->m_pGPSCtrl->IsXGRMode())
	{
		gm->m_pXGR_GPSDrawMgr->m_DrawInflLineMinWidget.Add_DrawInflLineMinWidget(&(pnt3d.x),scale,clr);
		return;
	}

	CPoint pnt;
	if(gm->m_bVirtualMode)  pnt=gm->m_pGPSCtrl->GetWorldToWindowP2D(pnt3d);
	else 		                pnt=gm->m_pGPSCtrl->GetWorldToMemDCP2D(pnt3d);
	if(pnt.x < 0 || pnt.y < 0 )return;

	CPen *old_pen,RectPen,RectPen2;
	CBrush *old_brush,MinWigetBrush;
	int nOffset=gm->m_nLineWidth*1.5;
	RectPen.CreatePen(PS_SOLID, gm->m_nLineWidth*2, RGB(0,0,0));
	RectPen2.CreatePen(PS_SOLID, gm->m_nLineWidth*2, RGB(250,250, 250));
	MinWigetBrush.CreateSolidBrush(clr);

	scale/=1.8;
	
	old_pen = (CPen *) pDC->SelectObject(&RectPen2);
	old_brush= (CBrush*) pDC->SelectObject(&MinWigetBrush);

	CRect rect(pnt.x-scale+nOffset,pnt.y-scale+nOffset,pnt.x+scale+nOffset,pnt.y+scale+nOffset);
	pDC->Rectangle(&rect);
	pDC->SelectObject(&RectPen);
	pDC->SelectStockObject(NULL_BRUSH);
	CRect rect2(pnt.x-scale,pnt.y-scale,pnt.x+scale,pnt.y+scale);
	pDC->Rectangle(&rect2);
	

	pDC->SelectObject(old_pen);
	pDC->SelectObject(old_brush);
	MinWigetBrush.DeleteObject();
	RectPen.DeleteObject();
	RectPen2.DeleteObject();
}

//XGLRenderer
void CEngineBase::DrawInflLineMaxWidget(CDC *pDC, C3DPoint& pnt3d, double scale,COLORREF clr)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	if(!gm->m_bVirtualMode && gm->m_pGPSCtrl->IsGLRenderer() && gm->m_pGPSCtrl->IsXGRMode())
	{
		gm->m_pXGR_GPSDrawMgr->m_DrawInflLineMaxWidget.Add_DrawInflLineMaxWidget(&(pnt3d.x),scale,clr);
		return;
	}

	CPoint pnt;
	if(gm->m_bVirtualMode)  pnt=gm->m_pGPSCtrl->GetWorldToWindowP2D(pnt3d);
	else 		                pnt=gm->m_pGPSCtrl->GetWorldToMemDCP2D(pnt3d);
	if(pnt.x < 0 || pnt.y < 0 )return;


	CPen *old_pen,CirclePen,CirclePen2;
	CBrush *old_brush,MaxWigetBrush;
	int nOffset=gm->m_nLineWidth*1.5;
	CirclePen.CreatePen(PS_SOLID, gm->m_nLineWidth*2, RGB(0,0,0));
	CirclePen2.CreatePen(PS_SOLID, gm->m_nLineWidth*2, RGB(250,250, 250));
	MaxWigetBrush.CreateSolidBrush(clr);

	scale/=1.5;
	
	old_pen = (CPen *) pDC->SelectObject(&CirclePen2);
	old_brush= (CBrush*) pDC->SelectObject(&MaxWigetBrush);

	CRect rect(pnt.x-scale+nOffset,pnt.y-scale+nOffset,pnt.x+scale+nOffset,pnt.y+scale+nOffset);
	pDC->Ellipse(&rect);
	pDC->SelectObject(&CirclePen);
	pDC->SelectStockObject(NULL_BRUSH);
	CRect rect2(pnt.x-scale,pnt.y-scale,pnt.x+scale,pnt.y+scale);
	pDC->Ellipse(&rect2);
	

	pDC->SelectObject(old_pen);
	pDC->SelectObject(old_brush);
	MaxWigetBrush.DeleteObject();
	CirclePen.DeleteObject();
	CirclePen2.DeleteObject();
}

//XGLRenderer
void CEngineBase::DrawInflLineMinWidget2(CDC *pDC, C3DPoint& pnt3d, double scale,COLORREF clr)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	
	if(!gm->m_bVirtualMode && gm->m_pGPSCtrl->IsGLRenderer() && gm->m_pGPSCtrl->IsXGRMode())
	{
		gm->m_pXGR_GPSDrawMgr->m_DrawInflLineMinWidget2.Add_DrawInflLineMinWidget2(&(pnt3d.x),scale,clr);
		return;
	}

	CPoint pnt;
	if(gm->m_bVirtualMode)  pnt=gm->m_pGPSCtrl->GetWorldToWindowP2D(pnt3d);
	else 		                pnt=gm->m_pGPSCtrl->GetWorldToMemDCP2D(pnt3d);
	if(pnt.x < 0 || pnt.y < 0 )return;

	CPen *old_pen,RectPen,RectPen2;
	CBrush *old_brush,MinWigetBrush;
	int nOffset=gm->m_nLineWidth*3;
	RectPen.CreatePen(PS_SOLID, gm->m_nLineWidth*1, clr);
	MinWigetBrush.CreateSolidBrush(clr);

	scale/=2.1;
	
	old_pen = (CPen *) pDC->SelectObject(&RectPen);
	old_brush= (CBrush*) pDC->SelectObject(&MinWigetBrush);

	CRect rect(pnt.x-scale,pnt.y-scale,pnt.x+scale,pnt.y+scale);
	pDC->Rectangle(&rect);
	
	pDC->SelectStockObject(NULL_BRUSH);
	CRect rect2(pnt.x-scale-nOffset,pnt.y-scale-nOffset,pnt.x+scale+nOffset,pnt.y+scale+nOffset);
	pDC->Rectangle(&rect2);
	

	pDC->SelectObject(old_pen);
	pDC->SelectObject(old_brush);
	MinWigetBrush.DeleteObject();
	RectPen.DeleteObject();
	
}

//XGLRenderer
void CEngineBase::DrawInflLineMaxWidget2(CDC *pDC, C3DPoint& pnt3d, double scale,COLORREF clr)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	if(!gm->m_bVirtualMode && gm->m_pGPSCtrl->IsGLRenderer() && gm->m_pGPSCtrl->IsXGRMode())
	{
		gm->m_pXGR_GPSDrawMgr->m_DrawInflLineMaxWidget2.Add_DrawInflLineMaxWidget2(&(pnt3d.x),scale,clr);
		return;
	}

	CPoint pnt;
	if(gm->m_bVirtualMode)  pnt=gm->m_pGPSCtrl->GetWorldToWindowP2D(pnt3d);
	else 		                pnt=gm->m_pGPSCtrl->GetWorldToMemDCP2D(pnt3d);
	if(pnt.x < 0 || pnt.y < 0 )return;

	CPen *old_pen,CirclePen,CirclePen2;
	CBrush *old_brush,MaxWigetBrush;
	int nOffset=gm->m_nLineWidth*3;
	CirclePen.CreatePen(PS_SOLID, gm->m_nLineWidth*1, clr);
	MaxWigetBrush.CreateSolidBrush(clr);

	scale/=1.9;
	
	old_pen = (CPen *) pDC->SelectObject(&CirclePen);
	old_brush= (CBrush*) pDC->SelectObject(&MaxWigetBrush);

	CRect rect(pnt.x-scale,pnt.y-scale,pnt.x+scale,pnt.y+scale);
	pDC->Ellipse(&rect);
	pDC->SelectStockObject(NULL_BRUSH);
	CRect rect2(pnt.x-scale-nOffset,pnt.y-scale-nOffset,pnt.x+scale+nOffset,pnt.y+scale+nOffset);
	pDC->Ellipse(&rect2);
	

	pDC->SelectObject(old_pen);
	pDC->SelectObject(old_brush);
	MaxWigetBrush.DeleteObject();
	CirclePen.DeleteObject();
	
}


//XGLRenderer
//void CEngineBase::DrawMvltrcPointLoadWidget(CDC *pDC, CPoint pnt, double scale, COLORREF clr,CPoint pnt2)
void CEngineBase::DrawMvltrcPointLoadWidget(CDC* pDC,C3DPoint& pnt3d1,double scale,COLORREF clr,C3DPoint& pnt3d2)
{
		I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	if(!gm->m_bVirtualMode && gm->m_pGPSCtrl->IsGLRenderer() && gm->m_pGPSCtrl->IsXGRMode())
	{
		double Pos6[6];
		Pos6[0] = pnt3d1.x;Pos6[1] = pnt3d1.y; Pos6[2] = pnt3d1.z;
		Pos6[3] = pnt3d2.x;Pos6[4] = pnt3d2.y; Pos6[5] = pnt3d2.z;

		gm->m_pXGR_GPSDrawMgr->m_DrawMvltrcPointLoadWidget.Add_DrawMvltrcPointLoadWidget(Pos6,scale,clr);
		return;
	}

	CPoint pnt, pnt2;
	if(gm->m_bVirtualMode)
	{
		pnt  = gm->m_pGPSCtrl->GetWorldToWindowP2D(pnt3d1);
		pnt2 = gm->m_pGPSCtrl->GetWorldToWindowP2D(pnt3d2);
	}
	else
	{
		pnt  = gm->m_pGPSCtrl->GetWorldToMemDCP2D(pnt3d1);
		pnt2 = gm->m_pGPSCtrl->GetWorldToMemDCP2D(pnt3d2);
	}

	if(pnt.x < 0 || pnt.y < 0) return;

	CPen *old_pen,RectPen,RectPen2;
	CBrush *old_brush,MinWigetBrush;
	int nOffset=gm->m_nLineWidth*2.5;
	RectPen.CreatePen(PS_SOLID, gm->m_nLineWidth*1, clr);
	MinWigetBrush.CreateSolidBrush(clr);

	scale/=2.0;
	
	old_pen = (CPen *) pDC->SelectObject(&RectPen);
	old_brush= (CBrush*) pDC->SelectObject(&MinWigetBrush);

	CRect rect(pnt.x-scale,pnt.y-scale,pnt.x+scale,pnt.y+scale);
	pDC->Rectangle(&rect);
	
	pDC->SelectStockObject(NULL_BRUSH);
	
	CRect rect2(pnt.x-scale-nOffset,pnt.y-scale-nOffset,pnt.x+scale+nOffset,pnt.y+scale+nOffset);
	pDC->Rectangle(&rect2);
	
	scale*=2;
	CRect rect3(pnt2.x,pnt2.y,pnt2.x+scale*2,pnt2.y+scale*0.7);
	pDC->SelectObject(&MinWigetBrush);
	pDC->Rectangle(&rect3);
	
	pDC->SelectObject(old_pen);
	pDC->SelectObject(old_brush);
	MinWigetBrush.DeleteObject();
	RectPen.DeleteObject();
}

//XGLRenderer
//void CEngineBase::DrawMvltrcDistLoadWidget(CDC *pDC, CPoint pnt, double scale,COLORREF clr)
void CEngineBase::DrawMvltrcDistLoadWidget(CDC* pDC,C3DPoint& pnt3d,double scale,COLORREF clr)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	if(!gm->m_bVirtualMode && gm->m_pGPSCtrl->IsGLRenderer() && gm->m_pGPSCtrl->IsXGRMode())
	{
		gm->m_pXGR_GPSDrawMgr->m_DrawMvltrcDistLoadWidget.Add_DrawMvltrcDistLoadWidget(&(pnt3d.x),scale,clr);
		return;
	}

	CPoint pnt;
	if(gm->m_bVirtualMode)
{
		pnt  = gm->m_pGPSCtrl->GetWorldToWindowP2D(pnt3d);
	}
	else
{
		pnt  = gm->m_pGPSCtrl->GetWorldToMemDCP2D(pnt3d);
	}

	if(pnt.x < 0 || pnt.y < 0) return;

	CPen *old_pen,CirclePen,CirclePen2;
	CBrush *old_brush,MaxWigetBrush;
	int nOffset=scale/2.5;
	CirclePen.CreatePen(PS_SOLID, gm->m_nLineWidth*1, clr);
	MaxWigetBrush.CreateSolidBrush(clr);

	old_pen = (CPen *) pDC->SelectObject(&CirclePen);
	old_brush= (CBrush*) pDC->SelectObject(&MaxWigetBrush);

	CRect rect(pnt.x-scale+nOffset,pnt.y-scale+nOffset,pnt.x+scale-nOffset,pnt.y+scale-nOffset);
	pDC->Ellipse(&rect);
	pDC->SelectStockObject(NULL_BRUSH);
	CRect rect2(pnt.x-scale,pnt.y-scale,pnt.x+scale,pnt.y+scale);
	pDC->Ellipse(&rect2);

	pDC->SelectObject(old_pen);
	pDC->SelectObject(old_brush);
	MaxWigetBrush.DeleteObject();
	CirclePen.DeleteObject();
	
}

COLORREF CEngineBase::GetShadeFactoredColor(COLORREF color, double dShadeFactor, double dSpecShadeFactor)
{
	// XGLRenderer
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	if(!gm->m_pGPSCtrl->IsForceGDIDraw())
	{
		if(gm->m_pGPSCtrl->IsGLRenderer())return color;
	}

	DWORD Red = GetRValue(color)*dShadeFactor + dSpecShadeFactor;
	DWORD Blue = GetBValue(color)*dShadeFactor + dSpecShadeFactor;
	DWORD Green = GetGValue(color)*dShadeFactor + dSpecShadeFactor;
	if(Red>255) Red= 255;
	if(Green>255) Green= 255;
	if(Blue>255) Blue= 255;
	return RGB(Red,Green,Blue);
}





void CEngineBase::GetHexaSolidContourPolys(float value, double *SolidcellScalars, C3DPoint* aVertexes,
										 CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>	&PolygonList,
										 CArray <CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					&PolygonEdgeArray)
								 
{

 static int edges[12][2] = { {0,1}, {1,2}, {3,2}, {0,3},
											{4,5}, {5,6}, {7,6}, {4,7},
											{0,4}, {1,5}, {3,7}, {2,6}};
 /*int faces[6][4] = { {0,4,7,3}, {1,2,6,5},
										 {0,1,5,4}, {3,7,6,2},
										 {0,3,2,1}, {4,5,6,7} };
										 */

//
// Edges to intersect.  Three at a time form a triangle. Comments at end of line
// indicate case number (0->255) and base case number (0->15).
//
	static TRIANGLE_CASES_HEXA triCases[] = { 
	{{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 0 0 */
	{{ 0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 1 1 */
	{{ 0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 2 1 */
	{{ 1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 3 2 */
	{{ 1, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 4 1 */
	{{ 0, 3, 8, 1, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 5 3 */
	{{ 9, 11, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 6 2 */
	{{ 2, 3, 8, 2, 8, 11, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1}}, /* 7 5 */
	{{ 3, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 8 1 */
	{{ 0, 2, 10, 8, 0, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 9 2 */
	{{ 1, 0, 9, 2, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 10 3 */
	{{ 1, 2, 10, 1, 10, 9, 9, 10, 8, -1, -1, -1, -1, -1, -1, -1}}, /* 11 5 */
	{{ 3, 1, 11, 10, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 12 2 */
	{{ 0, 1, 11, 0, 11, 8, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1}}, /* 13 5 */
	{{ 3, 0, 9, 3, 9, 10, 10, 9, 11, -1, -1, -1, -1, -1, -1, -1}}, /* 14 5 */
	{{ 9, 11, 8, 11, 10, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 15 8 */
	{{ 4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 16 1 */
	{{ 4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 17 2 */
	{{ 0, 9, 1, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 18 3 */
	{{ 4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1}}, /* 19 5 */
	{{ 1, 11, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 20 4 */
	{{ 3, 7, 4, 3, 4, 0, 1, 11, 2, -1, -1, -1, -1, -1, -1, -1}}, /* 21 7 */
	{{ 9, 11, 2, 9, 2, 0, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1}}, /* 22 7 */
	{{ 2, 9, 11, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1}}, /* 23 14 */
	{{ 8, 7, 4, 3, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 24 3 */
	{{10, 7, 4, 10, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1}}, /* 25 5 */
	{{ 9, 1, 0, 8, 7, 4, 2, 10, 3, -1, -1, -1, -1, -1, -1, -1}}, /* 26 6 */
	{{ 4, 10, 7, 9, 10, 4, 9, 2, 10, 9, 1, 2, -1, -1, -1, -1}}, /* 27 9 */
	{{ 3, 1, 11, 3, 11, 10, 7, 4, 8, -1, -1, -1, -1, -1, -1, -1}}, /* 28 7 */
	{{ 1, 11, 10, 1, 10, 4, 1, 4, 0, 7, 4, 10, -1, -1, -1, -1}}, /* 29 11 */
	{{ 4, 8, 7, 9, 10, 0, 9, 11, 10, 10, 3, 0, -1, -1, -1, -1}}, /* 30 12 */
	{{ 4, 10, 7, 4, 9, 10, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1}}, /* 31 5 */
	{{ 9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 32 1 */
	{{ 9, 4, 5, 0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 33 3 */
	{{ 0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 34 2 */
	{{ 8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1}}, /* 35 5 */
	{{ 1, 11, 2, 9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 36 3 */
	{{ 3, 8, 0, 1, 11, 2, 4, 5, 9, -1, -1, -1, -1, -1, -1, -1}}, /* 37 6 */
	{{ 5, 11, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1}}, /* 38 5 */
	{{ 2, 5, 11, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1}}, /* 39 9 */
	{{ 9, 4, 5, 2, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 40 4 */
	{{ 0, 2, 10, 0, 10, 8, 4, 5, 9, -1, -1, -1, -1, -1, -1, -1}}, /* 41 7 */
	{{ 0, 4, 5, 0, 5, 1, 2, 10, 3, -1, -1, -1, -1, -1, -1, -1}}, /* 42 7 */
	{{ 2, 5, 1, 2, 8, 5, 2, 10, 8, 4, 5, 8, -1, -1, -1, -1}}, /* 43 11 */
	{{11, 10, 3, 11, 3, 1, 9, 4, 5, -1, -1, -1, -1, -1, -1, -1}}, /* 44 7 */
	{{ 4, 5, 9, 0, 1, 8, 8, 1, 11, 8, 11, 10, -1, -1, -1, -1}}, /* 45 12 */
	{{ 5, 0, 4, 5, 10, 0, 5, 11, 10, 10, 3, 0, -1, -1, -1, -1}}, /* 46 14 */
	{{ 5, 8, 4, 5, 11, 8, 11, 10, 8, -1, -1, -1, -1, -1, -1, -1}}, /* 47 5 */
	{{ 9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 48 2 */
	{{ 9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1}}, /* 49 5 */
	{{ 0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1}}, /* 50 5 */
	{{ 1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 51 8 */
	{{ 9, 8, 7, 9, 7, 5, 11, 2, 1, -1, -1, -1, -1, -1, -1, -1}}, /* 52 7 */
	{{11, 2, 1, 9, 0, 5, 5, 0, 3, 5, 3, 7, -1, -1, -1, -1}}, /* 53 12 */
	{{ 8, 2, 0, 8, 5, 2, 8, 7, 5, 11, 2, 5, -1, -1, -1, -1}}, /* 54 11 */
	{{ 2, 5, 11, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1}}, /* 55 5 */
	{{ 7, 5, 9, 7, 9, 8, 3, 2, 10, -1, -1, -1, -1, -1, -1, -1}}, /* 56 7 */
	{{ 9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 10, 7, -1, -1, -1, -1}}, /* 57 14 */
	{{ 2, 10, 3, 0, 8, 1, 1, 8, 7, 1, 7, 5, -1, -1, -1, -1}}, /* 58 12 */
	{{10, 1, 2, 10, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1}}, /* 59 5 */
	{{ 9, 8, 5, 8, 7, 5, 11, 3, 1, 11, 10, 3, -1, -1, -1, -1}}, /* 60 10 */
	{{ 5, 0, 7, 5, 9, 0, 7, 0, 10, 1, 11, 0, 10, 0, 11, -1}}, /* 61 7 */
	{{10, 0, 11, 10, 3, 0, 11, 0, 5, 8, 7, 0, 5, 0, 7, -1}}, /* 62 7 */
	{{10, 5, 11, 7, 5, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 63 2 */
	{{11, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 64 1 */
	{{ 0, 3, 8, 5, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 65 4 */
	{{ 9, 1, 0, 5, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 66 3 */
	{{ 1, 3, 8, 1, 8, 9, 5, 6, 11, -1, -1, -1, -1, -1, -1, -1}}, /* 67 7 */
	{{ 1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 68 2 */
	{{ 1, 5, 6, 1, 6, 2, 3, 8, 0, -1, -1, -1, -1, -1, -1, -1}}, /* 69 7 */
	{{ 9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1}}, /* 70 5 */
	{{ 5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1}}, /* 71 11 */
	{{ 2, 10, 3, 11, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 72 3 */
	{{10, 8, 0, 10, 0, 2, 11, 5, 6, -1, -1, -1, -1, -1, -1, -1}}, /* 73 7 */
	{{ 0, 9, 1, 2, 10, 3, 5, 6, 11, -1, -1, -1, -1, -1, -1, -1}}, /* 74 6 */
	{{ 5, 6, 11, 1, 2, 9, 9, 2, 10, 9, 10, 8, -1, -1, -1, -1}}, /* 75 12 */
	{{ 6, 10, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1}}, /* 76 5 */
	{{ 0, 10, 8, 0, 5, 10, 0, 1, 5, 5, 6, 10, -1, -1, -1, -1}}, /* 77 14 */
	{{ 3, 6, 10, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1}}, /* 78 9 */
	{{ 6, 9, 5, 6, 10, 9, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1}}, /* 79 5 */
	{{ 5, 6, 11, 4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 80 3 */
	{{ 4, 0, 3, 4, 3, 7, 6, 11, 5, -1, -1, -1, -1, -1, -1, -1}}, /* 81 7 */
	{{ 1, 0, 9, 5, 6, 11, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1}}, /* 82 6 */
	{{11, 5, 6, 1, 7, 9, 1, 3, 7, 7, 4, 9, -1, -1, -1, -1}}, /* 83 12 */
	{{ 6, 2, 1, 6, 1, 5, 4, 8, 7, -1, -1, -1, -1, -1, -1, -1}}, /* 84 7 */
	{{ 1, 5, 2, 5, 6, 2, 3, 4, 0, 3, 7, 4, -1, -1, -1, -1}}, /* 85 10 */
	{{ 8, 7, 4, 9, 5, 0, 0, 5, 6, 0, 6, 2, -1, -1, -1, -1}}, /* 86 12 */
	{{ 7, 9, 3, 7, 4, 9, 3, 9, 2, 5, 6, 9, 2, 9, 6, -1}}, /* 87 7 */
	{{ 3, 2, 10, 7, 4, 8, 11, 5, 6, -1, -1, -1, -1, -1, -1, -1}}, /* 88 6 */
	{{ 5, 6, 11, 4, 2, 7, 4, 0, 2, 2, 10, 7, -1, -1, -1, -1}}, /* 89 12 */
	{{ 0, 9, 1, 4, 8, 7, 2, 10, 3, 5, 6, 11, -1, -1, -1, -1}}, /* 90 13 */
	{{ 9, 1, 2, 9, 2, 10, 9, 10, 4, 7, 4, 10, 5, 6, 11, -1}}, /* 91 6 */
	{{ 8, 7, 4, 3, 5, 10, 3, 1, 5, 5, 6, 10, -1, -1, -1, -1}}, /* 92 12 */
	{{ 5, 10, 1, 5, 6, 10, 1, 10, 0, 7, 4, 10, 0, 10, 4, -1}}, /* 93 7 */
	{{ 0, 9, 5, 0, 5, 6, 0, 6, 3, 10, 3, 6, 8, 7, 4, -1}}, /* 94 6 */
	{{ 6, 9, 5, 6, 10, 9, 4, 9, 7, 7, 9, 10, -1, -1, -1, -1}}, /* 95 3 */
	{{11, 9, 4, 6, 11, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 96 2 */
	{{ 4, 6, 11, 4, 11, 9, 0, 3, 8, -1, -1, -1, -1, -1, -1, -1}}, /* 97 7 */
	{{11, 1, 0, 11, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1}}, /* 98 5 */
	{{ 8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 11, 1, -1, -1, -1, -1}}, /* 99 14 */
	{{ 1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1}}, /* 100 5 */
	{{ 3, 8, 0, 1, 9, 2, 2, 9, 4, 2, 4, 6, -1, -1, -1, -1}}, /* 101 12 */
	{{ 0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 102 8 */
	{{ 8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1}}, /* 103 5 */
	{{11, 9, 4, 11, 4, 6, 10, 3, 2, -1, -1, -1, -1, -1, -1, -1}}, /* 104 7 */
	{{ 0, 2, 8, 2, 10, 8, 4, 11, 9, 4, 6, 11, -1, -1, -1, -1}}, /* 105 10 */
	{{ 3, 2, 10, 0, 6, 1, 0, 4, 6, 6, 11, 1, -1, -1, -1, -1}}, /* 106 12 */
	{{ 6, 1, 4, 6, 11, 1, 4, 1, 8, 2, 10, 1, 8, 1, 10, -1}}, /* 107 7 */
	{{ 9, 4, 6, 9, 6, 3, 9, 3, 1, 10, 3, 6, -1, -1, -1, -1}}, /* 108 11 */
	{{ 8, 1, 10, 8, 0, 1, 10, 1, 6, 9, 4, 1, 6, 1, 4, -1}}, /* 109 7 */
	{{ 3, 6, 10, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1}}, /* 110 5 */
	{{ 6, 8, 4, 10, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 111 2 */
	{{ 7, 6, 11, 7, 11, 8, 8, 11, 9, -1, -1, -1, -1, -1, -1, -1}}, /* 112 5 */
	{{ 0, 3, 7, 0, 7, 11, 0, 11, 9, 6, 11, 7, -1, -1, -1, -1}}, /* 113 11 */
	{{11, 7, 6, 1, 7, 11, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1}}, /* 114 9 */
	{{11, 7, 6, 11, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1}}, /* 115 5 */
	{{ 1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1}}, /* 116 14 */
	{{ 2, 9, 6, 2, 1, 9, 6, 9, 7, 0, 3, 9, 7, 9, 3, -1}}, /* 117 7 */
	{{ 7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1}}, /* 118 5 */
	{{ 7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 119 2 */
	{{ 2, 10, 3, 11, 8, 6, 11, 9, 8, 8, 7, 6, -1, -1, -1, -1}}, /* 120 12 */
	{{ 2, 7, 0, 2, 10, 7, 0, 7, 9, 6, 11, 7, 9, 7, 11, -1}}, /* 121 7 */
	{{ 1, 0, 8, 1, 8, 7, 1, 7, 11, 6, 11, 7, 2, 10, 3, -1}}, /* 122 6 */
	{{10, 1, 2, 10, 7, 1, 11, 1, 6, 6, 1, 7, -1, -1, -1, -1}}, /* 123 3 */
	{{ 8, 6, 9, 8, 7, 6, 9, 6, 1, 10, 3, 6, 1, 6, 3, -1}}, /* 124 7 */
	{{ 0, 1, 9, 10, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 125 4 */
	{{ 7, 0, 8, 7, 6, 0, 3, 0, 10, 10, 0, 6, -1, -1, -1, -1}}, /* 126 3 */
	{{ 7, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 127 1 */
	{{ 7, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 128 1 */
	{{ 3, 8, 0, 10, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 129 3 */
	{{ 0, 9, 1, 10, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 130 4 */
	{{ 8, 9, 1, 8, 1, 3, 10, 6, 7, -1, -1, -1, -1, -1, -1, -1}}, /* 131 7 */
	{{11, 2, 1, 6, 7, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 132 3 */
	{{ 1, 11, 2, 3, 8, 0, 6, 7, 10, -1, -1, -1, -1, -1, -1, -1}}, /* 133 6 */
	{{ 2, 0, 9, 2, 9, 11, 6, 7, 10, -1, -1, -1, -1, -1, -1, -1}}, /* 134 7 */
	{{ 6, 7, 10, 2, 3, 11, 11, 3, 8, 11, 8, 9, -1, -1, -1, -1}}, /* 135 12 */
	{{ 7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 136 2 */
	{{ 7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1}}, /* 137 5 */
	{{ 2, 6, 7, 2, 7, 3, 0, 9, 1, -1, -1, -1, -1, -1, -1, -1}}, /* 138 7 */
	{{ 1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1}}, /* 139 14 */
	{{11, 6, 7, 11, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1}}, /* 140 5 */
	{{11, 6, 7, 1, 11, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1}}, /* 141 9 */
	{{ 0, 7, 3, 0, 11, 7, 0, 9, 11, 6, 7, 11, -1, -1, -1, -1}}, /* 142 11 */
	{{ 7, 11, 6, 7, 8, 11, 8, 9, 11, -1, -1, -1, -1, -1, -1, -1}}, /* 143 5 */
	{{ 6, 4, 8, 10, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 144 2 */
	{{ 3, 10, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1}}, /* 145 5 */
	{{ 8, 10, 6, 8, 6, 4, 9, 1, 0, -1, -1, -1, -1, -1, -1, -1}}, /* 146 7 */
	{{ 9, 6, 4, 9, 3, 6, 9, 1, 3, 10, 6, 3, -1, -1, -1, -1}}, /* 147 11 */
	{{ 6, 4, 8, 6, 8, 10, 2, 1, 11, -1, -1, -1, -1, -1, -1, -1}}, /* 148 7 */
	{{ 1, 11, 2, 3, 10, 0, 0, 10, 6, 0, 6, 4, -1, -1, -1, -1}}, /* 149 12 */
	{{ 4, 8, 10, 4, 10, 6, 0, 9, 2, 2, 9, 11, -1, -1, -1, -1}}, /* 150 10 */
	{{11, 3, 9, 11, 2, 3, 9, 3, 4, 10, 6, 3, 4, 3, 6, -1}}, /* 151 7 */
	{{ 8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1}}, /* 152 5 */
	{{ 0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 153 8 */
	{{ 1, 0, 9, 2, 4, 3, 2, 6, 4, 4, 8, 3, -1, -1, -1, -1}}, /* 154 12 */
	{{ 1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1}}, /* 155 5 */
	{{ 8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 11, -1, -1, -1, -1}}, /* 156 14 */
	{{11, 0, 1, 11, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1}}, /* 157 5 */
	{{ 4, 3, 6, 4, 8, 3, 6, 3, 11, 0, 9, 3, 11, 3, 9, -1}}, /* 158 7 */
	{{11, 4, 9, 6, 4, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 159 2 */
	{{ 4, 5, 9, 7, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 160 3 */
	{{ 0, 3, 8, 4, 5, 9, 10, 6, 7, -1, -1, -1, -1, -1, -1, -1}}, /* 161 6 */
	{{ 5, 1, 0, 5, 0, 4, 7, 10, 6, -1, -1, -1, -1, -1, -1, -1}}, /* 162 7 */
	{{10, 6, 7, 8, 4, 3, 3, 4, 5, 3, 5, 1, -1, -1, -1, -1}}, /* 163 12 */
	{{ 9, 4, 5, 11, 2, 1, 7, 10, 6, -1, -1, -1, -1, -1, -1, -1}}, /* 164 6 */
	{{ 6, 7, 10, 1, 11, 2, 0, 3, 8, 4, 5, 9, -1, -1, -1, -1}}, /* 165 13 */
	{{ 7, 10, 6, 5, 11, 4, 4, 11, 2, 4, 2, 0, -1, -1, -1, -1}}, /* 166 12 */
	{{ 3, 8, 4, 3, 4, 5, 3, 5, 2, 11, 2, 5, 10, 6, 7, -1}}, /* 167 6 */
	{{ 7, 3, 2, 7, 2, 6, 5, 9, 4, -1, -1, -1, -1, -1, -1, -1}}, /* 168 7 */
	{{ 9, 4, 5, 0, 6, 8, 0, 2, 6, 6, 7, 8, -1, -1, -1, -1}}, /* 169 12 */
	{{ 3, 2, 6, 3, 6, 7, 1, 0, 5, 5, 0, 4, -1, -1, -1, -1}}, /* 170 10 */
	{{ 6, 8, 2, 6, 7, 8, 2, 8, 1, 4, 5, 8, 1, 8, 5, -1}}, /* 171 7 */
	{{ 9, 4, 5, 11, 6, 1, 1, 6, 7, 1, 7, 3, -1, -1, -1, -1}}, /* 172 12 */
	{{ 1, 11, 6, 1, 6, 7, 1, 7, 0, 8, 0, 7, 9, 4, 5, -1}}, /* 173 6 */
	{{ 4, 11, 0, 4, 5, 11, 0, 11, 3, 6, 7, 11, 3, 11, 7, -1}}, /* 174 7 */
	{{ 7, 11, 6, 7, 8, 11, 5, 11, 4, 4, 11, 8, -1, -1, -1, -1}}, /* 175 3 */
	{{ 6, 5, 9, 6, 9, 10, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1}}, /* 176 5 */
	{{ 3, 10, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1}}, /* 177 9 */
	{{ 0, 8, 10, 0, 10, 5, 0, 5, 1, 5, 10, 6, -1, -1, -1, -1}}, /* 178 14 */
	{{ 6, 3, 10, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1}}, /* 179 5 */
	{{ 1, 11, 2, 9, 10, 5, 9, 8, 10, 10, 6, 5, -1, -1, -1, -1}}, /* 180 12 */
	{{ 0, 3, 10, 0, 10, 6, 0, 6, 9, 5, 9, 6, 1, 11, 2, -1}}, /* 181 6 */
	{{10, 5, 8, 10, 6, 5, 8, 5, 0, 11, 2, 5, 0, 5, 2, -1}}, /* 182 7 */
	{{ 6, 3, 10, 6, 5, 3, 2, 3, 11, 11, 3, 5, -1, -1, -1, -1}}, /* 183 3 */
	{{ 5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1}}, /* 184 11 */
	{{ 9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1}}, /* 185 5 */
	{{ 1, 8, 5, 1, 0, 8, 5, 8, 6, 3, 2, 8, 6, 8, 2, -1}}, /* 186 7 */
	{{ 1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 187 2 */
	{{ 1, 6, 3, 1, 11, 6, 3, 6, 8, 5, 9, 6, 8, 6, 9, -1}}, /* 188 7 */
	{{11, 0, 1, 11, 6, 0, 9, 0, 5, 5, 0, 6, -1, -1, -1, -1}}, /* 189 3 */
	{{ 0, 8, 3, 5, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 190 4 */
	{{11, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 191 1 */
	{{10, 11, 5, 7, 10, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 192 2 */
	{{10, 11, 5, 10, 5, 7, 8, 0, 3, -1, -1, -1, -1, -1, -1, -1}}, /* 193 7 */
	{{ 5, 7, 10, 5, 10, 11, 1, 0, 9, -1, -1, -1, -1, -1, -1, -1}}, /* 194 7 */
	{{11, 5, 7, 11, 7, 10, 9, 1, 8, 8, 1, 3, -1, -1, -1, -1}}, /* 195 10 */
	{{10, 2, 1, 10, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1}}, /* 196 5 */
	{{ 0, 3, 8, 1, 7, 2, 1, 5, 7, 7, 10, 2, -1, -1, -1, -1}}, /* 197 12 */
	{{ 9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 10, -1, -1, -1, -1}}, /* 198 14 */
	{{ 7, 2, 5, 7, 10, 2, 5, 2, 9, 3, 8, 2, 9, 2, 8, -1}}, /* 199 7 */
	{{ 2, 11, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1}}, /* 200 5 */
	{{ 8, 0, 2, 8, 2, 5, 8, 5, 7, 11, 5, 2, -1, -1, -1, -1}}, /* 201 11 */
	{{ 9, 1, 0, 5, 3, 11, 5, 7, 3, 3, 2, 11, -1, -1, -1, -1}}, /* 202 12 */
	{{ 9, 2, 8, 9, 1, 2, 8, 2, 7, 11, 5, 2, 7, 2, 5, -1}}, /* 203 7 */
	{{ 1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 204 8 */
	{{ 0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1}}, /* 205 5 */
	{{ 9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1}}, /* 206 5 */
	{{ 9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 207 2 */
	{{ 5, 4, 8, 5, 8, 11, 11, 8, 10, -1, -1, -1, -1, -1, -1, -1}}, /* 208 5 */
	{{ 5, 4, 0, 5, 0, 10, 5, 10, 11, 10, 0, 3, -1, -1, -1, -1}}, /* 209 14 */
	{{ 0, 9, 1, 8, 11, 4, 8, 10, 11, 11, 5, 4, -1, -1, -1, -1}}, /* 210 12 */
	{{11, 4, 10, 11, 5, 4, 10, 4, 3, 9, 1, 4, 3, 4, 1, -1}}, /* 211 7 */
	{{ 2, 1, 5, 2, 5, 8, 2, 8, 10, 4, 8, 5, -1, -1, -1, -1}}, /* 212 11 */
	{{ 0, 10, 4, 0, 3, 10, 4, 10, 5, 2, 1, 10, 5, 10, 1, -1}}, /* 213 7 */
	{{ 0, 5, 2, 0, 9, 5, 2, 5, 10, 4, 8, 5, 10, 5, 8, -1}}, /* 214 7 */
	{{ 9, 5, 4, 2, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 215 4 */
	{{ 2, 11, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1}}, /* 216 9 */
	{{ 5, 2, 11, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1}}, /* 217 5 */
	{{ 3, 2, 11, 3, 11, 5, 3, 5, 8, 4, 8, 5, 0, 9, 1, -1}}, /* 218 6 */
	{{ 5, 2, 11, 5, 4, 2, 1, 2, 9, 9, 2, 4, -1, -1, -1, -1}}, /* 219 3 */
	{{ 8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1}}, /* 220 5 */
	{{ 0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 221 2 */
	{{ 8, 5, 4, 8, 3, 5, 9, 5, 0, 0, 5, 3, -1, -1, -1, -1}}, /* 222 3 */
	{{ 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 223 1 */
	{{ 4, 7, 10, 4, 10, 9, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1}}, /* 224 5 */
	{{ 0, 3, 8, 4, 7, 9, 9, 7, 10, 9, 10, 11, -1, -1, -1, -1}}, /* 225 12 */
	{{ 1, 10, 11, 1, 4, 10, 1, 0, 4, 7, 10, 4, -1, -1, -1, -1}}, /* 226 11 */
	{{ 3, 4, 1, 3, 8, 4, 1, 4, 11, 7, 10, 4, 11, 4, 10, -1}}, /* 227 7 */
	{{ 4, 7, 10, 9, 4, 10, 9, 10, 2, 9, 2, 1, -1, -1, -1, -1}}, /* 228 9 */
	{{ 9, 4, 7, 9, 7, 10, 9, 10, 1, 2, 1, 10, 0, 3, 8, -1}}, /* 229 6 */
	{{10, 4, 7, 10, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1}}, /* 230 5 */
	{{10, 4, 7, 10, 2, 4, 8, 4, 3, 3, 4, 2, -1, -1, -1, -1}}, /* 231 3 */
	{{ 2, 11, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1}}, /* 232 14 */
	{{ 9, 7, 11, 9, 4, 7, 11, 7, 2, 8, 0, 7, 2, 7, 0, -1}}, /* 233 7 */
	{{ 3, 11, 7, 3, 2, 11, 7, 11, 4, 1, 0, 11, 4, 11, 0, -1}}, /* 234 7 */
	{{ 1, 2, 11, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 235 4 */
	{{ 4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1}}, /* 236 5 */
	{{ 4, 1, 9, 4, 7, 1, 0, 1, 8, 8, 1, 7, -1, -1, -1, -1}}, /* 237 3 */
	{{ 4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 238 2 */
	{{ 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 239 1 */
	{{ 9, 8, 11, 11, 8, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 240 8 */
	{{ 3, 9, 0, 3, 10, 9, 10, 11, 9, -1, -1, -1, -1, -1, -1, -1}}, /* 241 5 */
	{{ 0, 11, 1, 0, 8, 11, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1}}, /* 242 5 */
	{{ 3, 11, 1, 10, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 243 2 */
	{{ 1, 10, 2, 1, 9, 10, 9, 8, 10, -1, -1, -1, -1, -1, -1, -1}}, /* 244 5 */
	{{ 3, 9, 0, 3, 10, 9, 1, 9, 2, 2, 9, 10, -1, -1, -1, -1}}, /* 245 3 */
	{{ 0, 10, 2, 8, 10, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 246 2 */
	{{ 3, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 247 1 */
	{{ 2, 8, 3, 2, 11, 8, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1}}, /* 248 5 */
	{{ 9, 2, 11, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 249 2 */
	{{ 2, 8, 3, 2, 11, 8, 0, 8, 1, 1, 8, 11, -1, -1, -1, -1}}, /* 250 3 */
	{{ 1, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 251 1 */
	{{ 1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 252 2 */
	{{ 0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 253 1 */
	{{ 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, /* 254 1 */
	{{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}}; /* 255 0 */



	static int CASE_MASK[8] = {1,2,4,8,16,32,64,128};
	TRIANGLE_CASES_HEXA *triCase;
	EDGE_LIST  *edge;
	int i, j, index, *vert;
	int e1, e2;

	float t, x1[3], x2[3], x[3], deltaScalar;
	C3DPoint IsoTriangle[3];
	CList <C3DPoint, C3DPoint>* pVertList;
	CArray <BOOL, BOOL>* pEdgeList;

	// Build the case table
	for ( i=0, index = 0; i < 8; i++)
		{
		if (SolidcellScalars[i] >= value)
			{
			index |= CASE_MASK[i];
			}
		}

	triCase = triCases + index;
	edge = triCase->edges;

	for ( ; edge[0] > -1; edge += 3 )
	{
		
		for (i=0; i<3; i++) // insert triangle
		{
			vert = edges[edge[i]];
			// calculate a preferred interpolation direction
			deltaScalar = (SolidcellScalars[vert[1]] - SolidcellScalars[vert[0]]);
			if (deltaScalar > 0)
				{
				e1 = vert[0]; e2 = vert[1];
				}
			else
				{
				e1 = vert[1]; e2 = vert[0];
				deltaScalar = -deltaScalar;
				}

			// linear interpolation
			if (deltaScalar == 0.0)
			{
				t = 0.0;
			}
			else
			{
				t = (value - SolidcellScalars[e1]) / deltaScalar;
			}

			x1[0] = aVertexes[e1].x; x1[1] = aVertexes[e1].y; x1[2] = aVertexes[e1].z;
			x2[0] = aVertexes[e2].x; x2[1] = aVertexes[e2].y; x2[2] = aVertexes[e2].z;
			
			for (j=0; j<3; j++)
			{
				x[j] = x1[j] + t * (x2[j] - x1[j]);
			}
			IsoTriangle[i].Set(x[0],x[1],x[2]);
		}
		pVertList = new CList <C3DPoint, C3DPoint>;
		pEdgeList = new CArray <BOOL, BOOL>;
		for (i=0; i<3; i++)
		{
			pVertList->AddHead(IsoTriangle[i]);
			pEdgeList->Add(TRUE);
		}
		PolygonList.Add(pVertList);
		PolygonEdgeArray.Add(pEdgeList);
	}
}



void CEngineBase::GetWedgeSolidContourPolys(float value, double *SolidcellScalars, C3DPoint* aVertexes,
										 CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>	&PolygonList,
										 CArray <CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					&PolygonEdgeArray)
{

// Marching (convex) wedge
//
	static int edges[9][2] = { {0,1}, {1,2}, {2,0}, 
											{3,4}, {4,5}, {5,3},
											{0,3}, {1,4}, {2,5} };
	/*int faces[5][4] = { {0,1,2,-1}, {3,5,4,-1}, 
											{0,3,4,1}, {1,4,5,2}, {2,5,3,0} };
											*/
	

	static TRIANGLE_CASES_WEDGE triCases[] = { 
	{{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, //0
	{{ 0,  6,  2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, //1
	{{ 0,  1,  7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, //2
	{{ 6,  1,  7,  6,  2,  1, -1, -1, -1, -1, -1, -1, -1}}, //3
	{{ 1,  2,  8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, //4
	{{ 6,  1,  0,  6,  8,  1, -1, -1, -1, -1, -1, -1, -1}}, //5
	{{ 0,  2,  8,  7,  0,  8, -1, -1, -1, -1, -1, -1, -1}}, //6
	{{ 7,  6,  8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, //7
	{{ 3,  5,  6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, //8
	{{ 3,  5,  0,  5,  2,  0, -1, -1, -1, -1, -1, -1, -1}}, //9
	{{ 0,  1,  7,  6,  3,  5, -1, -1, -1, -1, -1, -1, -1}}, //10
	{{ 1,  7,  3,  1,  3,  5,  1,  5,  2, -1, -1, -1, -1}}, //11
	{{ 2,  8,  1,  6,  3,  5, -1, -1, -1, -1, -1, -1, -1}}, //12
	{{ 0,  3,  1,  1,  3,  5,  1,  5,  8, -1, -1, -1, -1}}, //13
	{{ 6,  3,  5,  0,  8,  7,  0,  2,  8, -1, -1, -1, -1}}, //14
	{{ 7,  3,  5,  7,  5,  8, -1, -1, -1, -1, -1, -1, -1}}, //15
	{{ 7,  4,  3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, //16
	{{ 7,  4,  3,  0,  6,  2, -1, -1, -1, -1, -1, -1, -1}}, //17
	{{ 0,  1,  3,  1,  4,  3, -1, -1, -1, -1, -1, -1, -1}}, //18
	{{ 1,  4,  3,  1,  3,  6,  1,  6,  2, -1, -1, -1, -1}}, //19
	{{ 7,  4,  3,  2,  8,  1, -1, -1, -1, -1, -1, -1, -1}}, //20
	{{ 7,  4,  3,  6,  1,  0,  6,  8,  1, -1, -1, -1, -1}}, //21
	{{ 0,  4,  3,  0,  8,  4,  0,  2,  8, -1, -1, -1, -1}}, //22
	{{ 6,  8,  3,  3,  8,  4, -1, -1, -1, -1, -1, -1, -1}}, //23
	{{ 6,  7,  4,  6,  4,  5, -1, -1, -1, -1, -1, -1, -1}}, //24
	{{ 0,  7,  5,  7,  4,  5,  2,  0,  5, -1, -1, -1, -1}}, //25
	{{ 6,  0,  1,  6,  1,  5,  5,  1,  4, -1, -1, -1, -1}}, //26
	{{ 2,  1,  5,  5,  1,  4, -1, -1, -1, -1, -1, -1, -1}}, //27
	{{ 2,  8,  1,  6,  7,  5,  7,  4,  5, -1, -1, -1, -1}}, //28
	{{ 0,  7,  5,  7,  4,  5,  0,  5,  1,  1,  5,  8, -1}}, //29
	{{ 0,  2,  8,  0,  8,  4,  0,  4,  5,  0,  5,  6, -1}}, //30
	{{ 8,  4,  5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, //31
	{{ 4,  8,  5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, //32
	{{ 4,  8,  5,  0,  6,  2, -1, -1, -1, -1, -1, -1, -1}}, //33
	{{ 4,  8,  5,  0,  1,  7, -1, -1, -1, -1, -1, -1, -1}}, //34
	{{ 4,  8,  5,  6,  1,  7,  6,  2,  1, -1, -1, -1, -1}}, //35
	{{ 1,  5,  4,  2,  5,  1, -1, -1, -1, -1, -1, -1, -1}}, //36
	{{ 1,  5,  4,  1,  6,  5,  1,  0,  6, -1, -1, -1, -1}}, //37
	{{ 0,  2,  7,  7,  2,  5,  7,  5,  4, -1, -1, -1, -1}}, //38
	{{ 7,  5,  4,  7,  6,  5, -1, -1, -1, -1, -1, -1, -1}}, //39
	{{ 6,  3,  4,  6,  4,  8, -1, -1, -1, -1, -1, -1, -1}}, //40
	{{ 0,  3,  2,  2,  3,  8,  8,  3,  4, -1, -1, -1, -1}}, //41
	{{ 7,  0,  1,  6,  3,  4,  6,  4,  8, -1, -1, -1, -1}}, //42
	{{ 8,  2,  1,  3,  4,  7, -1, -1, -1, -1, -1, -1, -1}}, //43
	{{ 6,  1,  2,  1,  6,  4,  6,  3,  4, -1, -1, -1, -1}}, //44
	{{ 0,  3,  1,  3,  4,  1, -1, -1, -1, -1, -1, -1, -1}}, //45
	{{ 6,  0,  2,  3,  4,  7, -1, -1, -1, -1, -1, -1, -1}}, //46
	{{ 7,  3,  4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, //47
	{{ 7,  8,  5,  7,  5,  3, -1, -1, -1, -1, -1, -1, -1}}, //48
	{{ 0,  6,  2,  7,  8,  5,  7,  5,  3, -1, -1, -1, -1}}, //49
	{{ 0,  1,  3,  1,  5,  3,  1,  8,  5, -1, -1, -1, -1}}, //50
	{{ 2,  1,  6,  6,  1,  3,  5,  1,  8,  3,  1,  5, -1}}, //51
	{{ 1,  3,  7,  1,  5,  3,  1,  2,  5, -1, -1, -1, -1}}, //52
	{{ 1,  0,  6,  1,  6,  5,  1,  5,  7,  7,  5,  3, -1}}, //53
	{{ 0,  2,  5,  0,  5,  3, -1, -1, -1, -1, -1, -1, -1}}, //54
	{{ 3,  6,  5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, //55
	{{ 7,  8,  6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, //56
	{{ 0,  7,  8,  0,  8,  2, -1, -1, -1, -1, -1, -1, -1}}, //57
	{{ 0,  1,  6,  1,  8,  6, -1, -1, -1, -1, -1, -1, -1}}, //58
	{{ 2,  1,  8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, //59
	{{ 7,  1,  6,  6,  1,  2, -1, -1, -1, -1, -1, -1, -1}}, //60
	{{ 0,  7,  1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, //61
	{{ 2,  6,  0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}, //62
 {{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}};  //63
	
 

	static int CASE_MASK[6] = {1,2,4,8,16,32};
	TRIANGLE_CASES_WEDGE *triCase;
	EDGE_LIST  *edge;
	int i, j, index, *vert;
	int e1,e2;

	float t, x1[3], x2[3], x[3];
	C3DPoint IsoTriangle[3];
	CList <C3DPoint, C3DPoint>* pVertList;
	CArray <BOOL, BOOL>* pEdgeList;


	// Build the case table
	for ( i=0, index = 0; i < 6; i++)
		{
		if (SolidcellScalars[i] >= value)
			{
			index |= CASE_MASK[i];
			}
		}

	triCase = triCases + index;
	edge = triCase->edges;

	for ( ; edge[0] > -1; edge += 3 )
	{
		for (i=0; i<3; i++) // insert triangle
		{
			vert = edges[edge[i]];
			t = (value - SolidcellScalars[vert[0]]) /
					(SolidcellScalars[vert[1]] - SolidcellScalars[vert[0]]);

			e1 = vert[0]; e2 = vert[1];

			x1[0] = aVertexes[e1].x; x1[1] = aVertexes[e1].y; x1[2] = aVertexes[e1].z;
			x2[0] = aVertexes[e2].x; x2[1] = aVertexes[e2].y; x2[2] = aVertexes[e2].z;
			
			for (j=0; j<3; j++)
			{
				x[j] = x1[j] + t * (x2[j] - x1[j]);
			}
			IsoTriangle[i].Set(x[0],x[1],x[2]);
		}
		pVertList = new CList <C3DPoint, C3DPoint>;
		pEdgeList = new CArray <BOOL, BOOL>;
		for (i=0; i<3; i++)
		{
			pVertList->AddHead(IsoTriangle[i]);
			pEdgeList->Add(TRUE);
		}
		PolygonList.Add(pVertList);
		PolygonEdgeArray.Add(pEdgeList);
	}
}


void CEngineBase::GetTetraSolidContourPolys(float value, double *SolidcellScalars, C3DPoint* aVertexes,
										 CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>	&PolygonList,
										 CArray <CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					&PolygonEdgeArray)
{

//
// Marching (convex) tetrahedron
//
	static int edges[6][2] = { {0,1}, {1,2}, {2,0}, 
													 {0,3}, {1,3}, {2,3} };
	//int faces[4][3] = { {0,1,3}, {1,2,3}, {2,0,3}, {0,2,1} };


	static TRIANGLE_CASES_TETRA triCases[] = { 
	{{-1, -1, -1, -1, -1, -1, -1}},
	{{ 0, 3, 2, -1, -1, -1, -1}},
	{{ 0, 1, 4, -1, -1, -1, -1}},
	{{ 3, 2, 4, 4, 2, 1, -1}},
	{{ 1, 2, 5, -1, -1, -1, -1}},
	{{ 3, 5, 1, 3, 1, 0, -1}},
	{{ 0, 2, 5, 0, 5, 4, -1}},
	{{ 3, 5, 4, -1, -1, -1, -1}},
	{{ 3, 4, 5, -1, -1, -1, -1}},
	{{ 0, 4, 5, 0, 5, 2, -1}},
	{{ 0, 5, 3, 0, 1, 5, -1}},
	{{ 5, 2, 1, -1, -1, -1, -1}},
	{{ 3, 4, 1, 3, 1, 2, -1}},
	{{ 0, 4, 1, -1, -1, -1, -1}},
	{{ 0, 2, 3, -1, -1, -1, -1}},
	{{-1, -1, -1, -1, -1, -1, -1}}};

	static int CASE_MASK[4] = {1,2,4,8};
	TRIANGLE_CASES_TETRA *triCase;
	EDGE_LIST  *edge;
	int i, j, index, *vert;
	int e1,e2;

	float t, x1[3], x2[3], x[3];
	C3DPoint IsoTriangle[3];
	CList <C3DPoint, C3DPoint>* pVertList;
	CArray <BOOL, BOOL>* pEdgeList;


	// Build the case table
	for ( i=0, index = 0; i < 4; i++)
	{
		if(SolidcellScalars[i] >= value)
		{
			index |= CASE_MASK[i];
		}
	}

	triCase = triCases + index;
	edge = triCase->edges;

	for ( ; edge[0] > -1; edge += 3 )
	{
		for (i=0; i<3; i++) // insert triangle
		{
			vert = edges[edge[i]];
			t = (value - SolidcellScalars[vert[0]]) /
					(SolidcellScalars[vert[1]] - SolidcellScalars[vert[0]]);

			e1 = vert[0]; e2 = vert[1];

			x1[0] = aVertexes[e1].x; x1[1] = aVertexes[e1].y; x1[2] = aVertexes[e1].z;
			x2[0] = aVertexes[e2].x; x2[1] = aVertexes[e2].y; x2[2] = aVertexes[e2].z;
			
			for (j=0; j<3; j++)
			{
				x[j] = x1[j] + t * (x2[j] - x1[j]);
			}
			IsoTriangle[i].Set(x[0],x[1],x[2]);
		}
		pVertList = new CList <C3DPoint, C3DPoint>;
		pEdgeList = new CArray <BOOL, BOOL>;
		for (i=0; i<3; i++)
		{
			pVertList->AddHead(IsoTriangle[i]);
			pEdgeList->Add(TRUE);
		}
		PolygonList.Add(pVertList);
		PolygonEdgeArray.Add(pEdgeList);
	}
}



void CEngineBase::DrawSolidFreeEdge(CDC *pDC, T_ELEM_K ekey, CArray <C3DPoint, C3DPoint>& aUnSortedVertex)
{
	T_MIRE_K mkey;
	mkey.keymap = ekey;

	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;
	CClientDC			dc(gm->m_pMyView);
	
	T_FREEEDGE FreeEdge;
	CArray<C3DPoint,C3DPoint&> aFreeEdgePoint1,aFreeEdgePoint2;

	C3DPoint Point;
	CArray<T_FREEEDGE, T_FREEEDGE&>* paFreeEdge; 
	
	if(!m_mapFreeEdgebyElemKey.Lookup(mkey.key.elem_k,paFreeEdge))
		return;

	for(int i=0; i<paFreeEdge->GetSize(); i++)
	{
		FreeEdge = paFreeEdge->GetAt(i);
		Point = aUnSortedVertex[FreeEdge.No1Index];
		gm->RE_GetMirroredPoint(mkey.key.mirror_k,&Point);
		aFreeEdgePoint1.Add(Point);
		Point = aUnSortedVertex[FreeEdge.No2Index];
		gm->RE_GetMirroredPoint(mkey.key.mirror_k,&Point);
		aFreeEdgePoint2.Add(Point);
	}

	
	///////////////////////////////////////////////////////////////////////////		
	CPen pen,*old_pen,*old_pen2;
	if(gm->m_nSolidFreeEdgeType == 0)
		//pen.CreatePen(PS_SOLID, gm->m_nLineWidth*1.0, gm->m_FreeEdgeColor);
		pen.CreatePen(PS_SOLID, gm->m_nLineWidth*1.0, gm->m_DOPT.CL.m_FreeEdgeColor);
	else
		//pen.CreatePen(PS_SOLID, gm->m_nLineWidth*2.0, gm->m_FreeEdgeColor);
		pen.CreatePen(PS_SOLID, gm->m_nLineWidth*2.0, gm->m_DOPT.CL.m_FreeEdgeColor);

	old_pen = (CPen *) pDC->SelectObject(&pen);
	if(!gm->m_bVirtualMode && !gm->m_bAnimation)
		old_pen2 = (CPen *) dc.SelectObject(&pen);

	
	for(int i = 0; i<aFreeEdgePoint1.GetSize(); i++)
	{

	 	if (gm->m_bVirtualMode)
			gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, aFreeEdgePoint1[i], aFreeEdgePoint2[i]);
		else
		{
			if(!gm->m_bAnimation)
				gm->m_pGPSCtrl->DrawLine3DOnClientWindow(&dc, aFreeEdgePoint1[i], aFreeEdgePoint2[i]);
			gm->m_pGPSCtrl->DrawLine3D(pDC,aFreeEdgePoint1[i], aFreeEdgePoint2[i]);
		}
	}
			
		

	pDC->SelectObject(old_pen);
	if(!gm->m_bVirtualMode && !gm->m_bAnimation)
		dc.SelectObject(old_pen2);
	pen.DeleteObject();


}

void CEngineBase::MakeFreeEdgeData()
{
	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;
	
	CArray<T_FREEEDGE, T_FREEEDGE&> arFreeEdge; 
	if(gm->m_nSolidFreeEdgeType == 0)
		m_pDoc->makeFreeFace(gm->m_EKeyListActive,arFreeEdge);
	else
		m_pDoc->makeFreeEdge(gm->m_EKeyListActive,arFreeEdge);
	
	CArray<T_FREEEDGE, T_FREEEDGE&>* paFreeEdge; 
	T_FREEEDGE FreeEdge;

	for(int i=0; i<arFreeEdge.GetSize(); i++)
	{
		FreeEdge = arFreeEdge[i];

		if(m_mapFreeEdgebyElemKey.Lookup(FreeEdge.KeyElem,paFreeEdge))
			paFreeEdge->Add(FreeEdge);
		else
		{
			paFreeEdge = new CArray<T_FREEEDGE, T_FREEEDGE&>;
			paFreeEdge->Add(FreeEdge);
			m_mapFreeEdgebyElemKey.SetAt(FreeEdge.KeyElem,paFreeEdge);
		}
	}

	m_bIsFreeEdgeDataSet = TRUE;

}

void CEngineBase::MakeFreeFaceData()
{
	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;
	
	//GTimeCheckStart();
	CArray<T_FREEFACE, T_FREEFACE&> arFreeFace; 
	m_pDoc->makeFreeFace(gm->m_EKeyListActive,arFreeFace);
	//double t1=GTimeCheckEnd();
	
	CArray<int, int>* paFreeFace; 
	T_FREEFACE FreeFace;

	//GTimeCheckStart();
	for(int i=0; i<arFreeFace.GetSize(); i++)
	{
		FreeFace = arFreeFace[i];

		if(m_mapFreeFacebyElemKey.Lookup(FreeFace.KeyElem,paFreeFace))
			paFreeFace->Add(FreeFace.nFace);
		else
		{
			paFreeFace = new CArray<int, int>;
			paFreeFace->Add(FreeFace.nFace);
			m_mapFreeFacebyElemKey.SetAt(FreeFace.KeyElem,paFreeFace);
		}
	}
	//double t2=GTimeCheckEnd();
	//GSaveHistoryFormatNF("t1=%g, t2=%g", t1, t2);

	m_bIsFreeFaceDataSet = TRUE;

}


void CEngineBase::RemoveFreeEdgeData()
{
	T_ELEM_K key;
	CArray<T_FREEEDGE, T_FREEEDGE&>* paFreeEdge; 
	POSITION pos = m_mapFreeEdgebyElemKey.GetStartPosition();
	while(pos)
	{
		m_mapFreeEdgebyElemKey.GetNextAssoc(pos,key,paFreeEdge);
		paFreeEdge->RemoveAll();
		delete[] paFreeEdge;
	}
	m_mapFreeEdgebyElemKey.RemoveAll();
	m_bIsFreeEdgeDataSet = FALSE;

}

void CEngineBase::RemoveFreeFaceData()
{
	T_ELEM_K key;
	CArray<int, int>* paFreeFace; 
	POSITION pos = m_mapFreeFacebyElemKey.GetStartPosition();
	while(pos)
	{
		m_mapFreeFacebyElemKey.GetNextAssoc(pos,key,paFreeFace);
		paFreeFace->RemoveAll();
		delete[] paFreeFace;
	}
	m_mapFreeFacebyElemKey.RemoveAll();
	m_bIsFreeFaceDataSet = FALSE;
}

BOOL CEngineBase::IsFreeFace(CArray<int,int>* paFreeFace,int nFaceIndex)
{
	BOOL bFreeFaceFound = FALSE;
	for(int nFace = 0; nFace < paFreeFace->GetSize(); nFace++)
		if(nFaceIndex+1 == paFreeFace->GetAt(nFace))
		{
			bFreeFaceFound = TRUE;
			break;
		}

	return bFreeFaceFound;

}

// 정점들의 리스트를 받아서 평면의 법선벡터에 대해 CCW한 꼬이지 않은 폴리곤을 만들어낸다.
void CEngineBase::GetPolygon(CArray <C3DPoint,C3DPoint>& aCutVertex,
															 CArray <double, double>& aCutVertexVal, PLANE_FUNC& CuttingPlaneF)
{
	double dCenterPoint[3]={0.0},dPoint1[3],dPoint[3];
	double dVector1[3],dVector[3],dAngle;
	CArray<double,double> aAngle;

	C3DPoint Vertex,Point1,Point2;
	double  dVertexVal;
	double dist;
	
	//우선 중복된 점이 있으면 제거한다.
	for(int i =0; i<aCutVertex.GetSize()-1; i++)
		for(int j=i+1; j<aCutVertex.GetSize(); j++)
		{
			dist = CMathFunc::mathLength(aCutVertex[i].x,aCutVertex[i].y,aCutVertex[i].z,
			aCutVertex[j].x,aCutVertex[j].y,aCutVertex[j].z);
					
			if(dist<1e-8)
			{
				aCutVertex.RemoveAt(j);
				aCutVertexVal.RemoveAt(j);
				j--;
			}
		}	
	
		
	for(int i=0; i<aCutVertex.GetSize(); i++)
	{
		dCenterPoint[0] += aCutVertex[i].x;
		dCenterPoint[1] += aCutVertex[i].y;
		dCenterPoint[2] += aCutVertex[i].z;
	}
	
	dCenterPoint[0] /= aCutVertex.GetSize();
	dCenterPoint[1] /= aCutVertex.GetSize();
	dCenterPoint[2] /= aCutVertex.GetSize();

	dPoint1[0] = aCutVertex[0].x;
	dPoint1[1] = aCutVertex[0].y;
	dPoint1[2] = aCutVertex[0].z;

	dVector1[0] = dPoint1[0] - dCenterPoint[0];
	dVector1[1] = dPoint1[1] - dCenterPoint[1];
	dVector1[2] = dPoint1[2] - dCenterPoint[2];
	CMathFunc::mathNormalize(dVector1,dVector1);

	aAngle.Add(0.0);

	for(int i=1; i<aCutVertex.GetSize(); i++)
	{
		dPoint[0] = aCutVertex[i].x;
		dPoint[1] = aCutVertex[i].y;
		dPoint[2] = aCutVertex[i].z;

		dVector[0] = dPoint[0] - dCenterPoint[0];
		dVector[1] = dPoint[1] - dCenterPoint[1];
		dVector[2] = dPoint[2] - dCenterPoint[2];

		CMathFunc::mathNormalize(dVector,dVector);
		
		dAngle = CMathFunc::mathCrossAngle(dVector,dVector1);

		//평면상에서 기준벡터를 축으로 10도 돌려 평면법선벡터와 비교하여 양수이면 0~180사이의 각이다.
		CMathFunc::mathRotate(10,dPoint1[0],dPoint1[1],dPoint1[2],dVector1[0],dVector1[1],dVector1[2],
			dPoint[0],dPoint[1],dPoint[2]); 
		if(CuttingPlaneF.a*dPoint[0] +CuttingPlaneF.b*dPoint[1] +CuttingPlaneF.c*dPoint[2] +CuttingPlaneF.h <0.0) 
			dAngle *= -1.0;

		if(dAngle<0) dAngle = 360+dAngle;
		aAngle.Add(dAngle);
	}

	// 각도를 기준으로 소팅 
	for(int i =1; i<aCutVertex.GetSize(); i++)
		for(int j=i+1; j<aCutVertex.GetSize(); j++)
		{
			if(aAngle[j]<aAngle[i])
			{
				dAngle = aAngle[j];
				Vertex = aCutVertex[j];
				dVertexVal = aCutVertexVal[j];

				aAngle[j] = aAngle[i];
				aCutVertex[j] = aCutVertex[i];
				aCutVertexVal[j] =aCutVertexVal[i] ;

				aAngle[i] = dAngle;
				aCutVertex[i] = Vertex;
				aCutVertexVal[i] =dVertexVal;
			}
		}
}


int CEngineBase::GetSolidSurface( T_ELEM_D &edata, int node_num,CArray <T_NODE_K, T_NODE_K> *Vertex)
{
	int NodeOrder1,NodeOrder2;
	NodeOrder1 =GetNodeOrder(Vertex->GetAt(1), edata, node_num);
	NodeOrder2 =GetNodeOrder(Vertex->GetAt(2), edata, node_num);

	if(abs(NodeOrder1- NodeOrder2)>1) return 2; // Side Surface

	if((NodeOrder1- NodeOrder2) == 1) return 0; // top Surface
	
	return 1; // bottom surface;

}


void CEngineBase::MakeCutPlaneMovingPath()
{
 	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;
	
	m_dMaxDist = -DBL_MAX;
	m_dMinDist = DBL_MAX;

	double dPoint[8][3]; //아랫판 Min포인트에서 시작 시계 반대방향으로 회전 dPoint0= Min
											 // 윗판 Min포인트의 윗점에서 시작 시계 반대방향으로 회전  dPoint6= Max
	double dDist[8];

//
	dPoint[0][0] = m_CutPlnMovingRangeMinPnt.x;
	dPoint[0][1] = m_CutPlnMovingRangeMinPnt.y;
	dPoint[0][2] = m_CutPlnMovingRangeMinPnt.z;
	
	dPoint[1][0] = m_CutPlnMovingRangeMaxPnt.x;
	dPoint[1][1] = m_CutPlnMovingRangeMinPnt.y;
	dPoint[1][2] = m_CutPlnMovingRangeMinPnt.z;

	dPoint[2][0] = m_CutPlnMovingRangeMaxPnt.x;
	dPoint[2][1] = m_CutPlnMovingRangeMaxPnt.y;
	dPoint[2][2] = m_CutPlnMovingRangeMinPnt.z;

	dPoint[3][0] = m_CutPlnMovingRangeMinPnt.x;
	dPoint[3][1] = m_CutPlnMovingRangeMaxPnt.y;
	dPoint[3][2] = m_CutPlnMovingRangeMinPnt.z;
//
	dPoint[4][0] = m_CutPlnMovingRangeMinPnt.x;
	dPoint[4][1] = m_CutPlnMovingRangeMinPnt.y;
	dPoint[4][2] = m_CutPlnMovingRangeMaxPnt.z;

	dPoint[5][0] = m_CutPlnMovingRangeMaxPnt.x;
	dPoint[5][1] = m_CutPlnMovingRangeMinPnt.y;
	dPoint[5][2] = m_CutPlnMovingRangeMaxPnt.z;

	dPoint[6][0] = m_CutPlnMovingRangeMaxPnt.x;
	dPoint[6][1] = m_CutPlnMovingRangeMaxPnt.y;
	dPoint[6][2] = m_CutPlnMovingRangeMaxPnt.z;

	dPoint[7][0] = m_CutPlnMovingRangeMinPnt.x;
	dPoint[7][1] = m_CutPlnMovingRangeMaxPnt.y;
	dPoint[7][2] = m_CutPlnMovingRangeMaxPnt.z;
//
	T_NPLN_D CuttingPlane;
	PLANE_FUNC CuttingPlaneF;
	GetNPLN(gm->m_aCutPlanes[gm->m_nMovingPlane],CuttingPlane);
	CMathFunc::mathPlaneEquation(CuttingPlane.dPoint[0],CuttingPlane.dPoint[1],CuttingPlane.dPoint[2],
																	CuttingPlaneF.a,CuttingPlaneF.b,CuttingPlaneF.c,CuttingPlaneF.h);

	for(int i = 0 ; i<8; i++)
	{
		dDist[i] = CMathFunc::mathDistanceToPlaneWithSign(CuttingPlaneF.a,CuttingPlaneF.b,CuttingPlaneF.c,CuttingPlaneF.h,
																						 dPoint[i][0],dPoint[i][1],dPoint[i][2]);
		if(m_dMaxDist < dDist[i]) m_dMaxDist = dDist[i];
		if(m_dMinDist > dDist[i]) m_dMinDist = dDist[i];
	}
		
}

void CEngineBase::GetMovedCuttingPlane(T_NPLN_D &CuttingPlane)
{
	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;
	C3DPoint Point1,Point2;
	double dPlnVect[3];
	int i;

	switch(gm->m_nMovingDir)
	{
	case 0:// X dir Sweep
		
		CuttingPlane.nPlaneType = 4; // Y-Z Plane
		CuttingPlane.dCoor = m_CutPlnMovingRangeMinPnt.x + 
			(m_CutPlnMovingRangeMaxPnt.x-m_CutPlnMovingRangeMinPnt.x)*gm->m_AnimEngine.GetAnimationFactor(TRUE);
		return;

		break;
	case 1:// Y dir Sweep

		CuttingPlane.nPlaneType = 3; // X-Z Plane
		CuttingPlane.dCoor = m_CutPlnMovingRangeMinPnt.y + 
			(m_CutPlnMovingRangeMaxPnt.y-m_CutPlnMovingRangeMinPnt.y)*gm->m_AnimEngine.GetAnimationFactor(TRUE);
		return;
		break;

	case 2:// Z dir Sweep
		CuttingPlane.nPlaneType = 2; // X-Y Plane
		CuttingPlane.dCoor = m_CutPlnMovingRangeMinPnt.z + 
			(m_CutPlnMovingRangeMaxPnt.z-m_CutPlnMovingRangeMinPnt.z)*gm->m_AnimEngine.GetAnimationFactor(TRUE);
		return;

		break;
	case 3:// Normal to Plane;
		PLANE_FUNC CuttingPlaneF;
		
		
		CMathFunc::mathPlaneEquation(CuttingPlane.dPoint[0],CuttingPlane.dPoint[1],CuttingPlane.dPoint[2],
																	CuttingPlaneF.a,CuttingPlaneF.b,CuttingPlaneF.c,CuttingPlaneF.h);
		dPlnVect[0] = CuttingPlaneF.a;
		dPlnVect[1] = CuttingPlaneF.b;
		dPlnVect[2] = CuttingPlaneF.c;
		double dMovingDist; 
		for( i=0; i<3; i++)
		{
			Point1.x = CuttingPlane.dPoint[i][0];
			Point1.y = CuttingPlane.dPoint[i][1];
			Point1.z = CuttingPlane.dPoint[i][2];
			dMovingDist = m_dMinDist + (m_dMaxDist - m_dMinDist)*gm->m_AnimEngine.GetAnimationFactor(TRUE);
			CUtilFuncs::GetVectorDirectionPoint(dPlnVect,dMovingDist,1.0,Point1,Point2 );
			CuttingPlane.dPoint[i][0] = Point2.x;
			CuttingPlane.dPoint[i][1] = Point2.y;
			CuttingPlane.dPoint[i][2] = Point2.z;
		}
		break;
	case 4:// Rotaion by UCS Axis
		C3DPoint OriginPoint,UCSXVect,UCSYVect,UCSZVect;
		C3DPoint Point0,Point1,Point2;
		C3DPoint wPoint0,wPoint1,wPoint2;
		gm->m_pGPSCtrl->GetCurUcsData(OriginPoint,UCSXVect,UCSYVect,UCSZVect);

		Point0.x = 0.0;
		Point0.y = 0.0;
		Point0.z = 0.0;
		// get start point in UCS
		switch(gm->m_nRotationUCSAxis)
		{
			case 0: // X axis;
			Point1.x = 0.0;
			Point1.y = 10.0;
			Point1.z = 0.0;
		
			Point2.x = 10.0;
			Point2.y = 0.0;
			Point2.z = 0.0;
			 break;
			 case 1: // Y axis;
			
			Point1.x = 0.0;
			Point1.y = 0.0;
			Point1.z = 10.0;
		
			Point2.x = 0.0;
			Point2.y = 10.0;
			Point2.z = 0.0;
			break;
			case 2: // Z axis
			Point1.x = 10.0;
			Point1.y = 0.0;
			Point1.z = 0.0;
		
			Point2.x = 0.0;
			Point2.y = 0.0;
			Point2.z = 10.0;
				break;
		}

		// get moved point in UCS
		const double pi = CMathFunc::m_pi;
		const double radius = 10.0;
		double x, y;
		
		x = radius*cos(pi*gm->m_AnimEngine.GetAnimationFactor(TRUE));
		y = radius*sin(pi*gm->m_AnimEngine.GetAnimationFactor(TRUE));

		switch(gm->m_nRotationUCSAxis)
		{
		case 0: // X axis;
			Point1.y = x;
			Point1.z = y;
			break;
		case 1: // Y axis;
			Point1.x = y;
			Point1.z = x;
			break;
		case 2: // Z axis
			Point1.x = x;
			Point1.y = y;
			break;
		}
		
		gm->m_pGPSCtrl->CalcFromUcsToWcs(Point0,wPoint0);
		gm->m_pGPSCtrl->CalcFromUcsToWcs(Point1,wPoint1);
		gm->m_pGPSCtrl->CalcFromUcsToWcs(Point2,wPoint2);

		CuttingPlane.dPoint[0][0] = wPoint0.x;
		CuttingPlane.dPoint[0][1] = wPoint0.y;
		CuttingPlane.dPoint[0][2] = wPoint0.z;
		
		CuttingPlane.dPoint[1][0] = wPoint1.x;
		CuttingPlane.dPoint[1][1] = wPoint1.y;
		CuttingPlane.dPoint[1][2] = wPoint1.z;
		
		CuttingPlane.dPoint[2][0] = wPoint2.x;
		CuttingPlane.dPoint[2][1] = wPoint2.y;
		CuttingPlane.dPoint[2][2] = wPoint2.z;
		
		return;
		break;
	}

}


void CEngineBase::ReflectVertex(C3DPoint* pnt,int r)
{
	// 쓰이지 않는 루틴....
	T_NPLN_K npln_k;
	T_NPLN_D ReflectionPlane;
	PLANE_FUNC ReflectionPlaneF;
	double dPlnVect[3];
	double dDist;

	switch(r)
	{
	case 0:
		npln_k = UCS_XZ;
		break;
	case 1:
		npln_k = UCS_YZ;
		break;
	case 2:
		return;
		break;
	}
	
	GetNPLN(npln_k,ReflectionPlane);
	


	CMathFunc::mathPlaneEquation(ReflectionPlane.dPoint[0],ReflectionPlane.dPoint[1],ReflectionPlane.dPoint[2],
																ReflectionPlaneF.a,ReflectionPlaneF.b,ReflectionPlaneF.c,ReflectionPlaneF.h);
	dPlnVect[0] = ReflectionPlaneF.a;
	dPlnVect[1] = ReflectionPlaneF.b;
	dPlnVect[2] = ReflectionPlaneF.c;
	CMathFunc::mathNormalize(dPlnVect,dPlnVect);

	dDist = CMathFunc::mathDistanceToPlaneWithSign(ReflectionPlaneF.a,ReflectionPlaneF.b,ReflectionPlaneF.c,ReflectionPlaneF.h,
																					 pnt->x,pnt->y,pnt->z);

	
	pnt->x = pnt->x - dPlnVect[0]*dDist*2;
	pnt->y = pnt->y - dPlnVect[1]*dDist*2;
	pnt->z = pnt->z - dPlnVect[2]*dDist*2;
	
}

void CEngineBase::DrawVectorArrow(CDC *pDC,CDC *pClientDC, C3DPoint pnt_c, C3DPoint pnt_p1, C3DPoint arr_p11, C3DPoint arr_p12,int nMirror_k)
{
	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;
	double dx,dy,dz;
	if(nMirror_k)
	{
		gm->RE_GetMirroredPoint(nMirror_k,&pnt_c);
		gm->RE_GetMirroredPoint(nMirror_k,&pnt_p1);
		gm->RE_GetMirroredPoint(nMirror_k,&arr_p11);
		gm->RE_GetMirroredPoint(nMirror_k,&arr_p12);
	}

	if (gm->m_bVirtualMode) {
		gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, pnt_c, pnt_p1);
		gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, pnt_p1, arr_p11);
		gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, pnt_p1, arr_p12);
	}
	else {
		if(!gm->m_bAnimation)
		{
			gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pClientDC, pnt_c, pnt_p1);
			gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pClientDC, pnt_p1, arr_p11);
			gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pClientDC, pnt_p1, arr_p12);
		}
		gm->m_pGPSCtrl->DrawLine3D(pDC, pnt_c, pnt_p1);
		gm->m_pGPSCtrl->DrawLine3D(pDC, pnt_p1, arr_p11);
		gm->m_pGPSCtrl->DrawLine3D(pDC, pnt_p1, arr_p12);
	}

	dx = pnt_p1.x - pnt_c.x;		pnt_p1.x = pnt_c.x - dx;
	dy = pnt_p1.y - pnt_c.y;		pnt_p1.y = pnt_c.y - dy;
	dz = pnt_p1.z - pnt_c.z;		pnt_p1.z = pnt_c.z - dz;

	dx = arr_p11.x - pnt_c.x;		arr_p11.x = pnt_c.x - dx;
	dy = arr_p11.y - pnt_c.y;		arr_p11.y = pnt_c.y - dy;
	dz = arr_p11.z - pnt_c.z;		arr_p11.z = pnt_c.z - dz;

	dx = arr_p12.x - pnt_c.x;		arr_p12.x = pnt_c.x - dx;
	dy = arr_p12.y - pnt_c.y;		arr_p12.y = pnt_c.y - dy;
	dz = arr_p12.z - pnt_c.z;		arr_p12.z = pnt_c.z - dz;

	if (gm->m_bVirtualMode) {
		gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, pnt_c, pnt_p1);
		gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, pnt_p1, arr_p11);
		gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, pnt_p1, arr_p12);
	}
	else {
		if(!gm->m_bAnimation)
		{
			gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pClientDC, pnt_c, pnt_p1);
			gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pClientDC, pnt_p1, arr_p11);
			gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pClientDC, pnt_p1, arr_p12);
		}
		gm->m_pGPSCtrl->DrawLine3D(pDC, pnt_c, pnt_p1);
		gm->m_pGPSCtrl->DrawLine3D(pDC, pnt_p1, arr_p11);
		gm->m_pGPSCtrl->DrawLine3D(pDC, pnt_p1, arr_p12);
	}
}

void CEngineBase::ResetEngine()
{
	m_pDoc = CDBDoc::GetDocPoint();

	if(m_pContourEngine)
	{
		if(m_pContourEngine != &(CGPSBarContainer::m_ContourEngine))
		{
			delete m_pContourEngine;
			m_pContourEngine			= NULL;
		}
	}

	m_bDeformedShapeContour		= FALSE;
	

	m_dMaxValue = 0.0;
	m_dMinValue = 0.0;
	m_MvlTrc_F_max = 0.0;
	m_MvlTrc_F_min = 0.0;
	m_dMaxModelLength = 0.0;
	
	m_MaxInflEKey		= 0;
	m_MinInflEKey		= 0;
	m_MaxInflPart		= 0;
	m_MinInflPart		= 0;

	m_InflKeyNode		= 1;
	m_InflKeyElem		= 1;
	m_InflKeyNlnk		= 1;
	m_InflKeyElnk   = 1;
	m_bInflDataSet  = FALSE; 

	m_bOnCuttingLine = FALSE;
	m_bAverageNodalActiveOnly = FALSE;
	m_bDrawMVLTRCLoad = TRUE;
	m_bMVLTRCValue = TRUE;

	m_bMvlTrcCF = FALSE;
	m_dMvlTrcCF = 0.0;
	m_dMvlTrcCF_H= 0.0;
	m_sMvlTrcCompNodeOrEle.Empty();
	m_sMvlTrcLoadDesc.Empty(); 


	m_bMVLTRCValue = TRUE;
	m_dMVLTRCScaleFactor = 1.0;
	m_nMVLTRCValueType = 1; //0:Exp, 1:Fixed
	m_nMVLTRCValueDePt = 2; //Decimal Point

	ResetCuttingLineData();
	RemoveFreeEdgeData();
	RemoveFreeFaceData();
		
	/*
	//m_arLaneInfo.RemoveAll();
	m_arLaneInfoNew.RemoveAll();
	m_arLaneKey.RemoveAll();
	m_arMvlTrcData.RemoveAll();
	m_mapBeamPosToValueforValueOut.RemoveAll();
	m_mapBeamPosToVertexforValueOut.RemoveAll();
	m_mapNodesInElem.RemoveAll();
	m_PlateKeyList.RemoveAll();
	m_mapSerialNode.RemoveAll();
	m_arImpFct.RemoveAll();
	m_arInflInfo.RemoveAll(); 
	*/
	MVLTRC_ResetData(); 
	INFL_ResetInflData(); 

	m_bLockAdjFactor				= FALSE;

	RemoveInflGrid();

	m_dAnimStTime   = 0.0;
	m_dAnimEdTime   = 0.0;
	m_dAnimIncTime  = 0.0;

	m_bOnCuttingPlane = FALSE;
}

void CEngineBase::SetI_GPSModel(I_GPSModelBase *pGM)
{
	m_pGPSModel = pGM;
}


void CEngineBase::SetLockAdjFactor(BOOL bLock)
{
	m_bLockAdjFactor = bLock;
}

//CPoint CEngineBase::DrawPoint(CDC *pDC,C3DPoint& pnt,double dSize,int nType/*=0*/)// nType :0 round, 1:Rect
void CEngineBase::DrawPoint(CDC *pDC,C3DPoint& pnt,double dSize,int nType/*=0*/)// nType :0 round, 1:Rect
{
	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;
	//XGLRenderer

	if(!gm->m_bVirtualMode && gm->m_pGPSCtrl->IsGLRenderer() && gm->m_pGPSCtrl->IsXGRMode())
{
		LOGBRUSH lgbrush;
		pDC->GetCurrentBrush()->GetLogBrush(&lgbrush);
		gm->m_pXGR_GPSDrawMgr->m_DrawPoint.Add_DrawPoint(&(pnt.x),lgbrush.lbColor,dSize,nType);
		return ;
	}

	CPoint pnt2D;
		
	CRect rect;

	if (gm->m_bVirtualMode)
		pnt2D = gm->m_pGPSCtrl->GetWorldToWindowP2D(pnt);
	else
		pnt2D = gm->m_pGPSCtrl->GetWorldToMemDCP2D(pnt);    


	if(pnt2D.x>0 && pnt2D.y>0)
	{
		rect.left = pnt2D.x-dSize/2.0;
		rect.right = pnt2D.x+dSize/2.0;
		rect.top = pnt2D.y-dSize/2.0;
		rect.bottom = pnt2D.y+dSize/2.0;
		
		if(nType == 0)
			pDC->Ellipse(rect);
		else// if(nType ==1)
			pDC->Rectangle(rect);

	}
	
	//return pnt2D;
}

//CPoint CEngineBase::DrawCrossLine(CDC *pDC,C3DPoint& pnt,double dSize,int nType/*=0*/)
void CEngineBase::DrawCrossLine(CDC *pDC,C3DPoint& pnt,double dSize,int nType/*=0*/)
{
	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;
	//XGLRenderer
	if(!gm->m_bVirtualMode && gm->m_pGPSCtrl->IsGLRenderer() && gm->m_pGPSCtrl->IsXGRMode())
	{
		LOGPEN lgpen;
		pDC->GetCurrentPen()->GetLogPen(&lgpen);
		gm->m_pXGR_GPSDrawMgr->m_DrawCrossLine.Add_DrawCrossLine(&(pnt.x),dSize,lgpen.lopnColor,nType);
		return;
	}

	CPoint pnt2D;
		
	CRect rect;

	if(gm->m_bVirtualMode)pnt2D = gm->m_pGPSCtrl->GetWorldToWindowP2D(pnt);
	else		              pnt2D = gm->m_pGPSCtrl->GetWorldToMemDCP2D(pnt);    


	if(pnt2D.x>0 && pnt2D.y>0)
	{
		rect.left   = pnt2D.x-dSize/2.0;
		rect.right  = pnt2D.x+dSize/2.0;
		rect.top    = pnt2D.y-dSize/2.0;
		rect.bottom = pnt2D.y+dSize/2.0;
		
		if(nType == 0)
		{
			pDC->MoveTo(rect.left,rect.top);
			pDC->LineTo(rect.right,rect.bottom);
			pDC->MoveTo(rect.right,rect.top);
			pDC->LineTo(rect.left,rect.bottom);
		}
		else if(nType==1)
		{
			pDC->MoveTo(pnt2D.x,rect.top);
			pDC->LineTo(pnt2D.x,rect.bottom);
			pDC->MoveTo(rect.left,pnt2D.y);
			pDC->LineTo(rect.right,pnt2D.y);        
		}
	}

	//return pnt2D;
}

void CEngineBase::MakeSerialNodeMap()
{
	CArray<T_NODE_K,T_NODE_K> aNodeKey;

	m_mapSerialNode.RemoveAll();
	m_pDoc->m_pAttrCtrl->GetNodeKeyList(aNodeKey);
	
	for(int i=0; i<aNodeKey.GetSize(); i++)
		m_mapSerialNode.SetAt(aNodeKey[i],i);
}

///////////////////////////////////////////////////////////////////////////////
// DATE : 2002.1.30. by KYE-HONG
// FUNC : lane information이 변경되면서... DB에서 lane result를 갖고 오기 위해서는
//        ldc가 두개씩 필요하게 되었다.. 이때, factor라는 값이 필요한데..
//        factor는 load type에 따라.. 달라지게 된다.       
///////////////////////////////////////////////////////////////////////////////
/*
void CEngineBase::CalMvlLaneLoadFactor(T_LANEINFO_ILLN &base,double &f1,double &f2)
{
	double dEcc;
	int     ltype1,ltype2;
	ltype1 = base.nLType1;
	ltype2 = base.nLType2; 
	f1     = base.dLFact1;
	f2     = base.dLFact2;

	dEcc = m_pDoc->m_pUnitCtrl->ConvertUnitLengthIn(base.dEccentricity);
	if(ltype1==1) f1 = f1*dEcc;
	if(ltype2==1) f2 = f2*dEcc;
}
*/
///////////////////////////////////(수정중: 수정 완료후 위의 함수 삭제해야 됨)	20060424	kyungha
void CEngineBase::CalMvlLaneLoadFactor(T_INFLLINE_LANEINFO_BASE *base,double &f1,double &f2)
{
	double dEcc, dEcc4CF;
	int     ltype1,ltype2;
	ltype1 = base->nLType1;
	ltype2 = base->nLType2; 
	f1     = base->dLFact1;
	f2     = base->dLFact2;
	double dCentFInf =  base->dCentFInf;

	dEcc = m_pDoc->m_pUnitCtrl->ConvertUnitLengthIn(base->dEccentricity);
	dEcc4CF = m_pDoc->m_pUnitCtrl->ConvertUnitLengthIn(base->dEccentricity4CF);
	if(ltype1==1) f1 = f1*dEcc;
	if(ltype2==1) f2 = f2*dEcc;
	if(fabs(dCentFInf) > 0.0) f2 += 1.0 * dEcc4CF;
}
///////////////////////////////////////////////////////////////////////////		20060424	kyungha



///////////////////////////////////////////////////////////////////////////////
// DATE : 2002.2.4. by KYE-HONG
// FUNC : 현재 선택된 lane의 information을 구해옴 
//        
//        
///////////////////////////////////////////////////////////////////////////////
BOOL CEngineBase::GetLaneInfo(T_LANEINFO_NEW &lane)
{
	I_GPSModel	*gm=(I_GPSModel *)m_pGPSModel;

	m_pDoc->m_pPostCtrl->GetLaneInfo(m_arLaneInfoNew);
	int serialnum = m_pDoc->m_pPostCtrl->GetSerialLlan(gm->m_LoadCaseKey)-1;
	if(serialnum>=m_arLaneInfoNew.GetSize()) return FALSE;									
	lane	= m_arLaneInfoNew[serialnum];			                                
	
	return TRUE;
}

BOOL CEngineBase::GetLaneInfo_Special(T_LANEINFO_NEW &lane)
{
	I_GPSModel	*gm=(I_GPSModel *)m_pGPSModel;
	
	m_pDoc->m_pPostCtrl->GetLaneInfo_Special(m_arLaneInfoNew_Special);
	//int serialnum = m_pDoc->m_pPostCtrl->GetSerialLlan(gm->m_LoadCaseKey)-1;
	//if(serialnum>=m_arLaneInfoNew_Specail.GetSize()) return FALSE;									
	lane	= m_arLaneInfoNew_Special[m_arLaneInfoNew_Special.GetSize()-1];			                                
	
	return TRUE;
}

//------------------------------------------------------------------------------
// INIT : 2005.3.17
// DESC ; 차량 타입에 의해서 All Point Option이 바뀔수 있음 
//        따라서, DB의 All Point Option을 쓸수 없고 
//        Tracer차량의 종류를 판단한후 All Point를 결정해야함(ex.. 중국 QC하중)
//------------------------------------------------------------------------------
BOOL CEngineBase::IsAllPointOptionStaticVar()
{
	return CMvlTrcCommonBase::m_bAllPoint;
}
void CEngineBase::SetAllPointOption(BOOL bAll)
{
	CMvlTrcCommonBase::m_bAllPoint = bAll;
}

BOOL CEngineBase::IsAllPointOption(void)
{
	T_MVCT_D    DataMvct;
	T_MVCTid_D  DataMvctID;
	T_MVCTch_D  DataMvctCH;
	T_MVCTfr_D  DataMvctFR;

	/*
	switch(CProduct::GetMovingType())
	{
	case D_PRODUCT_MOVING_US:
	case D_PRODUCT_MOVING_ORG:
	default:
		if(CProduct::IsIndia())
		{
			if(!m_pDoc->m_pAttrCtrl->GetMvctid(DataMvctID))DataMvctID.Initialize();
		}
		else
		{
			if(!m_pDoc->m_pAttrCtrl->GetMvct(DataMvct))DataMvct.Initialize();
			if(DataMvct.nLoadPointSelection==1)        return FALSE;
		}
		break; 
	case D_PRODUCT_MOVING_JP:
		break; 
	case D_PRODUCT_MOVING_CH:
		if(!m_pDoc->m_pAttrCtrl->GetMvctch(DataMvctCH))DataMvctCH.Initialize();
		if(DataMvctCH.nLoadPointSelection==1)        return FALSE;
		break; 
	}
	*/
	switch(CGPSPostCtrl::GetMVCDType())
	{
	case D_MOVE_CODE_AASHTO_STAN:
	case D_MOVE_CODE_AASHTO_LRFD:
	case D_MOVE_CODE_KOREA:
	case D_MOVE_CODE_CANADA:    
	case D_MOVE_CODE_TAIWAN:
	case D_MOVE_CODE_PENDOT:
	case D_MOVE_CODE_BS:
	case D_MOVE_CODE_EURO_BS:	
	case D_MOVE_CODE_RUSSIA:
	case D_MOVE_CODE_KOREA_LRFD_2011:
	case D_MOVE_CODE_AUSTRALIA:
	case D_MOVE_CODE_POLAND:
	case D_MOVE_CODE_SOUTH_AFRICA:
		if(!m_pDoc->m_pAttrCtrl->GetMvct(DataMvct))DataMvct.Initialize();
		if(DataMvct.nLoadPointSelection==1)        return FALSE;
		break;
	case D_MOVE_CODE_INDIA:
		if(!m_pDoc->m_pAttrCtrl->GetMvctid(DataMvctID))DataMvctID.Initialize();
		break; 
	case D_MOVE_CODE_JAPAN:
		break; 
	case D_MOVE_CODE_CHINA:
		if(!m_pDoc->m_pAttrCtrl->GetMvctch(DataMvctCH))DataMvctCH.Initialize();
		if(DataMvctCH.nLoadPointSelection==1)        return FALSE;
		break; 
	case D_MOVE_CODE_FRANCE:
		if (!m_pDoc->m_pAttrCtrl->GetMvctfr(DataMvctFR))DataMvctFR.Initialize();
		break;
	case D_MOVE_CODE_TRANS:
		{
			 T_MVCTtr_D  DataMvctTr;
			if(!m_pDoc->m_pAttrCtrl->GetMvcttr(DataMvctTr))DataMvctTr.Initialize();
			if(DataMvctTr.nLoadPointSelection==1)        return FALSE;
		}
	default:
		ASSERT(0);
		break; 
	}
	return TRUE;
}


BOOL CEngineBase::MVLTRC_CalMidPt(double val1,double val2,double val3,
																			C3DPoint &p1,C3DPoint &p2,C3DPoint &p3,
																			C3DPoint &getpt1,C3DPoint &getpt2,BOOL start_pt,BOOL& bForward)
{
	if(val1==0.0 && val3!=0.0) 
	{
		if(start_pt)
		{
			getpt1  = p1; 
			getpt2  = p2;
			bForward= FALSE;
		}
		else
		{
			getpt1  = p1; 
			getpt2  = p1;
			bForward= FALSE;
		}
		return TRUE;
	}
	if(val1!=0.0 && val3==0.0) 
	{
		if(start_pt)
		{
			getpt1  = p3; 
			getpt2  = p3;
			bForward= TRUE;
		}
		else
		{
			getpt1  = p2; 
			getpt2  = p3;
			bForward= TRUE;
		}
		return TRUE;
	}
	// val1,val2,val3가 0인경우는 통과하지 못함 
	if(val1==0.0) ASSERT(FALSE);
	if(val2==0.0) ASSERT(FALSE);
	if(val3==0.0) ASSERT(FALSE);

	// 예외처리 
	if(val1*val2 <=0 && val2*val3 <=0 ) 
	{
		if(start_pt)
		{
			getpt1 = p2;
			getpt2 = p3;
			bForward= TRUE;
		}
		else
		{
			getpt1 = p1;
			getpt2 = p2;
			bForward= FALSE;
		}
	}
	// 1과 2사이에 있음 
	else if(val1*val2 <=0 && val2*val3 >=0 ) 
	{
		if(start_pt)
		{
			CUtilFuncs::GetInterPtOfTwoPtsByVals(val1,val2,p1,p2,getpt1);
			getpt2  = p2;
			bForward= FALSE;
		}
		else
		{
			CUtilFuncs::GetInterPtOfTwoPtsByVals(val1,val2,p1,p2,getpt2);
			getpt1 = p1;
			bForward= FALSE;
		}
	}
	// 2과 3사이에 있음 
	else if(val1*val2 >=0 && val2*val3 <=0 ) 
	{
		if(start_pt)
		{
			CUtilFuncs::GetInterPtOfTwoPtsByVals(val2,val3,p2,p3,getpt1);
			getpt2 = p3;
			bForward= TRUE;
		}
		else
		{
			CUtilFuncs::GetInterPtOfTwoPtsByVals(val2,val3,p2,p3,getpt2);
			getpt1 = p2;
			bForward= TRUE;
		}
	}

	return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////
// DATE : 2002.2.14. by KYE-HONG
// FUNC : 현재 만들어져 있는 Mn/Max Moving Load Data를 화일에 출력 
//        
////////////////////////////////////////////////////////////////////////////////////////
/*
BOOL CEngineBase::WriteMvlTrcMnMxLoad(FILE *wfp)
{
	ASSERT(wfp);
	if(!wfp) return FALSE;

	if(!m_arMvlTrcStld.GetSize()) return FALSE; 

	CString sLdcName; 
	sLdcName = this->m_sMvlTrcCompNodeOrEle;
	if(sLdcName.IsEmpty()) sLdcName=_T("Mvl-Trc-Ldc");
 
	// Write Title
	_ftprintf(wfp,_T("%s\n"), _T("*VERSION"));
	_ftprintf(wfp,_T("%s\n"), _T("5.4.0"));
	_ftprintf(wfp,_T("\n"));
	
	// Write Unit
	CString sForce,sLen;
	m_pDoc->m_pUnitCtrl->GetUnitSystemForce(sForce);
	m_pDoc->m_pUnitCtrl->GetUnitSystemLength(sLen);
	_ftprintf(wfp,_T("%s\n"), _T("*UNIT"));
	_ftprintf(wfp,_T("%s\n"), _T("; FORCE, LENGTH"));
	_ftprintf(wfp,_T("%s,%s\n"),sForce,sLen);
	_ftprintf(wfp,_T("\n"));
	
	_ftprintf(wfp,_T("*STLDCASE    ; Static Load Cases\n"));
	_ftprintf(wfp,_T("; LCNAME, LCTYPE, DESC\n"));

	if(sLdcName.GetLength()>=20)
	{
		AfxMessageBox(_T("Warning : Generated Load Case Name is over 20 Character"));
		int nSize=sLdcName.GetLength()-19;
		sLdcName.Delete(19,nSize);
	}
	
	_ftprintf(wfp,_T("%s, USER, %s\n"),(LPCSTR)sLdcName,(LPCSTR)m_sMvlTrcLoadDesc);
	_ftprintf(wfp,_T("\n"));
	_ftprintf(wfp,_T("*USE-STLD, %s\n"),(LPCSTR)sLdcName);
	_ftprintf(wfp,_T("\n"));
	_ftprintf(wfp,_T("*BEAMLOAD    ; Element Beam Loads\n"));
	_ftprintf(wfp,_T("; ELEM_LIST, CMD, TYPE, DIR, bPROJ, D1, P1, D2, P2, D3, P3, D4, P4, GROUP\n"));

	// Write Loading Info 
	int       nLNum;
	T_ELEM_K  nEKey;
	int       i,j,nLType,nLDir;
	CString   sLType,sLDir;
	double    dRatio[2],dVal[2];

	nLNum = this->m_arMvlTrcStld.GetSize();
	for(i=0; i<nLNum; i++)
	{
		nEKey = this->m_arMvlTrcStld[i].nEleKey;
		nLType= this->m_arMvlTrcStld[i].nLoadType;
		nLDir = this->m_arMvlTrcStld[i].nLoadDir;
		
		for(j=0; j<2; j++)
		{
			dRatio[j] = this->m_arMvlTrcStld[i].dDistaceRatio[j];
			dVal[j]   = this->m_arMvlTrcStld[i].dValue[j];
		}

		// long -> string
		switch(nLDir)
		{
		case 1:   sLDir=_T("LX"); break;
		case 6:   sLDir=_T("GZ"); break;
		default:  sLDir=_T("GZ"); break;
		}
		switch(nLType)
		{
		case 1:   sLType=_T("CONLOAD");   break;
		case 2:   sLType=_T("CONMOMENT"); break;
		case 3:   sLType=_T("UNILOAD");   break;
		case 4:   sLType=_T("UNIMOMENT"); break;
		default:  sLType=_T("CONLOAD"); break;
		}
		
		_ftprintf(wfp,_T("%5d, %-7s, %s, %s, %-3s, %15.10lf, %g, %15.10lf, %g, 0, 0, 0, 0, \n"),
							 nEKey,_T("BEAM"),sLType,sLDir,_T("NO"),dRatio[0],dVal[0],dRatio[1],dVal[1]);
	}
	return TRUE;
}
*/



/*
BOOL CEngineBase::WriteMvlTrcMnMxLoadBatch(FILE *wfp)
{
	ASSERT(wfp);
	if(!wfp) return FALSE;

	if(!m_arMvlTrcStld.GetSize()) return FALSE; 

	CString sLdcName; 
	sLdcName = this->m_sMvlTrcCompNodeOrEle;
	if(sLdcName.IsEmpty()) sLdcName=_T("Mvl-Trc-Ldc");
 
	// Write Title
	//_ftprintf(wfp,"%s\n", "*VERSION");
	//_ftprintf(wfp,"%s\n", "5.4.0");
	//_ftprintf(wfp,"\n");
	
	// Write Unit
	//CString sForce,sLen;
	//m_pDoc->m_pUnitCtrl->GetUnitSystemForce(sForce);
	//m_pDoc->m_pUnitCtrl->GetUnitSystemLength(sLen);
	//_ftprintf(wfp,"%s\n", "*UNIT");
	//_ftprintf(wfp,"%s\n", "; FORCE, LENGTH");
	//_ftprintf(wfp,"%s,%s\n",sForce,sLen);
	//_ftprintf(wfp,"\n");
	
	_ftprintf(wfp,_T("*STLDCASE    ; Static Load Cases\n"));
	_ftprintf(wfp,_T("; LCNAME, LCTYPE, DESC\n"));

	if(sLdcName.GetLength()>=20)
	{
		AfxMessageBox(_T("Warning : Generated Load Case Name is over 20 Character"));
		int nSize=sLdcName.GetLength()-19;
		sLdcName.Delete(19,nSize);
	}
	
	_ftprintf(wfp,_T("%s, USER, %s\n"),(LPCSTR)sLdcName,(LPCSTR)m_sMvlTrcLoadDesc);
	_ftprintf(wfp,_T("\n"));
	_ftprintf(wfp,_T("*USE-STLD, %s\n"),(LPCSTR)sLdcName);
	_ftprintf(wfp,_T("\n"));
	_ftprintf(wfp,_T("*BEAMLOAD    ; Element Beam Loads\n"));
	_ftprintf(wfp,_T("; ELEM_LIST, CMD, TYPE, DIR, bPROJ, D1, P1, D2, P2, D3, P3, D4, P4, GROUP\n"));

	// Write Loading Info 
	int       nLNum;
	T_ELEM_K  nEKey;
	int       i,j,nLType,nLDir;
	CString   sLType,sLDir;
	double    dRatio[2],dVal[2];

	nLNum = this->m_arMvlTrcStld.GetSize();
	for(i=0; i<nLNum; i++)
	{
		nEKey = this->m_arMvlTrcStld[i].nEleKey;
		nLType= this->m_arMvlTrcStld[i].nLoadType;
		nLDir = this->m_arMvlTrcStld[i].nLoadDir;
		
		for(j=0; j<2; j++)
		{
			dRatio[j] = this->m_arMvlTrcStld[i].dDistaceRatio[j];
			dVal[j]   = this->m_arMvlTrcStld[i].dValue[j];
		}

		// long -> string
		switch(nLDir)
		{
		case 1:   sLDir=_T("LX"); break;
		case 6:   sLDir=_T("GZ"); break;
		default:  sLDir=_T("GZ"); break;
		}
		switch(nLType)
		{
		case 1:   sLType=_T("CONLOAD");   break;
		case 2:   sLType=_T("CONMOMENT"); break;
		case 3:   sLType=_T("UNILOAD");   break;
		case 4:   sLType=_T("UNIMOMENT"); break;
		default:  sLType=_T("CONLOAD"); break;
		}
		
		_ftprintf(wfp,_T("%5d, %-7s, %s, %s, %-3s, %15.10lf, %g, %15.10lf, %g, 0, 0, 0, 0, \n"),
							 nEKey,_T("BEAM"),sLType,sLDir,_T("NO"),dRatio[0],dVal[0],dRatio[1],dVal[1]);
	}
	return TRUE;
}
*/


void  CEngineBase::FreeMemoryPolyList(CArray<GPS_3DPT_LISTP,GPS_3DPT_LISTP> *ListPoly,/*=NULL*/
	                                    CArray<GPS_BOOL_ARRYP,GPS_BOOL_ARRYP> *ListEdge,/*=NULL*/
	                                    CArray<GPS_UINT_ARRYP,GPS_UINT_ARRYP> *ListNode,/*=NULL*/
																			CArray<GPS_INTG_ARRYP,GPS_INTG_ARRYP> *ListOrder/*=NULL*/)
{
	int i; 
	if(ListPoly)
	{
		int nPNum = ListPoly->GetSize(); 
		for(i=0; i<nPNum; i++)
		{
			ListPoly->GetAt(i)->RemoveAll(); 
			delete ListPoly->GetAt(i);
		}
		ListPoly->RemoveAll(); 
	}
	
	if(ListEdge)
	{
		int nENum = ListEdge->GetSize(); 
		for(i=0; i<nENum ; i++)
		{
			ListEdge->GetAt(i)->RemoveAll(); 
			delete ListEdge->GetAt(i);
		}
		ListEdge->RemoveAll(); 
	}

	if(ListNode)
	{
		int nNNum = ListNode->GetSize(); 
		for(i=0; i<nNNum ; i++)
		{
			ListNode->GetAt(i)->RemoveAll(); 
			delete ListNode->GetAt(i);
		}
		ListNode->RemoveAll(); 
	}
	if(ListOrder)
	{
		int nONum = ListOrder->GetSize(); 
		for(i=0; i<nONum; i++)
		{
			ListOrder->GetAt(i)->RemoveAll(); 
			delete ListOrder->GetAt(i);
		}
		ListOrder->RemoveAll(); 
	}
}

double CEngineBase::InitValueAdjustFactor(double dMaxValue,double dScaleFactor)
{
	double    dAdjustFactor=1.0;
	C3DPoint	min_p, max_p;
	double		max_l;

	if(m_bLockAdjFactor)return 1.0;
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	gm->GetRangeModel(&min_p,&max_p);
	max_l = max(max(max_p.x-min_p.x, max_p.y-min_p.y), max_p.z-min_p.z);
	m_dMaxModelLength = max_l;
	
	if(dMaxValue> -1e-15 && dMaxValue < 1e-15)dMaxValue = 1.0f;
	// 최대값이 전체모델의 1/20의 크기로 나오도록...
	dAdjustFactor = max_l / (fabs(dMaxValue)*dScaleFactor);

	return dAdjustFactor;
}

int CEngineBase::GetVectorLineWidth()
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	int nVRatio,nHRatio,nMnRatio;
	int nThkLine = CEngineBase::m_dVectorThkScale;
	gm->m_pGPSCtrl->GetVirtualWHRatio(nHRatio,nVRatio);
	nMnRatio = nHRatio;
	nThkLine = nThkLine*nMnRatio;

	return nThkLine;
}



void CEngineBase::RemoveInflGrid()
{
	if(m_pInflGrid)delete m_pInflGrid;
	m_pInflGrid = NULL;
}


void  CEngineBase::DrawUCSPlaneIcon(CDC *pDC,double UCS_vector[3][3])
{
	//double UCS_vector[3][3];
	//GetUCSVector(m_NUCS,UCS_vector);

	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	double dOriginPt[3],dPt1[3],dPt2[3];
	CArray<C3DPoint,C3DPoint&> arPolygon;
	CArray<C3DPoint,C3DPoint&> arLine;
	
	memset(dOriginPt,0,sizeof(dOriginPt));
	memcpy(dPt1,UCS_vector[0],sizeof(dPt1));
	memcpy(dPt2,UCS_vector[1],sizeof(dPt2));


	CPen *pOldPen,Pen;
	Pen.CreatePen(PS_SOLID, gm->m_nLineWidth, RGB(0,0,0) );
	pOldPen   = (CPen *) pDC->SelectObject(&Pen);
	
	CRect ClientRect;
	gm->m_pMyView->GetClientRect(&ClientRect);


	int nX2D,nY2D;
	//nX2D = ClientRect.Width()/30.;
	//nY2D = ClientRect.Width()/30.;
	nX2D = 50;
	nY2D = ClientRect.bottom-50;

	gm->m_pGPSCtrl->GetUCSPlaneSymbol(dOriginPt,dPt1,dPt2,arPolygon,arLine,nX2D,nY2D); 

	C3DPoint  p1,p2;
	CPoint    Pt2D[2];
	for(int i=0; i<arPolygon.GetSize(); i++)
	{
		p1 = arPolygon[i];
		p2 = arPolygon[(i+1)%arPolygon.GetSize()];

		if(!gm->m_bVirtualMode && gm->m_pGPSCtrl->IsGLRenderer() && gm->m_pGPSCtrl->IsXGRMode())
		{
			gm->m_pXGR_GPSDrawMgr->m_DrawIconUCS.Add_Func_DrawIconUCS(pDC,&(p1.x),&(p2.x),RGB(0,0,0),gm->m_nLineWidth);
			continue; 
		}
		
		if(gm->m_bVirtualMode)  
		{
			Pt2D[0]=gm->m_pGPSCtrl->GetWorldToWindowP2D(p1);
			Pt2D[1]=gm->m_pGPSCtrl->GetWorldToWindowP2D(p2);
		}
	  else 		                
		{
			Pt2D[0]=gm->m_pGPSCtrl->GetWorldToMemDCP2D(p1);
			Pt2D[1]=gm->m_pGPSCtrl->GetWorldToMemDCP2D(p2);
		}

		

		pDC->MoveTo(Pt2D[0]);
		pDC->LineTo(Pt2D[1]);
		
	}
	for(int i=0; i<arLine.GetSize()/2; i++)
	{
		p1 = arLine[2*i];
		p2 = arLine[2*i+1];

		if(!gm->m_bVirtualMode && gm->m_pGPSCtrl->IsGLRenderer() && gm->m_pGPSCtrl->IsXGRMode())
		{
			gm->m_pXGR_GPSDrawMgr->m_DrawIconUCS.Add_Func_DrawIconUCS(pDC,&(p1.x),&(p2.x),RGB(0,0,0),gm->m_nLineWidth);
			continue; 
		}

		if(gm->m_bVirtualMode)  
		{
			Pt2D[0]=gm->m_pGPSCtrl->GetWorldToWindowP2D(p1);
			Pt2D[1]=gm->m_pGPSCtrl->GetWorldToWindowP2D(p2);
		}
	  else 		                
		{
			Pt2D[0]=gm->m_pGPSCtrl->GetWorldToMemDCP2D(p1);
			Pt2D[1]=gm->m_pGPSCtrl->GetWorldToMemDCP2D(p2);
		}


		pDC->MoveTo(Pt2D[0]);
		pDC->LineTo(Pt2D[1]);
	}

	pDC->SelectObject(pOldPen);
	Pen.DeleteObject(); 
}


int CEngineBase::GetLineThick(double nLineWidth)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	int nVRatio,nHRatio,nMnRatio;
	int nThkLine = nLineWidth;
	gm->m_pGPSCtrl->GetVirtualWHRatio(nHRatio,nVRatio);
	nMnRatio = nHRatio;
	nThkLine = nThkLine*nMnRatio;

	return nThkLine;
}