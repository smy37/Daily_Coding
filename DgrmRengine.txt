// DiagramEngine.cpp: implementation of the CDiagramEngine class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "wg_gps.h"
#include "DiagramEngine.h"

#include "PostTools.h"
#include "I_GPSModel.h"
#include "GPSDT_DBDATA.h"
#include "DeformEngine.h"

#include "PostTools.h"
#include "GPSDisplayFilter.h"
#include "GPSInflGridBase.h"
#include "GPostTextOut.h"

#include "..\wg_base\wg_baseAllPPreview.h"
#include "..\wg_db\wg_db_AttrCtrl.h"
#include "..\wg_db\QSort.h"
#include "..\wg_db\wg_db_MathFunc.h"
#include "..\wg_db\wg_db_DBLib.h"
#include "..\wg_db\StagCtrl.h"
#include <float.h>

#include "DRW_DATA.h"
#include "Func_GPS_Draw.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

#define DECLARE_GPSMD()  I_GPSModel *gm=(I_GPSModel *)m_pGPSModel
#define DECLARE_DBDOC()  CDBDoc		  *pDoc=((I_GPSModel *)m_pGPSModel)->GetDBDoc()
#define DECLARE_DPTDR()  T_GPS_DISP_OPT_DR *pDR = &(gm->m_DOPT.DR) 
#define DECLARE_DPTRD()  T_GPS_DISP_OPT_RD *pRD = &(gm->m_DOPT.RD)
#define DECLARE_DPTCL()  T_GPS_DISP_OPT_CL *pCL = &(gm->m_DOPT.CL)
#define DECLARE_DPTTX()  T_GPS_DISP_OPT_TX *pTX = &(gm->m_DOPT.TX)

BOOL CDiagramEngine::m_bIgnorePlotDiagram = FALSE;
BOOL CDiagramEngine::m_bBatchStepMode = FALSE;
BOOL CDiagramEngine::m_bBatchLoadMode = FALSE; 

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDiagramEngine::CDiagramEngine(I_GPSModelBase * pGM)
: CEngineBase()
{
	m_pGPSModel			= pGM;

	m_mapDgrmData.RemoveAll(); // 요소 Key와 Grup Key를 Multi Key로 
	m_mapDgrmData.InitHashTable(1001);
	m_mapDgrmGrup.InitHashTable(1001);
	//m_mapDeformedElem.InitHashTable(1001);
}

CDiagramEngine::~CDiagramEngine()
{

}


void  CDiagramEngine::ImportEngine(CEngineBase* egbase)
{
		if(!egbase)return;
		CEngineBase::ImportEngine(egbase); 

		CDiagramEngine* eg = (CDiagramEngine*)egbase;

		m_dEDgrmDefmScFc = eg->m_dEDgrmDefmScFc;
		m_nEDgrmScFcType = eg->m_nEDgrmScFcType;
		m_dEDgrmAutoScFc = eg->m_dEDgrmAutoScFc;
		m_dEDgrmRefValue = eg->m_dEDgrmRefValue;
		m_dEDgrmRefValueScFc = eg->m_dEDgrmRefValueScFc;

		m_bDataSet    = eg->m_bDataSet; 

		m_dMaxDgrmVal = eg->m_dMaxDgrmVal; 
		m_dMinDgrmVal = eg->m_dMinDgrmVal; 

		T_DIAG_K DiagK;
		T_CMAP_K2<UINT> mKey;
		T_DIAG_RESL_D   ReslD;
		T_DIAG_GRUP_D   GrupD;
		m_mapDgrmData.RemoveAll();
		m_mapDgrmGrup.RemoveAll();
		//m_mapDeformedElem.RemoveAll(); 

		POSITION pos =eg->m_mapDgrmData.GetStartPosition(); // general displ, infl. surface
		while(pos)
		{
				eg->m_mapDgrmData.GetNextAssoc(pos,mKey,ReslD);
				m_mapDgrmData.SetAt(mKey,ReslD);
		}

		pos =eg->m_mapDgrmGrup.GetStartPosition(); // general displ, infl. surface
		while(pos)
		{
				eg->m_mapDgrmGrup.GetNextAssoc(pos,DiagK,GrupD);
				m_mapDgrmGrup.SetAt(DiagK,GrupD);
		}

		// Deformed Shape
		/*
		T_ELEM_K ElemK,TmpElemK; 
		//pos =eg->m_mapDeformedElem.GetStartPosition(); // general displ, infl. surface
		while(pos)
		{
		eg->m_mapDeformedElem.GetNextAssoc(pos,ElemK,TmpElemK);
		m_mapDeformedElem.SetAt(ElemK,ElemK);
		}
		*/

		m_arSelectedDiagK.Copy(eg->m_arSelectedDiagK);
		m_dDgrmAdjustFactor = eg->m_dDgrmAdjustFactor;

		//m_arDiagramOutPut.RemoveAll(); 
		//m_arDiagramOutPut.Copy(eg->m_arDiagramOutPut); 
}


void CDiagramEngine::ResetEngine()
{
	CEngineBase::ResetEngine();

	m_bDataSet = FALSE; 

	m_dEDgrmDefmScFc = 1.0;
	m_nEDgrmScFcType = 0;
	m_dEDgrmAutoScFc = 1.0;
	m_dEDgrmRefValue = 100;
	m_dMaxDgrmVal = 0.0; 
	m_dMinDgrmVal = 0.0; 
	m_dEDgrmRefValueScFc = 1.0;

	m_dMaxModelLength   = 0.0; 
	m_dDgrmAdjustFactor = 0.0; 
	//m_arDiagramOutPut.RemoveAll(); 

	m_mapDgrmData.RemoveAll();
	m_mapDgrmGrup.RemoveAll();
	m_arSelectedDiagK.RemoveAll();

	m_bBatchStepMode = FALSE;
	m_bBatchLoadMode = FALSE; 
	m_bIgnorePlotDiagram = FALSE;
}

void  CDiagramEngine::InitEngine(int nGPSInstruction)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	m_bDataSet = FALSE; 
	gm->SelectLoad();
 
	int nGPSMode = (nGPSInstruction != -1)? nGPSInstruction:gm->m_GPSMode;
	switch (nGPSMode) 
	{
	case GPS_COMMAND_DRAW_EDGRM:
		MakeDgrmDataList();
		break;
	}
}

void CDiagramEngine::MakeDgrmDataList()
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	m_bDataSet = TRUE;  // 무조건 TRUE로 해야 결과가 없어도 요소가 Wire Frame으로 출력된다 
	CDBDoc *pDoc = CDBDoc::GetDocPoint(); 
	BOOL bHasData = FALSE;

	T_DIAG_D DiagD;
	T_DIAG_GRUP_D DiagGrupD;
	CArray<T_DIAG_K,T_DIAG_K> arDiagK;
	//pDoc->m_pAttrCtrl->GetDiagKeyList(arDiagK);
	arDiagK.Copy(m_arSelectedDiagK); 

	if(!arDiagK.GetSize()) return; 

	m_dMaxDgrmVal     = -DBL_MAX;
	m_dMinDgrmVal     = DBL_MAX;
	m_mapDgrmData.RemoveAll();
	m_mapDgrmGrup.RemoveAll();

	m_mapActiveElem.RemoveAll(); 
	m_mapActiveElem.InitHashTable(1001);
	for(int ii=0; ii<gm->m_EKeyListActive.GetSize(); ii++)
		m_mapActiveElem.SetAt(gm->m_EKeyListActive[ii],gm->m_EKeyListActive[ii]);

	T_ELEM_K TmpElemK = 0; 
	for(int i=0; i<arDiagK.GetSize(); i++)
	{
		if(!pDoc->m_pAttrCtrl->GetDiag(arDiagK[i],DiagD)){ continue; }
		DiagGrupD.Initialize(); 
		switch(DiagD.nTypeOfResult)
		{
		case D_DGRM_TYPE_DISPL:
			if(!MakeDgrmDataNDISP(arDiagK[i],DiagD,DiagGrupD))continue; 
			break; 
		case D_DGRM_TYPE_TFORC:
		case D_DGRM_TYPE_TSTRS:
			if(!MakeDgrmDataTSTRT(arDiagK[i],DiagD,DiagGrupD))continue; 
			break; 
		case D_DGRM_TYPE_BFORC:
		case D_DGRM_TYPE_BSTRS:
			if(!MakeDgrmDataBSTRB(arDiagK[i],DiagD,DiagGrupD))continue; 
			break; 
		case D_DGRM_TYPE_BSTSS:
			if(!MakeDgrmDataBSTSS(arDiagK[i],DiagD,DiagGrupD))continue; 
			break; 
		}
		bHasData = TRUE; 

		m_dMaxDgrmVal = max(m_dMaxDgrmVal,DiagGrupD.dMaxVal);
		m_dMinDgrmVal = min(m_dMinDgrmVal,DiagGrupD.dMinVal);
	}

	m_mapActiveElem.RemoveAll();
	if(!bHasData)
	{
		m_dMaxDgrmVal = 0.0;
		m_dMinDgrmVal = 0.0;
		return; 
	}
	// Auto Scale
	if(m_nEDgrmScFcType == 0) 
	{
		if(fabs(m_dMaxDgrmVal)<fabs(m_dMinDgrmVal))
			InitDiagramAdjustFactor(m_dMinDgrmVal);
		else
			InitDiagramAdjustFactor(m_dMaxDgrmVal);
	}
	// Ref Value Scale
	else
	{
		InitDiagramAdjustFactor(m_dEDgrmRefValue);
	}

}

BOOL  CDiagramEngine::MakeDgrmDataNDISP(T_DIAG_K DiagK,T_DIAG_D &DiagD,T_DIAG_GRUP_D &DiagGrupD)
{
	 if(!DiagD.aElemK.GetSize())return FALSE; 

	T_CMAP_K2<UINT> mKey;
	T_ELEM_D ElemD; 
	T_DIAG_RESL_D ReslD;
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	CDBDoc *pDoc = CDBDoc::GetDocPoint(); 

	DiagGrupD.Initialize(); 
	BOOL bHasData = FALSE; 
	DiagGrupD.dMaxVal = -DBL_MAX;
	DiagGrupD.dMinVal =  DBL_MAX;
	T_DISP_D DispD[2];
	T_ELEM_K TmpElemK;
	for(int i=0; i<DiagD.aElemK.GetSize(); i++)
	{
		if(!pDoc->m_pAttrCtrl->GetElem(DiagD.aElemK[i],ElemD)){ continue; }
		if(!pDoc->m_pAttrCtrl->IsTruss(ElemD.eltyp) && !pDoc->m_pAttrCtrl->IsBeam(ElemD.eltyp)) continue;
		if(!m_mapActiveElem.Lookup(DiagD.aElemK[i],TmpElemK))continue; 

		for(int j=0; j<2; j++)
		{
			switch(gm->m_LoadMinMaxType) 
		  {
		  case LOADTYPE_NORMAL:
		  case LOADTYPE_MAX:
				if(!m_pDoc->m_pPostCtrl->GetDispNew(ElemD.elnod[j], &(DispD[j]), NULL, NULL)){ return FALSE; }
				break;
		  case LOADTYPE_MIN:
				if(!m_pDoc->m_pPostCtrl->GetDispNew(ElemD.elnod[j],NULL, &(DispD[j]), NULL)){ return FALSE; }
				break;
		  case LOADTYPE_ALL:
				if(!m_pDoc->m_pPostCtrl->GetDispNew(ElemD.elnod[j],NULL, NULL, &(DispD[j]))){ return FALSE; }
				break;
		  }
		}
		
		if(!ConvertDisp2ReslD(DiagD,DispD,ReslD))continue; 
		if(!GetDiagramDirection(DiagD.aElemK[i],DiagD,ReslD))continue; 
		
		double dTmpMxVal,dTmpMnVal;
		ReslD.GetMxMnVal(dTmpMxVal,dTmpMnVal);
		DiagGrupD.dMaxVal = max(dTmpMxVal,DiagGrupD.dMaxVal);
		DiagGrupD.dMinVal = min(dTmpMnVal,DiagGrupD.dMinVal);

		mKey.i1 = DiagD.aElemK[i];
		mKey.i2 = DiagK;
		m_mapDgrmData.SetAt(mKey,ReslD);
		bHasData = TRUE; 
	}

	if(!bHasData)
	{
		DiagGrupD.dMaxVal = 0.0;
		DiagGrupD.dMinVal = 0.0;
		return FALSE; 
	}

	DiagGrupD.nType       = DiagD.nTypeOfResult;
	
	// 일단 Z방향으로 한다 
	DiagGrupD.dDirVec[0]  = 0.0;
	DiagGrupD.dDirVec[1]  = 0.0;
	DiagGrupD.dDirVec[2]  = 0.0;
	m_mapDgrmGrup.SetAt(DiagK,DiagGrupD); 

	return TRUE; 
}


BOOL  CDiagramEngine::MakeDgrmDataTSTRT(T_DIAG_K DiagK,T_DIAG_D &DiagD,T_DIAG_GRUP_D &DiagGrupD)
{
	if(!DiagD.aElemK.GetSize())return FALSE; 

	T_CMAP_K2<UINT> mKey;
	T_ELEM_D ElemD; 
	T_DIAG_RESL_D ReslD;
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	CDBDoc *pDoc = CDBDoc::GetDocPoint(); 

	DiagGrupD.Initialize(); 
	BOOL bHasData = FALSE; 
	DiagGrupD.dMaxVal = -DBL_MAX;
	DiagGrupD.dMinVal =  DBL_MAX;
	T_STRT_D StrtD;
	T_ELEM_K TmpElemK;
	for(int i=0; i<DiagD.aElemK.GetSize(); i++)
	{
		if(!pDoc->m_pAttrCtrl->GetElem(DiagD.aElemK[i],ElemD)){ continue; }
		if(!pDoc->m_pAttrCtrl->IsTruss(ElemD.eltyp))continue;
		if(!m_mapActiveElem.Lookup(DiagD.aElemK[i],TmpElemK))continue; 

		switch(gm->m_LoadMinMaxType) 
		{
		case LOADTYPE_NORMAL:
		case LOADTYPE_MAX:
			if(!m_pDoc->m_pPostCtrl->GetStrtNew(DiagD.aElemK[i], &StrtD, NULL, NULL)){ gm->m_pMyView->EndWaitCursor(); return FALSE; }
			break;
		case LOADTYPE_MIN:
			if(!m_pDoc->m_pPostCtrl->GetStrtNew(DiagD.aElemK[i],NULL, &StrtD, NULL)){ gm->m_pMyView->EndWaitCursor(); return FALSE; }
			break;
		case LOADTYPE_ALL:
		  if(!m_pDoc->m_pPostCtrl->GetStrtNew(DiagD.aElemK[i],NULL, NULL, &StrtD)){ gm->m_pMyView->EndWaitCursor(); return FALSE; }
			break;
		}
		
		if(((DiagD.nComponents == TFORC_COMP_TYPE_TEN)&&((StrtD.dblForce[0]<0.0)&&(StrtD.dblForce[1]<0.0))) ||
			 ((DiagD.nComponents == TFORC_COMP_TYPE_COMP)&&((StrtD.dblForce[0]>0.0)&&(StrtD.dblForce[1]>0.0))))    
			 continue; 

		if(!ConvertStrt2ReslD(DiagD,StrtD,ReslD))continue; 
		if(!GetDiagramDirection(DiagD.aElemK[i],DiagD,ReslD))continue; 
		
		double dTmpMxVal,dTmpMnVal;
		ReslD.GetMxMnVal(dTmpMxVal,dTmpMnVal);
		DiagGrupD.dMaxVal = max(dTmpMxVal,DiagGrupD.dMaxVal);
		DiagGrupD.dMinVal = min(dTmpMnVal,DiagGrupD.dMinVal);

		mKey.i1 = DiagD.aElemK[i];
		mKey.i2 = DiagK;
		m_mapDgrmData.SetAt(mKey,ReslD);
		bHasData = TRUE; 
	}

	if(!bHasData)
	{
		DiagGrupD.dMaxVal = 0.0;
		DiagGrupD.dMinVal = 0.0;
		return FALSE; 
	}

	DiagGrupD.nType       = DiagD.nTypeOfResult;
	
	// 일단 Z방향으로 한다 
	DiagGrupD.dDirVec[0]  = 0.0;
	DiagGrupD.dDirVec[1]  = 0.0;
	DiagGrupD.dDirVec[2]  = 0.0;
	m_mapDgrmGrup.SetAt(DiagK,DiagGrupD); 

	return TRUE; 
}

BOOL  CDiagramEngine::MakeDgrmDataBSTRB(T_DIAG_K DiagK,T_DIAG_D &DiagD,T_DIAG_GRUP_D &DiagGrupD)
{
	if(!DiagD.aElemK.GetSize())return FALSE; 

	T_CMAP_K2<UINT> mKey;
	T_ELEM_D ElemD; 
	T_DIAG_RESL_D ReslD;
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	CDBDoc *pDoc = CDBDoc::GetDocPoint(); 

	DiagGrupD.Initialize(); 
	BOOL bHasData = FALSE; 
	DiagGrupD.dMaxVal = -DBL_MAX;
	DiagGrupD.dMinVal =  DBL_MAX;
	T_STRB_D StrbD;
	T_ELEM_K TmpElemK;
	for(int i=0; i<DiagD.aElemK.GetSize(); i++)
	{
		if(!pDoc->m_pAttrCtrl->GetElem(DiagD.aElemK[i],ElemD)){ continue; }
		if(!pDoc->m_pAttrCtrl->IsBeam(ElemD.eltyp))continue;
		if(!m_mapActiveElem.Lookup(DiagD.aElemK[i],TmpElemK))continue; 

		if(DiagD.nBeamPscPart>0)
		{
			switch(gm->m_LoadMinMaxType) 
			{
			case LOADTYPE_NORMAL:
			case LOADTYPE_MAX:
				if(!m_pDoc->m_pPostCtrl->GetStrbPartNew(DiagD.aElemK[i],DiagD.nBeamPscPart,&StrbD,NULL,NULL)){ gm->m_pMyView->EndWaitCursor(); continue; }
				break;
			case LOADTYPE_MIN:
				if(!m_pDoc->m_pPostCtrl->GetStrbPartNew(DiagD.aElemK[i],DiagD.nBeamPscPart,NULL,&StrbD,NULL)){ gm->m_pMyView->EndWaitCursor(); continue; }
				break;
			case LOADTYPE_ALL:
				if(!m_pDoc->m_pPostCtrl->GetStrbPartNew(DiagD.aElemK[i],DiagD.nBeamPscPart,NULL,NULL,&StrbD)){ gm->m_pMyView->EndWaitCursor(); continue; }
				break;
			}
		}
		else
		{
			switch(gm->m_LoadMinMaxType) 
			{
			case LOADTYPE_NORMAL:
			case LOADTYPE_MAX:
				if(!m_pDoc->m_pPostCtrl->GetStrbNew(DiagD.aElemK[i], &StrbD, NULL,NULL, FALSE)){  gm->m_pMyView->EndWaitCursor(); return FALSE; }
				break;
			case LOADTYPE_MIN:
				if(!m_pDoc->m_pPostCtrl->GetStrbNew(DiagD.aElemK[i], NULL,&StrbD,NULL, FALSE)){  gm->m_pMyView->EndWaitCursor(); return FALSE; }
				break;
			case LOADTYPE_ALL:
				if(!m_pDoc->m_pPostCtrl->GetStrbNew(DiagD.aElemK[i], NULL,NULL,&StrbD, FALSE)){ gm->m_pMyView->EndWaitCursor(); return FALSE; }
				break;
			}
		}

		if(!ConvertStrb2ReslD(DiagD,StrbD,ReslD))continue; 
		if(!GetDiagramDirection(DiagD.aElemK[i],DiagD,ReslD))continue; 
		
		double dTmpMxVal,dTmpMnVal;
		ReslD.GetMxMnVal(dTmpMxVal,dTmpMnVal);
		DiagGrupD.dMaxVal = max(dTmpMxVal,DiagGrupD.dMaxVal);
		DiagGrupD.dMinVal = min(dTmpMnVal,DiagGrupD.dMinVal);

		mKey.i1 = DiagD.aElemK[i];
		mKey.i2 = DiagK;
		m_mapDgrmData.SetAt(mKey,ReslD);
		bHasData = TRUE; 
	}

	if(!bHasData)
	{
		DiagGrupD.dMaxVal = 0.0;
		DiagGrupD.dMinVal = 0.0;
		return FALSE; 
	}

	DiagGrupD.nType       = DiagD.nTypeOfResult;
	
	// 일단 Z방향으로 한다 
	DiagGrupD.dDirVec[0]  = 0.0;
	DiagGrupD.dDirVec[1]  = 0.0;
	DiagGrupD.dDirVec[2]  = 0.0;
	m_mapDgrmGrup.SetAt(DiagK,DiagGrupD); 

	return TRUE; 
}


BOOL  CDiagramEngine::ConvertDisp2ReslD(T_DIAG_D &DiagD, T_DISP_D DispD[2], T_DIAG_RESL_D &ReslD)
{
	int nComp = DiagD.nComponents;
	double dDisp[2];
	memset(dDisp,0,sizeof(dDisp)); 
	switch(nComp)
	{
	case NDISP_COMP_TYPE_DX:
	case NDISP_COMP_TYPE_DY:
	case NDISP_COMP_TYPE_DZ:
		 dDisp[0] = DispD[0].dblDisp[nComp]; 
		 dDisp[1] = DispD[1].dblDisp[nComp]; 
		break; 
	case NDISP_COMP_TYPE_DXY:
		dDisp[0]  = sqrt(pow(DispD[0].dblDisp[0],2) + pow(DispD[0].dblDisp[1],2) ); 
		dDisp[1]  = sqrt(pow(DispD[1].dblDisp[0],2) + pow(DispD[1].dblDisp[1],2) ); 
		break; 
	case NDISP_COMP_TYPE_DYZ:
		dDisp[0]  = sqrt(pow(DispD[0].dblDisp[1],2) + pow(DispD[0].dblDisp[2],2) ); 
		dDisp[1]  = sqrt(pow(DispD[1].dblDisp[1],2) + pow(DispD[1].dblDisp[2],2) ); 
		break; 
	case NDISP_COMP_TYPE_DXZ:
		dDisp[0]  = sqrt(pow(DispD[0].dblDisp[0],2) + pow(DispD[0].dblDisp[2],2) ); 
		dDisp[1]  = sqrt(pow(DispD[1].dblDisp[0],2) + pow(DispD[1].dblDisp[2],2) ); 
		break; 
	case NDISP_COMP_TYPE_DXYZ:
		dDisp[0]  = sqrt(pow(DispD[0].dblDisp[0],2) + pow(DispD[0].dblDisp[1],2) + pow(DispD[0].dblDisp[2],2) ); 
		dDisp[1]  = sqrt(pow(DispD[1].dblDisp[0],2) + pow(DispD[1].dblDisp[1],2) + pow(DispD[1].dblDisp[2],2) ); 
		break; 
	}
	for(int i=0; i<4; i++)
	{
		ReslD.dValue[i][0] = dDisp[0] + (dDisp[1] - dDisp[0])*((double)(i/4.0)) ;
		ReslD.dValue[i][1] = dDisp[0] + (dDisp[1] - dDisp[0])*((double)((i+1.)/4.0)) ;
	}
	return TRUE;   
}


BOOL  CDiagramEngine::ConvertStrt2ReslD(T_DIAG_D &DiagD, T_STRT_D &StrtD, T_DIAG_RESL_D &ReslD)
{
	if(DiagD.nTypeOfResult == D_DGRM_TYPE_TFORC)
	{
		for(int i=0; i<4; i++)
		{
			ReslD.dValue[i][0] = StrtD.dblForce[0] + (StrtD.dblForce[1] - StrtD.dblForce[0])*((double)(i/4.0)) ;
			ReslD.dValue[i][1] = StrtD.dblForce[0] + (StrtD.dblForce[1] - StrtD.dblForce[0])*((double)((i+1.)/4.0)) ;
		}
	}
	else if(DiagD.nTypeOfResult == D_DGRM_TYPE_TSTRS)
	{
		for(int i=0; i<4; i++)
		{
			ReslD.dValue[i][0] = StrtD.dblStress[0] + (StrtD.dblStress[1] - StrtD.dblStress[0])*((double)(i/4.0)) ;
			ReslD.dValue[i][1] = StrtD.dblStress[0] + (StrtD.dblStress[1] - StrtD.dblStress[0])*((double)((i+1.)/4.0)) ;
		}
	}
	else 
	{
		ASSERT(0);
		return FALSE; 
	}
	return TRUE;   
}

BOOL  CDiagramEngine::ConvertStrb2ReslD(T_DIAG_D &DiagD, T_STRB_D &StrbD, T_DIAG_RESL_D &ReslD)
{
	int nCompIdx = 0;
	if(DiagD.nTypeOfResult == D_DGRM_TYPE_BFORC)
	{
		nCompIdx = DiagD.nComponents; // Fx,Fy....
		for(int i=0; i<4; i++)
		{
			ReslD.dValue[i][0] = StrbD.dblForce[i][nCompIdx];
			ReslD.dValue[i][1] = StrbD.dblForce[i][6+nCompIdx];
		}
	}
	else if(DiagD.nTypeOfResult == D_DGRM_TYPE_BSTRS)
	{
		for(int i=0; i<4; i++)
		{
			switch(DiagD.nComponents)
			{
			case  BSTRS_COMP_TYPE_SAX:
				ReslD.dValue[i][0] = StrbD.dblStress[i][0*7+0];
				ReslD.dValue[i][1] = StrbD.dblStress[i][1*7+0];
				break; 
			case  BSTRS_COMP_TYPE_SSY:
				ReslD.dValue[i][0] = StrbD.dblStress[i][0*7+1];
				ReslD.dValue[i][1] = StrbD.dblStress[i][1*7+1];
				break; 
			case  BSTRS_COMP_TYPE_SSZ:
				ReslD.dValue[i][0] = StrbD.dblStress[i][0*7+2];
				ReslD.dValue[i][1] = StrbD.dblStress[i][1*7+2];
				break; 
			case  BSTRS_COMP_TYPE_SBY:
				if( fabs(StrbD.dblStress[i][0*7+3]) > fabs(StrbD.dblStress[i][0*7+4]) )
					ReslD.dValue[i][0] = StrbD.dblStress[i][0*7+3];
				else
					ReslD.dValue[i][0] = StrbD.dblStress[i][0*7+4];

				if( fabs(StrbD.dblStress[i][1*7+3]) > fabs(StrbD.dblStress[i][1*7+4]) )
					ReslD.dValue[i][1] = StrbD.dblStress[i][1*7+3];
				else
					ReslD.dValue[i][1] = StrbD.dblStress[i][1*7+4];
			  break;
			case  BSTRS_COMP_TYPE_SBZ:
				if( fabs(StrbD.dblStress[i][0*7+5]) > fabs(StrbD.dblStress[i][0*7+6]) )
					ReslD.dValue[i][0] = StrbD.dblStress[i][0*7+5];
				else
					ReslD.dValue[i][0] = StrbD.dblStress[i][0*7+6];

				if( fabs(StrbD.dblStress[i][1*7+5]) > fabs(StrbD.dblStress[i][1*7+6]) )
					ReslD.dValue[i][1] = StrbD.dblStress[i][1*7+5];
				else
					ReslD.dValue[i][1] = StrbD.dblStress[i][1*7+6];
			  break; 
			case BSTRS_COMP_TYPE_COMB:
				switch(DiagD.nCombined)
				{
				case BSTRS_COMB_TYPE_MAX:
					ReslD.dValue[i][0] = StrbD.dblStress[i][14+0];
					ReslD.dValue[i][1] = StrbD.dblStress[i][14+1];
					break; 
				case BSTRS_COMB_TYPE_P1:
					ReslD.dValue[i][0] = StrbD.dblStress[i][16+0];
					ReslD.dValue[i][1] = StrbD.dblStress[i][16+1];
					break; 
				case BSTRS_COMB_TYPE_P2:
					ReslD.dValue[i][0] = StrbD.dblStress[i][18+0];
					ReslD.dValue[i][1] = StrbD.dblStress[i][18+1];
					break; 
				case BSTRS_COMB_TYPE_P3:
					ReslD.dValue[i][0] = StrbD.dblStress[i][20+0];
					ReslD.dValue[i][1] = StrbD.dblStress[i][20+1];
					break; 
				case BSTRS_COMB_TYPE_P4:
					ReslD.dValue[i][0] = StrbD.dblStress[i][22+0];
					ReslD.dValue[i][1] = StrbD.dblStress[i][22+1];
					break; 
				}
				break; 
			}
		}
	}
	else 
	{
		ASSERT(0);
		return FALSE; 
	}
	return TRUE;   
}


BOOL  CDiagramEngine::ConvertStrs2ReslD(T_DIAG_D &DiagD, T_STSS_D &StssD, T_DIAG_RESL_D &ReslD)
{
	// Maximum
	double dValue2[5];
	memset(dValue2,0,sizeof(double)*5);
	if(DiagD.nSectPos == BSTSS_SPOS_TYPE_MAX)
	{
		double dValue  = 0.0;
		for(int part = 0; part<5; part++)
		{
			double dMaxVal = -DBL_MAX;
			for(int i=0; i<10; i++)
			{
				if(DiagD.nComponents      == BSTSS_COMP_TYPE_SIGXX_ISST)     // PS1과 동일 
					dValue = StssD.dblStress[part][i][10];
				else if(DiagD.nComponents == BSTSS_COMP_TYPE_SIGXX_PS1)    // PS1
					dValue = StssD.dblStress[part][i][10];        
				else if(DiagD.nComponents == BSTSS_COMP_TYPE_SIGXX_PS2)    // PS2
					dValue = StssD.dblStress[part][i][11];
				else
					dValue = StssD.dblStress[part][i][DiagD.nComponents];

				if (dMaxVal < dValue) dMaxVal = dValue;
			}
			dValue2[part] = dMaxVal;
		}
	}
	// Minimum
	else if(DiagD.nSectPos  ==BSTSS_SPOS_TYPE_MIN)
	{
		double dValue  = 0.0;
		for(int part = 0; part<5; part++)
		{
			double dMinVal = DBL_MAX;
			for(int i=0; i<10; i++)
			{
				if(DiagD.nComponents == BSTSS_COMP_TYPE_SIGXX_ISST)         // PS1과 동일 
					dValue = StssD.dblStress[part][i][10];
				else if(DiagD.nComponents == BSTSS_COMP_TYPE_SIGXX_PS1)    // PS1
					dValue = StssD.dblStress[part][i][10];        
				else if(DiagD.nComponents == BSTSS_COMP_TYPE_SIGXX_PS2)    // PS2
					dValue = StssD.dblStress[part][i][11];
				else
					dValue = StssD.dblStress[part][i][DiagD.nComponents];
				if (dMinVal > dValue) dMinVal = dValue;
			}
			dValue2[part] = dMinVal;
		}
	}
	// Abs Max
	else if(DiagD.nSectPos ==BSTSS_SPOS_TYPE_ABSMAX)
	{
		double dValue     = 0.0;
		for(int part = 0; part<5; part++)
		{
			double dAbsMaxVal = 0.0;
			for(int i=0; i<10; i++)
			{
				if(DiagD.nComponents == BSTSS_COMP_TYPE_SIGXX_ISST)         // PS1과 동일 
					dValue = StssD.dblStress[part][i][10];
				else if(DiagD.nComponents == BSTSS_COMP_TYPE_SIGXX_PS1)    // PS1
					dValue = StssD.dblStress[part][i][10];        
				else if(DiagD.nComponents == BSTSS_COMP_TYPE_SIGXX_PS2)    // PS2
					dValue = StssD.dblStress[part][i][11];
				else
					dValue = StssD.dblStress[part][i][DiagD.nComponents];
				if (dAbsMaxVal < fabs(dValue)) dAbsMaxVal = fabs(dValue);
			}
			dValue2[part] = dAbsMaxVal;
		}
	}
	else
	{
		for(int part = 0; part<5; part++)
		{
			double dValue;
			if(DiagD.nComponents == BSTSS_COMP_TYPE_SIGXX_ISST)         // PS1과 동일 
				dValue = StssD.dblStress[part][DiagD.nSectPos][10];
			else if(DiagD.nComponents == BSTSS_COMP_TYPE_SIGXX_PS1)    // PS1
				dValue = StssD.dblStress[part][DiagD.nSectPos][10];        
			else if(DiagD.nComponents == BSTSS_COMP_TYPE_SIGXX_PS2)    // PS2
				dValue = StssD.dblStress[part][DiagD.nSectPos][11];
			else
				dValue = StssD.dblStress[part][DiagD.nSectPos][DiagD.nComponents];
			dValue2[part] = dValue;
		}
	}

	// 5지점을 4지점으로 변환
	for(int part=0; part<4; part++)
	{
		ReslD.dValue[part][0] = dValue2[part];
		ReslD.dValue[part][1] = dValue2[part+1];
	}
	return TRUE; 
}

BOOL  CDiagramEngine::GetDiagramDirection(T_ELEM_K ElemK,T_DIAG_D &DiagD, T_DIAG_RESL_D &ReslD)
{
	double dLocalVec[3][3];
	if(!m_pDoc->calcFrameLocalVector(ElemK, dLocalVec))return FALSE; 

	memset(ReslD.dDirVec,0,sizeof(double)*3);
	
	int nVecIdx= 0;
	if(DiagD.nTypeOfResult == D_DGRM_TYPE_DISPL)
	{
		nVecIdx= 2; //무조건 z방향 
	}
	else if(DiagD.nTypeOfResult == D_DGRM_TYPE_TFORC || 
				 DiagD.nTypeOfResult == D_DGRM_TYPE_TSTRS )
	{
		nVecIdx= 2; 
	}
	else if(DiagD.nTypeOfResult == D_DGRM_TYPE_BFORC)
	{
		switch(DiagD.nComponents)
		{
		case BFORC_COMP_TYPE_FY:  
			nVecIdx= 1; 
			break; 
		case BFORC_COMP_TYPE_FZ:  
		case BFORC_COMP_TYPE_FX:  
			nVecIdx= 2; 
			break; 
		case BFORC_COMP_TYPE_MX:  
		case BFORC_COMP_TYPE_MY:  
			nVecIdx= -2; 
			break; 
		case BFORC_COMP_TYPE_MZ:  
			nVecIdx= -1; 
			break; 
		}
	}
	else if(DiagD.nTypeOfResult == D_DGRM_TYPE_BSTRS)
	{
		switch(DiagD.nComponents)
		{
		case  BSTRS_COMP_TYPE_SAX:  
		case  BSTRS_COMP_TYPE_SSZ:  
			nVecIdx= 2; 
			break; 
		case  BSTRS_COMP_TYPE_SSY:   
			nVecIdx= 1; 
			break; 
		case  BSTRS_COMP_TYPE_SBY:   
			nVecIdx= 1; 
			break; 
		case  BSTRS_COMP_TYPE_SBZ:   
			nVecIdx= 2; 
			break; 
		case  BSTRS_COMP_TYPE_COMB:  
			nVecIdx= 2; 
			break; 
		}
	}
	else if(DiagD.nTypeOfResult == D_DGRM_TYPE_BSTSS)
	{
		nVecIdx= 2; //무조건 z방향 
	}
	else 
	{
		ASSERT(0);
		return FALSE; 
	}
	memcpy(ReslD.dDirVec, dLocalVec[abs(nVecIdx)], sizeof(double)*3);

	if(nVecIdx < 0)
	{
		ReslD.dDirVec[0] = -ReslD.dDirVec[0];
		ReslD.dDirVec[1] = -ReslD.dDirVec[1];
		ReslD.dDirVec[2] = -ReslD.dDirVec[2];
	}
	return TRUE; 
}

/*
BOOL  CDiagramEngine::MakeDgrmDataBSTRS(T_DIAG_K DiagK,T_DIAG_D &DiagD,T_DIAG_GRUP_D &DiagGrupD)
{
	return TRUE; 
}
*/

BOOL  CDiagramEngine::MakeDgrmDataBSTSS(T_DIAG_K DiagK,T_DIAG_D &DiagD,T_DIAG_GRUP_D &DiagGrupD)
{
	if(!DiagD.aElemK.GetSize())return FALSE; 
	
	T_CMAP_K2<UINT> mKey;
	T_ELEM_D ElemD; 
	T_DIAG_RESL_D ReslD;
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	CDBDoc *pDoc = CDBDoc::GetDocPoint(); 

	DiagGrupD.Initialize(); 
	BOOL bHasData = FALSE; 
	DiagGrupD.dMaxVal = -DBL_MAX;
	DiagGrupD.dMinVal =  DBL_MAX;
	T_STSS_D StssD;
	T_ELEM_K TmpElemK; 
	for(int i=0; i<DiagD.aElemK.GetSize(); i++)
	{
		if(!pDoc->m_pAttrCtrl->GetElem(DiagD.aElemK[i],ElemD)){ continue; }
		if(!pDoc->m_pAttrCtrl->IsBeam(ElemD.eltyp))continue;
		if(!m_mapActiveElem.Lookup(DiagD.aElemK[i],TmpElemK))continue; 
		if(!CDBLib::IsPscDgnFor1st(DiagD.aElemK[i],FALSE))continue;

		switch(gm->m_LoadMinMaxType) 
		{
		case LOADTYPE_NORMAL:
		case LOADTYPE_MAX:
			if(!m_pDoc->m_pPostCtrl->GetStssNew(DiagD.aElemK[i], &StssD, NULL,NULL, 1)){  gm->m_pMyView->EndWaitCursor(); return FALSE; }
			break;
		case LOADTYPE_MIN:
			if(!m_pDoc->m_pPostCtrl->GetStssNew(DiagD.aElemK[i], NULL,&StssD,NULL, 1)){  gm->m_pMyView->EndWaitCursor(); return FALSE; }
			break;
		case LOADTYPE_ALL:
		  if(!m_pDoc->m_pPostCtrl->GetStssNew(DiagD.aElemK[i], NULL,NULL,&StssD, 1)){ gm->m_pMyView->EndWaitCursor(); return FALSE; }
			break;
		}
		if(!ConvertStrs2ReslD(DiagD,StssD,ReslD))continue; 
		if(!GetDiagramDirection(DiagD.aElemK[i],DiagD,ReslD))continue; 
		
		double dTmpMxVal,dTmpMnVal;
		ReslD.GetMxMnVal(dTmpMxVal,dTmpMnVal);
		DiagGrupD.dMaxVal = max(dTmpMxVal,DiagGrupD.dMaxVal);
		DiagGrupD.dMinVal = min(dTmpMnVal,DiagGrupD.dMinVal);

		mKey.i1 = DiagD.aElemK[i];
		mKey.i2 = DiagK;
		m_mapDgrmData.SetAt(mKey,ReslD);
		bHasData = TRUE; 
	}

	if(!bHasData)
	{
		DiagGrupD.dMaxVal = 0.0;
		DiagGrupD.dMinVal = 0.0;
		return FALSE; 
	}
	DiagGrupD.nType       = DiagD.nTypeOfResult;
	
	// 일단 Z방향으로 한다 
	DiagGrupD.dDirVec[0]  = 0.0;
	DiagGrupD.dDirVec[1]  = 0.0;
	DiagGrupD.dDirVec[2]  = 0.0;
	m_mapDgrmGrup.SetAt(DiagK,DiagGrupD); 

	return TRUE; 
}

void  CDiagramEngine::DrawEDgrm(CDC *pDC)
{
	if(m_bIgnorePlotDiagram)return; 


	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	
	int			i, nElem;
	T_ELEM_D	elem_d;
	CArray <int, int>				    type_list;
	CArray <GRE_Atom, GRE_Atom&>atom_list;
	BOOL bEscapePressed = FALSE;
	
	CDC	*pdc=gm->m_pMyView->GetDC();
	m_dUnitLength = fabs(gm->m_pGPSCtrl->GetWorldLength(((double) pdc->GetDeviceCaps(LOGPIXELSX))/5.0));
	
	gm->m_pMyView->ReleaseDC(pdc);

	BOOL fl_bak=gm->m_DOPT.DR.m_bFrameLine;
	gm->m_DOPT.DR.m_bFrameLine = TRUE;

	type_list.Add(gm->m_MinOTID + OBJECT_TYPE_ORIGINAL);
	gm->m_pGPSCtrl->GetZSortedList(type_list, gm->m_EKeyListVisible_Mirror, atom_list);
	nElem = atom_list.GetSize();

	//m_arDiagramOutPut.RemoveAll(); 
	T_MIRE_K mkey;
	for (i=0;i<nElem ;i++) 
	{
		if(gm->m_pGPSCtrl->WatchEscKeyPress()) return;
		if(gm->m_pGPSCtrl->IsZoomAllState() ||
			 gm->m_pGPSCtrl->IsObjectInClientWindow(atom_list[i].m_OType, atom_list[i].m_OKey)) 
		{
			mkey.keymap = atom_list[i].m_OKey;
			if(!m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d))continue;
			if(gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey) && !bEscapePressed)
			{
				BOOL bBeam    = m_pDoc->m_pAttrCtrl->IsBeam(elem_d.eltyp);
				BOOL bTruss   = m_pDoc->m_pAttrCtrl->IsTruss(elem_d.eltyp);
				
				if(!bBeam && !bTruss) 
				{
					gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
				}
				else
				{
					gm->GPSDrawElement(pDC, atom_list[i].m_OKey);
				}


				CArray<T_DIAG_K,T_DIAG_K> arDiagK;

				if(!GetDiagDataByElemK(mkey.key.elem_k,arDiagK))continue; 
				for(int j=0; j<arDiagK.GetSize(); j++)
				{
					DoDrawDiagram(pDC, mkey.key.elem_k, arDiagK[j]);
				}
				/*
				if(m_bDeformedShapeContour)
				{
				  if(bBeam) gm->m_pDeformEngine->DrawDeformedElement(pDC, atom_list[i].m_OKey);
					else			gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, atom_list[i].m_OKey);
				}
			  else
				{
				*/
			}
			else
			{
				//if(m_bDeformedShapeContour)
					//gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, atom_list[i].m_OKey);
				//else
					gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
			}
		}
	}

	/*
	BOOL bOutNum=gm->m_DOPT.TX.m_bOutputNumber;
	if(bOutNum)
	{
		// Beam/Truss의 결과값 출력 
		BOOL bGrpFltMode=gm->m_pGPSCtrl->IsGroupFilterMode();
		for(i=0; i<m_arBStrsOutPut.GetSize(); i++)
		{
			if(bGrpFltMode)if(!gm->m_pDispFilter->IsExistEKey(m_arBStrsOutPut[i].EKey))continue;
			OutputBStrsDgrmNumber(pDC, m_arBStrsOutPut[i].EKey, m_arBStrsOutPut[i].StrbD, m_arBStrsOutPut[i].Pos, m_arBStrsOutPut[i].nComp, m_arBStrsOutPut[i].dMinMaxVal);
		}
		for(i=0; i<m_arBStrsOutPutM.GetSize(); i++)
		{
			if(bGrpFltMode)if(!gm->m_pDispFilter->IsExistEKey(m_arBStrsOutPutM[i].EKey))continue;
			OutputBStrsDgrmNumber(pDC, m_arBStrsOutPutM[i].EKey, m_arBStrsOutPutM[i].StrbD, m_arBStrsOutPutM[i].Pos, m_arBStrsOutPutM[i].nComp,m_arBStrsOutPutM[i].dMinMaxVal);
		}
	}
	m_arBStrsOutPut.RemoveAll();
	m_arBStrsOutPutM.RemoveAll(); 


	// 변형된 모델에 Undeformed 모델을 같이 그릴 경우
	if (m_bDeformedShapeContour && gm->m_DOPT.DR.m_bDrawInactive && !m_bBSfdBmdLineOnly && !bEscapePressed) 
	{
		int	rf_bak=gm->m_DOPT.DR.m_RenderFlag;
		gm->m_DOPT.DR.m_RenderFlag = 2;
		gm->GPSDrawOriginal(pDC, TRUE);
		gm->m_DOPT.DR.m_RenderFlag = rf_bak;
	}
	*/
	gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}

COLORREF CDiagramEngine::GetColor(BOOL bGrayColor, T_DIAG_D DiagD)
{
	COLORREF TmpColor;
	
	if(bGrayColor)
		TmpColor = RGB(0,0,0);
	else
	{
		if(CDiagramEngine::m_bBatchStepMode)
			TmpColor = GetStagColor();
		else if(CDiagramEngine::m_bBatchLoadMode)
			TmpColor = GetLoadColor();
		else
			TmpColor = DiagD.DispOpt.Color;
	}

	return TmpColor;
}

COLORREF CDiagramEngine::GetStagColor()
{
	CAttrCtrl *pAttrCtrl = CDBDoc::GetDocPoint()->m_pAttrCtrl; 
	CStagCtrl *pStagCtrl = CDBDoc::GetDocPoint()->m_pStagCtrl; 
	if(!pStagCtrl)return 0; 

	T_DGMC_D DgmcD;
	T_STAG_K StagK = pStagCtrl->GetCurStag();
	if(!pAttrCtrl->GetDgmc(StagK,DgmcD)){ ASSERT(0); return 0; }

	return DgmcD.Color;
}

COLORREF CDiagramEngine::GetLoadColor()
{	
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	T_DGML_K DgmlK;
	T_DGML_D DgmlD;
	COLORREF TmpColor;

	UINT AnalType = GetAnalType(gm->m_LoadCaseType);
	int nLoadMaxMin = gm->m_LoadMinMaxType;

	if(!CDBDoc::GetDocPoint()->m_pAttrCtrl->GetDgmlKey(AnalType,gm->m_LoadCaseKey,DgmlK))	ASSERT(0);

	if(!CDBDoc::GetDocPoint()->m_pAttrCtrl->GetDgml(DgmlK,DgmlD))	{ ASSERT(0); return 0; }

	if((nLoadMaxMin==LOAD_NORMAL)||(nLoadMaxMin==LOAD_ALL))
		TmpColor = DgmlD.Color[0]; 
	else if(nLoadMaxMin==LOAD_MIN)
		TmpColor = DgmlD.Color[1]; 
	else if(nLoadMaxMin==LOAD_MAX)
		TmpColor = DgmlD.Color[2]; 

	return TmpColor;
}

void CDiagramEngine::DoDrawDiagram(CDC *pDC, T_ELEM_K ElemK, T_DIAG_K DiagK)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	
	T_DIAG_D DiagD;
	T_DIAG_RESL_D ReslD;
	T_DIAG_GRUP_D DiagGrupD;
	T_CMAP_K2<UINT> mKey;
	mKey.i1 = ElemK;
	mKey.i2 = DiagK;
	if(!m_mapDgrmData.Lookup(mKey,ReslD))return; 
	if(!m_mapDgrmGrup.Lookup(DiagK,DiagGrupD))return; 
	if(!m_pDoc->m_pAttrCtrl->GetDiag(DiagK,DiagD))return; 

 
	int		    poly_num;
	//double		local_vector[3][3];
	double    dMnMxVal[2];
			
	POSITION	pos;
	C3DPoint	pnt[2], *txt_pnt;
	CArray<BOOL, BOOL>				ef_list;
	CArray<BOOL, BOOL>				rect_flag;
	CArray<double, double &>	val_list;
	CArray<C3DPoint,C3DPoint&>vtx_list;
	CArray<CList<C3DPoint,C3DPoint> *, CList <C3DPoint, C3DPoint> *>polygon_list;

	BOOL bDeformedElem = FALSE; 
	//if(m_mapDeformedElem.Lookup(ElemK,DiagDispD))bDeformedElem = TRUE;
	//m_pDoc->calcFrameLocalVector(ElemK, local_vector);
	/*
	if(bDeformedElem)
	{
		//gm->m_pDeformEngine->GetDeformedShapeElement(ElemK, &polygon_list, NULL, NULL);
		gm->m_pDeformEngine->GetDeformedShapeElement4AnotherEngine(ElemK,
															 DiagDispD.nComponent, double dScaleFactor, 
									             &polygon_list,
									             NULL,
									             NULL,
															 NULL);
	}
	else
	*/
	  gm->GetShapeElement(ElemK, polygon_list, NULL, NULL, NULL);
	
	poly_num = polygon_list.GetSize();
	if((poly_num!=1) || (polygon_list[0]->GetCount()!=2))return;
	
	if(DiagD.DispOpt.bDisplayValue) 
	{
		txt_pnt   = new C3DPoint[4];
	}
	else 
	{
		txt_pnt   = NULL;
	}

	pos = polygon_list[0]->GetHeadPosition();
	pnt[0] = polygon_list[0]->GetNext(pos);
	pnt[1] = polygon_list[0]->GetNext(pos);

	T_DIAG_OUTVAL_D OutValD;
	DiagramPolygon(ReslD, DiagD, ReslD.dDirVec, pnt[0], pnt[1], vtx_list, val_list, 
								 ef_list, rect_flag, txt_pnt, ElemK, DiagD.DispOpt.nFillType,dMnMxVal);
	if(txt_pnt) GetDgrmOutputData(ElemK,DiagK,txt_pnt,dMnMxVal,OutValD);
		

	BOOL bGrayColor = FALSE; 
	if(gm->m_bVirtualMode || gm->m_pGPSCtrl->IsMakeEMFMode() ) 
	if(gm->m_DOPT.m_PrintMode == 0) // 0: Gray
	{
		bGrayColor = TRUE; 
	}

	int nCount = 0;
	int nNodeNum = 0;
	CList <C3DPoint, C3DPoint>	vlist;
	CArray<BOOL,BOOL> arEdgeFlag; 

	COLORREF DgrmCol = GetColor(bGrayColor, DiagD);

	CPen LinePen,*pOldPen;
	LinePen.CreatePen(PS_SOLID, gm->m_nLineWidth, DgrmCol );
	pOldPen = (CPen *) pDC->SelectObject(&LinePen);
	for(int i=0; i<rect_flag.GetSize(); i++)
	{
		if(rect_flag[i])nNodeNum = 4;
		else            nNodeNum = 3;

		vlist.RemoveAll(); 
		arEdgeFlag.RemoveAll(); 
		for(int j=0; j<nNodeNum; j++)
		{
			vlist.AddTail(vtx_list[j+nCount]);
			arEdgeFlag.Add(ef_list[j+nCount]);
		}

		// Solid Fill
		if(DiagD.DispOpt.nFillType == 2)
		{
			gm->DrawPolygon3DFill(pDC,vlist,DgrmCol);
		}
		else
		{
			gm->GPSDrawPolygonEdge(pDC,&vlist, &arEdgeFlag); // bOnClient : Client윈도에 직접 같이 그리는 것 조절.

		}
		nCount += nNodeNum; 
	}
	pDC->SelectObject(pOldPen);
	LinePen.DeleteObject(); 

	vtx_list.RemoveAll();
	val_list.RemoveAll();
	ef_list.RemoveAll();
	rect_flag.RemoveAll();

	FreeMemoryPolyList(&polygon_list); 
	
	if(txt_pnt) delete []txt_pnt;

	// Output Text
	if(DiagD.DispOpt.bDisplayValue)
	{
		BOOL bGrpFltMode=gm->m_pGPSCtrl->IsGroupFilterMode();
		if(bGrpFltMode) if(!gm->m_pDispFilter->IsExistEKey(ElemK))return ;
		COLORREF FontCol = GetColor(bGrayColor, DiagD);
		OutputDgrmNumber(pDC,DiagD,DiagGrupD,ReslD,OutValD,bDeformedElem,FontCol);
	}
}

#if defined(__OLD_OUTPUT_VALUE)
void CDiagramEngine::OutputDgrmNumber(CDC *pDC, T_DIAG_D &DiagD, T_DIAG_GRUP_D &DiagGrupD,
																			T_DIAG_RESL_D &ReslD,T_DIAG_OUTVAL_D &OutVal,BOOL bDeformed,
																			COLORREF FontCol)
{
	DECLARE_GPSMD();
	DECLARE_DPTTX();
	DECLARE_DPTDR();

	int			  j, slope;
	TCHAR			fmt_str[10], text_str[512];
	BOOL			fl_bak, is_inverse;
	C3DPoint	node3D_i, node3D_j,DrawPoint;
	CPoint		text_p,node_2d_i, node_2d_j;
	CFont			ft, *old_ft;
	T_ELEM_D	edata;

	POSITION	pos;
	CArray<GPS_3DPT_LISTP, GPS_3DPT_LISTP>  polygon_list;
	CArray<GPS_BOOL_ARRYP, GPS_BOOL_ARRYP>	edge_list;
	
	if(pTX->m_bNumberOpaque)pDC->SetBkMode(OPAQUE);
	else		                pDC->SetBkMode(TRANSPARENT);
	//pDC->SetTextColor(pTX->m_NumberTextColorC);
	pDC->SetTextColor(FontCol);
	pDC->SetBkColor(pTX->m_NumberBackCol);
	pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);

	if(DiagD.DispOpt.bExp)_stprintf(fmt_str, _T(" %s%de "), _T("%."), DiagD.DispOpt.nDecimalPoints);
	else		              _stprintf(fmt_str, _T(" %s%df "), _T("%."), DiagD.DispOpt.nDecimalPoints);

	if(!gm->m_pGPSCtrl->IsActiveElem(OutVal.ElemK))
		return; // Label Hidden 처리를 위해 추가 되었음.
	
	m_pDoc->m_pAttrCtrl->GetElem(OutVal.ElemK, edata);
	if(!m_pDoc->m_pAttrCtrl->IsBeam (edata.eltyp) && 
		 !m_pDoc->m_pAttrCtrl->IsTruss(edata.eltyp) )return;

	fl_bak = pDR->m_bFrameLine;
	gm->m_DOPT.DR.m_bFrameLine = TRUE;

	//if(bDeformed)
		//gm->m_pDeformEngine->GetDeformedShapeElement(OutVal.ElemK, &polygon_list, &edge_list);
	//else
	gm->GetShapeElement(OutVal.ElemK, polygon_list, &edge_list);
	
	CRect	rct;
	gm->m_pMyView->GetClientRect(&rct);

	pos = polygon_list[0]->GetHeadPosition();
	node3D_i = polygon_list[0]->GetNext(pos);
	node3D_j = polygon_list[0]->GetNext(pos);

	 //XGLRenderer
	BOOL bSaveTextOutput = FALSE;
	if(gm->m_pGPSCtrl->IsGLRenderer() && gm->m_pGPSCtrl->IsXGRMode() && 
		 !gm->m_pGPSCtrl->IsMakeEMFMode() )
	{
		 bSaveTextOutput = TRUE;
	}

	if(gm->m_bVirtualMode) 
	{
		node_2d_i = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_i);
		node_2d_j = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_j);
	}
	else 
	{
		node_2d_i = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_i);
		node_2d_j = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_j);
	}

	 //XGLRenderer 
	if(bSaveTextOutput == FALSE) //저장 모드에서는 현재 화면 상태와 관계된 Filtering처리를 하지 않는다. 
	{
	if(node_2d_i.x < 0 ||node_2d_i.y < 0 ) return;
	if(node_2d_j.x < 0 ||node_2d_j.y < 0 ) return;
	}

	slope = (int) (atan2(node_2d_i.y-node_2d_j.y, node_2d_j.x-node_2d_i.x)*1800.0/3.14159);
	slope = (slope+3600)%3600;
	if ((900<slope) && (slope<=2700)) 
	{
		slope = (slope+1800)%3600;
		is_inverse = TRUE;
	}
	else 
	{
		is_inverse = FALSE;
	}

	gm->SetNumberFontOrientation(slope);
	ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
	old_ft = (CFont *) pDC->SelectObject(&ft);

	if(DiagD.DispOpt.bMinMaxOnly)
	{
		double dLimit = (DiagGrupD.dMaxVal-DiagGrupD.dMinVal) * DiagD.DispOpt.dLimitScale / 100.0;
		double dBValue;
		
		for(int n=0; n<3; n++)
		{
			if(DiagD.DispOpt.OutputSectLoc[4] == '1') //m_bBStrsOutputMinMax)
			{
				// Min
				if(n==0)
				{
					pDC->SetTextAlign(TA_CENTER|TA_TOP);
					DrawPoint = OutVal.Pos[0];  
					dBValue   = OutVal.dMinMaxVal[0];
				}
				// Max
				else if(n==1)
				{
					pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);
					DrawPoint = OutVal.Pos[1];  
					dBValue   = OutVal.dMinMaxVal[1];
				}
				else continue; 
			}
			// Abs Max
			else if(DiagD.DispOpt.OutputSectLoc[3] == '1') 
			{
				if(n==0)
				{
					DrawPoint = OutVal.Pos[1];  
					dBValue   = OutVal.dMinMaxVal[1];
				}
				else continue; 
			}
			else if(n==0) // I단 
			{
				if(!(DiagD.DispOpt.OutputSectLoc[0] == '1'||
					 DiagD.DispOpt.OutputSectLoc[3] == '1')) continue;
				
				if(is_inverse) pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
				else		   pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
				DrawPoint = OutVal.Pos[0];
				//dBValue = CalcBStrsValue(StrbD, 0, I_NODE);
				//dBValue = this->CalcBStrsValue(StrbD, 0);
				dBValue = ReslD.dValue[0][0];
				
			}
			else if(n==1)// CNT or MAX
			{			  
				if (!(DiagD.DispOpt.OutputSectLoc[1] == '1'||
					  DiagD.DispOpt.OutputSectLoc[3] == '1')) continue;
				
				pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);
				DrawPoint= OutVal.Pos[1];
				
				// I Val
				if(DiagD.DispOpt.OutputSectLoc[3] == '1') 
				{
					dBValue = OutVal.dMinMaxVal[1];
				}
				// Abs Max
				else
				{
					//dBValue = CalcBStrsValue(StrbD, 1, J_NODE);
					//dBValue = this->CalcBStssValue(StssD, 4);
					dBValue = ReslD.dValue[1][1];
				}
				
			}
			else if(n==2)// J단 
			{			  
				if (!(DiagD.DispOpt.OutputSectLoc[2] == '1'||
							DiagD.DispOpt.OutputSectLoc[3] == '1')) continue;

				if(is_inverse)pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
				else					pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
				DrawPoint = OutVal.Pos[2];
				//dBValue = CalcBForcValue(bforc_d, 3, J_NODE);
				//this->CalcBStssValue(StssD, 2);
				//dBValue = CalcBStrsValue(StrbD, 3, J_NODE);
				dBValue = ReslD.dValue[3][1];
			}
					
			switch(DiagD.DispOpt.nMinMaxOpt)
			{
			case 0: // Min & Max
				if(bSaveTextOutput)
				{
					double Pos6[6];
					Pos6[0] = node3D_i.x;Pos6[1] = node3D_i.y;Pos6[2] = node3D_i.z;
					Pos6[3] = node3D_j.x;Pos6[4] = node3D_j.y;Pos6[5] = node3D_j.z;
					if((DiagGrupD.dMaxVal-dBValue) <= dLimit)
						gm->m_pXGR_GPSDrawMgr->m_OutputDgrmNumber.Add_OutputDgrmNumber(&(DrawPoint.x),Pos6, 0,dBValue, DiagD.DispOpt.bSetOrientation,(int)(DiagD.DispOpt.dAngle*10),DiagD.DispOpt.bExp,DiagD.DispOpt.nDecimalPoints,FontCol);
					else if((dBValue-DiagGrupD.dMinVal) <= dLimit)
						gm->m_pXGR_GPSDrawMgr->m_OutputDgrmNumber.Add_OutputDgrmNumber(&(DrawPoint.x),Pos6, 1,dBValue, DiagD.DispOpt.bSetOrientation,(int)(DiagD.DispOpt.dAngle*10),DiagD.DispOpt.bExp,DiagD.DispOpt.nDecimalPoints,FontCol);
				}
				else
				{
				if((DiagGrupD.dMaxVal-dBValue) <= dLimit)
					 DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,dBValue);
				else if((dBValue-DiagGrupD.dMinVal) <= dLimit)
					 DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,dBValue);
				}
				break;
			case 1: // Abs Max
				if(bSaveTextOutput)
				{
					double Pos6[6];
					Pos6[0] = node3D_i.x;Pos6[1] = node3D_i.y;Pos6[2] = node3D_i.z;
					Pos6[3] = node3D_j.x;Pos6[4] = node3D_j.y;Pos6[5] = node3D_j.z;

					if(fabs(DiagGrupD.dMaxVal) >= fabs(DiagGrupD.dMinVal))
					{
						if( fabs(DiagGrupD.dMaxVal)-fabs(dBValue) <= dLimit)
							gm->m_pXGR_GPSDrawMgr->m_OutputDgrmNumber.Add_OutputDgrmNumber(&(DrawPoint.x),Pos6, 2,dBValue, DiagD.DispOpt.bSetOrientation,(int)(DiagD.DispOpt.dAngle*10),DiagD.DispOpt.bExp,DiagD.DispOpt.nDecimalPoints,FontCol);
					}
					else
					{
						if( fabs(DiagGrupD.dMinVal)-fabs(dBValue) <= dLimit)
							gm->m_pXGR_GPSDrawMgr->m_OutputDgrmNumber.Add_OutputDgrmNumber(&(DrawPoint.x),Pos6, 2,dBValue, DiagD.DispOpt.bSetOrientation,(int)(DiagD.DispOpt.dAngle*10),DiagD.DispOpt.bExp,DiagD.DispOpt.nDecimalPoints,FontCol);
					}
				}
				else
				{
					if(fabs(DiagGrupD.dMaxVal) >= fabs(DiagGrupD.dMinVal))
					{
						if( fabs(DiagGrupD.dMaxVal)-fabs(dBValue) <= dLimit)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dBValue);
					}
					else
					{
						if( fabs(DiagGrupD.dMinVal)-fabs(dBValue) <= dLimit)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dBValue);
					}
				}
				break;
			case 2: // Max
				if(bSaveTextOutput)
				{
					double Pos6[6];
					Pos6[0] = node3D_i.x;Pos6[1] = node3D_i.y;Pos6[2] = node3D_i.z;
					Pos6[3] = node3D_j.x;Pos6[4] = node3D_j.y;Pos6[5] = node3D_j.z;
					if((DiagGrupD.dMaxVal-dBValue) <= dLimit)
						gm->m_pXGR_GPSDrawMgr->m_OutputDgrmNumber.Add_OutputDgrmNumber(&(DrawPoint.x),Pos6, 0,dBValue, DiagD.DispOpt.bSetOrientation,(int)(DiagD.DispOpt.dAngle*10),DiagD.DispOpt.bExp,DiagD.DispOpt.nDecimalPoints,FontCol);
				}
				else
				{
					if((DiagGrupD.dMaxVal-dBValue) <= dLimit)
						DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,dBValue);
				}
				break;
			case 3: // Min
				if(bSaveTextOutput)
				{
					double Pos6[6];
					Pos6[0] = node3D_i.x;Pos6[1] = node3D_i.y;Pos6[2] = node3D_i.z;
					Pos6[3] = node3D_j.x;Pos6[4] = node3D_j.y;Pos6[5] = node3D_j.z;
					if((dBValue-DiagGrupD.dMinVal) <= dLimit)
						gm->m_pXGR_GPSDrawMgr->m_OutputDgrmNumber.Add_OutputDgrmNumber(&(DrawPoint.x),Pos6, 1,dBValue, DiagD.DispOpt.bSetOrientation,(int)(DiagD.DispOpt.dAngle*10),DiagD.DispOpt.bExp,DiagD.DispOpt.nDecimalPoints,FontCol);
				}
				else
				{
					if((dBValue-DiagGrupD.dMinVal) <= dLimit)
						DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,dBValue);
				}
				break;
			}
		}
	//////////////////////////////////////////////////////////////////////////////////////
	}      
	else      
	{
		// Min/Max
		if(DiagD.DispOpt.OutputSectLoc[4] == '1')      
		{
			if(bSaveTextOutput)
			{
				double Pos6[6];
				Pos6[0] = node3D_i.x;Pos6[1] = node3D_i.y;Pos6[2] = node3D_i.z;
				Pos6[3] = node3D_j.x;Pos6[4] = node3D_j.y;Pos6[5] = node3D_j.z;
				gm->m_pXGR_GPSDrawMgr->m_OutputDgrmNumber.Add_OutputDgrmNumber(&(OutVal.Pos[0].x),Pos6, 3, OutVal.dMinMaxVal[0], DiagD.DispOpt.bSetOrientation,(int)(DiagD.DispOpt.dAngle*10),DiagD.DispOpt.bExp,DiagD.DispOpt.nDecimalPoints,FontCol);
				gm->m_pXGR_GPSDrawMgr->m_OutputDgrmNumber.Add_OutputDgrmNumber(&(OutVal.Pos[1].x),Pos6, 4, OutVal.dMinMaxVal[1], DiagD.DispOpt.bSetOrientation,(int)(DiagD.DispOpt.dAngle*10),DiagD.DispOpt.bExp,DiagD.DispOpt.nDecimalPoints,FontCol);
			}
			else
			{
				// Min Val
				pDC->SetTextAlign(TA_CENTER|TA_TOP);
				if(gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(OutVal.Pos[0]);
				else                  text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(OutVal.Pos[0]);
				_stprintf(text_str, fmt_str, OutVal.dMinMaxVal[0]);
				if(text_p.x >= 0 && text_p.y>=0)pDC->TextOut(text_p.x, text_p.y, text_str);  

				// Max Val
				pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);
				if(gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(OutVal.Pos[1]);
				else                  text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(OutVal.Pos[1]);
				_stprintf(text_str, fmt_str, OutVal.dMinMaxVal[1]);
				if(text_p.x >= 0 && text_p.y>=0)pDC->TextOut(text_p.x, text_p.y, text_str);  
			}
		}
		// Abs Max
		else if(DiagD.DispOpt.OutputSectLoc[3] == '1') 
		{
			if(bSaveTextOutput)
			{
				double Pos6[6];
				Pos6[0] = node3D_i.x;Pos6[1] = node3D_i.y;Pos6[2] = node3D_i.z;
				Pos6[3] = node3D_j.x;Pos6[4] = node3D_j.y;Pos6[5] = node3D_j.z;
				gm->m_pXGR_GPSDrawMgr->m_OutputDgrmNumber.Add_OutputDgrmNumber(&(OutVal.Pos[1].x),Pos6, 5, OutVal.dMinMaxVal[1], DiagD.DispOpt.bSetOrientation,(int)(DiagD.DispOpt.dAngle*10),DiagD.DispOpt.bExp,DiagD.DispOpt.nDecimalPoints,FontCol);
			}
			else
			{
				if (gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(OutVal.Pos[1]);
				else                  text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(OutVal.Pos[1]);
				_stprintf(text_str, fmt_str, OutVal.dMinMaxVal[1]);
				if(text_p.x >= 0 && text_p.y>=0) pDC->TextOut(text_p.x, text_p.y, text_str);
			}
		 }
		else 
		{
			if(bSaveTextOutput) 
			{
				double Pos6[6];
				Pos6[0] = node3D_i.x;Pos6[1] = node3D_i.y;Pos6[2] = node3D_i.z;
				Pos6[3] = node3D_j.x;Pos6[4] = node3D_j.y;Pos6[5] = node3D_j.z;
				if(DiagD.DispOpt.OutputSectLoc[0] == '1') 
				{
					gm->m_pXGR_GPSDrawMgr->m_OutputDgrmNumber.Add_OutputDgrmNumber(&(OutVal.Pos[0].x),Pos6, 6, ReslD.dValue[0][0], DiagD.DispOpt.bSetOrientation,(int)(DiagD.DispOpt.dAngle*10),DiagD.DispOpt.bExp,DiagD.DispOpt.nDecimalPoints,FontCol);
				}
				if (DiagD.DispOpt.OutputSectLoc[2] == '1') 
				{
					gm->m_pXGR_GPSDrawMgr->m_OutputDgrmNumber.Add_OutputDgrmNumber(&(OutVal.Pos[2].x),Pos6, 7, ReslD.dValue[3][1], DiagD.DispOpt.bSetOrientation,(int)(DiagD.DispOpt.dAngle*10),DiagD.DispOpt.bExp,DiagD.DispOpt.nDecimalPoints,FontCol);
				}
				if(DiagD.DispOpt.OutputSectLoc[1] == '1') 
				{
					gm->m_pXGR_GPSDrawMgr->m_OutputDgrmNumber.Add_OutputDgrmNumber(&(OutVal.Pos[1].x),Pos6, 8, ReslD.dValue[1][1], DiagD.DispOpt.bSetOrientation,(int)(DiagD.DispOpt.dAngle*10),DiagD.DispOpt.bExp,DiagD.DispOpt.nDecimalPoints,FontCol);
				}
			}
			else
			{
				
				if (DiagD.DispOpt.OutputSectLoc[0] == '1')
				{
					//pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorI);
					if (is_inverse)pDC->SetTextAlign(TA_RIGHT | TA_BOTTOM);
					else		   pDC->SetTextAlign(TA_LEFT | TA_BOTTOM);
					if (gm->m_bVirtualMode) text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(OutVal.Pos[0]);
					else                    text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(OutVal.Pos[0]);
					_stprintf(text_str, fmt_str, ReslD.dValue[0][0]);
					if (text_p.x >= 0 && text_p.y >= 0)pDC->TextOut(text_p.x, text_p.y, text_str);
				}
				if (DiagD.DispOpt.OutputSectLoc[2] == '1')
				{
					//pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorJ);
					if (is_inverse)pDC->SetTextAlign(TA_LEFT | TA_BOTTOM);
					else		   pDC->SetTextAlign(TA_RIGHT | TA_BOTTOM);
					if (gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(OutVal.Pos[2]);
					else                   text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(OutVal.Pos[2]);
					_stprintf(text_str, fmt_str, ReslD.dValue[3][1]);
					if (text_p.x >= 0 && text_p.y >= 0) pDC->TextOut(text_p.x, text_p.y, text_str);
				}
				if (DiagD.DispOpt.OutputSectLoc[1] == '1')
				{
					//pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
					pDC->SetTextAlign(TA_CENTER | TA_BOTTOM);
					if (gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(OutVal.Pos[1]);
					else 				   text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(OutVal.Pos[1]);
					_stprintf(text_str, fmt_str, ReslD.dValue[1][1]);
					if (text_p.x >= 0 && text_p.y >= 0) pDC->TextOut(text_p.x, text_p.y, text_str);
				}
				
			}
		}
	 }

	pDC->SelectObject(old_ft);
	ft.DeleteObject();

	for(j=0;j<polygon_list.GetSize();j++) 
	{
		polygon_list[j]->RemoveAll();
		delete polygon_list[j];
		edge_list[j]->RemoveAll();
		delete edge_list[j];
	}
	polygon_list.RemoveAll();
	edge_list.RemoveAll();

	gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}
#else
void CDiagramEngine::OutputDgrmNumber(CDC* pDC, T_DIAG_D& DiagD, T_DIAG_GRUP_D& DiagGrupD,
	T_DIAG_RESL_D& ReslD, T_DIAG_OUTVAL_D& OutVal, BOOL bDeformed,
	COLORREF FontCol)
{
	DECLARE_GPSMD();
	DECLARE_DPTTX();
	DECLARE_DPTDR();

	int			  j, slope;
	TCHAR			fmt_str[10], text_str[512];
	BOOL			fl_bak, is_inverse;
	C3DPoint	node3D_i, node3D_j, DrawPoint;
	CPoint		text_p, node_2d_i, node_2d_j;
	CFont			ft, * old_ft;
	T_ELEM_D	edata;

	POSITION	pos;
	CArray<GPS_3DPT_LISTP, GPS_3DPT_LISTP>  polygon_list;
	CArray<GPS_BOOL_ARRYP, GPS_BOOL_ARRYP>	edge_list;

	GPostTextOut TextOutModel;
	TextOutModel.SetDC(pDC);
	TextOutModel.StartDgrmVal();
	TextOutModel.SettingDgrm(gm, FontCol);

	if (DiagD.DispOpt.bExp)_stprintf(fmt_str, _T(" %s%de "), _T("%."), DiagD.DispOpt.nDecimalPoints);
	else		              _stprintf(fmt_str, _T(" %s%df "), _T("%."), DiagD.DispOpt.nDecimalPoints);

	if (!gm->m_pGPSCtrl->IsActiveElem(OutVal.ElemK))
		return; // Label Hidden 처리를 위해 추가 되었음.

	m_pDoc->m_pAttrCtrl->GetElem(OutVal.ElemK, edata);
	if (!m_pDoc->m_pAttrCtrl->IsBeam(edata.eltyp) &&
		!m_pDoc->m_pAttrCtrl->IsTruss(edata.eltyp))return;

	fl_bak = pDR->m_bFrameLine;
	gm->m_DOPT.DR.m_bFrameLine = TRUE;
	gm->GetShapeElement(OutVal.ElemK, polygon_list, &edge_list);

	CRect	rct;
	gm->m_pMyView->GetClientRect(&rct);

	pos = polygon_list[0]->GetHeadPosition();
	node3D_i = polygon_list[0]->GetNext(pos);
	node3D_j = polygon_list[0]->GetNext(pos);

	//XGLRenderer
	BOOL bSaveTextOutput = FALSE;
	if (gm->m_pGPSCtrl->IsGLRenderer() && gm->m_pGPSCtrl->IsXGRMode() &&
		!gm->m_pGPSCtrl->IsMakeEMFMode())
	{
		bSaveTextOutput = TRUE;
	}

	if (gm->m_bVirtualMode)
	{
		node_2d_i = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_i);
		node_2d_j = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_j);
	}
	else
	{
		node_2d_i = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_i);
		node_2d_j = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_j);
	}

	//XGLRenderer 
	if (bSaveTextOutput == FALSE) //저장 모드에서는 현재 화면 상태와 관계된 Filtering처리를 하지 않는다. 
	{
		if (node_2d_i.x < 0 || node_2d_i.y < 0) return;
		if (node_2d_j.x < 0 || node_2d_j.y < 0) return;
	}

	slope = (int)(atan2(node_2d_i.y - node_2d_j.y, node_2d_j.x - node_2d_i.x) * 1800.0 / 3.14159);
	slope = (slope + 3600) % 3600;
	if ((900 < slope) && (slope <= 2700))
	{
		slope = (slope + 1800) % 3600;
		is_inverse = TRUE;
	}
	else
	{
		is_inverse = FALSE;
	}

	TextOutModel.Font4Dgrm(gm, slope);

	if (DiagD.DispOpt.bMinMaxOnly)
	{
		double dLimit = (DiagGrupD.dMaxVal - DiagGrupD.dMinVal) * DiagD.DispOpt.dLimitScale / 100.0;
		double dBValue;

		for (int n = 0; n < 3; n++)
		{
			if (DiagD.DispOpt.OutputSectLoc[4] == '1') 
			{
				// Min
				if (n == 0)
				{
					TextOutModel.AlignTextTop(TA_CENTER);;
					DrawPoint = OutVal.Pos[0];
					dBValue = OutVal.dMinMaxVal[0];
				}
				// Max
				else if (n == 1)
				{
					TextOutModel.AlignTextBot(TA_CENTER);
					DrawPoint = OutVal.Pos[1];
					dBValue = OutVal.dMinMaxVal[1];
				}
				else continue;
			}
			// Abs Max
			else if (DiagD.DispOpt.OutputSectLoc[3] == '1')
			{
				if (n == 0)
				{
					DrawPoint = OutVal.Pos[1];
					dBValue = OutVal.dMinMaxVal[1];
				}
				else continue;
			}
			else if (n == 0) // I단 
			{
				if (!(DiagD.DispOpt.OutputSectLoc[0] == '1' ||
					DiagD.DispOpt.OutputSectLoc[3] == '1')) continue;

				if (is_inverse) TextOutModel.AlignTextBot(TA_RIGHT);
				else		   TextOutModel.AlignTextBot(TA_LEFT);
				DrawPoint = OutVal.Pos[0];
				dBValue = ReslD.dValue[0][0];

			}
			else if (n == 1)// CNT or MAX
			{
				if (!(DiagD.DispOpt.OutputSectLoc[1] == '1' ||
					DiagD.DispOpt.OutputSectLoc[3] == '1')) continue;

				TextOutModel.AlignTextBot(TA_CENTER);
				DrawPoint = OutVal.Pos[1];

				// I Val
				if (DiagD.DispOpt.OutputSectLoc[3] == '1')
				{
					dBValue = OutVal.dMinMaxVal[1];
				}
				// Abs Max
				else
				{
					dBValue = ReslD.dValue[1][1];
				}

			}
			else if (n == 2)// J단 
			{
				if (!(DiagD.DispOpt.OutputSectLoc[2] == '1' ||
					DiagD.DispOpt.OutputSectLoc[3] == '1')) continue;

				if (is_inverse)		TextOutModel.AlignTextBot(TA_LEFT);
				else					TextOutModel.AlignTextBot(TA_RIGHT);
				DrawPoint = OutVal.Pos[2];
				dBValue = ReslD.dValue[3][1];
			}

			switch (DiagD.DispOpt.nMinMaxOpt)
			{
			case 0: // Min & Max
				if (bSaveTextOutput)
				{
					double Pos6[6];
					Pos6[0] = node3D_i.x; Pos6[1] = node3D_i.y; Pos6[2] = node3D_i.z;
					Pos6[3] = node3D_j.x; Pos6[4] = node3D_j.y; Pos6[5] = node3D_j.z;
					if ((DiagGrupD.dMaxVal - dBValue) <= dLimit)
						gm->m_pXGR_GPSDrawMgr->m_OutputDgrmNumber.Add_OutputDgrmNumber(&(DrawPoint.x), Pos6, 0, dBValue, DiagD.DispOpt.bSetOrientation, (int)(DiagD.DispOpt.dAngle * 10), DiagD.DispOpt.bExp, DiagD.DispOpt.nDecimalPoints, FontCol);
					else if ((dBValue - DiagGrupD.dMinVal) <= dLimit)
						gm->m_pXGR_GPSDrawMgr->m_OutputDgrmNumber.Add_OutputDgrmNumber(&(DrawPoint.x), Pos6, 1, dBValue, DiagD.DispOpt.bSetOrientation, (int)(DiagD.DispOpt.dAngle * 10), DiagD.DispOpt.bExp, DiagD.DispOpt.nDecimalPoints, FontCol);
				}
				else
				{
					if ((DiagGrupD.dMaxVal - dBValue) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, dBValue);
					else if ((dBValue - DiagGrupD.dMinVal) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, dBValue);
				}
				break;
			case 1: // Abs Max
				if (bSaveTextOutput)
				{
					double Pos6[6];
					Pos6[0] = node3D_i.x; Pos6[1] = node3D_i.y; Pos6[2] = node3D_i.z;
					Pos6[3] = node3D_j.x; Pos6[4] = node3D_j.y; Pos6[5] = node3D_j.z;

					if (fabs(DiagGrupD.dMaxVal) >= fabs(DiagGrupD.dMinVal))
					{
						if (fabs(DiagGrupD.dMaxVal) - fabs(dBValue) <= dLimit)
							gm->m_pXGR_GPSDrawMgr->m_OutputDgrmNumber.Add_OutputDgrmNumber(&(DrawPoint.x), Pos6, 2, dBValue, DiagD.DispOpt.bSetOrientation, (int)(DiagD.DispOpt.dAngle * 10), DiagD.DispOpt.bExp, DiagD.DispOpt.nDecimalPoints, FontCol);
					}
					else
					{
						if (fabs(DiagGrupD.dMinVal) - fabs(dBValue) <= dLimit)
							gm->m_pXGR_GPSDrawMgr->m_OutputDgrmNumber.Add_OutputDgrmNumber(&(DrawPoint.x), Pos6, 2, dBValue, DiagD.DispOpt.bSetOrientation, (int)(DiagD.DispOpt.dAngle * 10), DiagD.DispOpt.bExp, DiagD.DispOpt.nDecimalPoints, FontCol);
					}
				}
				else
				{
					if (fabs(DiagGrupD.dMaxVal) >= fabs(DiagGrupD.dMinVal))
					{
						if (fabs(DiagGrupD.dMaxVal) - fabs(dBValue) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, dBValue);
					}
					else
					{
						if (fabs(DiagGrupD.dMinVal) - fabs(dBValue) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, dBValue);
					}
				}
				break;
			case 2: // Max
				if (bSaveTextOutput)
				{
					double Pos6[6];
					Pos6[0] = node3D_i.x; Pos6[1] = node3D_i.y; Pos6[2] = node3D_i.z;
					Pos6[3] = node3D_j.x; Pos6[4] = node3D_j.y; Pos6[5] = node3D_j.z;
					if ((DiagGrupD.dMaxVal - dBValue) <= dLimit)
						gm->m_pXGR_GPSDrawMgr->m_OutputDgrmNumber.Add_OutputDgrmNumber(&(DrawPoint.x), Pos6, 0, dBValue, DiagD.DispOpt.bSetOrientation, (int)(DiagD.DispOpt.dAngle * 10), DiagD.DispOpt.bExp, DiagD.DispOpt.nDecimalPoints, FontCol);
				}
				else
				{
					if ((DiagGrupD.dMaxVal - dBValue) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, dBValue);
				}
				break;
			case 3: // Min
				if (bSaveTextOutput)
				{
					double Pos6[6];
					Pos6[0] = node3D_i.x; Pos6[1] = node3D_i.y; Pos6[2] = node3D_i.z;
					Pos6[3] = node3D_j.x; Pos6[4] = node3D_j.y; Pos6[5] = node3D_j.z;
					if ((dBValue - DiagGrupD.dMinVal) <= dLimit)
						gm->m_pXGR_GPSDrawMgr->m_OutputDgrmNumber.Add_OutputDgrmNumber(&(DrawPoint.x), Pos6, 1, dBValue, DiagD.DispOpt.bSetOrientation, (int)(DiagD.DispOpt.dAngle * 10), DiagD.DispOpt.bExp, DiagD.DispOpt.nDecimalPoints, FontCol);
				}
				else
				{
					if ((dBValue - DiagGrupD.dMinVal) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, dBValue);
				}
				break;
			}
		}
		//////////////////////////////////////////////////////////////////////////////////////
	}
	else
	{
		// Min/Max
		if (DiagD.DispOpt.OutputSectLoc[4] == '1')
		{
			if (bSaveTextOutput)
			{
				double Pos6[6];
				Pos6[0] = node3D_i.x; Pos6[1] = node3D_i.y; Pos6[2] = node3D_i.z;
				Pos6[3] = node3D_j.x; Pos6[4] = node3D_j.y; Pos6[5] = node3D_j.z;
				gm->m_pXGR_GPSDrawMgr->m_OutputDgrmNumber.Add_OutputDgrmNumber(&(OutVal.Pos[0].x), Pos6, 3, OutVal.dMinMaxVal[0], DiagD.DispOpt.bSetOrientation, (int)(DiagD.DispOpt.dAngle * 10), DiagD.DispOpt.bExp, DiagD.DispOpt.nDecimalPoints, FontCol);
				gm->m_pXGR_GPSDrawMgr->m_OutputDgrmNumber.Add_OutputDgrmNumber(&(OutVal.Pos[1].x), Pos6, 4, OutVal.dMinMaxVal[1], DiagD.DispOpt.bSetOrientation, (int)(DiagD.DispOpt.dAngle * 10), DiagD.DispOpt.bExp, DiagD.DispOpt.nDecimalPoints, FontCol);
			}
			else
			{
				// Min Val
				TextOutModel.AlignTextTop(TA_CENTER);
				if (gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(OutVal.Pos[0]);
				else                  text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(OutVal.Pos[0]);
				_stprintf(text_str, fmt_str, OutVal.dMinMaxVal[0]);
				if (text_p.x >= 0 && text_p.y >= 0)
					TextOutModel.TextOutDgrm(text_p.x, text_p.y, text_str);

				// Max Val
				TextOutModel.AlignTextBot(TA_CENTER);
				if (gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(OutVal.Pos[1]);
				else                  text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(OutVal.Pos[1]);
				_stprintf(text_str, fmt_str, OutVal.dMinMaxVal[1]);
				if (text_p.x >= 0 && text_p.y >= 0)
					TextOutModel.TextOutDgrm(text_p.x, text_p.y, text_str);
			}
		}
		// Abs Max
		else if (DiagD.DispOpt.OutputSectLoc[3] == '1')
		{
			if (bSaveTextOutput)
			{
				double Pos6[6];
				Pos6[0] = node3D_i.x; Pos6[1] = node3D_i.y; Pos6[2] = node3D_i.z;
				Pos6[3] = node3D_j.x; Pos6[4] = node3D_j.y; Pos6[5] = node3D_j.z;
				gm->m_pXGR_GPSDrawMgr->m_OutputDgrmNumber.Add_OutputDgrmNumber(&(OutVal.Pos[1].x), Pos6, 5, OutVal.dMinMaxVal[1], DiagD.DispOpt.bSetOrientation, (int)(DiagD.DispOpt.dAngle * 10), DiagD.DispOpt.bExp, DiagD.DispOpt.nDecimalPoints, FontCol);
			}
			else
			{
				if (gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(OutVal.Pos[1]);
				else                  text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(OutVal.Pos[1]);
				_stprintf(text_str, fmt_str, OutVal.dMinMaxVal[1]);
				if (text_p.x >= 0 && text_p.y >= 0)
					TextOutModel.TextOutDgrm(text_p.x, text_p.y, text_str);
			}
		}
		else
		{
			if (bSaveTextOutput)
			{
				double Pos6[6];
				Pos6[0] = node3D_i.x; Pos6[1] = node3D_i.y; Pos6[2] = node3D_i.z;
				Pos6[3] = node3D_j.x; Pos6[4] = node3D_j.y; Pos6[5] = node3D_j.z;
				if (DiagD.DispOpt.OutputSectLoc[0] == '1')
				{
					gm->m_pXGR_GPSDrawMgr->m_OutputDgrmNumber.Add_OutputDgrmNumber(&(OutVal.Pos[0].x), Pos6, 6, ReslD.dValue[0][0], DiagD.DispOpt.bSetOrientation, (int)(DiagD.DispOpt.dAngle * 10), DiagD.DispOpt.bExp, DiagD.DispOpt.nDecimalPoints, FontCol);
				}
				if (DiagD.DispOpt.OutputSectLoc[2] == '1')
				{
					gm->m_pXGR_GPSDrawMgr->m_OutputDgrmNumber.Add_OutputDgrmNumber(&(OutVal.Pos[2].x), Pos6, 7, ReslD.dValue[3][1], DiagD.DispOpt.bSetOrientation, (int)(DiagD.DispOpt.dAngle * 10), DiagD.DispOpt.bExp, DiagD.DispOpt.nDecimalPoints, FontCol);
				}
				if (DiagD.DispOpt.OutputSectLoc[1] == '1')
				{
					gm->m_pXGR_GPSDrawMgr->m_OutputDgrmNumber.Add_OutputDgrmNumber(&(OutVal.Pos[1].x), Pos6, 8, ReslD.dValue[1][1], DiagD.DispOpt.bSetOrientation, (int)(DiagD.DispOpt.dAngle * 10), DiagD.DispOpt.bExp, DiagD.DispOpt.nDecimalPoints, FontCol);
				}
			}
			else
			{

				if (DiagD.DispOpt.OutputSectLoc[0] == '1')
				{
					if (is_inverse)
						TextOutModel.AlignTextBot(TA_RIGHT);
					else
						TextOutModel.AlignTextBot(TA_LEFT);
					if (gm->m_bVirtualMode) text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(OutVal.Pos[0]);
					else                    text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(OutVal.Pos[0]);
					_stprintf(text_str, fmt_str, ReslD.dValue[0][0]);
					if (text_p.x >= 0 && text_p.y >= 0)
						TextOutModel.TextOutDgrm(text_p.x, text_p.y, text_str);
				}
				if (DiagD.DispOpt.OutputSectLoc[2] == '1')
				{
					if (is_inverse)
						TextOutModel.AlignTextBot(TA_LEFT);
					else		   
						TextOutModel.AlignTextBot(TA_RIGHT);
					if (gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(OutVal.Pos[2]);
					else                   text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(OutVal.Pos[2]);
					_stprintf(text_str, fmt_str, ReslD.dValue[3][1]);
					if (text_p.x >= 0 && text_p.y >= 0)
						TextOutModel.TextOutDgrm(text_p.x, text_p.y, text_str);
				}
				if (DiagD.DispOpt.OutputSectLoc[1] == '1')
				{
					TextOutModel.AlignTextBot(TA_CENTER);
					if (gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(OutVal.Pos[1]);
					else 				   text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(OutVal.Pos[1]);
					_stprintf(text_str, fmt_str, ReslD.dValue[1][1]);
					if (text_p.x >= 0 && text_p.y >= 0) 
						TextOutModel.TextOutDgrm(text_p.x, text_p.y, text_str);
				}

			}
		}
	}
	TextOutModel.DeleteFont();
	TextOutModel.EndDgrmVal();
	for (j = 0; j < polygon_list.GetSize(); j++)
	{
		polygon_list[j]->RemoveAll();
		delete polygon_list[j];
		edge_list[j]->RemoveAll();
		delete edge_list[j];
	}
	polygon_list.RemoveAll();
	edge_list.RemoveAll();

	gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}
#endif


void CDiagramEngine::GetDgrmOutputData(T_ELEM_K ElemK,T_DIAG_K DiagK,C3DPoint *pTxtPt,
																			double *pMnMxVal,T_DIAG_OUTVAL_D &OutVal)
{
	OutVal.Pos[0] = pTxtPt[0];
	OutVal.Pos[1] = pTxtPt[1];
	OutVal.Pos[2] = pTxtPt[2];
	OutVal.Pos[3] = pTxtPt[3];
	OutVal.ElemK  = ElemK;
	OutVal.DiagK  = DiagK;
	OutVal.dMinMaxVal[0] = pMnMxVal[0];
	OutVal.dMinMaxVal[1] = pMnMxVal[1];
}

void CDiagramEngine::DiagramPolygon(T_DIAG_RESL_D &ReslD, T_DIAG_D &DiagD, double dDirVec[3],
									  C3DPoint &node_i, C3DPoint &node_j,
									  CArray<C3DPoint, C3DPoint &> &vtx_list,
									  CArray<double, double &> &val_list,
									  CArray<BOOL, BOOL> &ef_list,
									  CArray<BOOL, BOOL> &rect_flag,
									  C3DPoint *txt_pnt,T_ELEM_K ElemKey,int nFillType,double *pMnMxVal )
{
	if(pMnMxVal){ pMnMxVal[0]=0;  pMnMxVal[1]=0;}
	
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel; 
	
	int			i, j, sl_num;
	double	val_i, val_j;
	double  dVal[2];
	double  ulen, udist, uval, ldist, vdist;
	double  sub_ival, sub_jval, sub_mval;
	double  dMaxVal=-DBL_MAX,dMinVal=DBL_MAX;
	double  dAbsMax=0;
	
	C3DPoint	ps, pss, pe, pee;
	C3DPoint  sub_ps, sub_pss, sub_pe, sub_pee, sub_pm;

	CDC	*pdc=gm->m_pMyView->GetDC();
	ulen = fabs(gm->m_pGPSCtrl->GetWorldLength(((double) pdc->GetDeviceCaps(LOGPIXELSX))/6.0));
	gm->m_pMyView->ReleaseDC(pdc);

	// SFD,BMD Inverse 
	//double SFDvector[3],BMDvector[3];
	//int nBMDSign = (gm->m_DOPT.DR.m_bInverseBMD == TRUE)? -1:1;
	//int nSFDSign = (gm->m_DOPT.DR.m_bInverseSFD == TRUE)? -1:1;
	
	pe = node_i;

	double prv_j_val;
	double pst_i_val;
	for(i=0;i<4;i++) 
	{
	  //dVal[0] = val_i = CalcBStrsValue(StrbD, i, I_NODE);
		//dVal[1] = val_j = CalcBStrsValue(StrbD, i, J_NODE);
		dVal[0] = val_i = ReslD.dValue[i][0];
		dVal[1] = val_j = ReslD.dValue[i][1];
		if(i==0)prv_j_val = val_i;
		else    prv_j_val = ReslD.dValue[i-1][1];

		if(i==3)pst_i_val = val_j;
		else    pst_i_val = ReslD.dValue[i+1][0];
		
		//if (gm->m_AnimEngine.m_bAnimateContour) 
		//{
			//val_i = val_i*fabs(gm->m_AnimEngine.GetAnimationFactor(TRUE));
			//val_j = val_j*fabs(gm->m_AnimEngine.GetAnimationFactor(TRUE));
		//}

		ps = pe;
		CUtilFuncs::GetInnerLinePoint((double) (i+1), 4.0-((double) (i+1)), node_i, node_j, pe);

		//for(j=0; j<3; j++) SFDvector[j] = local_vector[1][j]*nSFDSign;
		double dFactor = 1.0;

		if(m_nEDgrmScFcType == 0)
			dFactor = m_dDgrmAdjustFactor*m_dEDgrmAutoScFc*DiagD.DispOpt.dScaleFactor;
		else
			dFactor = m_dDgrmAdjustFactor*DiagD.DispOpt.dScaleFactor*m_dEDgrmRefValueScFc;
		
		CUtilFuncs::GetVectorDirectionPoint(dDirVec, val_i, dFactor, ps, pss);
		CUtilFuncs::GetVectorDirectionPoint(dDirVec, val_j, dFactor, pe, pee);

		/*
		switch(m_BStrsComponent) 
		{
		case BSTRS_COMPONENT_FY:
			for(j=0; j<3; j++)
				SFDvector[j] = local_vector[1][j]*nSFDSign;
			CUtilFuncs::GetVectorDirectionPoint(SFDvector, val_i, m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, ps, pss);
			CUtilFuncs::GetVectorDirectionPoint(SFDvector, val_j, m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, pe, pee);
			break;
		case BSTRS_COMPONENT_FZ:
		case BSTRS_COMPONENT_FX:
			for(j=0; j<3; j++)
				SFDvector[j] = local_vector[2][j]*nSFDSign;
			CUtilFuncs::GetVectorDirectionPoint(SFDvector, val_i, m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, ps, pss);
			CUtilFuncs::GetVectorDirectionPoint(SFDvector, val_j, m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, pe, pee);
			break;
		case BSTRS_COMPONENT_MZ:
		  for(j=0; j<3; j++)
				BMDvector[j] = local_vector[2][j]*nBMDSign;
			CUtilFuncs::GetVectorDirectionPoint(BMDvector, val_i, m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, ps, pss);
			CUtilFuncs::GetVectorDirectionPoint(BMDvector, val_j, m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, pe, pee);
			break;
		case BSTRS_COMPONENT_MY:
			for(j=0; j<3; j++)
				BMDvector[j] = local_vector[1][j]*nBMDSign;
			CUtilFuncs::GetVectorDirectionPoint(BMDvector, val_i, m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, ps, pss);
			CUtilFuncs::GetVectorDirectionPoint(BMDvector, val_j, m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, pe, pee);
			break; 
		case BSTRS_COMPONENT_COMB:
			for(j=0; j<3; j++)
				BMDvector[j] = local_vector[2][j]*nBMDSign;
			CUtilFuncs::GetVectorDirectionPoint(BMDvector, val_i, m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, ps, pss);
			CUtilFuncs::GetVectorDirectionPoint(BMDvector, val_j, m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, pe, pee);
			break;
		default:
			return;
		}
		*/

		
		if(txt_pnt) 
		{
			// Min/Max
			if(DiagD.DispOpt.OutputSectLoc[4] == '1')
			{
				if(dVal[0]>dMaxVal){ txt_pnt[1] = pss; dMaxVal=dVal[0]; }
				if(dVal[1]>dMaxVal){ txt_pnt[1] = pee; dMaxVal=dVal[1]; }
				if(dVal[0]<dMinVal){ txt_pnt[0] = pss; dMinVal=dVal[0]; }
				if(dVal[1]<dMinVal){ txt_pnt[0] = pee; dMinVal=dVal[1]; }
			}
			// Abs Max
			else if(DiagD.DispOpt.OutputSectLoc[3] == '1')
			{
				if(fabs(dVal[0])>fabs(dAbsMax)){ dAbsMax=dVal[0]; }
				if(fabs(dVal[1])>fabs(dAbsMax)){ dAbsMax=dVal[1]; }
				switch(i) 
				{
			  case 0: txt_pnt[0] = pss; break;
			  case 2: txt_pnt[1] = pss; break;
			  case 3: txt_pnt[2] = pee; break;
			  }
			}
			else
			{
			  switch(i) 
				{
			  case 0: txt_pnt[0] = pss; break;
			  case 2: txt_pnt[1] = pss; break;
			  case 3: txt_pnt[2] = pee; break;
			  }
			}
		}
		
		ldist = sqrt( (pe.x-ps.x)*(pe.x-ps.x) +
					        (pe.y-ps.y)*(pe.y-ps.y) +
					        (pe.z-ps.z)*(pe.z-ps.z) );
		sl_num = (int) (ldist/ulen);
		if(((double) sl_num)*ulen == ldist)sl_num--;
		if(sl_num==-1) continue; 
		udist = ldist/((double) (sl_num+1));

		vdist = val_j - val_i;
		uval = vdist*udist/ldist;

		sub_jval = val_i;
		sub_pe = ps;
		sub_pee = pss;
		for(j=0;j<=sl_num;j++) 
		{
			sub_ival  = sub_jval;
			sub_ps    = sub_pe;
			sub_pss   = sub_pee;
			if(j == sl_num) 
			{
				sub_jval = val_j;
				sub_pe = pe;
				sub_pee = pee;
			}
			else 
			{
				sub_jval = val_i + uval*(j+1);
				CUtilFuncs::GetInnerLinePoint(fabs(udist*(j+1)), fabs(fabs(ldist)-fabs(udist*(j+1))), ps, pe, sub_pe);
				CUtilFuncs::GetInnerLinePoint(fabs(udist*(j+1)), fabs(fabs(ldist)-fabs(udist*(j+1))), pss, pee, sub_pee);
			}
			BOOL bIsStart     = (i==0 && j==0)?       TRUE:FALSE;
			BOOL bIsEnd       = (i==3 && j==sl_num)?  TRUE:FALSE;

			/*
			BOOL bAnyFill = m_bVerticalLineFill; // No Fill Option일 경우만 FALSE이다.
			if(m_bBSfdBmdLineOnly == FALSE && m_bVerticalLineFill == TRUE && gm->m_bGradient) bAnyFill = FALSE; // Gradient Fill시 외곽선을 없앤다.
			*/
			BOOL bAnyFill = (nFillType != 0); // No Fill Option일 경우만 FALSE이다.
			if(nFillType == 1 && gm->m_bGradient) bAnyFill = TRUE; 
						

			// x/4지점에서 값이 변하는 경우 Check
			BOOL bIsValModifySubStart=FALSE;
			BOOL bIsValModifySubEnd=FALSE;
			
			if(i!=0 && j==0)
			{
				if(sub_ival*prv_j_val < 0)  bIsValModifySubStart=TRUE;
				else                        bIsValModifySubStart=FALSE;
			}
			if(i!=3 && j==sl_num)
			{
				if(sub_jval*pst_i_val < 0)  bIsValModifySubEnd=TRUE;
				else                        bIsValModifySubEnd=FALSE;
			}
			
			if((sub_ival==0) && (sub_jval==0)) 
			{
				continue;
			}
			else if(sub_ival == 0) 
			{
				ef_list.Add(TRUE);	vtx_list.Add(sub_ps);	val_list.Add(sub_ival);
				ef_list.Add(bAnyFill || bIsEnd);	vtx_list.Add(sub_pee);	val_list.Add(sub_jval);
				ef_list.Add(FALSE);	vtx_list.Add(sub_pe);	val_list.Add(sub_jval);
				rect_flag.Add(FALSE);
			}
			else if(sub_jval == 0) 
			{
				ef_list.Add(bAnyFill || bIsStart);	vtx_list.Add(sub_ps);	val_list.Add(sub_ival);
				ef_list.Add(TRUE);	vtx_list.Add(sub_pss);	val_list.Add(sub_ival);
				ef_list.Add(FALSE);	vtx_list.Add(sub_pe);	val_list.Add(sub_jval);
				rect_flag.Add(FALSE);
			}
			else if((sub_ival*sub_jval) < 0) 
			{
				sub_mval = 0.0;
				CUtilFuncs::GetInnerLinePoint(fabs(sub_ival), fabs(sub_jval), sub_ps, sub_pe, sub_pm);
				ef_list.Add(bAnyFill || bIsStart);	vtx_list.Add(sub_ps);	val_list.Add(sub_ival);
				ef_list.Add(TRUE);	vtx_list.Add(sub_pss);	val_list.Add(sub_ival);
				ef_list.Add(FALSE);	vtx_list.Add(sub_pm);	val_list.Add(sub_mval);
				rect_flag.Add(FALSE);
				ef_list.Add(TRUE);	vtx_list.Add(sub_pm);	val_list.Add(sub_mval);
				ef_list.Add(bAnyFill || bIsEnd);	vtx_list.Add(sub_pee);	val_list.Add(sub_jval);
				ef_list.Add(FALSE);	vtx_list.Add(sub_pe);	val_list.Add(sub_jval);
				rect_flag.Add(FALSE);
			}
			else 
			{
				ef_list.Add(bAnyFill || bIsStart || bIsValModifySubStart);	vtx_list.Add(sub_ps);	val_list.Add(sub_ival);
				ef_list.Add(TRUE);	vtx_list.Add(sub_pss);	val_list.Add(sub_ival);
				ef_list.Add(bAnyFill || bIsEnd || bIsValModifySubEnd);	    vtx_list.Add(sub_pee);	val_list.Add(sub_jval);
				ef_list.Add(FALSE);	vtx_list.Add(sub_pe);	val_list.Add(sub_jval);
				rect_flag.Add(TRUE);
			}
		}
	}

	if(pMnMxVal)
	{
		if(DiagD.DispOpt.OutputSectLoc[4] == '1' ) // Min,Max
		{
			pMnMxVal[0] = dMinVal;
			pMnMxVal[1] = dMaxVal;
		}
		if(DiagD.DispOpt.OutputSectLoc[3] == '1' ) // Abs Max
		{
			pMnMxVal[0] = 0.0;
			pMnMxVal[1] = dAbsMax;
		}
	}
}

int  CDiagramEngine::GetDiagDataByElemK(T_ELEM_K ElemK, CArray<T_DIAG_K,T_DIAG_K> &rarDiagK)
{
	CDBDoc *pDoc = CDBDoc::GetDocPoint(); 

	// 내용교체해야한다 
	rarDiagK.RemoveAll(); 
	T_DIAG_D DiagD;
	CArray<T_DIAG_K,T_DIAG_K> arDiagK;
	//pDoc->m_pAttrCtrl->GetDiagKeyList(arDiagK);
	arDiagK.Copy(m_arSelectedDiagK);
	for(int i=0; i<arDiagK.GetSize(); i++)
	{
		pDoc->m_pAttrCtrl->GetDiag(arDiagK[i],DiagD);
		for(int j=0; j<DiagD.aElemK.GetSize(); j++)
		if(DiagD.aElemK[j] == ElemK)
		{
			rarDiagK.Add(arDiagK[i]); 
		}
	}

	return rarDiagK.GetSize(); 
}

void CDiagramEngine::InitDiagramAdjustFactor(double max_bforc)
{
	C3DPoint	min_p, max_p;
	double		max_l;

	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	gm->GetRangeModel(&min_p,&max_p);
	max_l = max(max(max_p.x-min_p.x, max_p.y-min_p.y), max_p.z-min_p.z);
	m_dMaxModelLength = max_l;
	
	if(max_bforc > -1e-15 && max_bforc < 1e-15)max_bforc = 1.0f;
	// 최대값이 전체모델의 1/20의 크기로 나오도록...
	if(CDiagramEngine::m_bBatchStepMode) 
	{
		// MQC:2163 20080919 mylee - Batch 일때는 밖의 함수에서 한번만 해주고 여기선 SKIP 하도록
		// 이렇게 안하면 Stage 별로 각각 계산하여 기준 Scale 이 다르게 된다.
	}
	else
	{
	m_dDgrmAdjustFactor = max_l / (fabs(max_bforc)*20.0);
	}
}

int CDiagramEngine::GetAnalType(unsigned int aLodeType)
{
	unsigned int LComType=0;

	if(aLodeType==D_LOADCASE_STATIC)				LComType=D_LCOM_STATIC;
	else if(aLodeType==D_LOADCASE_SPECTRUM)			LComType=D_LCOM_SPECTRUM;
	else if(aLodeType==D_LOADCASE_SPECTRUM_ND)		LComType=D_LCOM_SPECTRUM_ND;
	else if(aLodeType==D_LOADCASE_HISTORY)			LComType=D_LCOM_HISTORY;
	else if(aLodeType==D_LOADCASE_MOVING)			LComType=D_LCOM_MOVING;
	else if(aLodeType==D_LOADCASE_SETTLE)			LComType=D_LCOM_SETTLEMENT;
	else if(aLodeType==D_LOADCASE_PUSHOVER)			LComType=D_LCOM_PUSHOVER;			
	else if(aLodeType==D_LOADCASE_ECCENSPEC)		LComType=D_LCOM_ECCENSPEC;
	else if(aLodeType==D_LOADCASE_ECCENSPEC_ND)		LComType=D_LCOM_ECCENSPEC_ND;
	else if(aLodeType==D_LOADCASE_GRIDMODEL)		LComType=D_LCOM_GRIDMODEL;
	else if(aLodeType==D_LOADCASE_COMB_GENERAL)		LComType=D_LCOM_CB_GENERAL;
	else if(aLodeType==D_LOADCASE_COMB_STEEL)		LComType=D_LCOM_CB_STEEL;
	else if(aLodeType==D_LOADCASE_COMB_CONCRETE)	LComType=D_LCOM_CB_CONCRETE;
	else if(aLodeType==D_LOADCASE_COMB_FDN)			LComType=D_LCOM_CB_FOOTING;
	else if(aLodeType==D_LOADCASE_COMB_SRC)			LComType=D_LCOM_CB_SRC;
	else if(aLodeType==D_LOADCASE_COMB_ALUMINUM)	LComType=D_LCOM_CB_ALUMINUM;
	else if(aLodeType==D_LOADCASE_COMB_STLCOMP) 	LComType=D_LCOM_CB_STLCOMP;
	else if(aLodeType==D_LOADCASE_ENVELOPE)			LComType=D_LCOM_ENVELOPE;

	return LComType;
}

