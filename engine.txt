// DesignEngine.cpp: implementation of the CDesignEngine class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "wg_gps.h"
#include "DesignEngine.h"
#include "ForceEngine.h"
#include "DeformEngine.h"
#include "..\wg_base\CompFunc.h"
#include "..\wg_base\ArrayUtil.h"

#include "I_GPSModel.h"
#include "GPSDisplayFilter.h"
#include "GPSMembCtrl.h"  
#include "GPSDsgnLabel.h"
#include "GPSCutLineDetDlg.h"
#include "GPSPostCtrl.h"
#include "MathLib.h"
#include "GPostTextOut.h"

#include "..\wg_db\wg_db_DataCtrl.h"
#include "..\wg_db\wg_db_AttrCtrl.h"
#include "..\wg_db\wg_db_AttrCtrl2.h"
#include "..\wg_db\wg_db_PostCtrl.h"
#include "..\wg_db\wg_db_PoverInfo.h"
#include "..\wg_db\wg_db_StfDgnMethod.h"
#include "..\wg_db\wg_db_MembCtrl.h"
#include "..\wg_db\wg_db_DesignResult.h"
#include "..\wg_db\\DB_ST_DN_RESULT_PSC.H"
#include "..\wg_db\\AnalysisResult.h"
#include "..\wg_db\\UnitCtrl.h"
#include "..\wg_db\SCWBRatio.h"
#include "..\wg_db\QSort.h"
#include "..\wg_db\ViewCtrl.h"
#include "..\wg_db\PCDesign.h"
#include "..\wg_db\DB_ST_DN.h"
#include "..\wg_db\MatlDB.h"
#include "..\wg_db\AluDgnTool.h"
#include "..\wg_db\CFSDgnTool.h"
#include "..\wg_db\ResultFileCtrl.h"
#include "..\wg_db\ISeisEvalInterface.h"
#include "..\wg_db\SeisEvalDataTool.h"
#include "..\wg_db\wg_db_DispOptSizeObj.h"
#include "..\wg_db\wg_db_DispOptMgr.h"

#include "..\wg_db\DBLib.h"
#include "Func_GPS_Draw.h"
#include "..\wg_db\StlDgnTool.h"
#include "..\wg_db\DBCodeDef.h"
#include "..\wg_db\SeisResultsAveragingCalculator.h"
#include "..\wg_db\SeisResultsReCalculator.h"

#include "..\wg_db\JsonPostDataManager.h"

#include "..\..\dgnengine\idesign\DGN_lib\DGNCompare.h"

#ifdef _TOWER
#include "..\wg_db\wg_db_TowerInfo.h"
#endif

#include <float.h>
#include "DRW_DATA.h"
#include "..\wg_dgn\SeisEval.h"

int CDesignEngine::m_nSeisPrfmElementSummation;
int CDesignEngine::m_nSeisPrfmElement[5];

int CDesignEngine::m_nSeisPrfmNodeSummation;
int CDesignEngine::m_nSeisPrfmNode[5];

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

#define DECLARE_GPSMD()  I_GPSModel *gm=(I_GPSModel *)m_pGPSModel
#define DECLARE_DBDOC()  CDBDoc		  *pDoc=((I_GPSModel *)m_pGPSModel)->GetDBDoc()
#define DECLARE_DPTDR()  T_GPS_DISP_OPT_DR *pDR = &(gm->m_DOPT.DR) 
#define DECLARE_DPTRD()  T_GPS_DISP_OPT_RD *pRD = &(gm->m_DOPT.RD)
#define DECLARE_DPTCL()  T_GPS_DISP_OPT_CL *pCL = &(gm->m_DOPT.CL)
#define DECLARE_DPTTX()  T_GPS_DISP_OPT_TX *pTX = &(gm->m_DOPT.TX)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDesignEngine::CDesignEngine(I_GPSModelBase *pGM)
{
	CEngineBase::CEngineBase();
	m_pGPSModel = pGM;
	m_mapSTData.InitHashTable(HASHSIZEELEM);
	m_mapAluData.InitHashTable(HASHSIZEELEM);
	m_mapPfdnData.InitHashTable(HASHSIZEELEM);
	m_mapFireData.InitHashTable(HASHSIZEELEM);
	m_mapST_LSD_Data.InitHashTable(HASHSIZEELEM);
	m_mapCTData.InitHashTable(HASHSIZEELEM);
	m_mapSRCData.InitHashTable(HASHSIZEELEM);
	m_mapDprfData.InitHashTable(HASHSIZEELEM);
	m_mapBdgnSlMsKey.InitHashTable(HASHSIZEELEM);
	m_mapRebr.InitHashTable(HASHSIZEELEM);
	//	m_mapCBData.InitHashTable(HASHSIZENODE);
	m_mapMnyRatioCW.InitHashTable(HASHSIZENODE);
	m_mapMnzRatioCW.InitHashTable(HASHSIZENODE);
	m_mapMnyRatioCCW.InitHashTable(HASHSIZENODE);
	m_mapMnzRatioCCW.InitHashTable(HASHSIZENODE);
	m_mapTendonData.InitHashTable(HASHSIZEELEM);
	m_mapbBrdgData.InitHashTable(HASHSIZEELEM);
	m_mapSDRData.InitHashTable(HASHSIZEELEM);
	m_mapCrackData.InitHashTable(HASHSIZENODE);
	m_mapCrackElem.InitHashTable(HASHSIZEELEM);
	m_mapStripResData.InitHashTable(HASHSIZEMSTR);
	m_mapSbdoResData.InitHashTable(HASHSIZESBDO);
	m_mapStripUnbalancedMoment.InitHashTable(HASHSIZENODE);
	m_mSeisPerform.InitHashTable(HASHSIZEELEM);
	ResetEngine();

	m_pJsonMgr = NULL;
}

CDesignEngine::~CDesignEngine()
{
	m_pGPSModel = NULL;
	m_EKeyList.RemoveAll();
	m_mapSTData.RemoveAll();
	m_mapAluData.RemoveAll();
	m_mapPfdnData.RemoveAll();
	m_mapFireData.RemoveAll();
	m_mapST_LSD_Data.RemoveAll();
	m_mapCTData.RemoveAll();
	m_mapSRCData.RemoveAll();
	m_mapDprfData.RemoveAll();
	m_mapBdgnSlMsKey.RemoveAll();
	m_mapRebr.RemoveAll();
	//	m_mapCBData.RemoveAll();
	m_mapMnyRatioCW.RemoveAll();
	m_mapMnzRatioCW.RemoveAll();
	m_mapMnyRatioCCW.RemoveAll();
	m_mapMnzRatioCCW.RemoveAll();
	m_mapDgrmData.RemoveAll();
	m_mapTendonData.RemoveAll();
	m_mapbBrdgData.RemoveAll();
	m_mapSDRData.RemoveAll();
	m_mapStripResData.RemoveAll();
	m_mapSbdoResData.RemoveAll();
	m_mapStripUnbalancedMoment.RemoveAll();
	m_mSeisPerform.RemoveAll();

	ResetPnChkCutlData();

	_SAFE_DELETE(m_pJsonMgr);
}

// 다른 엔진으로부터 데이터를 Import
void CDesignEngine::ImportEngine(CEngineBase* egbase)
{
	if (!egbase)return;

	CEngineBase::ImportEngine(egbase);

	CDesignEngine* eg = (CDesignEngine*)egbase;

	if (eg->m_pContourEngine)
	{
		if (!m_pContourEngine)m_pContourEngine = new CContourEngine();
		*m_pContourEngine = *(eg->m_pContourEngine);
	}

	if (!m_pGPSModel && eg->m_pGPSModel)m_pGPSModel = eg->m_pGPSModel;

	m_bDsgnDataSet = eg->m_bDsgnDataSet;
	m_DsgnComponent = eg->m_DsgnComponent;
	m_bBeamOutputMax = eg->m_bBeamOutputMax;
	m_bBeamOutputAll = eg->m_bBeamOutputAll;
	m_bBeamOutputI = eg->m_bBeamOutputI;
	m_bBeamOutputC = eg->m_bBeamOutputC;
	m_bBeamOutputJ = eg->m_bBeamOutputJ;
	m_dMaxValue = eg->m_dMaxValue;
	m_dMinValue = eg->m_dMinValue;
	m_nOut = eg->m_nOut;
	m_bOutLocalY = eg->m_bOutLocalY;
	m_bOutLocalZ = eg->m_bOutLocalZ;
	m_bOutMin = eg->m_bOutMin;
	m_nRatio = eg->m_nRatio;
	m_fLimitVal = eg->m_fLimitVal;
	m_bSrchNode = eg->m_bSrchNode;
	m_dAngleVal = eg->m_dAngleVal;
	m_nDirection = eg->m_nDirection;
	m_nBrdgLoadRateLcIndex = eg->m_nBrdgLoadRateLcIndex;
	m_BrdgLoadRateLCName = eg->m_BrdgLoadRateLCName;
	m_bDC_Max = eg->m_bDC_Max;
	m_bDW_MAX = eg->m_bDW_MAX;
	m_bTemp_Max = eg->m_bTemp_Max;
	m_nBrdgLoadRateComp = eg->m_nBrdgLoadRateComp;
	m_nRatingRstType = eg->m_nRatingRstType;
	m_nSteelRatingRstType = eg->m_nSteelRatingRstType;
	m_nSODResultType = eg->m_nSODResultType;

	m_nCPG_ShearConnForceType = eg->m_nCPG_ShearConnForceType;
	m_nCPG_RUSResultBeforeAfterType = eg->m_nCPG_RUSResultBeforeAfterType;
	m_nCPG_RUSResultBeforeType = eg->m_nCPG_RUSResultBeforeType;
	m_nCPG_RUSResultAfterType = eg->m_nCPG_RUSResultAfterType;
	m_nMaxMin = eg->m_nMaxMin;
	m_SeisRCPerformComponent_1st = eg->m_SeisRCPerformComponent_1st;
	m_SeisStlPerformComponent_1st = eg->m_SeisStlPerformComponent_1st;
	m_SeisMasonryPerformComponent_1st = eg->m_SeisMasonryPerformComponent_1st;
	m_SeisPerformComponent_2nd = eg->m_SeisPerformComponent_2nd;
	m_SeisMasonryPerformComponent_2nd = eg->m_SeisMasonryPerformComponent_2nd;

	m_EKeyList.RemoveAll();
	m_EKeyList.Copy(eg->m_EKeyList);
	m_mapSTData.RemoveAll();
	m_mapAluData.RemoveAll();
	m_mapPfdnData.RemoveAll();
	m_mapFireData.RemoveAll();
	m_mapST_LSD_Data.RemoveAll();
	m_mapCTData.RemoveAll();
	m_mapSRCData.RemoveAll();
	m_mapBdgnSlMsKey.RemoveAll();
	//	m_mapCBData.RemoveAll();
	m_mapMnyRatioCW.RemoveAll();
	m_mapMnzRatioCW.RemoveAll();
	m_mapMnyRatioCCW.RemoveAll();
	m_mapMnzRatioCCW.RemoveAll();
	m_mapTendonData.RemoveAll();
	m_mapbBrdgData.RemoveAll();
	m_mapSDRData.RemoveAll();
	m_mapStripResData.RemoveAll();
	m_mapSbdoResData.RemoveAll();
	m_mapStripUnbalancedMoment.RemoveAll();
	m_mSeisPerform.RemoveAll();

	T_ELEM_K key;
	T_ELEM_K mkey;
	T_RSTL_D rstl_d;
	T_SDRD_D sdrd_d;
	T_RCON_D rcon_d;
	//T_RSRC_D rsrc_d;
	T_RCON_D rsrc_d;
	T_RALU_D ralu_d;
	T_NODE_K NodeK;
	double	cbdataY, cbdataZ;
	T_TENDON_D tendonD;
	T_ISBRDG_D BrdgData;
	T_GPS_SLAB_DESIGN_RESULT   SdrdD;
	T_GPS_STRIP_RESULT StripResD;
	T_GPS_SBDO_RESULT  SbdoResD;
	T_GPS_STRIP_UBM    UBMResD;
	T_RSTL_PFDN_D PfdnD;
	T_RSTL_GB51249_17_D FireD;
	POSITION pos = eg->m_mapSTData.GetStartPosition();
	while (pos)
	{
		eg->m_mapSTData.GetNextAssoc(pos, key, rstl_d);
		m_mapSTData.SetAt(key, rstl_d);
	}

	T_RESULT_FIGURE stlFigData;
	pos = eg->m_mapStlFigData.GetStartPosition();
	while (pos)
	{
		eg->m_mapStlFigData.GetNextAssoc(pos, key, stlFigData);
		m_mapStlFigData.SetAt(key, stlFigData);
	}

	pos = eg->m_mapAluData.GetStartPosition();
	while (pos)
	{
		eg->m_mapAluData.GetNextAssoc(pos, key, ralu_d);
		m_mapAluData.SetAt(key, ralu_d);
	}
	pos = eg->m_mapPfdnData.GetStartPosition();
	while (pos)
	{
		eg->m_mapPfdnData.GetNextAssoc(pos, key, PfdnD);
		m_mapPfdnData.SetAt(key, PfdnD);
	}
	pos = eg->m_mapFireData.GetStartPosition();
	while (pos)
	{
		eg->m_mapFireData.GetNextAssoc(pos, key, FireD);
		m_mapFireData.SetAt(key, FireD);
	}
	pos = eg->m_mapST_LSD_Data.GetStartPosition();
	while (pos)
	{
		eg->m_mapST_LSD_Data.GetNextAssoc(pos, key, sdrd_d);
		m_mapST_LSD_Data.SetAt(key, sdrd_d);
	}

	pos = eg->m_mapCTData.GetStartPosition();
	while (pos)
	{
		eg->m_mapCTData.GetNextAssoc(pos, key, rcon_d);
		m_mapCTData.SetAt(key, rcon_d);
	}
	pos = eg->m_mapSRCData.GetStartPosition();
	while (pos)
	{
		eg->m_mapSRCData.GetNextAssoc(pos, key, rsrc_d);
		m_mapSRCData.SetAt(key, rsrc_d);
	}
	pos = eg->m_mapBdgnSlMsKey.GetStartPosition();
	while (pos)
	{
		eg->m_mapBdgnSlMsKey.GetNextAssoc(pos, key, mkey);
		m_mapBdgnSlMsKey.SetAt(key, mkey);
	}
	pos = eg->m_mapMnyRatioCW.GetStartPosition();
	while (pos)
	{
		eg->m_mapMnyRatioCW.GetNextAssoc(pos, NodeK, cbdataY);
		m_mapMnyRatioCW.SetAt(NodeK, cbdataY);
	}
	pos = eg->m_mapMnzRatioCW.GetStartPosition();
	while (pos)
	{
		eg->m_mapMnzRatioCW.GetNextAssoc(pos, NodeK, cbdataZ);
		m_mapMnzRatioCW.SetAt(NodeK, cbdataZ);
	}
	pos = eg->m_mapMnyRatioCCW.GetStartPosition();
	while (pos)
	{
		eg->m_mapMnyRatioCCW.GetNextAssoc(pos, NodeK, cbdataY);
		m_mapMnyRatioCCW.SetAt(NodeK, cbdataY);
	}
	pos = eg->m_mapMnzRatioCCW.GetStartPosition();
	while (pos)
	{
		eg->m_mapMnzRatioCCW.GetNextAssoc(pos, NodeK, cbdataZ);
		m_mapMnzRatioCCW.SetAt(NodeK, cbdataZ);
	}
	pos = eg->m_mapTendonData.GetStartPosition();
	while (pos)
	{
		eg->m_mapTendonData.GetNextAssoc(pos, key, tendonD);
		m_mapTendonData.SetAt(key, tendonD);
	}
	pos = eg->m_mapbBrdgData.GetStartPosition();
	while (pos)
	{
		eg->m_mapbBrdgData.GetNextAssoc(pos, key, BrdgData);
		m_mapbBrdgData.SetAt(key, BrdgData);
	}

	pos = eg->m_mapSDRData.GetStartPosition();
	while (pos)
	{
		eg->m_mapSDRData.GetNextAssoc(pos, key, SdrdD);
		m_mapSDRData.SetAt(key, SdrdD);
	}

	pos = eg->m_mapStripResData.GetStartPosition();
	while (pos)
	{
		eg->m_mapStripResData.GetNextAssoc(pos, key, StripResD);
		m_mapStripResData.SetAt(key, StripResD);
	}

	pos = eg->m_mapSbdoResData.GetStartPosition();
	while (pos)
	{
		eg->m_mapSbdoResData.GetNextAssoc(pos, key, SbdoResD);
		m_mapSbdoResData.SetAt(key, SbdoResD);
	}

	pos = eg->m_mapStripUnbalancedMoment.GetStartPosition();
	while (pos)
	{
		eg->m_mapStripUnbalancedMoment.GetNextAssoc(pos, key, UBMResD);
		m_mapStripUnbalancedMoment.SetAt(key, UBMResD);
	}

	T_PRFM_RESULT Prfm;

	m_mSeisPerform.RemoveAll();
	pos = eg->m_mSeisPerform.GetStartPosition();
	while (pos)
	{
		int nStatus = 0;
		eg->m_mSeisPerform.GetNextAssoc(pos, key, Prfm);
		m_mSeisPerform.SetAt(key, Prfm);
	}

	UINT     nCheckLineName;
	T_NODE_D pPnt;
	m_OnewayResPosition.RemoveAll();
	pos = eg->m_OnewayResPosition.GetStartPosition();
	while (pos)
	{
		eg->m_OnewayResPosition.GetNextAssoc(pos, nCheckLineName, pPnt);
		m_OnewayResPosition.SetAt(nCheckLineName, pPnt);
	}

	UINT nCLKey;
	T_RSL1_D slab_result;
	m_OnewaySlabResData.RemoveAll();
	pos = eg->m_OnewaySlabResData.GetStartPosition();
	while (pos)
	{
		eg->m_OnewaySlabResData.GetNextAssoc(pos, nCLKey, slab_result);
		m_OnewaySlabResData.SetAt(nCLKey, slab_result);
	}

	T_RSS1_D shear_result;
	m_OnewaySlabShearResData.RemoveAll();
	pos = eg->m_OnewaySlabShearResData.GetStartPosition();
	while (pos)
	{
		eg->m_OnewaySlabShearResData.GetNextAssoc(pos, nCLKey, shear_result);
		m_OnewaySlabShearResData.SetAt(nCLKey, shear_result);
	}

	m_bCRLmtVal = eg->m_bCRLmtVal;
	m_dCRLmtVal = eg->m_dCRLmtVal;

	int i;
	m_nDprfComp = eg->m_nDprfComp; // 0:Total, 1:Axial, 2:Torsinal, 3:Moment-y, 4:Moment-z, 5:Shear-y, 6:Shear-z
	m_nDprfType = eg->m_nDprfType; // 0:Eleme별, 1: Property별 
	for (i = 0; i < 3; i++)
	{
		m_nDprfDispLdc[i] = eg->m_nDprfDispLdc[i]; // [0]:Key, [1]:Type, [2]:Min/Max 
		m_nDprfUnitLdc[i] = eg->m_nDprfUnitLdc[i]; // [0]:Key, [1]:Type, [2]:Min/Max 
	}

	T_GPS_DPRF_D DprfD;
	m_mapDprfData.RemoveAll();
	pos = eg->m_mapDprfData.GetStartPosition();
	while (pos)
	{
		eg->m_mapDprfData.GetNextAssoc(pos, key, DprfD);
		m_mapDprfData.SetAt(key, DprfD);
	}

	m_bDprfDispLdcSet = eg->m_bDprfDispLdcSet;
	m_bDprfUnitLdcSet = eg->m_bDprfUnitLdcSet;

	m_bCtReinforce = eg->m_bCtReinforce;
	m_nCtReinfType = eg->m_nCtReinfType;

	T_GPS_REBR_D RebrD;
	m_mapRebr.RemoveAll();
	pos = eg->m_mapRebr.GetStartPosition();
	while (pos)
	{
		eg->m_mapRebr.GetNextAssoc(pos, key, RebrD);
		m_mapRebr.SetAt(key, RebrD);
	}

	m_bCtShowBeam = eg->m_bCtShowBeam;
	m_bCtShowColm = eg->m_bCtShowColm;
	m_bCtShowBrce = eg->m_bCtShowBrce;
	m_bCtShowWall = eg->m_bCtShowWall;
	m_bCtShowColmM = eg->m_bCtShowColmM;
	m_bCtShowBrceBeam = eg->m_bCtShowBrceBeam;
	m_bCtShowBrceTrss = eg->m_bCtShowBrceTrss;
	m_bCtShowStrut = eg->m_bCtShowStrut;

	m_nDisplayMode = eg->m_nDisplayMode;
	m_bCtShowIO = eg->m_bCtShowIO;
	m_bCtShowLS = eg->m_bCtShowLS;
	m_bCtShowCP = eg->m_bCtShowCP;
	m_bCtShowCL = eg->m_bCtShowCL;

	m_bCtRatioAxStrs = eg->m_bCtRatioAxStrs;
	m_bCtMainRebar = eg->m_bCtMainRebar;
	m_bCtShearReinf = eg->m_bCtShearReinf;

	m_bCtValExp = eg->m_bCtValExp;  m_nCtValDeciPt = eg->m_nCtValDeciPt;
	m_nCtOnlyAxialRatio = eg->m_nCtOnlyAxialRatio;

	m_bStCodeCheck = eg->m_bStCodeCheck;
	m_bStShowBeam = eg->m_bStShowBeam;
	m_bStShowColm = eg->m_bStShowColm;
	m_bStShowBrce = eg->m_bStShowBrce;
	m_bStShowTruss = eg->m_bStShowTruss;

	m_bStShowService = eg->m_bStShowService;
	m_bStShowDeflection = eg->m_bStShowDeflection;
	m_bStShowBeam2 = eg->m_bStShowBeam2;
	m_bStShowColm2 = eg->m_bStShowColm2;

	m_bSRCReinforce = eg->m_bSRCReinforce;
	m_dColmSectScFc = eg->m_dColmSectScFc;

	m_bBeamOutputMaxMin = eg->m_bBeamOutputMaxMin;
	m_dCritLineVal = eg->m_dCritLineVal;
	m_nPSCCode = eg->m_nPSCCode;
	m_nRCCode = eg->m_nRCCode;
	m_nDgnCode = eg->m_nDgnCode;
	m_nPSCComp = eg->m_nPSCComp;
	m_nPSCCompCH = eg->m_nPSCCompCH;
	m_nPSCCompJP = eg->m_nPSCCompJP;
	m_nPSCCirteriaType = eg->m_nPSCCirteriaType; //0:Force, 1:Ratio 2:Stress 3:Ratio
	m_nFillType = eg->m_nFillType; // Line
	m_dPSCDgrmScFc = eg->m_dPSCDgrmScFc;
	m_dRCDgrmScFc = eg->m_dRCDgrmScFc;
	m_dCPGDgrmScFc = eg->m_dCPGDgrmScFc;


	T_CMAP_K2<UINT>   mKey;
	T_PSC_DSGN_RESL_D ReslD;
	m_mapDgrmData.RemoveAll();
	pos = eg->m_mapDgrmData.GetStartPosition(); // general displ, infl. surface
	while (pos)
	{
		eg->m_mapDgrmData.GetNextAssoc(pos, mKey, ReslD);
		m_mapDgrmData.SetAt(mKey, ReslD);
	}

	m_dMaxDgrmVal = eg->m_dMaxDgrmVal;
	m_dMinDgrmVal = eg->m_dMinDgrmVal;
	m_dDgrmAdjustFactor = eg->m_dDgrmAdjustFactor;

	m_nDgrmDirType = eg->m_nDgrmDirType;
	m_nDgrmDirOptn = eg->m_nDgrmDirOptn;

	m_nResistanceLineCol = eg->m_nResistanceLineCol;
	m_nResistanceLineThk = eg->m_nResistanceLineThk;
	m_bPSCSignPos = eg->m_bPSCSignPos;
	m_bPSCSignNeg = eg->m_bPSCSignNeg;

	m_bSTCSignPos = eg->m_bSTCSignPos;
	m_bSTCSignNeg = eg->m_bSTCSignNeg;

	m_nPSCPart = eg->m_nPSCPart;
	m_nPSCCompStr = eg->m_nPSCCompStr;
	m_nPSCPosition = eg->m_nPSCPosition;

	m_nRCCompBeam = eg->m_nRCCompBeam;
	m_nRCCompColumn = eg->m_nRCCompColumn;

	m_dMaxDgrmValBeam = eg->m_dMaxDgrmValBeam;
	m_dMaxDgrmValColm = eg->m_dMaxDgrmValColm;
	m_dMinDgrmValBeam = eg->m_dMinDgrmValBeam;
	m_dMinDgrmValColm = eg->m_dMinDgrmValColm;
	m_nMaxDgrmKeyBeam = eg->m_nMaxDgrmKeyBeam;
	m_nMaxDgrmKeyColm = eg->m_nMaxDgrmKeyColm;
	m_nMinDgrmKeyBeam = eg->m_nMinDgrmKeyBeam;
	m_nMinDgrmKeyColm = eg->m_nMinDgrmKeyColm;

	m_nSteelCode = eg->m_nSteelCode;
	m_nSteelCodeSub = eg->m_nSteelCodeSub;
	m_nSteelComp = eg->m_nSteelComp;
	m_nSteelCompSub = eg->m_nSteelCompSub;
	m_nSteelCompCom = eg->m_nSteelCompCom;

	m_nSteel_Component = eg->m_nSteel_Component;
	m_nSteel_Component_Sub = eg->m_nSteel_Component_Sub;

	m_bSlabDgnResult = eg->m_bSlabDgnResult;
	m_nElemAvg = eg->m_nElemAvg;
	m_nPosi = eg->m_nPosi;
	m_nElemCell = eg->m_nElemCell;
	m_nXDirYDir = eg->m_nXDirYDir;
	m_nRebarRatio = eg->m_nRebarRatio;
	m_nXDType = eg->m_nXDType;
	m_nCutPosi = eg->m_nCutPosi;
	m_dCellLength = eg->m_dCellLength;
	m_nUpdateRebar = eg->m_nUpdateRebar;
	m_nULSnELS = eg->m_nULSnELS;

	m_aRebarAsList.RemoveAll();
	m_aRebarAsList.Copy(eg->m_aRebarAsList);

	m_aRebarStringList.RemoveAll();
	m_aRebarStringList.Copy(eg->m_aRebarStringList);

	m_bPunchShear = eg->m_bPunchShear;
	m_nForceStress = eg->m_nForceStress;
	m_nAvgElemSide = eg->m_nAvgElemSide;
	m_nComponent = eg->m_nComponent;

	m_nPunchFlag = eg->m_nPunchFlag;
	m_aPunchingPoint.Copy(eg->m_aPunchingPoint);
	m_aPunchingRatio.Copy(eg->m_aPunchingRatio);

	ResetPnChkCutlData();
	m_arPnChkCutlLine.Copy(eg->m_arPnChkCutlLine);
	m_arPnChkCutlMnMx.Copy(eg->m_arPnChkCutlMnMx);
	CArray<T_CUTLINE_D, T_CUTLINE_D&>* paCutLineData;
	for (i = 0; i < eg->m_arPnChkCutl.GetSize(); i++)
	{
		paCutLineData = new CArray<T_CUTLINE_D, T_CUTLINE_D&>;
		m_arPnChkCutl.Add(paCutLineData);
		m_arPnChkCutl[i]->Copy(*(eg->m_arPnChkCutl[i]));
	}

	m_nMode = eg->m_nMode;
	m_nStress = eg->m_nStress;
	m_nCrack = eg->m_nCrack;
	m_nDeflection = eg->m_nDeflection;
	m_nAniCrack = eg->m_nAniCrack;
	m_bLongTermDefl = eg->m_bLongTermDefl;
	m_nTimeCreep = eg->m_nTimeCreep;
	m_dTimeCreepCoef = eg->m_dTimeCreepCoef;
	m_bCrackPoint = eg->m_bCrackPoint;

	m_mapCrackData.RemoveAll();
	pos = eg->m_mapCrackData.GetStartPosition();
	double dCrackDisp;
	while (pos)
	{
		eg->m_mapCrackData.GetNextAssoc(pos, NodeK, dCrackDisp);
		m_mapCrackData.SetAt(NodeK, dCrackDisp);
	}

	m_mapCrackElem.RemoveAll();
	pos = eg->m_mapCrackElem.GetStartPosition();
	T_GPS_SLAB_CRACK CrackD;
	while (pos)
	{
		eg->m_mapCrackElem.GetNextAssoc(pos, key, CrackD);
		m_mapCrackElem.SetAt(key, CrackD);
	}

	m_nActiveElemCount = eg->m_nActiveElemCount;
	m_nSumActiveElemNum = eg->m_nSumActiveElemNum;
	m_bStripDgnResult = eg->m_bStripDgnResult;
	m_bStripSlabDgnResult = eg->m_bStripSlabDgnResult;
	m_bSeisPerformDataSet = eg->m_bSeisPerformDataSet;

	m_nHingeTimeIndex = eg->m_nHingeTimeIndex;
	m_nSeisFiberMatl = eg->m_nSeisFiberMatl;
	m_mapFiberAsValue.insert(eg->m_mapFiberAsValue.begin(), eg->m_mapFiberAsValue.end());

	m_nDispText = eg->m_nDispText;
}

void CDesignEngine::InitEngine()
{
	DECLARE_GPSMD();
	DECLARE_DBDOC();

	gm->SelectLoad();

	m_bDsgnDataSet = FALSE;
	m_bSeisPerformDataSet = FALSE;

	switch (gm->m_GPSMode)
	{
	case GPS_COMMAND_DSGNST:
		if (!pDoc->m_pPostCtrl->GetDesignResult()->IsSteelDesignResultEnable())return;
		MakeSteelDesignDataList();
		break;
	case GPS_COMMAND_DSGNPFDN:
		if (!pDoc->m_pPostCtrl->GetDesignResult()->IsSteelPfdnResultEnable())return;
		MakeSteelPFDNDesignDataList();
		break;
	case GPS_COMMAND_DSGNFIRE:
		if (!pDoc->m_pPostCtrl->GetDesignResult()->IsSteelFireDesignResultEnable())return;
		MakeSteelFireDesignDataList();
		break;
	case GPS_COMMAND_DSGNST_LSD:
		if (!pDoc->m_pPostCtrl->GetDesignResult()->IsSteelDesignResultEnable())return;
		MakeSteelLSD_DesignDataList();
		break;
	case GPS_COMMAND_DSGNCFST:
		if (!pDoc->m_pPostCtrl->GetDesignResult()->IsColdFormDesignResultEnable())return;
		MakeColdFormSteelDesignDataList();
		break;
	case GPS_COMMAND_DSGNALU:
		if (!pDoc->m_pPostCtrl->AluDgnMgr()->IsDesignResultEnable())return;
		MakeAluDesignDataList();
		break;

	case GPS_COMMAND_DSGNCT:
		if (!pDoc->m_pPostCtrl->GetDesignResult()->IsConcreteDesignResultEnable())return;
		MakeConcreteDesignDataList();
		break;
	case GPS_COMMAND_DSGNSRC:
		if (!pDoc->m_pPostCtrl->GetDesignResult()->IsSRCDesignResultEnable())return;
		MakeSRCDesignDataList();
		break;
	case GPS_COMMAND_DISPPART_FACT:
		MakeDprfDataList();
		break;
	case GPS_COMMAND_PSC_DSGN_DGRM:
		MakePscDsgnDgrmDataList();
		break;
	case GPS_COMMAND_BCCR:                       //   060315  kyungha
		if (!pDoc->m_pPostCtrl->GetDesignResult()->IsConcreteDesignResultEnable())return;
		MakeCBRatioDataList();
		break;
	case GPS_COMMAND_BRDG_LOAD_DGRM:
		MakeBrdgLoadRateList();
		break;
	case GPS_COMMAND_STEEL_RATING:  // hslee : 여길 따라 따라 들어가면 그릴 Data를 세팅하는 부분이 나옵니다!!
	case GPS_COMMAND_PSC_RATING:  // hslee : 여길 따라 따라 들어가면 그릴 Data를 세팅하는 부분이 나옵니다!!
	case GPS_COMMAND_RC_RATING:
		if (GetSteelRatingDrawType() == 0)
		{
			MakeRatingList();
		}
		else if (GetSteelRatingDrawType() == 1)
		{
			ASSERT(0);
		}
		else
		{
			ASSERT(0);
		}
		break;
	case GPS_COMMAND_STEEL_AASHTO_RATING:  // hslee : 여길 따라 따라 들어가면 그릴 Data를 세팅하는 부분이 나옵니다!!
	{
		if (m_nDgnCode == STL_AASHTO_LRFD19)
		{
			MakeAASHTO19RatingList();
		}
		else
		{
			MakeAASHTORatingList();
		}
	}
	break;
	case GPS_COMMAND_SOD_Design:
		MakeSODList();
		break;
	case GPS_COMMAND_SHEAR_CONN_FORCE:
		MakeCPG_ShearCoonForceList();
		break;
	case GPS_COMMAND_CPG_RUS_DESING_RESULT:
		MakeCPG_RUSResultList();
		break;
	case GPS_COMMAND_RC_DSGN_DGRM:
		MakeRCDsgnDgrmDataList();
		break;
	case GPS_COMMAND_RAIL_PSC_DSGN_DGRM:
		MakeRailPSCDgrmDataList();
		break;
	case GPS_COMMAND_RAIL_RC_DSGN_DGRM:
		MakeRailRCDgrmDataList();
		break;
	case GPS_COMMAND_STEEL_DSGN_DGRM:
		MakeSteelDgrmDataList();
		break;
	case GPS_COMMAND_STEEL_COMP_DSGN_DGRM:
		MakeSteelCompDgrmDataList();
		break;
	case GPS_COMMAND_SLAB_DGN:
	case GPS_COMMAND_SLAB_CHK:
		MakeSlabDesignDataList();
		break;
	case GPS_COMMAND_SHEAR_CHK:
	{
		if (CDBLib::IsCodeForMeshedDesignAIJ_JP())
		{
			MakeSlabShrAdhDataList();
		}
		else
		{
			MakePunchingCheckData();
		}
	}
	break;
	case GPS_COMMAND_WALL_DGN:
	case GPS_COMMAND_WALL_CHK:
		MakeWallDesignDataList();
		break;
	case GPS_COMMAND_SLABSERV_CHK:
		MakeSlabServCheckData();
		break;
	case GPS_COMMAND_STRIP_DGN:
		MakeStripDesignDataList(TRUE);
		break;
	case GPS_COMMAND_STRIP_CHK:
		MakeStripDesignDataList(FALSE);
		break;
	case GPS_COMMAND_SEIS_1ST_RC_PERFORM:
		MakeSeisRCPerform1stData();
		break;
	case GPS_COMMAND_SEIS_2ND_RC_PERFORM:
		MakeSeisPerform2ndData(TRUE, FALSE, FALSE, ecPerfomType::SEIS_PO_LUMPED);
		break;
	case GPS_COMMAND_SEIS_LUMPED_HINGE_PFRM_PO:
		MakeSeisPerform2ndData(TRUE, FALSE, FALSE, ecPerfomType::SEIS_PO_LUMPED);
		break;
	case GPS_COMMAND_SEIS_FIBER_HINGE_PFRM_PO:
		MakeSeisPerform2ndData(TRUE, FALSE, FALSE, ecPerfomType::SEIS_PO_FIBER);
		break;
	case GPS_COMMAND_SEIS_AXIAL_STRAIN_PFRM_PO:
		MakeSeisPerform2ndDataPO_AxialStrain();
		break;
	case GPS_COMMAND_SEIS_LUMPED_HINGE_PFRM_TH:
		MakeSeisPerform2ndDataTH(TRUE, ecPerfomType::SEIS_TH_LUMPED);
		break;
	case GPS_COMMAND_SEIS_FIBER_HINGE_PFRM_TH:
		MakeSeisPerform2ndDataTH(TRUE, ecPerfomType::SEIS_TH_FIBER);
		break;
	case GPS_COMMAND_SEIS_AXIAL_STRAIN_PFRM_TH:
		MakeSeisPerform2ndDataTH_AxialStrain();
		break;
	case GPS_COMMAND_SEIS_1ST_STL_PERFORM:
		MakeSeisStlPerform1stData();
		break;
	case GPS_COMMAND_SEIS_2ND_STL_PERFORM:
		MakeSeisPerform2ndData(FALSE, TRUE, FALSE, ecPerfomType::SEIS_PO_LUMPED);
		break;
	case GPS_COMMAND_SEIS_1ST_MASONRY_PERFORM:
		MakeSeisMasonryPerform1stData();
		break;
	case GPS_COMMAND_SEIS_2ND_MASONRY_PERFORM:
		MakeSeisPerform2ndData(FALSE, FALSE, TRUE, ecPerfomType::SEIS_PO_LUMPED);
		break;
	case GPS_COMMAND_SHELL_DGN:
	case GPS_COMMAND_SHELL_CHK:
		MakeShellDesignDataList();
		break;
	case GPS_COMMAND_SHELL_SHEAR_CHK:
		MakeShellShearChkDataList();
		break;
	}
}

BOOL CDesignEngine::MakeSteelDesignDataList()
{
	if (m_bStCodeCheck)
	{
		return MakeSTDesingCodeChk();
	}

	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;
	CDBDoc		*pDoc = gm->GetDBDoc();
	int			i, elem_num;
	BOOL		bMaxMoving, has_content = FALSE;
	double		max_val = -DBL_MAX, min_val = DBL_MAX, len;
	T_LCOM_K	lcom_key;
	T_ELEM_K	elem_key;
	T_RSTL_D	stdata;
	T_RESULT_FIGURE stlFigData;
	double dZero = 10E-7;

	if (!gm->m_bLoadDataSet)
	{
		return FALSE;
	}

#if defined(_TOWER)
	m_DsgnComponent = 0; // Axial 로 고정.
	T_RTOW_D twdata;
#endif

	gm->m_pMyView->BeginWaitCursor();

	if (gm->m_LoadCombi.LoadCombName.IsEmpty()) lcom_key = 0; // All Combination
	else lcom_key = pDoc->m_pAttrCtrl->GetLcomKey(D_LCOMTYPE_STEEL, gm->m_LoadCombi.LoadCombName);

	switch (gm->m_LoadMinMaxType)
	{
	case LOADTYPE_NORMAL:
	case LOADTYPE_MAX:
	case LOADTYPE_ALL:
		bMaxMoving = TRUE;
		break;
	case LOADTYPE_MIN:
		bMaxMoving = FALSE;
		break;
	}

	m_EKeyList.RemoveAll();
	m_mapSTData.RemoveAll();
	m_mapStlFigData.RemoveAll();
	m_mapAluData.RemoveAll();
	m_mapPfdnData.RemoveAll();
	m_mapFireData.RemoveAll();
	m_mapST_LSD_Data.RemoveAll();
	m_mapCTData.RemoveAll();
	m_mapSRCData.RemoveAll();
	m_mapBdgnSlMsKey.RemoveAll();

	UINT nMasterElem;
	CMembCtrl *pMembCtrl = CMembCtrl::GetMembCtrl();
	if (!pMembCtrl) { ASSERT(FALSE);  return FALSE; }
	CString strDgnCode = CDBLib::GetStlCodeName();

	elem_num = gm->m_EKeyListActive.GetSize();
	for (i = 0; i < elem_num; i++)
	{
		elem_key = gm->m_EKeyListActive[i];
		pMembCtrl->GetShowElemByIncludeElem(elem_key, nMasterElem);

#if defined(_TOWER)
		if (!pDoc->m_pPostCtrl->ReadTowerDesignResult(elem_key, lcom_key, twdata) || !twdata.bCheck)
			continue;
		stdata.bCheck = twdata.bCheck;
		for (int j = 0; j < 6; j++)
			stdata.dblCodeRatio[j] = twdata.dblCodeRatio[j];
#else            
		// Modify by GAY. MNET:2683. ('07.05.10). 
		BOOL bCrane = pDoc->m_pAttrCtrl->IsCraneComb(gm->m_LoadCombi);
#if defined (_CIVIL)
		{
			BOOL bIsMaxMin = pDoc->m_pAttrCtrl->IsMaxMinComb(gm->m_LoadCombi);
			T_RSTL_D	stdataTemp1, stdataTemp2;
			BOOL bCheck01 = TRUE, bCheck02 = TRUE;  // bCheck02 왜 필요? MQC 9802 로 인해 FALSE로 수정
			if (bIsMaxMin == TRUE)
			{
				if (!pDoc->m_pPostCtrl->GetDesignResult()->GetSteelDesignResult(nMasterElem, lcom_key, bMaxMoving, bCrane, m_DsgnComponent, stdataTemp1) || !stdataTemp1.bCheck)  bCheck01 = FALSE;
				if (!pDoc->m_pPostCtrl->GetDesignResult()->GetSteelDesignResult(nMasterElem, lcom_key, !bMaxMoving, bCrane, m_DsgnComponent, stdataTemp2) || !stdataTemp2.bCheck)  bCheck02 = FALSE;
			}
			else
			{
				if (!pDoc->m_pPostCtrl->GetDesignResult()->GetSteelDesignResult(nMasterElem, lcom_key, bMaxMoving, bCrane, m_DsgnComponent, stdataTemp1) || !stdataTemp1.bCheck)  bCheck01 = FALSE;
				bCheck02 = FALSE;
			}
			if (!bCheck01 && !bCheck02) continue;
			double dlen01 = (!bCheck01) ? 0.0 : CalcSTDataValue(stdataTemp1);
			double dlen02 = (!bCheck02) ? 0.0 : CalcSTDataValue(stdataTemp2);

			stdata = (dlen01 > dlen02 - dZero) ? stdataTemp1 : stdataTemp2;

		}
#else      

		if (strDgnCode == _T("GB50017-17") || strDgnCode == _T("JGJ209-2010"))
		{
			int CheckType[] = { T_RSTL_MEMB_SECT::RLT_AXIS, T_RSTL_MEMB_SECT::RLT_SHEAR_Y, T_RSTL_MEMB_SECT::RLT_SHEAR_Z, T_RSTL_MEMB_SECT::RLT_BEND_Y, T_RSTL_MEMB_SECT::RLT_BEND_Z,
							   T_RSTL_MEMB_SECT::RLT_COMP, T_RSTL_MEMB_SECT::RLT_SLENDER, T_RSTL_MEMB_SECT::RLT_WTRATIO_FLG, T_RSTL_MEMB_SECT::RLT_SECTGRADE };
			T_KEY nElemKey = 0;
			if (m_DsgnComponent == 9)
				nElemKey = pDoc->m_pPostCtrl->GetDesignResult()->GetStlDgnMgr()->GetMaxRltElemKAsMemb(nMasterElem, CheckType[5], lcom_key, bMaxMoving, 0);
			else
				nElemKey = pDoc->m_pPostCtrl->GetDesignResult()->GetStlDgnMgr()->GetMaxRltElemKAsMemb(nMasterElem, CheckType[m_DsgnComponent], lcom_key, bMaxMoving, 0);
			T_ELEM_D ElemD;	ElemD.Initialize();
			T_SECT_D SectD;	SectD.Initialize();
			if (!m_pDoc->m_pAttrCtrl->GetElem(nElemKey, ElemD))
				continue;
			if (!m_pDoc->m_pAttrCtrl->GetSectDesign(ElemD.elpro, SectD))
				continue;
			if (CheckType[m_DsgnComponent] == T_RSTL_MEMB_SECT::RLT_BEND_Z && SectD.SectBefore.Shape == D_SECT_SHAPE_REG_P)
				continue;
			if (!pDoc->m_pPostCtrl->GetDesignResult()->GetSteelDesignResult(nElemKey, lcom_key, bMaxMoving, bCrane, m_DsgnComponent, stdata) || !stdata.bCheck
				|| !pDoc->m_pPostCtrl->GetDesignResult()->GetStlDgnMgr()->ReadDesignResult(nElemKey, stlFigData, lcom_key) || !stlFigData.bCheck)
				continue;

		}
		else
		{
			if (!pDoc->m_pPostCtrl->GetDesignResult()->GetSteelDesignResult(nMasterElem, lcom_key, bMaxMoving, bCrane, m_DsgnComponent, stdata) || !stdata.bCheck)  continue;
		}
#endif


#endif

		has_content = TRUE;

		m_EKeyList.Add(elem_key);
		//Add By xuezc 2017/9/27
		T_DSTL_D DstlD;
		m_pDoc->m_pAttrCtrl->GetDstl(DstlD);
		if (DstlD.DesignCode == _T("GB50017-03"))
		{
			if (m_DsgnComponent == 1 && stdata.res_dDispLim > stdata.dblCodeRatio[1])//max(YShear,DisEnergyBeamShear)
				stdata.dblCodeRatio[1] = stdata.res_dDispLim;
			if (m_DsgnComponent == 0 && stdata.res_dDefLim > stdata.dblCodeRatio[0])//max(Axial,CenterBrackAxial)
				stdata.dblCodeRatio[0] = stdata.res_dDefLim;
		}
		m_mapSTData.SetAt(elem_key, stdata);
		if (strDgnCode == _T("GB50017-17") || strDgnCode == _T("JGJ209-2010"))
		{
			m_mapStlFigData.SetAt(elem_key, stlFigData);
		}
		CalcSTDataValueNew(elem_key, len);

		if (len > max_val)
		{
			max_val = len;
			gm->m_nLgdMaxValKey = elem_key;
		}
		if (len < min_val)
		{
			min_val = len;
			gm->m_nLgdMinValKey = elem_key;
		}
	}

	if (!has_content)
	{
		min_val = max_val = 0.0;
		gm->m_nLgdMaxValKey = 0;
		gm->m_nLgdMinValKey = 0;
	}

	m_dMaxValue = max_val;
	m_dMinValue = min_val;

	if (m_pContourEngine == NULL)
		m_pContourEngine = new CContourEngine(min_val, max_val);
	else
		m_pContourEngine->MakeRankMap(min_val, max_val);

	gm->m_pMyView->EndWaitCursor();

	m_bDsgnDataSet = TRUE;
	return TRUE;
}

BOOL CDesignEngine::MakeSteelPFDNDesignDataList()
{
	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;
	CDBDoc		*pDoc = gm->GetDBDoc();
	int			i, elem_num;
	BOOL		has_content = FALSE;
	double		max_val = -DBL_MAX, min_val = DBL_MAX, len;
	T_ELEM_K	elem_key;
	T_RSTL_PFDN_D	stdata;

	if (!gm->m_bLoadDataSet)
	{
		return FALSE;
	}

	gm->m_pMyView->BeginWaitCursor();
	m_EKeyList.RemoveAll();
	m_mapSTData.RemoveAll();
	m_mapPfdnData.RemoveAll();
	m_mapFireData.RemoveAll();
	m_mapST_LSD_Data.RemoveAll();
	m_mapCTData.RemoveAll();
	m_mapSRCData.RemoveAll();
	m_mapBdgnSlMsKey.RemoveAll();


	CMembCtrl *pMembCtrl = CMembCtrl::GetMembCtrl();
	if (!pMembCtrl) { ASSERT(FALSE);  return FALSE; }

	CDesignResult *pDgnResult = pDoc->m_pPostCtrl->GetDesignResult();
	if (!pDgnResult) { ASSERT(0); return FALSE; }

	elem_num = gm->m_EKeyListActive.GetSize();
	for (i = 0; i < elem_num; i++)
	{
		elem_key = gm->m_EKeyListActive[i];
		if (!pDgnResult->GetStlDgnMgr()->GetPfdnDgnMgr()->ReadDesignResult(elem_key, stdata))
			continue;
		if (!stdata.m_bCheck)
			continue;

		has_content = TRUE;

		m_EKeyList.Add(elem_key);
		m_mapPfdnData.SetAt(elem_key, stdata);

		len = CalcPfdnDataValue(stdata);

		if (len > max_val)
		{
			max_val = len;
			gm->m_nLgdMaxValKey = elem_key;
		}
		if (len < min_val)
		{
			min_val = len;
			gm->m_nLgdMinValKey = elem_key;
		}

	}

	if (!has_content)
	{
		min_val = max_val = 0.0;
		gm->m_nLgdMaxValKey = 0;
		gm->m_nLgdMinValKey = 0;
	}

	m_dMaxValue = max_val;
	m_dMinValue = min_val;
	if (m_DsgnComponent == 7)
	{
		CArray<CString, CString&> arLgndStr;
		CArray<double, double&>  arLgndVal;
		CString strDucLevel[] = { _LS(IDS_TB_PFDL_1),_LS(IDS_TB_PFDL_2),_LS(IDS_TB_PFDL_3),_LS(IDS_TB_PFDL_4),_LS(IDS_TB_PFDL_5),_T("") };
		double dDucLevelVal[] = { 0.5, 1.5, 2.5, 3.5, 4.5, 5.5 };
		for (i = 0; i < 6; i++)
		{
			arLgndStr.Add(strDucLevel[i]);
			arLgndVal.Add(dDucLevelVal[i]);
		}
		if (m_pContourEngine)m_pContourEngine->MakeRankMap(arLgndStr, arLgndVal);
		else                m_pContourEngine = new CContourEngine(arLgndStr, arLgndVal);
		m_pContourEngine->SetSerialColor(2, RGB(0, 255, 0));
	}
	else
	{
		if (m_pContourEngine == NULL)
			m_pContourEngine = new CContourEngine(min_val, max_val);
		else
			m_pContourEngine->MakeRankMap(min_val, max_val);
	}


	gm->m_pMyView->EndWaitCursor();

	m_bDsgnDataSet = TRUE;
	return TRUE;
}

BOOL CDesignEngine::MakeSteelFireDesignDataList()
{
	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;
	CDBDoc		*pDoc = gm->GetDBDoc();
	int			i, elem_num;
	BOOL		has_content = FALSE;
	double		max_val = -DBL_MAX, min_val = DBL_MAX, len;
	T_ELEM_K	elem_key;
	T_RSTL_GB51249_17_D	stdata;

	if (!gm->m_bLoadDataSet)
	{
		return FALSE;
	}

	gm->m_pMyView->BeginWaitCursor();
	m_EKeyList.RemoveAll();
	m_mapSTData.RemoveAll();
	m_mapPfdnData.RemoveAll();
	m_mapFireData.RemoveAll();
	m_mapST_LSD_Data.RemoveAll();
	m_mapCTData.RemoveAll();
	m_mapSRCData.RemoveAll();
	m_mapBdgnSlMsKey.RemoveAll();

	UINT nMasterElem;
	CMembCtrl *pMembCtrl = CMembCtrl::GetMembCtrl();
	if (!pMembCtrl) { ASSERT(FALSE);  return FALSE; }

	CDesignResult *pDgnResult = pDoc->m_pPostCtrl->GetDesignResult();
	if (!pDgnResult) { ASSERT(0); return FALSE; }

	elem_num = gm->m_EKeyListActive.GetSize();
	for (i = 0; i < elem_num; i++)
	{
		elem_key = gm->m_EKeyListActive[i];
		pMembCtrl->GetShowElemByIncludeElem(elem_key, nMasterElem);

		int CheckType[] = { T_RFIRE_MEMB_SECT::RLT_AXIS, T_RFIRE_MEMB_SECT::RLT_BEND_Y, T_RFIRE_MEMB_SECT::RLT_BEND_Z, T_RFIRE_MEMB_SECT::RLT_COMP,
			T_RFIRE_MEMB_SECT::RLT_LOAD,T_RFIRE_MEMB_SECT::RLT_TD, T_RFIRE_MEMB_SECT::RLT_TM, T_RFIRE_MEMB_SECT::RLT_TEMPER };
		T_KEY nElemKey = pDoc->m_pPostCtrl->GetDesignResult()->GetStlDgnMgr()->GetFireDgnMgr()->GetMaxRltElemKAsMemb(nMasterElem, CheckType[m_DsgnComponent], 0, TRUE, 0);
		if (!pDgnResult->GetStlDgnMgr()->GetFireDgnMgr()->ReadDesignResult(elem_key, stdata))
			continue;
		if (!stdata.m_bCheck)
			continue;

		has_content = TRUE;

		m_EKeyList.Add(elem_key);
		m_mapFireData.SetAt(elem_key, stdata);

		len = CalcFireDataValue(stdata);

		if (len > max_val)
		{
			max_val = len;
			gm->m_nLgdMaxValKey = elem_key;
		}
		if (len < min_val)
		{
			min_val = len;
			gm->m_nLgdMinValKey = elem_key;
		}

	}

	if (!has_content)
	{
		min_val = max_val = 0.0;
		gm->m_nLgdMaxValKey = 0;
		gm->m_nLgdMinValKey = 0;
	}

	m_dMaxValue = max_val;
	m_dMinValue = min_val;

	if (m_pContourEngine == NULL)
		m_pContourEngine = new CContourEngine(min_val, max_val);
	else
		m_pContourEngine->MakeRankMap(min_val, max_val);

	gm->m_pMyView->EndWaitCursor();

	m_bDsgnDataSet = TRUE;
	return TRUE;
}

BOOL CDesignEngine::GetAluRangeDataList(double& dMaxRange, double& dMinRange, CArray<UINT, UINT>& aElemKeyList)
{
	aElemKeyList.RemoveAll();

	DECLARE_GPSMD();

	int			i;
	double		len_max = -DBL_MAX, len_min = DBL_MAX;
	T_ELEM_K	elem_key;
	T_RALU_D	stdata;

	gm->m_pMyView->BeginWaitCursor();

	int elem_num = gm->m_EKeyListActive.GetSize();
	for (i = 0; i < elem_num; i++)
	{
		elem_key = gm->m_EKeyListActive[i];
		if (!m_mapAluData.Lookup(elem_key, stdata)) continue;

		len_max = len_min = CalcAluDataValue(stdata);

		if ((len_min <= dMinRange && len_max >= dMaxRange) ||
			(len_min >= dMinRange && len_min <= dMaxRange) ||
			(len_max >= dMinRange && len_max <= dMaxRange))
			aElemKeyList.Add(elem_key);
	}

	gm->m_pMyView->EndWaitCursor();

	return TRUE;
}

BOOL CDesignEngine::GetPfdnRangeDataList(double& dMaxRange, double& dMinRange, CArray<UINT, UINT>& aElemKeyList)
{
	aElemKeyList.RemoveAll();

	DECLARE_GPSMD();

	int			i;
	double		len_max = -DBL_MAX, len_min = DBL_MAX;
	T_ELEM_K	elem_key;
	//T_RSTL_PFDN_D	stdata;

	gm->m_pMyView->BeginWaitCursor();

	int elem_num = gm->m_EKeyListActive.GetSize();
	for (i = 0; i < elem_num; i++)
	{
		elem_key = gm->m_EKeyListActive[i];
		if ((len_min <= dMinRange && len_max >= dMaxRange) ||
			(len_min >= dMinRange && len_min <= dMaxRange) ||
			(len_max >= dMinRange && len_max <= dMaxRange))
			aElemKeyList.Add(elem_key);
	}

	gm->m_pMyView->EndWaitCursor();

	return TRUE;
}

BOOL CDesignEngine::GetFireRangeDataList(double& dMaxRange, double& dMinRange, CArray<UINT, UINT>& aElemKeyList)
{
	aElemKeyList.RemoveAll();

	DECLARE_GPSMD();

	int			i;
	double		len_max = -DBL_MAX, len_min = DBL_MAX;
	T_ELEM_K	elem_key;
	//T_RSTL_PFDN_D	stdata;

	gm->m_pMyView->BeginWaitCursor();

	int elem_num = gm->m_EKeyListActive.GetSize();
	for (i = 0; i < elem_num; i++)
	{
		elem_key = gm->m_EKeyListActive[i];
		if ((len_min <= dMinRange && len_max >= dMaxRange) ||
			(len_min >= dMinRange && len_min <= dMaxRange) ||
			(len_max >= dMinRange && len_max <= dMaxRange))
			aElemKeyList.Add(elem_key);
	}

	gm->m_pMyView->EndWaitCursor();

	return TRUE;
}

BOOL  CDesignEngine::ResultIsOK_New(T_ELEM_K elem_key, double dVal)
{
	if (m_pDoc->m_pPostCtrl->StlDgnMgr()->IsCHStlCodeDgn() == FALSE)
		return dVal < 1.0;
	if (m_DsgnComponent == 6)
	{
		auto pPair = m_mapStlFigData.PLookup(elem_key);
		if (pPair == nullptr)
			return FALSE;
		return pPair->value.m_dSlender < pPair->value.m_dSlenderMax;
	}
	if (m_DsgnComponent == 7)
	{
		auto pPair = m_mapStlFigData.PLookup(elem_key);
		if (pPair == nullptr)
			return FALSE;
		//CString text_str = pPair->value.strResult_WHRatio;
		double dRto = pPair->value.m_dRltWHRatio;
		return dRto < 1.0;
	}
	return dVal < 1.0;
}


BOOL  CDesignEngine::CalcSTDataValueNew(T_ELEM_K elem_key, double &dVal)
{
	dVal = 0;
	if (m_pDoc->m_pPostCtrl->StlDgnMgr()->IsCHStlCodeDgn() && m_DsgnComponent >= 6)
	{
		auto pPair = m_mapStlFigData.PLookup(elem_key);
		if (pPair == nullptr)
			return FALSE;
		if (m_DsgnComponent == 6)
		{
			dVal = pPair->value.m_dSlender;
			if (!pPair->value.bChk_Slender)
				return FALSE;
		}
		if (m_DsgnComponent == 7)
		{
			//CString strVal = pPair->value.strResult_WHRatio;
			dVal = pPair->value.m_dRltWHRatio;
			if (!pPair->value.bChk_WHRatio)
				return FALSE;
		}
	}
	else
	{
		auto pPair = m_mapSTData.PLookup(elem_key);
		if (pPair == nullptr)
			return FALSE;
		dVal = CalcSTDataValue(pPair->value);
	}
	return TRUE;
}

BOOL CDesignEngine::GetSteelDesignRangeDataList(double& dMaxRange, double& dMinRange, CArray<UINT, UINT>& aElemKeyList)
{
	aElemKeyList.RemoveAll();

	if (m_bStCodeCheck) return FALSE;

	DECLARE_GPSMD();

	int			i;
	double		len_max = -DBL_MAX, len_min = DBL_MAX;
	T_ELEM_K	elem_key;
	gm->m_pMyView->BeginWaitCursor();

	int elem_num = gm->m_EKeyListActive.GetSize();
	for (i = 0; i < elem_num; i++)
	{
		elem_key = gm->m_EKeyListActive[i];

		if (!CalcSTDataValueNew(elem_key, len_max))
			continue;
		len_min = len_max;

		if ((len_min <= dMinRange && len_max >= dMaxRange) ||
			(len_min >= dMinRange && len_min <= dMaxRange) ||
			(len_max >= dMinRange && len_max <= dMaxRange))
			aElemKeyList.Add(elem_key);
	}

	gm->m_pMyView->EndWaitCursor();

	return TRUE;
}

BOOL CDesignEngine::MakeSteelLSD_DesignDataList()
{
	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;
	m_bDsgnDataSet = TRUE;
	CDBDoc *pDoc = CDBDoc::GetDocPoint();
	BOOL bHasData = FALSE;

	gm->m_pMyView->BeginWaitCursor();

	m_EKeyList.RemoveAll();
	m_mapST_LSD_Data.RemoveAll();

	double max_val, min_val;
	m_dMaxDgrmVal = max_val = -DBL_MAX;
	m_dMinDgrmVal = min_val = DBL_MAX;

	INT_PTR nElemNum = gm->m_EKeyListActive.GetSize();

	T_SDRD_D SdrdD;

	for (INT_PTR i = 0; i < nElemNum; i++)
	{
		T_ELEM_K ElemK = gm->m_EKeyListActive[i];

		SdrdD.Initialize();
		if (!MakeSteelLSD_DesignDataUnit(ElemK, SdrdD))continue;

		m_EKeyList.Add(ElemK);
		m_mapST_LSD_Data.SetAt(ElemK, SdrdD);

		bHasData = TRUE;

		double len = CalcSTDataValue(SdrdD);

		if (len > max_val)
		{
			max_val = len;
			gm->m_nLgdMaxValKey = ElemK;
		}
		if (len < min_val)
		{
			min_val = len;
			gm->m_nLgdMinValKey = ElemK;
		}
	}

	if (!bHasData)
	{
		m_dMaxDgrmVal = 0.0;
		m_dMinDgrmVal = 0.0;
		gm->m_nLgdMaxValKey = 0;
		gm->m_nLgdMinValKey = 0;
		if (m_pContourEngine) m_pContourEngine->MakeRankMap(m_dMinDgrmVal, m_dMaxDgrmVal);
	}
	else
	{
		m_dMaxDgrmVal = max_val;
		m_dMinDgrmVal = min_val;
	}

	if (fabs(max_val) < fabs(min_val)) { InitDiagramAdjustFactor(min_val); }
	else { InitDiagramAdjustFactor(max_val); }

	if (m_pContourEngine == nullptr) { m_pContourEngine = new CContourEngine(m_dMinDgrmVal, m_dMaxDgrmVal); }
	else { m_pContourEngine->MakeRankMap(m_dMinDgrmVal, m_dMaxDgrmVal); }

	m_bDsgnDataSet = TRUE;

	gm->m_pMyView->EndWaitCursor();

	return TRUE;
}

BOOL CDesignEngine::MakeSteelLSD_DesignDataUnit(T_ELEM_K ElemK, T_SDRD_D& rData)
{
	CDBDoc *pDoc = CDBDoc::GetDocPoint();

	T_DSTL_D DstlD;
	m_pDoc->m_pAttrCtrl->GetDstl(DstlD);
	if (DstlD.DesignCode.CompareNoCase(_T("KSCE-LSD15")) == 0)
	{
		if (m_nSteelCode == 0)
		{
			if (!pDoc->m_pPostCtrl->GetDesignResult()->ReadSteelConcurrentDataForDgm_KSCE(ElemK, m_nSteelCodeSub, rData)) return FALSE;
		}
		else if (m_nSteelCode == 1)
		{
			if (!pDoc->m_pPostCtrl->GetDesignResult()->ReadSteelMaxMinDataForDgm_KSCE(ElemK, m_nSteelCodeSub, rData))     return FALSE;
		}
		else
		{
			if (!pDoc->m_pPostCtrl->GetDesignResult()->ReadSteelAllLcomMaxDataForDgm_KSCE(ElemK, 0, TRUE, 0, rData))        return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}


BOOL CDesignEngine::MakeAluDesignDataList()
{
	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;
	CDBDoc		*pDoc = gm->GetDBDoc();
	int			i, elem_num;
	BOOL		bMaxMoving, has_content = FALSE;
	double		max_val = -DBL_MAX, min_val = DBL_MAX, len;
	T_LCOM_K	lcom_key;
	T_ELEM_K	elem_key;
	T_RALU_D	stdata;
	T_KEY nElemKey;
	int CheckType[] = { T_RALU_SECT::RLT_AXIS, T_RALU_SECT::RLT_SHEAR_Y, T_RALU_SECT::RLT_SHEAR_Z, T_RALU_SECT::RLT_BEND_Y,
		T_RALU_SECT::RLT_BEND_Z,T_RALU_SECT::RLT_COMP, T_RALU_SECT::RLT_SLENDER_Y, T_RALU_SECT::RLT_SLENDER_Z };

	if (!gm->m_bLoadDataSet)
	{
		return FALSE;
	}

	gm->m_pMyView->BeginWaitCursor();

	if (gm->m_LoadCombi.LoadCombName.IsEmpty()) lcom_key = 0; // All Combination
	else lcom_key = pDoc->m_pAttrCtrl->GetLcomKey(D_LCOMTYPE_ALUMINUM, gm->m_LoadCombi.LoadCombName);

	switch (gm->m_LoadMinMaxType)
	{
	case LOADTYPE_NORMAL:
	case LOADTYPE_MAX:
	case LOADTYPE_ALL:
		bMaxMoving = TRUE;
		break;
	case LOADTYPE_MIN:
		bMaxMoving = FALSE;
		break;
	}

	m_EKeyList.RemoveAll();
	m_mapSTData.RemoveAll();
	m_mapAluData.RemoveAll();
	m_mapST_LSD_Data.RemoveAll();
	m_mapCTData.RemoveAll();
	m_mapSRCData.RemoveAll();
	m_mapBdgnSlMsKey.RemoveAll();


	CMembCtrl *pMembCtrl = CMembCtrl::GetMembCtrl();
	if (!pMembCtrl) { ASSERT(FALSE);  return FALSE; }

	CDesignResult *pDgnResult = pDoc->m_pPostCtrl->GetDesignResult();
	if (!pDgnResult) { ASSERT(0); return FALSE; }

	elem_num = gm->m_EKeyListActive.GetSize();
	for (i = 0; i < elem_num; i++)
	{
		elem_key = gm->m_EKeyListActive[i];
		nElemKey = pDoc->m_pPostCtrl->GetDesignResult()->GetAluDgnMgr()->GetMaxRltElemKAsMemb(elem_key, CheckType[m_DsgnComponent], lcom_key, bMaxMoving, 0);
		int nMembType = GetMbtpType(elem_key); // COLUMN:1  D_MBTP_BEAM:2  D_MBTP_BRACE:3
		if (nMembType == D_MBTP_COLUMN && m_bStShowColm == FALSE) continue;
		if (nMembType == D_MBTP_BEAM && m_bStShowBeam == FALSE) continue;
		if (nMembType == D_MBTP_BRACE && m_bStShowBrce == FALSE) continue;
		if (nMembType == D_MBTP_TRUSS && m_bStShowBrce == FALSE) continue;
		if (nMembType == D_MBTP_WALL) continue;
		if (!pDgnResult->GetAluDgnMgr()->ReadDesignResult(nElemKey, stdata, lcom_key, bMaxMoving ? 0 : 1))
			continue;
		if (!stdata.m_bCheck)
			continue;

		has_content = TRUE;

		m_EKeyList.Add(elem_key);
		m_mapAluData.SetAt(elem_key, stdata);

		len = CalcAluDataValue(stdata);

		if (len > max_val)
		{
			max_val = len;
			gm->m_nLgdMaxValKey = elem_key;
		}
		if (len < min_val)
		{
			min_val = len;
			gm->m_nLgdMinValKey = elem_key;
		}
	}

	if (!has_content)
	{
		min_val = max_val = 0.0;
		gm->m_nLgdMaxValKey = 0;
		gm->m_nLgdMinValKey = 0;
	}

	m_dMaxValue = max_val;
	m_dMinValue = min_val;

	if (m_pContourEngine == NULL)
		m_pContourEngine = new CContourEngine(min_val, max_val);
	else
		m_pContourEngine->MakeRankMap(min_val, max_val);

	gm->m_pMyView->EndWaitCursor();

	m_bDsgnDataSet = TRUE;
	return TRUE;
}

BOOL CDesignEngine::MakeColdFormSteelDesignDataList()
{
	if (m_bStCodeCheck)
	{
		return MakeCFSTDesingCodeChk();
	}

	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;
	CDBDoc		*pDoc = gm->GetDBDoc();
	int			i, elem_num;
	BOOL		bMaxMoving, has_content = FALSE;
	double		max_val = -DBL_MAX, min_val = DBL_MAX, len;
	T_LCOM_K	lcom_key;
	T_ELEM_K	elem_key;
	T_RSTL_D	stdata;

	if (!gm->m_bLoadDataSet)
	{
		return FALSE;
	}

#if defined(_TOWER)
	m_DsgnComponent = 0; // Axial 로 고정.
	T_RTOW_D twdata;
#endif

	gm->m_pMyView->BeginWaitCursor();

	if (gm->m_LoadCombi.LoadCombName.IsEmpty()) lcom_key = 0; // All Combination
	else lcom_key = pDoc->m_pAttrCtrl->GetLcomKey(D_LCOMTYPE_CFSTEEL, gm->m_LoadCombi.LoadCombName);

	switch (gm->m_LoadMinMaxType)
	{
	case LOADTYPE_NORMAL:
	case LOADTYPE_MAX:
	case LOADTYPE_ALL:
		bMaxMoving = TRUE;
		break;
	case LOADTYPE_MIN:
		bMaxMoving = FALSE;
		break;
	}

	m_EKeyList.RemoveAll();
	m_mapSTData.RemoveAll();
	m_mapAluData.RemoveAll();
	m_mapST_LSD_Data.RemoveAll();
	m_mapCTData.RemoveAll();
	m_mapSRCData.RemoveAll();
	m_mapBdgnSlMsKey.RemoveAll();

	UINT nMasterElem;
	T_KEY nElemKey;
	int CheckType[] = { CH_RCFS_SECT::RLT_AXIS, CH_RCFS_SECT::RLT_SHEAR_Y, CH_RCFS_SECT::RLT_SHEAR_Z, CH_RCFS_SECT::RLT_BEND_Y,
		CH_RCFS_SECT::RLT_BEND_Z,CH_RCFS_SECT::RLT_COMP, CH_RCFS_SECT::RLT_SLENDER_Y, CH_RCFS_SECT::RLT_SLENDER_Z };
	CString strDgnCode = CDBLib::GetCfsCodeName();
	CMembCtrl *pMembCtrl = CMembCtrl::GetMembCtrl();
	if (!pMembCtrl) { ASSERT(FALSE);  return FALSE; }

	CDesignResult *pDgnResult = pDoc->m_pPostCtrl->GetDesignResult();
	if (!pDgnResult) { ASSERT(0); return FALSE; }

	elem_num = gm->m_EKeyListActive.GetSize();
	for (i = 0; i < elem_num; i++)
	{
		elem_key = gm->m_EKeyListActive[i];
		pMembCtrl->GetShowElemByIncludeElem(elem_key, nMasterElem);
		if (strDgnCode == _T("GB50018-02"))
		{
			nElemKey = pDoc->m_pPostCtrl->GetDesignResult()->GetCfsDgnMgr()->GetMaxRltElemKAsMemb(elem_key, CheckType[m_DsgnComponent], lcom_key, bMaxMoving, 0);
			if (!pDgnResult->ReadColdFormDesignResult(nElemKey, lcom_key, bMaxMoving, 0, stdata)) continue;
		}
		else
			if (!pDgnResult->ReadColdFormDesignResult(nMasterElem, lcom_key, bMaxMoving, 0, stdata)) continue;
		if (!stdata.bCheck) continue;

		has_content = TRUE;

		m_EKeyList.Add(elem_key);
		m_mapSTData.SetAt(elem_key, stdata);

		len = CalcSTDataValue(stdata);

		if (len > max_val)
		{
			max_val = len;
			gm->m_nLgdMaxValKey = elem_key;
		}
		if (len < min_val)
		{
			min_val = len;
			gm->m_nLgdMinValKey = elem_key;
		}
	}

	if (!has_content)
	{
		min_val = max_val = 0.0;
		gm->m_nLgdMaxValKey = 0;
		gm->m_nLgdMinValKey = 0;
	}

	m_dMaxValue = max_val;
	m_dMinValue = min_val;

	if (m_pContourEngine == NULL)
		m_pContourEngine = new CContourEngine(min_val, max_val);
	else
		m_pContourEngine->MakeRankMap(min_val, max_val);

	gm->m_pMyView->EndWaitCursor();

	m_bDsgnDataSet = TRUE;
	return TRUE;
}

BOOL CDesignEngine::MakeConcreteDesignDataList()
{
	if (m_bCtReinforce)
	{
		return MakeCTDesignRebar();
	}

	DECLARE_GPSMD();
	DECLARE_DBDOC();

	if (!gm->m_bLoadDataSet)return FALSE;

	CWaitCursor Wait;

	T_LCOM_K	lcom_key;
	if (gm->m_LoadCombi.LoadCombName.IsEmpty()) lcom_key = 0; // All Combination
	else lcom_key = pDoc->m_pAttrCtrl->GetLcomKey(D_LCOMTYPE_CONCRETE, gm->m_LoadCombi.LoadCombName);

	BOOL bMaxMoving = FALSE;
	switch (gm->m_LoadMinMaxType)
	{
	case LOADTYPE_NORMAL:
	case LOADTYPE_MAX:
	case LOADTYPE_ALL:
		bMaxMoving = TRUE;
		break;
	case LOADTYPE_MIN:
		bMaxMoving = FALSE;
		break;
	}

	m_EKeyList.RemoveAll();
	m_mapSTData.RemoveAll();
	m_mapAluData.RemoveAll();
	m_mapST_LSD_Data.RemoveAll();
	m_mapCTData.RemoveAll();
	m_mapSRCData.RemoveAll();
	m_mapBdgnSlMsKey.RemoveAll();
	m_mapRebr.RemoveAll();


	CMembCtrl *pMembCtrl = CMembCtrl::GetMembCtrl();
	if (!pMembCtrl) { ASSERT(FALSE);  return FALSE; }

	BOOL has_content = FALSE;
	double max_val = -DBL_MAX;
	double min_val = DBL_MAX;

	const INT_PTR elem_num = gm->m_EKeyListActive.GetSize();
	for (INT_PTR i = 0; i < elem_num; i++)
	{
		T_ELEM_K elem_key = gm->m_EKeyListActive[i];

		T_ELEM_K nMasterElem = 0;
		pMembCtrl->GetShowElemByIncludeElem(elem_key, nMasterElem);

		T_RCON_D ctdata;
		if (!ReadConcreteDesignResult(nMasterElem, lcom_key, bMaxMoving, ctdata) || !ctdata.bCheck)
		{
			continue;
		}

		has_content = TRUE;

		m_EKeyList.Add(elem_key);
		m_mapCTData.SetAt(elem_key, ctdata);

		double len = CalcMaxCTDataValue(ctdata);
		if (len > max_val)
		{
			max_val = len;
			gm->m_nLgdMaxValKey = elem_key;
		}

		len = CalcMinCTDataValue(ctdata);
		if (len < min_val)
		{
			min_val = len;
			gm->m_nLgdMinValKey = elem_key;
		}
	}

	if (!has_content)
	{
		min_val = max_val = 0.0;
		gm->m_nLgdMaxValKey = 0;
		gm->m_nLgdMinValKey = 0;
	}

	m_dMaxValue = max_val;
	m_dMinValue = min_val;

	if (m_pContourEngine == NULL)
	{
		m_pContourEngine = new CContourEngine(min_val, max_val);
	}
	else
	{
		m_pContourEngine->MakeRankMap(min_val, max_val);
	}

	m_bDsgnDataSet = TRUE;
	return TRUE;
}

BOOL CDesignEngine::GetConcreteDesignRangeDataList(double& dMaxRange, double& dMinRange, CArray<UINT, UINT>& aElemKeyList)
{
	aElemKeyList.RemoveAll();

	if (m_bCtReinforce) return FALSE;

	DECLARE_GPSMD();

	int			  i;
	double		len_max = -DBL_MAX, len_min = DBL_MAX;
	T_ELEM_K	elem_key;
	T_RCON_D	ctdata;

	gm->m_pMyView->BeginWaitCursor();

	int elem_num = gm->m_EKeyListActive.GetSize();
	for (i = 0; i < elem_num; i++)
	{
		elem_key = gm->m_EKeyListActive[i];
		if (!m_mapCTData.Lookup(elem_key, ctdata)) continue;

		len_max = CalcMaxCTDataValue(ctdata);
		len_min = CalcMinCTDataValue(ctdata);

		if (len_min > len_max)
		{
			double len_temp = len_max;
			len_max = len_min;
			len_min = len_temp;
		}

		if ((len_min <= dMinRange && len_max >= dMaxRange) ||
			(len_min >= dMinRange && len_min <= dMaxRange) ||
			(len_max >= dMinRange && len_max <= dMaxRange))
			aElemKeyList.Add(elem_key);
	}

	gm->m_pMyView->EndWaitCursor();

	return TRUE;
}

BOOL CDesignEngine::MakeSRCDesignDataList()
{
	if (m_bSRCReinforce)
	{
		return MakeSRCDesignRebar();
	}

	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;
	CDBDoc		*pDoc = gm->GetDBDoc();
	int			i, elem_num;
	BOOL		bMaxMoving, has_content = FALSE;
	double		max_val = -DBL_MAX, min_val = DBL_MAX, len;
	T_LCOM_K	lcom_key;
	T_ELEM_K	elem_key;
	//T_RSRC_D	srcdata;
	T_RCON_D  RconD;

	if (!gm->m_bLoadDataSet)
	{
		return FALSE;
	}

	gm->m_pMyView->BeginWaitCursor();

	if (gm->m_LoadCombi.LoadCombName.IsEmpty()) lcom_key = 0; // All Combination
	else lcom_key = pDoc->m_pAttrCtrl->GetLcomKey(D_LCOMTYPE_SRC, gm->m_LoadCombi.LoadCombName);

	switch (gm->m_LoadMinMaxType)
	{
	case LOADTYPE_NORMAL:
	case LOADTYPE_MAX:
	case LOADTYPE_ALL:
		bMaxMoving = TRUE;
		break;
	case LOADTYPE_MIN:
		bMaxMoving = FALSE;
		break;
	}

	m_EKeyList.RemoveAll();
	m_mapSTData.RemoveAll();
	m_mapAluData.RemoveAll();
	m_mapST_LSD_Data.RemoveAll();
	m_mapCTData.RemoveAll();
	m_mapSRCData.RemoveAll();
	m_mapBdgnSlMsKey.RemoveAll();

	UINT nMasterElem;
	CMembCtrl *pMembCtrl = CMembCtrl::GetMembCtrl();
	if (!pMembCtrl) { ASSERT(FALSE);  return FALSE; }

	// Modify by GAY. MNET:2683. ('07.05.10). 
	BOOL bCrane = pDoc->m_pAttrCtrl->IsCraneComb(gm->m_LoadCombi);

	elem_num = gm->m_EKeyListActive.GetSize();
	for (i = 0; i < elem_num; i++)
	{
		elem_key = gm->m_EKeyListActive[i];

		pMembCtrl->GetShowElemByIncludeElem(elem_key, nMasterElem);
		if (!pDoc->m_pPostCtrl->GetDesignResult()->GetSRCDesignResult(nMasterElem, lcom_key, bMaxMoving, bCrane, m_DsgnComponent, RconD) ||
			!RconD.bCheck)
			continue;

		has_content = TRUE;

		m_EKeyList.Add(elem_key);
		//m_mapSRCData.SetAt(elem_key,srcdata);
		m_mapSRCData.SetAt(elem_key, RconD);

		//len = CalcSRCDataValue(srcdata);
		//len = CalcCTDataValue(RconD,0); //수정
		len = CalcMaxCTDataValue(RconD);

		if (len > max_val)
		{
			max_val = len;
			gm->m_nLgdMaxValKey = elem_key;
		}

		len = CalcMinCTDataValue(RconD);
		if (len < min_val)
		{
			min_val = len;
			gm->m_nLgdMinValKey = elem_key;
		}
	}

	if (!has_content)
	{
		min_val = max_val = 0.0;
		gm->m_nLgdMaxValKey = 0;
		gm->m_nLgdMinValKey = 0;
	}
	m_dMaxValue = max_val;
	m_dMinValue = min_val;

	if (m_pContourEngine == NULL)
		m_pContourEngine = new CContourEngine(min_val, max_val);
	else
		m_pContourEngine->MakeRankMap(min_val, max_val);

	gm->m_pMyView->EndWaitCursor();

	m_bDsgnDataSet = TRUE;
	return TRUE;
}

BOOL CDesignEngine::GetSRCDesignRangeDataList(double& dMaxRange, double& dMinRange, CArray<UINT, UINT>& aElemKeyList)
{
	aElemKeyList.RemoveAll();

	if (m_bSRCReinforce) return FALSE;

	DECLARE_GPSMD();

	int			i;
	double		len_max = -DBL_MAX, len_min = DBL_MAX;
	T_ELEM_K	elem_key;
	T_RCON_D  RconD;

	gm->m_pMyView->BeginWaitCursor();

	int elem_num = gm->m_EKeyListActive.GetSize();
	for (i = 0; i < elem_num; i++)
	{
		elem_key = gm->m_EKeyListActive[i];
		if (!m_mapSRCData.Lookup(elem_key, RconD)) continue;

		len_max = CalcMaxCTDataValue(RconD);
		len_min = CalcMinCTDataValue(RconD);

		if (len_min > len_max)
		{
			double len_temp = len_max;
			len_max = len_min;
			len_min = len_temp;
		}

		if ((len_min <= dMinRange && len_max >= dMaxRange) ||
			(len_min >= dMinRange && len_min <= dMaxRange) ||
			(len_max >= dMinRange && len_max <= dMaxRange))
			aElemKeyList.Add(elem_key);
	}

	gm->m_pMyView->EndWaitCursor();

	return TRUE;
}

//----------------------------------------------------------------------------------------
// INIT : 2006.04.17. by kyungha
// FUNC : RC C/B Flexural Capacity Ratio 
//----------------------------------------------------------------------------------------
BOOL CDesignEngine::MakeCBRatioDataList()
{
	SCWBRatio SCWBRatio;
	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;
	CDBDoc		*pDoc = gm->GetDBDoc();
	int			i, SelectYorZ;
	BOOL		bMaxMoving, has_content = FALSE;
	double		max_val = -DBL_MAX, min_val = DBL_MAX;
	BOOL bAngle = TRUE;
	double len = 0;
	double	cbdataY, cbdataZ, cbdataY2, cbdataZ2;
	CArray<UINT, UINT> arLimitNode;
	arLimitNode.RemoveAll();

	if (m_nOut == 1) bAngle = FALSE;

	CArray<T_NODE_K, T_NODE_K> arNodeKList; arNodeKList.RemoveAll();
	pDoc->m_pAttrCtrl->GetNodeKeyList(arNodeKList);
	int NodeNum = arNodeKList.GetSize();

	if (!gm->m_bLoadDataSet) { return FALSE; }

	gm->m_pMyView->BeginWaitCursor();

	switch (gm->m_LoadMinMaxType)
	{
	case LOADTYPE_NORMAL:
	case LOADTYPE_MAX:
	case LOADTYPE_ALL:
		bMaxMoving = TRUE;
		break;
	case LOADTYPE_MIN:
		bMaxMoving = FALSE;
		break;
	}

	m_EKeyList.RemoveAll();
	m_mapSTData.RemoveAll();
	m_mapAluData.RemoveAll();
	m_mapST_LSD_Data.RemoveAll();
	m_mapCTData.RemoveAll();
	m_mapSRCData.RemoveAll();
	m_mapBdgnSlMsKey.RemoveAll();
	m_mapMnyRatioCW.RemoveAll();
	m_mapMnzRatioCW.RemoveAll();
	m_mapMnyRatioCCW.RemoveAll();
	m_mapMnzRatioCCW.RemoveAll();

	SCWBRatio.Get_SCWBRatio(bAngle, m_dAngleVal, m_mapMnyRatioCW, m_mapMnyRatioCCW, m_mapMnzRatioCW, m_mapMnzRatioCCW);

	CMap<UINT, UINT, UINT, UINT> mapLimitNode;
	mapLimitNode.InitHashTable(1001);

	for (i = 0; i < NodeNum; i++)
	{
		cbdataY = 0, cbdataZ = 0, cbdataY2 = 0, cbdataZ2 = 0;
		if (m_nDirection == 1)       // Clockwise
		{
			if (!m_mapMnyRatioCW.Lookup(arNodeKList[i], cbdataY)) continue;
			m_mapMnzRatioCW.Lookup(arNodeKList[i], cbdataZ);
		}
		else if (m_nDirection == 2)  // Counter-Clockwise
		{
			if (!m_mapMnyRatioCCW.Lookup(arNodeKList[i], cbdataY)) continue;
			m_mapMnzRatioCCW.Lookup(arNodeKList[i], cbdataZ);
		}
		else if (m_nDirection == 0)  // Minimum Ratio of CW & CCW
		{
			if (!m_mapMnyRatioCW.Lookup(arNodeKList[i], cbdataY)) continue;
			m_mapMnzRatioCW.Lookup(arNodeKList[i], cbdataZ);
			m_mapMnyRatioCCW.Lookup(arNodeKList[i], cbdataY2);
			m_mapMnzRatioCCW.Lookup(arNodeKList[i], cbdataZ2);
			cbdataY = min(cbdataY, cbdataY2);
			cbdataZ = min(cbdataZ, cbdataZ2);
		}

		for (SelectYorZ = 0; SelectYorZ < 2; SelectYorZ++)
		{
			switch (SelectYorZ)
			{
			case 0:			// case Y
			{
				//if (m_mapMnyRatioCW.Lookup(arNodeKList[i],cbdataY))
				{
					if ((!m_bOutLocalY) && (m_nOut == 1)) continue;
					//if (m_mapMnzRatioCW.Lookup(arNodeKList[i],cbdataZ))
					//{
					if (m_nOut && m_bOutMin && (cbdataY > cbdataZ))	continue;
					//}
					if ((m_nRatio == 1) && (cbdataY >= m_fLimitVal)) continue;  // Acceptance Limit 미만인 경우만 출력
					has_content = TRUE;
					if (cbdataY > max_val)
					{
						max_val = cbdataY;	gm->m_nLgdMaxValKey = arNodeKList[i];
					}
					if (cbdataY < min_val)
					{
						min_val = cbdataY;	gm->m_nLgdMinValKey = arNodeKList[i];
					}

					mapLimitNode.SetAt(arNodeKList[i], arNodeKList[i]);
				}
			}
			break;
			case 1:			// case Z
			{
				//if (m_mapMnzRatioCW.Lookup(arNodeKList[i],cbdataZ))
				{
					if ((!m_bOutLocalZ) && (m_nOut == 1)) continue;
					//if (m_mapMnyRatioCW.Lookup(arNodeKList[i],cbdataY))
					//{
					if (m_nOut && m_bOutMin && (cbdataY < cbdataZ))	continue;
					//}
					if ((m_nRatio == 1) && (cbdataZ >= m_fLimitVal)) continue;  // Acceptance Limit 미만인 경우만 출력
					has_content = TRUE;
					if (cbdataZ > max_val)
					{
						max_val = cbdataZ;	gm->m_nLgdMaxValKey = arNodeKList[i];
					}
					if (cbdataZ < min_val)
					{
						min_val = cbdataZ;	gm->m_nLgdMinValKey = arNodeKList[i];
					}

					mapLimitNode.SetAt(arNodeKList[i], arNodeKList[i]);
				}
			}
			break;
			}
		}
	}

	if (m_nRatio == 1 && m_bSrchNode && mapLimitNode.GetCount())
	{
		T_NODE_K NodeK1, NodeK2;
		POSITION pos = mapLimitNode.GetStartPosition();
		while (pos)
		{
			mapLimitNode.GetNextAssoc(pos, NodeK1, NodeK2);
			arLimitNode.Add(NodeK1);
		}
		CQSort::QSortUInt(arLimitNode.GetData(), arLimitNode.GetSize());
		pDoc->m_pViewCtrl->SelectNode(NULL, arLimitNode, TRUE, TRUE);
	}
	else
	{
		CQSort::QSortUInt(arLimitNode.GetData(), arLimitNode.GetSize());
		pDoc->m_pViewCtrl->SelectNode(NULL, arLimitNode, TRUE, TRUE);
	}

	if (!has_content)
	{
		min_val = max_val = 0.0;
		gm->m_nLgdMaxValKey = 0;
		gm->m_nLgdMinValKey = 0;
	}
	m_dMaxValue = max_val;
	m_dMinValue = min_val;

	if (m_pContourEngine == NULL)m_pContourEngine = new CContourEngine(min_val, max_val);
	else		                    m_pContourEngine->MakeRankMap(min_val, max_val);

	gm->m_pMyView->EndWaitCursor();
	m_bDsgnDataSet = TRUE;
	return TRUE;
}
//----------------------------------------------------------------------------------------

double CDesignEngine::CalcPfdnDataValue(T_RSTL_PFDN_D &stdata)
{
	return stdata.GetFigureValue(m_DsgnComponent);
}

double   CDesignEngine::CalcFireDataValue(T_RSTL_GB51249_17_D &stdata)
{
	return stdata.m_Sect.GetFigureValue(m_DsgnComponent);
}

double CDesignEngine::CalcSTDataValue(T_RSTL_D &stdata)
{
	return stdata.dblCodeRatio[m_DsgnComponent];
}

double CDesignEngine::CalcAluDataValue(T_RALU_D &stdata)
{
	T_RALU_ITEM itemD;
	stdata.GetMaxRltByItem((T_RALU_SECT::RTLTYPE)m_DsgnComponent, itemD);
	if (itemD.IsValid())
		return itemD.GetRatio();
	return 0;
}

double	CDesignEngine::CalcSTDataValue(T_SDRD_D& rD)
{
	double dRatIJ[2] = { 0.0,0.0 };
	double dRatio = 0.0;
	double dZero = 10E-7;
	switch (m_DsgnComponent)
	{
	case DESIGN_COMPONENT_RSX:
	{
		for (int i = 0; i < 2; ++i)
		{
			if (!rD.SdrdBase[i].bCheck) continue;
			dRatIJ[i] = rD.SdrdBase[i].dPn < dZero ? 0.0 : fabs(rD.SdrdBase[i].dPu / rD.SdrdBase[i].dPn);
		}
		dRatio = max(dRatIJ[0], dRatIJ[1]);
		break;
	}
	case DESIGN_COMPONENT_RSY:
	{
		for (int i = 0; i < 2; ++i)
		{
			if (!rD.SdrdBase[i].bCheck) continue;
			dRatIJ[i] = rD.SdrdBase[i].dVny < dZero ? 0.0 : fabs(rD.SdrdBase[i].dVuy / rD.SdrdBase[i].dVny);
		}
		dRatio = max(dRatIJ[0], dRatIJ[1]);
		break;
	}
	case DESIGN_COMPONENT_RSZ:
	{
		for (int i = 0; i < 2; ++i)
		{
			if (!rD.SdrdBase[i].bCheck) continue;
			dRatIJ[i] = rD.SdrdBase[i].dVnz < dZero ? 0.0 : fabs(rD.SdrdBase[i].dVuz / rD.SdrdBase[i].dVnz);
		}
		dRatio = max(dRatIJ[0], dRatIJ[1]);
		break;
	}
	case DESIGN_COMPONENT_RBY:
	{
		for (int i = 0; i < 2; ++i)
		{
			if (!rD.SdrdBase[i].bCheck) continue;
			dRatIJ[i] = rD.SdrdBase[i].dMny < dZero ? 0.0 : fabs(rD.SdrdBase[i].dMuy / rD.SdrdBase[i].dMny);
		}
		dRatio = max(dRatIJ[0], dRatIJ[1]);
		break;
	}
	case DESIGN_COMPONENT_RBZ:
	{
		for (int i = 0; i < 2; ++i)
		{
			if (!rD.SdrdBase[i].bCheck) continue;
			dRatIJ[i] = rD.SdrdBase[i].dMnz < dZero ? 0.0 : fabs(rD.SdrdBase[i].dMuz / rD.SdrdBase[i].dMnz);
		}
		dRatio = max(dRatIJ[0], dRatIJ[1]);
		break;
	}
	case DESIGN_COMPONENT_RCOMB:
	{
		for (int i = 0; i < 2; ++i)
		{
			if (!rD.SdrdBase[i].bCheck) continue;
			dRatIJ[i] = rD.SdrdBase[i].dCombinedRat;
		}
		dRatio = max(dRatIJ[0], dRatIJ[1]);
		break;
	}
	default: {ASSERT(0); return dRatio; }
	}

	return dRatio;
}

double CDesignEngine::CalcCTDataValue(T_RCON_D &ctdata, int pos)
{
	return ctdata.dblCodeRatio[pos][m_DsgnComponent];
}

double CDesignEngine::CalcSRCDataValue(T_RSRC_D &srcdata)
{
	return srcdata.dblCodeRatio[m_DsgnComponent];
}

double CDesignEngine::CalcMaxCTDataValue(T_RCON_D &ctdata)
{
	int		i;
	double	val[3];

	for (i = 0; i < 3; i++)
		val[i] = CalcCTDataValue(ctdata, i);

	return max(val[0], max(val[1], val[2]));
}

double CDesignEngine::CalcMinCTDataValue(T_RCON_D &ctdata)
{
	int		i;
	double	val[3];

	for (i = 0; i < 3; i++)
		val[i] = CalcCTDataValue(ctdata, i);

	return min(val[0], min(val[1], val[2]));
}


void CDesignEngine::DrawSTDesignContour(CDC *pDC)
{
	if (m_bStCodeCheck)
	{
		DrawSTDesignCodeChk(pDC);
		return;
	}
	DrawSTDesignContourSub(pDC);
}

void CDesignEngine::DrawAluDesignContour(CDC *pDC)
{
	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;
	CDBDoc		  *pDoc = gm->GetDBDoc();
	int			i, elem_num, nMembType;
	double		val[3];
	T_ELEM_D	elem_d;
	T_RALU_D	stdata;
	CGPSMembCtrl MembCtrl;
	CPen		elem_pen, *old_pen;
	CArray<int, int>	type_list;
	CArray<GRE_Atom, GRE_Atom&> atom_list;
	BOOL bEscapePressed = FALSE, bFrameType;

	if (!gm->m_bContour)
	{
		gm->GPSDrawOriginal(pDC);
		return;
	}

	//elem_pen.CreatePen(PS_SOLID, gm->m_nLineWidth, m_pContourEngine->m_ElemColor);
	//elem_pen.CreatePen(PS_SOLID, gm->m_LnWd.nElemHddn, m_pContourEngine->m_ElemColor);
	elem_pen.CreatePen(PS_SOLID, gm->m_DOPT.DR.nElemHddn, m_pContourEngine->m_ElemColor);
	old_pen = (CPen *)pDC->SelectObject(&elem_pen);

	type_list.Add(gm->m_MinOTID + OBJECT_TYPE_ORIGINAL);
	gm->m_pGPSCtrl->GetZSortedList(type_list, gm->m_EKeyListVisible, atom_list);

	m_mapBdgnSlMsKey.RemoveAll();
	elem_num = atom_list.GetSize();
	for (i = 0; i < elem_num; i++)
	{
		//if(gm->m_pGPSCtrl->WatchEscKeyPress()) bEscapePressed = TRUE;
		if (gm->m_pGPSCtrl->WatchEscKeyPress()) return;
		if (gm->m_pGPSCtrl->IsZoomAllState() ||
			gm->m_pGPSCtrl->IsObjectInClientWindow(atom_list[i].m_OType, atom_list[i].m_OKey))
		{
			pDoc->m_pAttrCtrl->GetElem(atom_list[i].m_OKey, elem_d);
			BOOL bRedundant = FALSE;
#if defined(_TOWER)
			bRedundant = m_pDoc->m_pPostCtrl->GetTowerInfo()->IsRedundantElement(atom_list[i].m_OKey);
#endif

			bFrameType = pDoc->m_pAttrCtrl->IsFrameType(elem_d.eltyp);
			nMembType = GetMbtpType(atom_list[i].m_OKey); // COLUMN:1  D_MBTP_BEAM:2  D_MBTP_BRACE:3

			// Member Design하면서 추가됨 
			if (bFrameType && (nMembType == 1 || nMembType == 2 || nMembType == 3) && (gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey)) && !bEscapePressed)
			{
				if (GetAluData(atom_list[i].m_OKey, stdata))
				{
					val[0] = val[1] = val[2] = CalcAluDataValue(stdata);
					if (m_bCRLmtVal && val[0] < m_dCRLmtVal) // Limit value보다 작으면 그리지 않음 
					{
						gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
						continue;
					}
					DoBeamElementContour(pDC, atom_list[i].m_OKey, val);
				}
				else
				{
					gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
				}
			}
			else if (pDoc->m_pAttrCtrl->IsTruss(elem_d.eltyp) && (gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey)) && !bEscapePressed && !bRedundant)
			{
				if (GetAluData(atom_list[i].m_OKey, stdata))
				{
					val[0] = val[1] = val[2] = CalcAluDataValue(stdata);
					if (m_bCRLmtVal && val[0] < m_dCRLmtVal) // Limit value보다 작으면 그리지 않음 
						gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
					else
						DoTrussElementContour(pDC, atom_list[i].m_OKey, val);
				}
				else
				{
					gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
				}
			}
			else if (pDoc->m_pAttrCtrl->IsBeam(elem_d.eltyp) && (gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey)) && !bEscapePressed && !bRedundant) {
				if (GetAluData(atom_list[i].m_OKey, stdata))
				{
					val[0] = val[1] = val[2] = CalcAluDataValue(stdata);
					if (m_bCRLmtVal && val[0] < m_dCRLmtVal) // Limit value보다 작으면 그리지 않음 
						gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
					else
						DoBeamElementContour(pDC, atom_list[i].m_OKey, val);
				}
				else
				{
					gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
				}
			}
			else
			{
				gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
			}
		}
	}
	type_list.RemoveAll();
	atom_list.RemoveAll();

	pDC->SelectObject(old_pen);
	elem_pen.DeleteObject();
}

void CDesignEngine::DrawFireDesignContour(CDC *pDC)
{
	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;
	CDBDoc		  *pDoc = gm->GetDBDoc();
	int			i, elem_num, nMembType;
	double		val[3];
	T_ELEM_D	elem_d;
	T_RSTL_GB51249_17_D	stdata;
	CGPSMembCtrl MembCtrl;
	CPen		elem_pen, *old_pen;
	CArray<int, int>	type_list;
	CArray<GRE_Atom, GRE_Atom&> atom_list;
	BOOL bEscapePressed = FALSE, bFrameType;

	if (!gm->m_bContour)
	{
		gm->GPSDrawOriginal(pDC);
		return;
	}

	elem_pen.CreatePen(PS_SOLID, gm->m_DOPT.DR.nElemHddn, m_pContourEngine->m_ElemColor);
	old_pen = (CPen *)pDC->SelectObject(&elem_pen);

	type_list.Add(gm->m_MinOTID + OBJECT_TYPE_ORIGINAL);
	gm->m_pGPSCtrl->GetZSortedList(type_list, gm->m_EKeyListVisible, atom_list);

	m_mapBdgnSlMsKey.RemoveAll();
	elem_num = atom_list.GetSize();
	for (i = 0; i < elem_num; i++)
	{
		//if(gm->m_pGPSCtrl->WatchEscKeyPress()) bEscapePressed = TRUE;
		if (gm->m_pGPSCtrl->WatchEscKeyPress()) return;
		if (gm->m_pGPSCtrl->IsZoomAllState() ||
			gm->m_pGPSCtrl->IsObjectInClientWindow(atom_list[i].m_OType, atom_list[i].m_OKey))
		{
			pDoc->m_pAttrCtrl->GetElem(atom_list[i].m_OKey, elem_d);
			BOOL bRedundant = FALSE;
			bFrameType = pDoc->m_pAttrCtrl->IsFrameType(elem_d.eltyp);
			nMembType = GetMbtpType(atom_list[i].m_OKey); // COLUMN:1  D_MBTP_BEAM:2  D_MBTP_BRACE:3

			if (bFrameType && (nMembType == 1 || nMembType == 2 || nMembType == 3) && (gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey)) && !bEscapePressed)
			{
				if (GetFireData(atom_list[i].m_OKey, stdata))
				{
					val[0] = val[1] = val[2] = CalcFireDataValue(stdata);
					if (m_bCRLmtVal && val[0] < m_dCRLmtVal) // Limit value보다 작으면 그리지 않음 
					{
						gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
						continue;
					}
					DoBeamElementContour(pDC, atom_list[i].m_OKey, val);
				}
				else
				{
					gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
				}
			}
			else if (pDoc->m_pAttrCtrl->IsTruss(elem_d.eltyp) && (gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey)) && !bEscapePressed && !bRedundant)
			{
				if (GetFireData(atom_list[i].m_OKey, stdata))
				{
					val[0] = val[1] = val[2] = CalcFireDataValue(stdata);
					if (m_bCRLmtVal && val[0] < m_dCRLmtVal) // Limit value보다 작으면 그리지 않음 
						gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
					else
						DoTrussElementContour(pDC, atom_list[i].m_OKey, val);
				}
				else
				{
					gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
				}
			}
			else if (pDoc->m_pAttrCtrl->IsBeam(elem_d.eltyp) && (gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey)) && !bEscapePressed && !bRedundant) {
				if (GetFireData(atom_list[i].m_OKey, stdata))
				{
					val[0] = val[1] = val[2] = CalcFireDataValue(stdata);
					if (m_bCRLmtVal && val[0] < m_dCRLmtVal) // Limit value보다 작으면 그리지 않음 
						gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
					else
						DoBeamElementContour(pDC, atom_list[i].m_OKey, val);
				}
				else
				{
					gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
				}
			}
			else
			{
				gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
			}
		}
	}
	type_list.RemoveAll();
	atom_list.RemoveAll();

	pDC->SelectObject(old_pen);
	elem_pen.DeleteObject();
}

void CDesignEngine::DrawPfdnDesignContour(CDC *pDC)
{
	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;
	CDBDoc		  *pDoc = gm->GetDBDoc();
	int			i, elem_num, nMembType;
	double		val[3];
	T_ELEM_D	elem_d;
	T_RSTL_PFDN_D	stdata;
	CGPSMembCtrl MembCtrl;
	CPen		elem_pen, *old_pen;
	CArray<int, int>	type_list;
	CArray<GRE_Atom, GRE_Atom&> atom_list;
	BOOL bEscapePressed = FALSE, bFrameType;

	if (!gm->m_bContour)
	{
		gm->GPSDrawOriginal(pDC);
		return;
	}

	//elem_pen.CreatePen(PS_SOLID, gm->m_nLineWidth, m_pContourEngine->m_ElemColor);
	//elem_pen.CreatePen(PS_SOLID, gm->m_LnWd.nElemHddn, m_pContourEngine->m_ElemColor);
	elem_pen.CreatePen(PS_SOLID, gm->m_DOPT.DR.nElemHddn, m_pContourEngine->m_ElemColor);
	old_pen = (CPen *)pDC->SelectObject(&elem_pen);

	type_list.Add(gm->m_MinOTID + OBJECT_TYPE_ORIGINAL);
	gm->m_pGPSCtrl->GetZSortedList(type_list, gm->m_EKeyListVisible, atom_list);

	m_mapBdgnSlMsKey.RemoveAll();
	elem_num = atom_list.GetSize();
	for (i = 0; i < elem_num; i++)
	{
		//if(gm->m_pGPSCtrl->WatchEscKeyPress()) bEscapePressed = TRUE;
		if (gm->m_pGPSCtrl->WatchEscKeyPress()) return;
		if (gm->m_pGPSCtrl->IsZoomAllState() ||
			gm->m_pGPSCtrl->IsObjectInClientWindow(atom_list[i].m_OType, atom_list[i].m_OKey))
		{
			pDoc->m_pAttrCtrl->GetElem(atom_list[i].m_OKey, elem_d);
			BOOL bRedundant = FALSE;
			bFrameType = pDoc->m_pAttrCtrl->IsFrameType(elem_d.eltyp);
			nMembType = GetMbtpType(atom_list[i].m_OKey); // COLUMN:1  D_MBTP_BEAM:2  D_MBTP_BRACE:3

			if (bFrameType && (nMembType == 1 || nMembType == 2 || nMembType == 3) && (gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey)) && !bEscapePressed)
			{
				if (GetPfdnData(atom_list[i].m_OKey, stdata))
				{
					if (m_DsgnComponent == 8 && nMembType != 1)
					{
						gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
						continue;
					}
					else if (m_DsgnComponent == 9 && nMembType == 2)
					{
						gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
						continue;
					}
					val[0] = val[1] = val[2] = CalcPfdnDataValue(stdata);
					if (m_bCRLmtVal && val[0] < m_dCRLmtVal) // Limit value보다 작으면 그리지 않음 
					{
						gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
						continue;
					}
					DoBeamElementContour(pDC, atom_list[i].m_OKey, val);
				}
				else
				{
					gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
				}
			}
			else if (pDoc->m_pAttrCtrl->IsTruss(elem_d.eltyp) && (gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey)) && !bEscapePressed && !bRedundant)
			{
				if (GetPfdnData(atom_list[i].m_OKey, stdata))
				{
					val[0] = val[1] = val[2] = CalcPfdnDataValue(stdata);
					if (m_bCRLmtVal && val[0] < m_dCRLmtVal) // Limit value보다 작으면 그리지 않음 
						gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
					else
						DoTrussElementContour(pDC, atom_list[i].m_OKey, val);
				}
				else
				{
					gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
				}
			}
			else if (pDoc->m_pAttrCtrl->IsBeam(elem_d.eltyp) && (gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey)) && !bEscapePressed && !bRedundant) {
				if (GetPfdnData(atom_list[i].m_OKey, stdata))
				{
					val[0] = val[1] = val[2] = CalcPfdnDataValue(stdata);
					if (m_bCRLmtVal && val[0] < m_dCRLmtVal) // Limit value보다 작으면 그리지 않음 
						gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
					else
						DoBeamElementContour(pDC, atom_list[i].m_OKey, val);
				}
				else
				{
					gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
				}
			}
			else
			{
				gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
			}
		}
	}
	type_list.RemoveAll();
	atom_list.RemoveAll();

	pDC->SelectObject(old_pen);
	elem_pen.DeleteObject();
}

void CDesignEngine::DrawSTDesignContourSub(CDC *pDC)
{
	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;
	CDBDoc		  *pDoc = gm->GetDBDoc();
	int			i, elem_num, nMembType;
	double		val[3];
	T_ELEM_D	elem_d;
	//T_RSTL_D	stdata;
	CGPSMembCtrl MembCtrl;
	CPen		elem_pen, *old_pen;
	CArray<int, int>	type_list;
	CArray<GRE_Atom, GRE_Atom&> atom_list;
	BOOL bEscapePressed = FALSE, bFrameType;

	if (!gm->m_bContour)
	{
		gm->GPSDrawOriginal(pDC);
		return;
	}

	//elem_pen.CreatePen(PS_SOLID, gm->m_nLineWidth, m_pContourEngine->m_ElemColor);
	//elem_pen.CreatePen(PS_SOLID, gm->m_LnWd.nElemHddn, m_pContourEngine->m_ElemColor);
	elem_pen.CreatePen(PS_SOLID, gm->m_DOPT.DR.nElemHddn, m_pContourEngine->m_ElemColor);
	old_pen = (CPen *)pDC->SelectObject(&elem_pen);

	type_list.Add(gm->m_MinOTID + OBJECT_TYPE_ORIGINAL);
	gm->m_pGPSCtrl->GetZSortedList(type_list, gm->m_EKeyListVisible, atom_list);

	m_mapBdgnSlMsKey.RemoveAll();
	elem_num = atom_list.GetSize();
	for (i = 0; i < elem_num; i++)
	{
		//if(gm->m_pGPSCtrl->WatchEscKeyPress()) bEscapePressed = TRUE;
		if (gm->m_pGPSCtrl->WatchEscKeyPress()) return;
		if (gm->m_pGPSCtrl->IsZoomAllState() ||
			gm->m_pGPSCtrl->IsObjectInClientWindow(atom_list[i].m_OType, atom_list[i].m_OKey))
		{
			pDoc->m_pAttrCtrl->GetElem(atom_list[i].m_OKey, elem_d);
			BOOL bRedundant = FALSE;
#if defined(_TOWER)
			bRedundant = m_pDoc->m_pPostCtrl->GetTowerInfo()->IsRedundantElement(atom_list[i].m_OKey);
#endif

			bFrameType = pDoc->m_pAttrCtrl->IsFrameType(elem_d.eltyp);
			nMembType = GetMbtpType(atom_list[i].m_OKey); // COLUMN:1  D_MBTP_BEAM:2  D_MBTP_BRACE:3

			// Member Design하면서 추가됨 
			if (bFrameType && (nMembType == 1 || nMembType == 2 || nMembType == 3) && (gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey)) && !bEscapePressed)
			{
				if (CalcSTDataValueNew(atom_list[i].m_OKey, val[2]))
				{
					val[0] = val[1] = val[2];
					if (m_bCRLmtVal && val[0] < m_dCRLmtVal) // Limit value보다 작으면 그리지 않음 
					{
						gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
						continue;
					}

					if (MembCtrl.IsMemberWithOneElement(atom_list[i].m_OKey))
					{
						DoBeamElementContour(pDC, atom_list[i].m_OKey, val);
					}
					else
					{
						T_GPS_BDGN_D BdgnD;
						double dDivRatio[] = { 0.0, 0.25, 0.75, 1.0 };
						MembCtrl.GetBeamDgnRatio4SElem(atom_list[i].m_OKey, 3, dDivRatio, val, BdgnD);
						m_mapBdgnSlMsKey.SetAt(atom_list[i].m_OKey, BdgnD.nMElemK);
						DoBeamElementContourBdgn(pDC, atom_list[i].m_OKey, &BdgnD);
					}
				}
				else
				{
					gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
				}
			}
			else if (pDoc->m_pAttrCtrl->IsTruss(elem_d.eltyp) && (gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey)) && !bEscapePressed && !bRedundant)
			{
				if (CalcSTDataValueNew(atom_list[i].m_OKey, val[2]))
				{
					val[0] = val[1] = val[2];
					if (m_bCRLmtVal && val[0] < m_dCRLmtVal) // Limit value보다 작으면 그리지 않음 
						gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
					else
						DoTrussElementContour(pDC, atom_list[i].m_OKey, val);
				}
				else
				{
					gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
				}
			}
			else if (pDoc->m_pAttrCtrl->IsBeam(elem_d.eltyp) && (gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey)) && !bEscapePressed && !bRedundant) {
				if (CalcSTDataValueNew(atom_list[i].m_OKey, val[2]))
				{
					val[0] = val[1] = val[2];
					if (m_bCRLmtVal && val[0] < m_dCRLmtVal) // Limit value보다 작으면 그리지 않음 
						gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
					else
						DoBeamElementContour(pDC, atom_list[i].m_OKey, val);
				}
				else
				{
					gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
				}
			}
			else
			{
				gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
			}
		}
	}
	type_list.RemoveAll();
	atom_list.RemoveAll();

	pDC->SelectObject(old_pen);
	elem_pen.DeleteObject();
}

void CDesignEngine::DrawSTLSDDesignContour(CDC *pDC)
{
	I_GPSModel *gm = (I_GPSModel *)m_pGPSModel;
	CDBDoc	   *pDoc = gm->GetDBDoc();
	double		val[3];
	T_ELEM_D	elem_d;
	T_SDRD_D	stdata;
	CGPSMembCtrl MembCtrl;
	CPen		elem_pen, *old_pen;
	CArray<int, int>	type_list;
	CArray<GRE_Atom, GRE_Atom&> atom_list;
	BOOL bEscapePressed = FALSE, bFrameType;

	if (!gm->m_bContour)
	{
		gm->GPSDrawOriginal(pDC);
		return;
	}

	elem_pen.CreatePen(PS_SOLID, gm->m_DOPT.DR.nElemHddn, m_pContourEngine->m_ElemColor);
	old_pen = (CPen *)pDC->SelectObject(&elem_pen);

	type_list.Add(gm->m_MinOTID + OBJECT_TYPE_ORIGINAL);
	gm->m_pGPSCtrl->GetZSortedList(type_list, gm->m_EKeyListVisible, atom_list);

	m_mapBdgnSlMsKey.RemoveAll();
	int elem_num = atom_list.GetSize();
	for (int i = 0; i < elem_num; i++)
	{
		if (gm->m_pGPSCtrl->WatchEscKeyPress()) return;
		if (gm->m_pGPSCtrl->IsZoomAllState() ||
			gm->m_pGPSCtrl->IsObjectInClientWindow(atom_list[i].m_OType, atom_list[i].m_OKey))
		{
			pDoc->m_pAttrCtrl->GetElem(atom_list[i].m_OKey, elem_d);
			BOOL bRedundant = FALSE;

			bFrameType = pDoc->m_pAttrCtrl->IsFrameType(elem_d.eltyp);

			if (bFrameType && (gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey)) && !bEscapePressed)
			{
				if (GetST_LSDData(atom_list[i].m_OKey, stdata))
				{
					val[0] = val[1] = val[2] = CalcSTDataValue(stdata);
					// 					if(m_bCRLmtVal && val[0] < m_dCRLmtVal) // Limit value보다 작으면 그리지 않음 
					// 					{
					// 						gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
					// 						continue;
					// 					}

					if (MembCtrl.IsMemberWithOneElement(atom_list[i].m_OKey))
					{
						DoBeamElementContour(pDC, atom_list[i].m_OKey, val);
					}
					else
					{
						T_GPS_BDGN_D BdgnD;
						double dDivRatio[] = { 0.0, 0.25, 0.75, 1.0 };
						MembCtrl.GetBeamDgnRatio4SElem(atom_list[i].m_OKey, 3, dDivRatio, val, BdgnD);
						m_mapBdgnSlMsKey.SetAt(atom_list[i].m_OKey, BdgnD.nMElemK);
						DoBeamElementContourBdgn(pDC, atom_list[i].m_OKey, &BdgnD);
					}
				}
				else
				{
					gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
				}
			}
			else
			{
				gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
			}
		}
	}
	type_list.RemoveAll();
	atom_list.RemoveAll();

	pDC->SelectObject(old_pen);
	elem_pen.DeleteObject();
}

void CDesignEngine::DrawSRCDesignContour(CDC *pDC)
{
	if (m_bSRCReinforce)
	{
		DrawSRCDesignRebar(pDC);
		return;
	}
	//DrawSRCDesignContourSub(pDC);
	DrawCTDesignContourSub(pDC, TRUE);
}

void CDesignEngine::DrawSRCDesignContourSub(CDC *pDC)
{
	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;
	CDBDoc		*pDoc = gm->GetDBDoc();
	int			i, elem_num;
	double		val[3];
	T_ELEM_D	elem_d;
	//T_RSRC_D	srcdata;
	T_RCON_D	srcdata;
	CPen		elem_pen, *old_pen;
	CArray <int, int>				type_list;
	CArray <GRE_Atom, GRE_Atom&>		atom_list;
	BOOL bEscapePressed = FALSE;

	if (!gm->m_bContour) {
		gm->GPSDrawOriginal(pDC);
		return;
	}

	//elem_pen.CreatePen(PS_SOLID, gm->m_nLineWidth, m_pContourEngine->m_ElemColor);
	//elem_pen.CreatePen(PS_SOLID, gm->m_LnWd.nElemHddn, m_pContourEngine->m_ElemColor);
	elem_pen.CreatePen(PS_SOLID, gm->m_DOPT.DR.nElemHddn, m_pContourEngine->m_ElemColor);
	old_pen = (CPen *)pDC->SelectObject(&elem_pen);

	type_list.Add(gm->m_MinOTID + OBJECT_TYPE_ORIGINAL);
	gm->m_pGPSCtrl->GetZSortedList(type_list, gm->m_EKeyListVisible, atom_list);

	elem_num = atom_list.GetSize();
	for (i = 0; i < elem_num; i++)
	{
		//if(gm->m_pGPSCtrl->WatchEscKeyPress()) bEscapePressed = TRUE;
		if (gm->m_pGPSCtrl->WatchEscKeyPress()) return;
		if (gm->m_pGPSCtrl->IsZoomAllState() ||
			gm->m_pGPSCtrl->IsObjectInClientWindow(atom_list[i].m_OType, atom_list[i].m_OKey))
		{
			pDoc->m_pAttrCtrl->GetElem(atom_list[i].m_OKey, elem_d);
			if (pDoc->m_pAttrCtrl->IsTruss(elem_d.eltyp) && (gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey)) && !bEscapePressed) {
				if (GetSRCData(atom_list[i].m_OKey, srcdata))
				{
					//val[0] = val[1] = val[2] = CalcSRCDataValue(srcdata);
					val[0] = val[1] = val[2] = CalcCTDataValue(srcdata, 0);
					if (m_bCRLmtVal && val[0] < m_dCRLmtVal) // Limit value보다 작으면 그리지 않음 
						gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
					else
						DoTrussElementContour(pDC, atom_list[i].m_OKey, val);
				}
				else
				{
					gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
				}
			}
			else if (pDoc->m_pAttrCtrl->IsBeam(elem_d.eltyp) && (gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey)) && !bEscapePressed) {
				if (GetSRCData(atom_list[i].m_OKey, srcdata)) {
					//val[0] = val[1] = val[2] = CalcSRCDataValue(srcdata);
					val[0] = val[1] = val[2] = CalcCTDataValue(srcdata, 0);
					if (m_bCRLmtVal && val[0] < m_dCRLmtVal) // Limit value보다 작으면 그리지 않음 
						gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
					else
						DoBeamElementContour(pDC, atom_list[i].m_OKey, val);
				}
				else
				{
					gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
				}
			}
			else {
				gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
			}
		}
	}

	type_list.RemoveAll();
	atom_list.RemoveAll();

	pDC->SelectObject(old_pen);
	elem_pen.DeleteObject();
}


void CDesignEngine::DrawCTDesignContour(CDC *pDC)
{
	if (m_bCtReinforce)
	{
		DrawCTDesignRebar(pDC);
		return;
	}
	DrawCTDesignContourSub(pDC);
}

void CDesignEngine::DrawCTDesignContourSub(CDC *pDC, BOOL bSRC/*=FALSE*/)
{
	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;
	CDBDoc		*pDoc = gm->GetDBDoc();
	int			  i, elem_num, nMembType;
	double		val[3], dTmpMax;
	T_ELEM_D	elem_d;
	T_RCON_D	ctdata;
	CGPSMembCtrl MembCtrl;
	CPen		elem_pen, *old_pen;
	CArray <int, int>				type_list;
	CArray <GRE_Atom, GRE_Atom&>		atom_list;
	BOOL bEscapePressed = FALSE, bFrameType;

	if (!gm->m_bContour)
	{
		gm->GPSDrawOriginal(pDC);
		return;
	}

	elem_pen.CreatePen(PS_SOLID, gm->m_DOPT.DR.nElemHddn, m_pContourEngine->m_ElemColor);
	old_pen = (CPen *)pDC->SelectObject(&elem_pen);
	type_list.Add(gm->m_MinOTID + OBJECT_TYPE_ORIGINAL);
	gm->m_pGPSCtrl->GetZSortedList(type_list, gm->m_EKeyListVisible, atom_list);

	m_mapBdgnSlMsKey.RemoveAll();
	elem_num = atom_list.GetSize();
	for (i = 0; i < elem_num; i++)
	{
		if (gm->m_pGPSCtrl->WatchEscKeyPress()) return;
		if (gm->m_pGPSCtrl->IsZoomAllState() ||
			gm->m_pGPSCtrl->IsObjectInClientWindow(atom_list[i].m_OType, atom_list[i].m_OKey))
		{
			pDoc->m_pAttrCtrl->GetElem(atom_list[i].m_OKey, elem_d);

			bFrameType = pDoc->m_pAttrCtrl->IsFrameType(elem_d.eltyp);
			nMembType = GetMbtpType(atom_list[i].m_OKey); // COLUMN:1  D_MBTP_BEAM:2  D_MBTP_BRACE:3

			// Member Design하면서 추가됨 
			if (bFrameType && (nMembType == 1 || nMembType == 2 || nMembType == 3) && (gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey)) && !bEscapePressed)
			{
				BOOL bRtnVal = FALSE;
				if (bSRC)  bRtnVal = this->GetSRCData(atom_list[i].m_OKey, ctdata);
				else      bRtnVal = this->GetCTData(atom_list[i].m_OKey, ctdata);
				//if(GetCTData(atom_list[i].m_OKey, ctdata)) 
				if (bRtnVal)
				{
					val[0] = CalcCTDataValue(ctdata, 0);
					val[1] = CalcCTDataValue(ctdata, 1);
					val[2] = CalcCTDataValue(ctdata, 2);

					dTmpMax = CalcMaxCTDataValue(ctdata);
					if (m_bCRLmtVal && dTmpMax < m_dCRLmtVal) // Limit value보다 작으면 그리지 않음 
					{
						gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
						continue;
					}

					if (MembCtrl.IsMemberWithOneElement(atom_list[i].m_OKey))
					{
						DoBeamElementContour(pDC, atom_list[i].m_OKey, val);
					}
					else
					{
						T_GPS_BDGN_D BdgnD;
						double dDivRatio[] = { 0.0, 0.25, 0.75, 1.0 };
						MembCtrl.GetBeamDgnRatio4SElem(atom_list[i].m_OKey, 3, dDivRatio, val, BdgnD);
						m_mapBdgnSlMsKey.SetAt(atom_list[i].m_OKey, BdgnD.nMElemK);
						DoBeamElementContourBdgn(pDC, atom_list[i].m_OKey, &BdgnD);
					}
				}
				else
				{
					gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
				}
			}
			else if (pDoc->m_pAttrCtrl->IsTruss(elem_d.eltyp) && (gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey)) && !bEscapePressed)
			{
				BOOL bRtnVal = FALSE;
				if (bSRC)  bRtnVal = this->GetSRCData(atom_list[i].m_OKey, ctdata);
				else      bRtnVal = this->GetCTData(atom_list[i].m_OKey, ctdata);
				//if(GetCTData(atom_list[i].m_OKey, ctdata)) 
				if (bRtnVal)
				{
					val[0] = CalcCTDataValue(ctdata, 0);
					val[1] = CalcCTDataValue(ctdata, 1);
					val[2] = CalcCTDataValue(ctdata, 2);

					dTmpMax = CalcMaxCTDataValue(ctdata);
					if (m_bCRLmtVal && dTmpMax < m_dCRLmtVal) // Limit value보다 작으면 그리지 않음 
						gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
					else
						DoTrussElementContour(pDC, atom_list[i].m_OKey, val);
				}
				else
				{
					gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
				}
			}
			else if (pDoc->m_pAttrCtrl->IsBeam(elem_d.eltyp) && (gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey)) && !bEscapePressed)
			{
				BOOL bRtnVal = FALSE;
				if (bSRC)  bRtnVal = this->GetSRCData(atom_list[i].m_OKey, ctdata);
				else      bRtnVal = this->GetCTData(atom_list[i].m_OKey, ctdata);
				//if(GetCTData(atom_list[i].m_OKey, ctdata)) 
				if (bRtnVal)
				{
					val[0] = CalcCTDataValue(ctdata, 0);
					val[1] = CalcCTDataValue(ctdata, 1);
					val[2] = CalcCTDataValue(ctdata, 2);
					dTmpMax = CalcMaxCTDataValue(ctdata);
					if (m_bCRLmtVal && dTmpMax < m_dCRLmtVal) // Limit value보다 작으면 그리지 않음 
						gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
					else
						DoBeamElementContour(pDC, atom_list[i].m_OKey, val);
				}
				else
				{
					gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
				}
			}
			else if (pDoc->m_pAttrCtrl->IsWall(elem_d.eltyp) && (gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey)) && !bEscapePressed)
			{
				//if (GetCTData(atom_list[i].m_OKey, ctdata)) 
				BOOL bRtnVal = FALSE;
				if (bSRC)  bRtnVal = this->GetSRCData(atom_list[i].m_OKey, ctdata);
				else      bRtnVal = this->GetCTData(atom_list[i].m_OKey, ctdata);
				//if(GetCTData(atom_list[i].m_OKey, ctdata)) 
				if (bRtnVal)
				{
					val[0] = val[1] = val[2] = CalcCTDataValue(ctdata, 0);
					if (m_bCRLmtVal && val[0] < m_dCRLmtVal) // Limit value보다 작으면 그리지 않음 
						gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
					else
						DoWallElementContour(pDC, atom_list[i].m_OKey, val);
				}
				else
				{
					gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
				}
			}
			else
			{
				gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
			}
		}
	}

	type_list.RemoveAll();
	atom_list.RemoveAll();

	pDC->SelectObject(old_pen);
	elem_pen.DeleteObject();
}

void CDesignEngine::DoTrussElementContour(CDC *pDC, T_ELEM_K ekey, double *val)
{
	I_GPSModel		*gm = (I_GPSModel *)m_pGPSModel;
	CDBDoc			*pDoc = gm->GetDBDoc();
	int				i, poly_num, vtx_num;
	T_ELEM_D		elem_d;

	CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray <CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					edge_list;
	CArray <CArray <T_NODE_K, T_NODE_K> *, CArray <T_NODE_K, T_NODE_K> *>	VertexNode;

	pDoc->m_pAttrCtrl->GetElem(ekey, elem_d);
	gm->GetShapeElement(ekey, polygon_list, &edge_list, NULL, &VertexNode);

	gm->GPS_XGL_Begin_Elem(ekey, elem_d);
	poly_num = polygon_list.GetSize();
	for (i = 0; i < poly_num; i++)
	{
		vtx_num = polygon_list[i]->GetCount();
		if (vtx_num == 2)
		{
			DoLineContour(pDC, polygon_list[i], VertexNode[i], elem_d, val);
		}
		else
		{
			DoPolyContour(pDC, polygon_list[i], edge_list[i], VertexNode[i], elem_d, val);
			//if (gm->m_RenderFlag == 3 || gm->m_RenderFlag == 2 )
			if (gm->m_DOPT.DR.m_RenderFlag == 3 || gm->m_DOPT.DR.m_RenderFlag == 2)
				gm->GPSDrawPolygonEdge(pDC, polygon_list[i], edge_list[i]);
		}
	}
	gm->GPS_XGL_End_Elem();
	FreeMemoryPolyList(&polygon_list, &edge_list, &VertexNode);
	/*
	for (i=0;i<poly_num;i++) {
	polygon_list[i]->RemoveAll();
	delete polygon_list[i];
	edge_list[i]->RemoveAll();
	delete edge_list[i];
	VertexNode[i]->RemoveAll();
	delete VertexNode[i];
	}
	polygon_list.RemoveAll();
	edge_list.RemoveAll();
	VertexNode.RemoveAll();
	*/
}

void CDesignEngine::DoBeamElementContour(CDC *pDC, T_ELEM_K ekey, double *val)
{
	I_GPSModel		*gm = (I_GPSModel *)m_pGPSModel;
	CDBDoc			*pDoc = gm->GetDBDoc();
	int				i, poly_num, vtx_num;
	T_ELEM_D		elem_d;

	CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray <CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					edge_list;
	CArray <CArray <T_NODE_K, T_NODE_K> *, CArray <T_NODE_K, T_NODE_K> *>	VertexNode;

	pDoc->m_pAttrCtrl->GetElem(ekey, elem_d);
	gm->GetShapeElement(ekey, polygon_list, &edge_list, NULL, &VertexNode);

	gm->GPS_XGL_Begin_Elem(ekey, elem_d);
	poly_num = polygon_list.GetSize();
	for (i = 0; i < poly_num; i++) {
		vtx_num = polygon_list[i]->GetCount();
		if (vtx_num == 2) {
			DoLineContour(pDC, polygon_list[i], VertexNode[i], elem_d, val);
		}
		else {
			DoPolyContour(pDC, polygon_list[i], edge_list[i], VertexNode[i], elem_d, val);
			//if (gm->m_RenderFlag == 3 ||gm->m_RenderFlag == 2)
			if (gm->m_DOPT.DR.m_RenderFlag == 3 || gm->m_DOPT.DR.m_RenderFlag == 2)
				gm->GPSDrawPolygonEdge(pDC, polygon_list[i], edge_list[i]);
		}
	}
	gm->GPS_XGL_End_Elem();
	FreeMemoryPolyList(&polygon_list, &edge_list, &VertexNode);
	/*
	for (i=0;i<poly_num;i++) {
	polygon_list[i]->RemoveAll();
	delete polygon_list[i];
	edge_list[i]->RemoveAll();
	delete edge_list[i];
	VertexNode[i]->RemoveAll();
	delete VertexNode[i];
	}
	polygon_list.RemoveAll();
	edge_list.RemoveAll();
	VertexNode.RemoveAll();
	*/
}

void CDesignEngine::DoBeamElementContourBdgn(CDC *pDC, T_ELEM_K ekey, T_GPS_BDGN_D *pBdgn)
{
	I_GPSModel		*gm = (I_GPSModel *)m_pGPSModel;
	CDBDoc			*pDoc = gm->GetDBDoc();
	int				i, poly_num, vtx_num;
	T_ELEM_D		elem_d;

	CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray <CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					edge_list;
	CArray <CArray <T_NODE_K, T_NODE_K> *, CArray <T_NODE_K, T_NODE_K> *>	VertexNode;

	pDoc->m_pAttrCtrl->GetElem(ekey, elem_d);
	gm->GetShapeElement(ekey, polygon_list, &edge_list, NULL, &VertexNode);

	gm->GPS_XGL_Begin_Elem(ekey, elem_d);
	poly_num = polygon_list.GetSize();
	for (i = 0; i < poly_num; i++)
	{
		vtx_num = polygon_list[i]->GetCount();
		if (vtx_num == 2)
		{
			DoLineContourBdgn(pDC, polygon_list[i], VertexNode[i], elem_d, pBdgn);
		}
		else
		{
			DoPolyContourBdgn(pDC, polygon_list[i], edge_list[i], VertexNode[i], elem_d, pBdgn);
			if (gm->m_DOPT.DR.m_RenderFlag == 3 || gm->m_DOPT.DR.m_RenderFlag == 2)
				gm->GPSDrawPolygonEdge(pDC, polygon_list[i], edge_list[i]);
		}
	}
	gm->GPS_XGL_End_Elem();
	FreeMemoryPolyList(&polygon_list, &edge_list, &VertexNode);
}

void CDesignEngine::DoWallElementContour(CDC *pDC, T_ELEM_K ekey, double *val)
{
	I_GPSModel		*gm = (I_GPSModel *)m_pGPSModel;
	CDBDoc			*pDoc = gm->GetDBDoc();
	int				i, poly_num, vtx_num;
	T_ELEM_D		elem_d;

	CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray <CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					edge_list;
	CArray <CArray <T_NODE_K, T_NODE_K> *, CArray <T_NODE_K, T_NODE_K> *>	VertexNode;

	pDoc->m_pAttrCtrl->GetElem(ekey, elem_d);
	gm->GetShapeElement(ekey, polygon_list, &edge_list, NULL, &VertexNode);

	gm->GPS_XGL_Begin_Elem(ekey, elem_d);
	poly_num = polygon_list.GetSize();
	for (i = 0; i < poly_num; i++) {
		vtx_num = polygon_list[i]->GetCount();
		if (vtx_num == 2) {
			DoLineContour(pDC, polygon_list[i], VertexNode[i], elem_d, val);
		}
		else {
			DoPolyContour(pDC, polygon_list[i], edge_list[i], VertexNode[i], elem_d, val);
			//if (gm->m_RenderFlag == 3 ||gm->m_RenderFlag == 2  )
			if (gm->m_DOPT.DR.m_RenderFlag == 3 || gm->m_DOPT.DR.m_RenderFlag == 2)
				gm->GPSDrawPolygonEdge(pDC, polygon_list[i], edge_list[i]);
		}
	}
	gm->GPS_XGL_End_Elem();
	FreeMemoryPolyList(&polygon_list, &edge_list, &VertexNode);
	/*
	for (i=0;i<poly_num;i++) {
	polygon_list[i]->RemoveAll();
	delete polygon_list[i];
	edge_list[i]->RemoveAll();
	delete edge_list[i];
	VertexNode[i]->RemoveAll();
	delete VertexNode[i];
	}
	polygon_list.RemoveAll();
	edge_list.RemoveAll();
	VertexNode.RemoveAll();
	*/
}

void CDesignEngine::DoElementContourPrfm(CDC *pDC, T_ELEM_K ekey, double *val)
{
	I_GPSModel		*gm = (I_GPSModel *)m_pGPSModel;
	CDBDoc			*pDoc = gm->GetDBDoc();
	int				i, poly_num, vtx_num;
	T_ELEM_D		elem_d;

	CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray <CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					edge_list;
	CArray <CArray <T_NODE_K, T_NODE_K> *, CArray <T_NODE_K, T_NODE_K> *>	VertexNode;

	T_MIRE_K mkey;
	mkey.keymap = ekey;

	pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d);

	if (m_bDeformedShapeContour) gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list, &VertexNode);
	else												gm->GetShapeElement(ekey, polygon_list, &edge_list, NULL, &VertexNode);

	gm->GPS_XGL_Begin_Elem(mkey.key.elem_k, elem_d);
	poly_num = polygon_list.GetSize();
	for (i = 0; i < poly_num; i++) {
		vtx_num = polygon_list[i]->GetCount();
		if (vtx_num == 2) {
			if (gm->m_AnimEngine.m_bAnimateContour)
			{
				val[0] = m_pContourEngine->GetSubFrameValue(val[0], gm->m_AnimEngine.GetAnimationFactor(TRUE));
				val[1] = m_pContourEngine->GetSubFrameValue(val[1], gm->m_AnimEngine.GetAnimationFactor(TRUE));
				val[2] = m_pContourEngine->GetSubFrameValue(val[2], gm->m_AnimEngine.GetAnimationFactor(TRUE));
			}
			DoLineContour(pDC, polygon_list[i], VertexNode[i], elem_d, val);
		}
		else {
			DoPolyContour(pDC, polygon_list[i], edge_list[i], VertexNode[i], elem_d, val);
			if (gm->m_DOPT.DR.m_RenderFlag == 3 || gm->m_DOPT.DR.m_RenderFlag == 2)
				gm->GPSDrawPolygonEdge(pDC, polygon_list[i], edge_list[i]);
		}
	}
	gm->GPS_XGL_End_Elem();
	FreeMemoryPolyList(&polygon_list, &edge_list, &VertexNode);
}

void CDesignEngine::DoLineContour(CDC *pDC, CList <C3DPoint, C3DPoint> *Vertex,
	CArray <T_NODE_K, T_NODE_K> *VertexNode, T_ELEM_D &ElemData, double *val)
{
	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;
	POSITION	pos = Vertex->GetHeadPosition();
	C3DPoint	p[3];

	CArray <C3DPoint, C3DPoint>		rvtx_list;
	CArray <double, double>			rval_list;

	p[0] = Vertex->GetNext(pos);
	p[2] = Vertex->GetNext(pos);

	// Composite Section의 Concrete부분 
	// I,J단의 Line을 Plotting하는 경우는 
	if (VertexNode->GetAt(0) == VertexNode->GetAt(1))
	{
		double dValue;
		// I단 
		if (ElemData.elnod[0] == VertexNode->GetAt(0))
			dValue = val[0];
		// J단 
		else
			dValue = val[2];
		rvtx_list.Add(p[0]);  rval_list.Add(dValue);
		rvtx_list.Add(p[2]);  rval_list.Add(dValue);
		DrawContourLine(pDC, rvtx_list, rval_list, gm->m_DOPT.DR.nElemWire);
		rvtx_list.RemoveAll();
		rval_list.RemoveAll();
		return;
	}

	p[1].Set((p[0].x + p[2].x) / 2.0, (p[0].y + p[2].y) / 2.0, (p[0].z + p[2].z) / 2.0);

	if (val[0] > val[1]) {
		rvtx_list.Add(p[0]);
		rval_list.Add(val[0]);
		m_pContourEngine->GetRankVertices(p[0], p[1], val[0], val[1], rvtx_list, rval_list, NULL);
		rvtx_list.Add(p[1]);
		rval_list.Add(val[1]);
	}
	else {
		rvtx_list.Add(p[1]);
		rval_list.Add(val[1]);
		m_pContourEngine->GetRankVertices(p[1], p[0], val[1], val[0], rvtx_list, rval_list, NULL);
		rvtx_list.Add(p[0]);
		rval_list.Add(val[0]);
	}
	//DrawContourLine(pDC, rvtx_list, rval_list);
	//DrawContourLine(pDC, rvtx_list, rval_list,gm->m_LnWd.nElemWire);
	DrawContourLine(pDC, rvtx_list, rval_list, gm->m_DOPT.DR.nElemWire);
	rvtx_list.RemoveAll();
	rval_list.RemoveAll();

	if (val[1] > val[2]) {
		rvtx_list.Add(p[1]);
		rval_list.Add(val[1]);
		m_pContourEngine->GetRankVertices(p[1], p[2], val[1], val[2], rvtx_list, rval_list, NULL);
		rvtx_list.Add(p[2]);
		rval_list.Add(val[2]);
	}
	else {
		rvtx_list.Add(p[2]);
		rval_list.Add(val[2]);
		m_pContourEngine->GetRankVertices(p[2], p[1], val[2], val[1], rvtx_list, rval_list, NULL);
		rvtx_list.Add(p[1]);
		rval_list.Add(val[1]);
	}
	//DrawContourLine(pDC, rvtx_list, rval_list);
	//DrawContourLine(pDC, rvtx_list, rval_list,gm->m_LnWd.nElemWire);
	DrawContourLine(pDC, rvtx_list, rval_list, gm->m_DOPT.DR.nElemWire);
	rvtx_list.RemoveAll();
	rval_list.RemoveAll();
}

void CDesignEngine::DoLineContourBdgn(CDC *pDC, CList<C3DPoint, C3DPoint> *Vertex,
	CArray <T_NODE_K, T_NODE_K> *VertexNode, T_ELEM_D &ElemData,
	T_GPS_BDGN_D *pBdgn)
{
	int i;
	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;
	POSITION	pos = Vertex->GetHeadPosition();
	C3DPoint	p[3], TmpPt;

	CArray<C3DPoint, C3DPoint>arDivPt;
	CArray<C3DPoint, C3DPoint>rvtx_list;
	CArray<double, double>	 rval_list;

	double dx, dy, dz;
	p[0] = Vertex->GetNext(pos);
	p[2] = Vertex->GetNext(pos);

	// Composite Section의 Concrete부분 
	// I,J단의 Line을 Plotting하는 경우는 
	if (VertexNode->GetAt(0) == VertexNode->GetAt(1))
	{
		double dValue;

		if (!pBdgn->nDiv) { ASSERT(0); return; }

		// I단 
		if (ElemData.elnod[0] == VertexNode->GetAt(0))
			dValue = pBdgn->dVal[0];
		// J단 
		else
			dValue = pBdgn->dVal[pBdgn->nDiv - 1];
		rvtx_list.Add(p[0]);  rval_list.Add(dValue);
		rvtx_list.Add(p[2]);  rval_list.Add(dValue);
		DrawContourLine(pDC, rvtx_list, rval_list, gm->m_DOPT.DR.nElemWire);
		rvtx_list.RemoveAll();
		rval_list.RemoveAll();
		return;
	}

	dx = p[2].x - p[0].x;
	dy = p[2].y - p[0].y;
	dz = p[2].z - p[0].z;
	for (i = 0; i < pBdgn->nDiv + 1; i++)
	{
		TmpPt.x = p[0].x + dx * pBdgn->dDist[i];
		TmpPt.y = p[0].y + dy * pBdgn->dDist[i];
		TmpPt.z = p[0].z + dz * pBdgn->dDist[i];
		arDivPt.Add(TmpPt);
	}
	for (i = 0; i < pBdgn->nDiv; i++)
	{
		rvtx_list.Add(arDivPt[i]);
		rval_list.Add(pBdgn->dVal[i]);
		rvtx_list.Add(arDivPt[i + 1]);
		rval_list.Add(pBdgn->dVal[i]);
		DrawContourLine(pDC, rvtx_list, rval_list, gm->m_DOPT.DR.nElemWire);
		rvtx_list.RemoveAll();
		rval_list.RemoveAll();
	}
}

void CDesignEngine::DoPolyContour(CDC *pDC,
	CList <C3DPoint, C3DPoint> *Vertex,
	CArray <BOOL, BOOL> *EdgeFlag,
	CArray <T_NODE_K, T_NODE_K> *VertexNode,
	T_ELEM_D &edata, double *val)
{
	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;
	int			i, vertex_num = Vertex->GetCount();
	double		ctval[4], dx1, dy1, dz1, dx2, dy2, dz2;
	BOOL		ef[4];
	C3DPoint	p[4];
	POSITION	pos;
	CList <C3DPoint, C3DPoint>	sub_vertex;

	// polygon이 i단 쪽에 있을 경우
	if ((VertexNode->GetAt(0) == VertexNode->GetAt(1)) &&
		(VertexNode->GetAt(0) == VertexNode->GetAt(2)) &&
		(VertexNode->GetAt(0) == edata.elnod[0]))
	{
		for (i = 0; i < vertex_num; i++)
		{
			ctval[i] = val[0];
			if (gm->m_AnimEngine.m_bAnimateContour)
				ctval[i] = m_pContourEngine->GetSubFrameValue(ctval[i], gm->m_AnimEngine.GetAnimationFactor(TRUE));
			ef[i] = EdgeFlag->GetAt(i);
		}
		DoSubPolyContour(pDC, ctval, Vertex, ef, TRUE);
	}
	// polygon이 j단 쪽에 있을 경우
	else if ((VertexNode->GetAt(0) == VertexNode->GetAt(1)) &&
		(VertexNode->GetAt(0) == VertexNode->GetAt(2)) &&
		(VertexNode->GetAt(0) == edata.elnod[1]))
	{
		for (i = 0; i < vertex_num; i++) {
			ctval[i] = val[2];
			if (gm->m_AnimEngine.m_bAnimateContour)
				ctval[i] = m_pContourEngine->GetSubFrameValue(ctval[i], gm->m_AnimEngine.GetAnimationFactor(TRUE));
			ef[i] = EdgeFlag->GetAt(i);
		}
		DoSubPolyContour(pDC, ctval, Vertex, ef, TRUE);
	}
	// polygon이 i, j단에 걸쳐 있을 경우
	else
	{
		if (vertex_num != 4)return;
		pos = Vertex->GetHeadPosition();
		for (i = 0; i < 4; i++) {
			p[i] = Vertex->GetNext(pos);
		}
		dx1 = (p[3].x - p[0].x) / 2.0;
		dy1 = (p[3].y - p[0].y) / 2.0;
		dz1 = (p[3].z - p[0].z) / 2.0;

		dx2 = (p[2].x - p[1].x) / 2.0;
		dy2 = (p[2].y - p[1].y) / 2.0;
		dz2 = (p[2].z - p[1].z) / 2.0;

		p[3] = p[0];
		p[2] = p[1];
		for (i = 0; i < 2; i++) {
			p[0] = p[3];
			p[1] = p[2];
			p[3].x = p[0].x + dx1;
			p[3].y = p[0].y + dy1;
			p[3].z = p[0].z + dz1;
			p[2].x = p[1].x + dx2;
			p[2].y = p[1].y + dy2;
			p[2].z = p[1].z + dz2;
			sub_vertex.AddTail(p[0]);
			sub_vertex.AddTail(p[1]);
			sub_vertex.AddTail(p[2]);
			sub_vertex.AddTail(p[3]);

			ctval[0] = ctval[1] = val[i];
			ctval[2] = ctval[3] = val[i + 1];
			if (gm->m_AnimEngine.m_bAnimateContour) {
				ctval[0] = m_pContourEngine->GetSubFrameValue(ctval[0], gm->m_AnimEngine.GetAnimationFactor(TRUE));
				ctval[1] = m_pContourEngine->GetSubFrameValue(ctval[1], gm->m_AnimEngine.GetAnimationFactor(TRUE));
				ctval[2] = m_pContourEngine->GetSubFrameValue(ctval[2], gm->m_AnimEngine.GetAnimationFactor(TRUE));
				ctval[3] = m_pContourEngine->GetSubFrameValue(ctval[3], gm->m_AnimEngine.GetAnimationFactor(TRUE));
			}

			if (i == 0)
				ef[0] = EdgeFlag->GetAt(0);
			else
				ef[0] = FALSE;
			ef[1] = EdgeFlag->GetAt(1);
			if (i == 1)
				ef[2] = EdgeFlag->GetAt(2);
			else
				ef[2] = FALSE;
			ef[3] = EdgeFlag->GetAt(3);

			DoSubPolyContour(pDC, ctval, &sub_vertex, ef, TRUE);
			sub_vertex.RemoveAll();
		}
	}
}

void CDesignEngine::DoPolyContourBdgn(CDC *pDC,
	CList <C3DPoint, C3DPoint> *Vertex,
	CArray <BOOL, BOOL> *EdgeFlag,
	CArray <T_NODE_K, T_NODE_K> *VertexNode,
	T_ELEM_D &edata, T_GPS_BDGN_D *pBdgn)
{
	I_GPSModel *gm = (I_GPSModel*)m_pGPSModel;
	int			i, vertex_num = Vertex->GetCount();
	double	ctval[4], dx1, dy1, dz1, dx2, dy2, dz2;
	BOOL		ef[4];
	C3DPoint	p[4];
	POSITION	pos;
	CList <C3DPoint, C3DPoint>	sub_vertex;

	int nVtxNode[3];
	nVtxNode[0] = VertexNode->GetAt(0);
	nVtxNode[1] = VertexNode->GetAt(1);
	nVtxNode[2] = VertexNode->GetAt(2);

	// polygon이 i단 쪽에 있을 경우
	if ((nVtxNode[0] == nVtxNode[1]) &&
		(nVtxNode[0] == nVtxNode[2]) &&
		(nVtxNode[0] == edata.elnod[0]))
	{
		for (i = 0; i < vertex_num; i++)
		{
			if (pBdgn->bReverse) ctval[i] = pBdgn->dVal[pBdgn->nDiv - 1];
			else			          ctval[i] = pBdgn->dVal[0];
			if (gm->m_AnimEngine.m_bAnimateContour)
				ctval[i] = m_pContourEngine->GetSubFrameValue(ctval[i], gm->m_AnimEngine.GetAnimationFactor(TRUE));
			ef[i] = EdgeFlag->GetAt(i);
		}
		DoSubPolyContour(pDC, ctval, Vertex, ef, TRUE);
	}
	// polygon이 j단 쪽에 있을 경우
	else if ((nVtxNode[0] == nVtxNode[1]) &&
		(nVtxNode[0] == nVtxNode[2]) &&
		(nVtxNode[0] == edata.elnod[1]))
	{
		for (i = 0; i < vertex_num; i++)
		{
			if (pBdgn->bReverse) ctval[i] = pBdgn->dVal[0];
			else			          ctval[i] = pBdgn->dVal[pBdgn->nDiv - 1];
			if (gm->m_AnimEngine.m_bAnimateContour)
				ctval[i] = m_pContourEngine->GetSubFrameValue(ctval[i], gm->m_AnimEngine.GetAnimationFactor(TRUE));
			ef[i] = EdgeFlag->GetAt(i);
		}
		DoSubPolyContour(pDC, ctval, Vertex, ef, TRUE);
	}
	// polygon이 i, j단에 걸쳐 있을 경우
	else
	{
		if (vertex_num != 4)return;
		pos = Vertex->GetHeadPosition();
		for (i = 0; i < 4; i++)p[i] = Vertex->GetNext(pos);

		C3DPoint TmpPt;
		CArray<C3DPoint, C3DPoint&> arTopPt;
		CArray<C3DPoint, C3DPoint&> arBotPt;

		arTopPt.SetSize(pBdgn->nDiv + 1);
		arBotPt.SetSize(pBdgn->nDiv + 1);

		dx1 = (p[3].x - p[0].x);
		dy1 = (p[3].y - p[0].y);
		dz1 = (p[3].z - p[0].z);
		dx2 = (p[2].x - p[1].x);
		dy2 = (p[2].y - p[1].y);
		dz2 = (p[2].z - p[1].z);
		for (i = 0; i < pBdgn->nDiv + 1; i++)
		{
			arTopPt[i].x = p[0].x + dx1 * pBdgn->dDist[i];
			arTopPt[i].y = p[0].y + dy1 * pBdgn->dDist[i];
			arTopPt[i].z = p[0].z + dz1 * pBdgn->dDist[i];
			arBotPt[i].x = p[1].x + dx2 * pBdgn->dDist[i];
			arBotPt[i].y = p[1].y + dy2 * pBdgn->dDist[i];
			arBotPt[i].z = p[1].z + dz2 * pBdgn->dDist[i];
		}

		for (i = 0; i < pBdgn->nDiv; i++)
		{
			sub_vertex.AddTail(arTopPt[i]);
			sub_vertex.AddTail(arBotPt[i]);
			sub_vertex.AddTail(arBotPt[i + 1]);
			sub_vertex.AddTail(arTopPt[i + 1]);
			ctval[0] = ctval[1] = ctval[2] = ctval[3] = pBdgn->dVal[i];
			if (gm->m_AnimEngine.m_bAnimateContour)
			{
				ctval[0] = m_pContourEngine->GetSubFrameValue(ctval[0], gm->m_AnimEngine.GetAnimationFactor(TRUE));
				ctval[1] = m_pContourEngine->GetSubFrameValue(ctval[1], gm->m_AnimEngine.GetAnimationFactor(TRUE));
				ctval[2] = m_pContourEngine->GetSubFrameValue(ctval[2], gm->m_AnimEngine.GetAnimationFactor(TRUE));
				ctval[3] = m_pContourEngine->GetSubFrameValue(ctval[3], gm->m_AnimEngine.GetAnimationFactor(TRUE));
			}

			if (i == 0) ef[0] = EdgeFlag->GetAt(0);
			else     ef[0] = FALSE;
			ef[1] = EdgeFlag->GetAt(1);
			if (i == pBdgn->nDiv - 1)
				ef[2] = EdgeFlag->GetAt(2);
			else
				ef[2] = FALSE;
			ef[3] = EdgeFlag->GetAt(3);

			DoSubPolyContour(pDC, ctval, &sub_vertex, ef, TRUE);
			sub_vertex.RemoveAll();
		}
	}
}


#if defined(__OLD_OUTPUT_VALUE)
void CDesignEngine::OutputSTNumbers(CDC *pDC)
{
	OutputSTNumbersBdgn(pDC);

	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;
	CDBDoc		*pDoc = gm->GetDBDoc();
	int			i, elem_num, slope;
	double		val;
	T_ELEM_K	ekey;
	T_ELEM_D	edata;
	T_RSTL_D	stdata;
	C3DPoint	node3D_i, node3D_j, DrawPoint;
	CPoint		text_p, node_2d_i, node_2d_j;
	TCHAR		fmt_str[10];
	CString		text_str;
	CFont		ft, *old_ft;
	BOOL		fl_bak, is_inverse;

	CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray <CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					edge_list;
	POSITION pos;

	COLORREF ColorNG;
	ColorNG = RGB(255, 0, 0);

	if (!m_bDsgnDataSet)
		return;

	if (gm->m_DOPT.TX.m_bNumberOpaque)
		pDC->SetBkMode(OPAQUE);
	else
		pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
	pDC->SetBkColor(gm->m_DOPT.TX.m_NumberBackCol);
	pDC->SetTextAlign(TA_CENTER | TA_BOTTOM);

	// 지수형태로 출력인가?
	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);

	BOOL bGrpFltMode = gm->m_pGPSCtrl->IsGroupFilterMode();
	if (!bGrpFltMode)elem_num = gm->m_EKeyListActive.GetSize();
	else            elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize();

	T_ELEM_K nMElemK;
	for (i = 0; i < elem_num; i++)
	{
		if (!bGrpFltMode)ekey = gm->m_EKeyListActive[i];
		else            ekey = gm->m_pDispFilter->m_aGrpEKey[i];

		if (!gm->m_pGPSCtrl->IsActiveElem(ekey))
			continue; // Lable Hidden 처리를 위해 추가 
#if defined(_TOWER)
		if (m_pDoc->m_pPostCtrl->GetTowerInfo()->IsRedundantElement(ekey))
			continue;
#endif


		if (!GetSTData(ekey, stdata))
			continue;

		int nElemKind = GetMbtpType(ekey);
		if (m_bStShowService)
		{
			if (m_bStShowDeflection == FALSE) continue;

			if (nElemKind == D_MBTP_BEAM)
			{
				if (m_bStShowBeam2 == FALSE) continue;
			}
			else if (nElemKind == D_MBTP_COLUMN)
			{
				if (m_bStShowColm2 == FALSE) continue;
			}
			else continue;
		}
		else
		{
			if (!CalcSTDataValueNew(ekey, val))
				continue;

			if (m_bCRLmtVal && val < m_dCRLmtVal) // Limit value보다 작으면 그리지 않음 
				continue;
		}

		pDoc->m_pAttrCtrl->GetElem(ekey, edata);

		if (m_mapBdgnSlMsKey.Lookup(ekey, nMElemK)) // MQC:1541 20080109 mylee
			continue;

		fl_bak = gm->m_DOPT.DR.m_bFrameLine;
		gm->m_DOPT.DR.m_bFrameLine = TRUE;
		gm->GetShapeElement(ekey, polygon_list, &edge_list);
		gm->m_DOPT.DR.m_bFrameLine = fl_bak;

		pos = polygon_list[0]->GetHeadPosition();
		node3D_i = polygon_list[0]->GetNext(pos);
		node3D_j = polygon_list[0]->GetNext(pos);

		for (int j = 0; j < polygon_list.GetSize(); j++)
		{
			polygon_list[j]->RemoveAll();
			delete polygon_list[j];
			edge_list[j]->RemoveAll();
			delete edge_list[j];
		}
		polygon_list.RemoveAll();
		edge_list.RemoveAll();

		if (gm->m_bVirtualMode)
		{
			node_2d_i = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_i);
			node_2d_j = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_j);
		}
		else
		{
			node_2d_i = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_i);
			node_2d_j = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_j);
		}
		if (node_2d_i.x < 0 || node_2d_i.y < 0) continue;
		if (node_2d_j.x < 0 || node_2d_j.y < 0) continue;
		slope = (int)(atan2(node_2d_i.y - node_2d_j.y, node_2d_j.x - node_2d_i.x)*1800.0 / 3.14159);
		slope = (slope + 3600) % 3600;
		if ((900 < slope) && (slope <= 2700)) {
			is_inverse = TRUE;
			slope = (slope + 1800) % 3600;
		}
		else {
			is_inverse = FALSE;
		}

		gm->SetNumberFontOrientation(slope);
		ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
		old_ft = (CFont *)pDC->SelectObject(&ft);

		if (m_bStShowDeflection)
		{
			T_SECT_D SectD; SectD.Initialize();
			if (!m_pDoc->m_pAttrCtrl->GetSectDesign(edata.elpro, SectD)) continue;
			if (SectD.SectBefore.Shape == D_SECT_SHAPE_REG_UP) continue;

			text_p.x = (int)((node_2d_i.x + node_2d_j.x) / 2.0);
			text_p.y = (int)((node_2d_i.y + node_2d_j.y) / 2.0);

			double dL = stdata.res_dDefLim * stdata.res_dDispLim;
			if (fabs(dL) < 1e-9)
			{
				pDC->SelectObject(old_ft);
				ft.DeleteObject();
				continue;
			}
			int iMax = 0;
			int nVal = 0;
			if (nElemKind == D_MBTP_BEAM)
			{
				iMax = 2;
			}
			else if (nElemKind == D_MBTP_COLUMN)
			{
				iMax = fabs(stdata.res_dMaxDisp[0]) >= fabs(stdata.res_dMaxDisp[1]) ? 0 : 1;
			}
			else
			{
				ASSERT(0);
				continue;
			}

			if (fabs(stdata.res_dMaxDisp[iMax]) > 0.0) nVal = (int)CMathFunc::mathRoundOff(fabs(dL / stdata.res_dMaxDisp[iMax]), 1);

			if (fabs(nVal) > 0) text_str.Format(_T("L/%d"), nVal);
			else text_str.Format(_T("%d"), nVal);

			if (fabs(stdata.res_dMaxDisp[iMax]) / stdata.res_dDispLim > 1.0) pDC->SetTextColor(ColorNG);
			else                                                          pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);

			pDC->TextOut(text_p.x, text_p.y, text_str);
		}
		else
		{
			if (m_pDoc->m_pPostCtrl->StlDgnMgr()->IsCHStlCodeDgn() && m_DsgnComponent >= 8)
			{
				text_p.x = (int)((node_2d_i.x + node_2d_j.x) / 2.0);
				text_p.y = (int)((node_2d_i.y + node_2d_j.y) / 2.0);

				auto pPair = m_mapStlFigData.PLookup(ekey);
				if (pPair == nullptr) continue;
				/*if ( m_DsgnComponent == 7 )
				{
					//text_str = pPair->value.strResult_WHRatio;
					double dRto = pPair->value.m_dRltWHRatio;
					if (dRto > 1.0)
						pDC->SetTextColor(ColorNG);
					else
						pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
				}
				else */if (m_DsgnComponent == 8)
				{
					text_str = pPair->value.strResult_SectG;
					pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
				}
				else if (m_DsgnComponent == 9)
				{
					text_str = pPair->value.strCompRto;
					pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
				}
				else
					continue;

				pDC->TextOut(text_p.x, text_p.y, text_str);
			}
			else if (gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
			{
				double dLimit = (m_dMaxValue - m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;

				DrawPoint.x = (int)((node3D_i.x + node3D_j.x) / 2.0);
				DrawPoint.y = (int)((node3D_i.y + node3D_j.y) / 2.0);
				DrawPoint.z = (int)((node3D_i.z + node3D_j.z) / 2.0);

				text_p.x = (int)((node_2d_i.x + node_2d_j.x) / 2.0);
				text_p.y = (int)((node_2d_i.y + node_2d_j.y) / 2.0);

				if (ResultIsOK_New(ekey, val))
					pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
				else
					pDC->SetTextColor(ColorNG);
				switch (gm->m_DOPT.TX.m_nOutputMinMaxType)
				{
				case 0: // Min & Max
					if ((m_dMaxValue - val) <= dLimit)
					{
						DrawMinMaxOutputValue(pDC, DrawPoint, text_p, fmt_str, 0, val);
					}
					else if ((val - m_dMinValue) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, text_p, fmt_str, 1, val);
					break;
				case 1: // Abs Max
					if (fabs(m_dMaxValue) >= fabs(m_dMinValue))
					{
						if (fabs(m_dMaxValue) - fabs(val) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, text_p, fmt_str, 2, val);
					}
					else
					{
						if (fabs(m_dMinValue) - fabs(val) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, text_p, fmt_str, 2, val);
					}
					break;
				case 2: // Max
					if ((m_dMaxValue - val) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, text_p, fmt_str, 0, val);
					break;
				case 3: // Min
					if ((val - m_dMinValue) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, text_p, fmt_str, 1, val);
					break;
				}

			}
			else
			{
				text_p.x = (int)((node_2d_i.x + node_2d_j.x) / 2.0);
				text_p.y = (int)((node_2d_i.y + node_2d_j.y) / 2.0);
				text_str.Format(fmt_str, val);

				if (ResultIsOK_New(ekey, val))
					pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
				else
					pDC->SetTextColor(ColorNG);

				pDC->TextOut(text_p.x, text_p.y, text_str);
			}
		}

		pDC->SelectObject(old_ft);
		ft.DeleteObject();
	}
}
#else
void CDesignEngine::OutputSTNumbers(CDC* pDC)
{
	OutputSTNumbersBdgn(pDC);

	I_GPSModel* gm = (I_GPSModel*)m_pGPSModel;
	CDBDoc* pDoc = gm->GetDBDoc();
	int			i, elem_num, slope;
	double		val;
	T_ELEM_K	ekey;
	T_ELEM_D	edata;
	T_RSTL_D	stdata;
	C3DPoint	node3D_i, node3D_j, DrawPoint;
	CPoint		text_p, node_2d_i, node_2d_j;
	TCHAR		fmt_str[10];
	CString		text_str;
	
	BOOL		fl_bak, is_inverse;

	CArray <CList <C3DPoint, C3DPoint>*, CList <C3DPoint, C3DPoint>*>		polygon_list;
	CArray <CArray <BOOL, BOOL>*, CArray <BOOL, BOOL>*>					edge_list;
	POSITION pos;

	COLORREF ColorNG;
	ColorNG = RGB(255, 0, 0);

	if (!m_bDsgnDataSet)
		return;

	GPostTextOut TextOutModel;
	TextOutModel.SetDC(pDC);
	TextOutModel.StartSteelVal();
	TextOutModel.SettingSteel(gm);

	// 지수형태로 출력인가?
	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);

	BOOL bGrpFltMode = gm->m_pGPSCtrl->IsGroupFilterMode();
	if (!bGrpFltMode)elem_num = gm->m_EKeyListActive.GetSize();
	else            elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize();

	T_ELEM_K nMElemK;
	for (i = 0; i < elem_num; i++)
	{
		if (!bGrpFltMode)ekey = gm->m_EKeyListActive[i];
		else            ekey = gm->m_pDispFilter->m_aGrpEKey[i];

		if (!gm->m_pGPSCtrl->IsActiveElem(ekey))
			continue; // Lable Hidden 처리를 위해 추가 
#if defined(_TOWER)
		if (m_pDoc->m_pPostCtrl->GetTowerInfo()->IsRedundantElement(ekey))
			continue;
#endif


		if (!GetSTData(ekey, stdata))
			continue;

		int nElemKind = GetMbtpType(ekey);
		if (m_bStShowService)
		{
			if (m_bStShowDeflection == FALSE) continue;

			if (nElemKind == D_MBTP_BEAM)
			{
				if (m_bStShowBeam2 == FALSE) continue;
			}
			else if (nElemKind == D_MBTP_COLUMN)
			{
				if (m_bStShowColm2 == FALSE) continue;
			}
			else continue;
		}
		else
		{
			if (!CalcSTDataValueNew(ekey, val))
				continue;

			if (m_bCRLmtVal && val < m_dCRLmtVal) // Limit value보다 작으면 그리지 않음 
				continue;
		}

		pDoc->m_pAttrCtrl->GetElem(ekey, edata);

		if (m_mapBdgnSlMsKey.Lookup(ekey, nMElemK)) // MQC:1541 20080109 mylee
			continue;

		fl_bak = gm->m_DOPT.DR.m_bFrameLine;
		gm->m_DOPT.DR.m_bFrameLine = TRUE;
		gm->GetShapeElement(ekey, polygon_list, &edge_list);
		gm->m_DOPT.DR.m_bFrameLine = fl_bak;

		pos = polygon_list[0]->GetHeadPosition();
		node3D_i = polygon_list[0]->GetNext(pos);
		node3D_j = polygon_list[0]->GetNext(pos);

		for (int j = 0; j < polygon_list.GetSize(); j++)
		{
			polygon_list[j]->RemoveAll();
			delete polygon_list[j];
			edge_list[j]->RemoveAll();
			delete edge_list[j];
		}
		polygon_list.RemoveAll();
		edge_list.RemoveAll();

		if (gm->m_bVirtualMode)
		{
			node_2d_i = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_i);
			node_2d_j = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_j);
		}
		else
		{
			node_2d_i = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_i);
			node_2d_j = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_j);
		}
		if (node_2d_i.x < 0 || node_2d_i.y < 0) continue;
		if (node_2d_j.x < 0 || node_2d_j.y < 0) continue;
		slope = (int)(atan2(node_2d_i.y - node_2d_j.y, node_2d_j.x - node_2d_i.x) * 1800.0 / 3.14159);
		slope = (slope + 3600) % 3600;
		if ((900 < slope) && (slope <= 2700)) {
			is_inverse = TRUE;
			slope = (slope + 1800) % 3600;
		}
		else {
			is_inverse = FALSE;
		}

		TextOutModel.Font4Steel(gm, slope);

		if (m_bStShowDeflection)
		{
			T_SECT_D SectD; SectD.Initialize();
			if (!m_pDoc->m_pAttrCtrl->GetSectDesign(edata.elpro, SectD)) continue;
			if (SectD.SectBefore.Shape == D_SECT_SHAPE_REG_UP) continue;

			text_p.x = (int)((node_2d_i.x + node_2d_j.x) / 2.0);
			text_p.y = (int)((node_2d_i.y + node_2d_j.y) / 2.0);

			double dL = stdata.res_dDefLim * stdata.res_dDispLim;
			if (fabs(dL) < 1e-9)
			{
				TextOutModel.DeleteFont();
				continue;
			}
			int iMax = 0;
			int nVal = 0;
			if (nElemKind == D_MBTP_BEAM)
			{
				iMax = 2;
			}
			else if (nElemKind == D_MBTP_COLUMN)
			{
				iMax = fabs(stdata.res_dMaxDisp[0]) >= fabs(stdata.res_dMaxDisp[1]) ? 0 : 1;
			}
			else
			{
				ASSERT(0);
				continue;
			}

			if (fabs(stdata.res_dMaxDisp[iMax]) > 0.0) nVal = (int)CMathFunc::mathRoundOff(fabs(dL / stdata.res_dMaxDisp[iMax]), 1);

			if (fabs(nVal) > 0) text_str.Format(_T("L/%d"), nVal);
			else text_str.Format(_T("%d"), nVal);

			if (fabs(stdata.res_dMaxDisp[iMax]) / stdata.res_dDispLim > 1.0)
				TextOutModel.TextOutSteel(text_p.x, text_p.y, text_str, ColorNG);
			else
				TextOutModel.TextOutSteel(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorC);
		}
		else
		{
			if (m_pDoc->m_pPostCtrl->StlDgnMgr()->IsCHStlCodeDgn() && m_DsgnComponent >= 8)
			{
				text_p.x = (int)((node_2d_i.x + node_2d_j.x) / 2.0);
				text_p.y = (int)((node_2d_i.y + node_2d_j.y) / 2.0);

				auto pPair = m_mapStlFigData.PLookup(ekey);
				if (pPair == nullptr) continue;
				/*if ( m_DsgnComponent == 7 )
				{
					//text_str = pPair->value.strResult_WHRatio;
					double dRto = pPair->value.m_dRltWHRatio;
					if (dRto > 1.0)
						pDC->SetTextColor(ColorNG);
					else
						pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
				}
				else */if (m_DsgnComponent == 8)
				{
					text_str = pPair->value.strResult_SectG;
					TextOutModel.TextOutSteel(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorC);
				}
				else if (m_DsgnComponent == 9)
				{
					text_str = pPair->value.strCompRto;
					TextOutModel.TextOutSteel(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorC);
				}
				else
					continue;
			}
			else if (gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
			{
				double dLimit = (m_dMaxValue - m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;

				DrawPoint.x = (int)((node3D_i.x + node3D_j.x) / 2.0);
				DrawPoint.y = (int)((node3D_i.y + node3D_j.y) / 2.0);
				DrawPoint.z = (int)((node3D_i.z + node3D_j.z) / 2.0);

				text_p.x = (int)((node_2d_i.x + node_2d_j.x) / 2.0);
				text_p.y = (int)((node_2d_i.y + node_2d_j.y) / 2.0);

				if (ResultIsOK_New(ekey, val))
					TextOutModel.SetColorText(gm->m_DOPT.TX.m_NumberTextColorC);
				else
					TextOutModel.SetColorText(ColorNG);
				switch (gm->m_DOPT.TX.m_nOutputMinMaxType)
				{
				case 0: // Min & Max
					if ((m_dMaxValue - val) <= dLimit)
					{
						DrawMinMaxOutputValue(pDC, DrawPoint, text_p, fmt_str, 0, val);
					}
					else if ((val - m_dMinValue) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, text_p, fmt_str, 1, val);
					break;
				case 1: // Abs Max
					if (fabs(m_dMaxValue) >= fabs(m_dMinValue))
					{
						if (fabs(m_dMaxValue) - fabs(val) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, text_p, fmt_str, 2, val);
					}
					else
					{
						if (fabs(m_dMinValue) - fabs(val) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, text_p, fmt_str, 2, val);
					}
					break;
				case 2: // Max
					if ((m_dMaxValue - val) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, text_p, fmt_str, 0, val);
					break;
				case 3: // Min
					if ((val - m_dMinValue) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, text_p, fmt_str, 1, val);
					break;
				}

			}
			else
			{
				text_p.x = (int)((node_2d_i.x + node_2d_j.x) / 2.0);
				text_p.y = (int)((node_2d_i.y + node_2d_j.y) / 2.0);
				text_str.Format(fmt_str, val);

				if (ResultIsOK_New(ekey, val))
					TextOutModel.TextOutSteel(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorC);
				else
					TextOutModel.TextOutSteel(text_p.x, text_p.y, text_str, ColorNG);
			}
		}
		TextOutModel.DeleteFont();
	}
	TextOutModel.EndSteelVal();
}
#endif


#if defined(__OLD_OUTPUT_VALUE)
void CDesignEngine::OutputAluNumbers(CDC *pDC)
{

	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;
	CDBDoc		*pDoc = gm->GetDBDoc();
	int			i, elem_num, slope;
	double		val;
	T_ELEM_K	ekey;
	T_ELEM_D	edata;
	T_RALU_D	stdata;
	C3DPoint	node3D_i, node3D_j, DrawPoint;
	CPoint		text_p, node_2d_i, node_2d_j;
	TCHAR		fmt_str[10];
	CString		text_str;
	CFont		ft, *old_ft;
	BOOL		fl_bak, is_inverse;

	CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray <CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					edge_list;
	POSITION pos;

	COLORREF ColorNG;
	ColorNG = RGB(255, 0, 0);

	if (!m_bDsgnDataSet)
		return;

	if (gm->m_DOPT.TX.m_bNumberOpaque)
		pDC->SetBkMode(OPAQUE);
	else
		pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
	pDC->SetBkColor(gm->m_DOPT.TX.m_NumberBackCol);
	pDC->SetTextAlign(TA_CENTER | TA_BOTTOM);

	// 지수형태로 출력인가?
	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);

	BOOL bGrpFltMode = gm->m_pGPSCtrl->IsGroupFilterMode();
	if (!bGrpFltMode)
		elem_num = gm->m_EKeyListActive.GetSize();
	else
		elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize();

	for (i = 0; i < elem_num; i++)
	{
		if (!bGrpFltMode)
			ekey = gm->m_EKeyListActive[i];
		else
			ekey = gm->m_pDispFilter->m_aGrpEKey[i];

		if (!gm->m_pGPSCtrl->IsActiveElem(ekey))
			continue; // Lable Hidden 처리를 위해 추가 
#if defined(_TOWER)
		if (m_pDoc->m_pPostCtrl->GetTowerInfo()->IsRedundantElement(ekey))
			continue;
#endif

		if (!GetAluData(ekey, stdata))
			continue;
		int nElemKind = GetMbtpType(ekey);
		val = CalcAluDataValue(stdata);
		if (m_bCRLmtVal && val < m_dCRLmtVal) // Limit value보다 작으면 그리지 않음 
			continue;


		pDoc->m_pAttrCtrl->GetElem(ekey, edata);


		fl_bak = gm->m_DOPT.DR.m_bFrameLine;
		gm->m_DOPT.DR.m_bFrameLine = TRUE;
		gm->GetShapeElement(ekey, polygon_list, &edge_list);
		gm->m_DOPT.DR.m_bFrameLine = fl_bak;

		pos = polygon_list[0]->GetHeadPosition();
		node3D_i = polygon_list[0]->GetNext(pos);
		node3D_j = polygon_list[0]->GetNext(pos);

		for (int j = 0; j < polygon_list.GetSize(); j++)
		{
			polygon_list[j]->RemoveAll();
			delete polygon_list[j];
			edge_list[j]->RemoveAll();
			delete edge_list[j];
		}
		polygon_list.RemoveAll();
		edge_list.RemoveAll();

		if (gm->m_bVirtualMode)
		{
			node_2d_i = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_i);
			node_2d_j = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_j);
		}
		else
		{
			node_2d_i = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_i);
			node_2d_j = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_j);
		}
		if (node_2d_i.x < 0 || node_2d_i.y < 0) continue;
		if (node_2d_j.x < 0 || node_2d_j.y < 0) continue;
		slope = (int)(atan2(node_2d_i.y - node_2d_j.y, node_2d_j.x - node_2d_i.x)*1800.0 / 3.14159);
		slope = (slope + 3600) % 3600;
		if ((900 < slope) && (slope <= 2700)) {
			is_inverse = TRUE;
			slope = (slope + 1800) % 3600;
		}
		else {
			is_inverse = FALSE;
		}

		gm->SetNumberFontOrientation(slope);
		ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
		old_ft = (CFont *)pDC->SelectObject(&ft);


		if (gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
		{
			double dLimit = (m_dMaxValue - m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;

			DrawPoint.x = (int)((node3D_i.x + node3D_j.x) / 2.0);
			DrawPoint.y = (int)((node3D_i.y + node3D_j.y) / 2.0);
			DrawPoint.z = (int)((node3D_i.z + node3D_j.z) / 2.0);

			if (val < 1.0) pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
			else          pDC->SetTextColor(ColorNG);
			switch (gm->m_DOPT.TX.m_nOutputMinMaxType)
			{
			case 0: // Min & Max
				if ((m_dMaxValue - val) <= dLimit)
				{
					DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, val);
				}
				else if ((val - m_dMinValue) <= dLimit)
					DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, val);
				break;
			case 1: // Abs Max
				if (fabs(m_dMaxValue) >= fabs(m_dMinValue))
				{
					if (fabs(m_dMaxValue) - fabs(val) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, val);
				}
				else
				{
					if (fabs(m_dMinValue) - fabs(val) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, val);
				}
				break;
			case 2: // Max
				if ((m_dMaxValue - val) <= dLimit)
					DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, val);
				break;
			case 3: // Min
				if ((val - m_dMinValue) <= dLimit)
					DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, val);
				break;
			}

		}
		else
		{
			text_p.x = (int)((node_2d_i.x + node_2d_j.x) / 2.0);
			text_p.y = (int)((node_2d_i.y + node_2d_j.y) / 2.0);
			text_str.Format(fmt_str, val);

			if (val < 1.0) pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
			else          pDC->SetTextColor(ColorNG);

			pDC->TextOut(text_p.x, text_p.y, text_str);
		}
		pDC->SelectObject(old_ft);
		ft.DeleteObject();
	}
}
#else
void CDesignEngine::OutputAluNumbers(CDC* pDC)
{

	I_GPSModel* gm = (I_GPSModel*)m_pGPSModel;
	CDBDoc* pDoc = gm->GetDBDoc();
	int			i, elem_num, slope;
	double		val;
	T_ELEM_K	ekey;
	T_ELEM_D	edata;
	T_RALU_D	stdata;
	C3DPoint	node3D_i, node3D_j, DrawPoint;
	CPoint		text_p, node_2d_i, node_2d_j;
	TCHAR		fmt_str[10];
	CString		text_str;
	BOOL		fl_bak, is_inverse;

	CArray <CList <C3DPoint, C3DPoint>*, CList <C3DPoint, C3DPoint>*>		polygon_list;
	CArray <CArray <BOOL, BOOL>*, CArray <BOOL, BOOL>*>					edge_list;
	POSITION pos;

	COLORREF ColorNG;
	ColorNG = RGB(255, 0, 0);

	if (!m_bDsgnDataSet)
		return;

	GPostTextOut TextOutModel;
	TextOutModel.SetDC(pDC);
	TextOutModel.StartAluminumVal();
	TextOutModel.SettingAluminum(gm);

	// 지수형태로 출력인가?
	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);

	BOOL bGrpFltMode = gm->m_pGPSCtrl->IsGroupFilterMode();
	if (!bGrpFltMode)
		elem_num = gm->m_EKeyListActive.GetSize();
	else
		elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize();

	for (i = 0; i < elem_num; i++)
	{
		if (!bGrpFltMode)
			ekey = gm->m_EKeyListActive[i];
		else
			ekey = gm->m_pDispFilter->m_aGrpEKey[i];

		if (!gm->m_pGPSCtrl->IsActiveElem(ekey))
			continue; // Lable Hidden 처리를 위해 추가 
#if defined(_TOWER)
		if (m_pDoc->m_pPostCtrl->GetTowerInfo()->IsRedundantElement(ekey))
			continue;
#endif

		if (!GetAluData(ekey, stdata))
			continue;
		int nElemKind = GetMbtpType(ekey);
		val = CalcAluDataValue(stdata);
		if (m_bCRLmtVal && val < m_dCRLmtVal) // Limit value보다 작으면 그리지 않음 
			continue;


		pDoc->m_pAttrCtrl->GetElem(ekey, edata);


		fl_bak = gm->m_DOPT.DR.m_bFrameLine;
		gm->m_DOPT.DR.m_bFrameLine = TRUE;
		gm->GetShapeElement(ekey, polygon_list, &edge_list);
		gm->m_DOPT.DR.m_bFrameLine = fl_bak;

		pos = polygon_list[0]->GetHeadPosition();
		node3D_i = polygon_list[0]->GetNext(pos);
		node3D_j = polygon_list[0]->GetNext(pos);

		for (int j = 0; j < polygon_list.GetSize(); j++)
		{
			polygon_list[j]->RemoveAll();
			delete polygon_list[j];
			edge_list[j]->RemoveAll();
			delete edge_list[j];
		}
		polygon_list.RemoveAll();
		edge_list.RemoveAll();

		if (gm->m_bVirtualMode)
		{
			node_2d_i = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_i);
			node_2d_j = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_j);
		}
		else
		{
			node_2d_i = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_i);
			node_2d_j = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_j);
		}
		if (node_2d_i.x < 0 || node_2d_i.y < 0) continue;
		if (node_2d_j.x < 0 || node_2d_j.y < 0) continue;
		slope = (int)(atan2(node_2d_i.y - node_2d_j.y, node_2d_j.x - node_2d_i.x) * 1800.0 / 3.14159);
		slope = (slope + 3600) % 3600;
		if ((900 < slope) && (slope <= 2700)) {
			is_inverse = TRUE;
			slope = (slope + 1800) % 3600;
		}
		else {
			is_inverse = FALSE;
		}

		TextOutModel.Font4Aluminum(gm, slope);

		if (gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
		{
			double dLimit = (m_dMaxValue - m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;

			DrawPoint.x = (int)((node3D_i.x + node3D_j.x) / 2.0);
			DrawPoint.y = (int)((node3D_i.y + node3D_j.y) / 2.0);
			DrawPoint.z = (int)((node3D_i.z + node3D_j.z) / 2.0);

			if (val < 1.0)
				TextOutModel.SetColorText(gm->m_DOPT.TX.m_NumberTextColorC);
			else
				TextOutModel.SetColorText(ColorNG);
			switch (gm->m_DOPT.TX.m_nOutputMinMaxType)
			{
			case 0: // Min & Max
				if ((m_dMaxValue - val) <= dLimit)
				{
					DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, val);
				}
				else if ((val - m_dMinValue) <= dLimit)
					DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, val);
				break;
			case 1: // Abs Max
				if (fabs(m_dMaxValue) >= fabs(m_dMinValue))
				{
					if (fabs(m_dMaxValue) - fabs(val) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, val);
				}
				else
				{
					if (fabs(m_dMinValue) - fabs(val) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, val);
				}
				break;
			case 2: // Max
				if ((m_dMaxValue - val) <= dLimit)
					DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, val);
				break;
			case 3: // Min
				if ((val - m_dMinValue) <= dLimit)
					DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, val);
				break;
			}

		}
		else
		{
			text_p.x = (int)((node_2d_i.x + node_2d_j.x) / 2.0);
			text_p.y = (int)((node_2d_i.y + node_2d_j.y) / 2.0);
			text_str.Format(fmt_str, val);

			if (val < 1.0)
				TextOutModel.TextOutAluminum(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorC);
			else
				TextOutModel.TextOutAluminum(text_p.x, text_p.y, text_str, ColorNG);
		}
		TextOutModel.DeleteFont();
	}
	TextOutModel.EndAluminumVal();
}
#endif

#if defined(__OLD_OUTPUT_VALUE)
void CDesignEngine::OutputPfdnNumbers(CDC *pDC)
{
	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;
	CDBDoc		*pDoc = gm->GetDBDoc();
	int			i, elem_num, slope;
	double		val;
	T_ELEM_K	ekey;
	T_RSTL_PFDN_D	stdata;
	C3DPoint	node3D_i, node3D_j, DrawPoint;
	CPoint		text_p, node_2d_i, node_2d_j;
	TCHAR		fmt_str[10];
	CString		text_str;
	CFont		ft, *old_ft;
	BOOL		fl_bak, is_inverse;

	CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray <CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					edge_list;
	POSITION pos;

	COLORREF ColorNG;
	ColorNG = RGB(255, 0, 0);

	if (!m_bDsgnDataSet)
		return;

	if (gm->m_DOPT.TX.m_bNumberOpaque)
		pDC->SetBkMode(OPAQUE);
	else
		pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
	pDC->SetBkColor(gm->m_DOPT.TX.m_NumberBackCol);
	pDC->SetTextAlign(TA_CENTER | TA_BOTTOM);

	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);

	BOOL bGrpFltMode = gm->m_pGPSCtrl->IsGroupFilterMode();
	if (!bGrpFltMode)
		elem_num = gm->m_EKeyListActive.GetSize();
	else
		elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize();

	for (i = 0; i < elem_num; i++)
	{
		if (!bGrpFltMode)
			ekey = gm->m_EKeyListActive[i];
		else
			ekey = gm->m_pDispFilter->m_aGrpEKey[i];

		if (!gm->m_pGPSCtrl->IsActiveElem(ekey))
			continue;
		if (!GetPfdnData(ekey, stdata))
			continue;
		int nElemKind = GetMbtpType(ekey);
		if (m_bCRLmtVal)
			continue;
		if ((m_DsgnComponent == 2 || m_DsgnComponent == 5 || m_DsgnComponent == 8 || m_DsgnComponent == 9) && nElemKind == 2)
			continue;
		else if (((m_DsgnComponent > 1 && m_DsgnComponent < 6) || m_DsgnComponent == 8) && nElemKind == 3)
			continue;
		//pDoc->m_pAttrCtrl->GetElem(ekey, edata);
		val = CalcPfdnDataValue(stdata);
		fl_bak = gm->m_DOPT.DR.m_bFrameLine;
		gm->m_DOPT.DR.m_bFrameLine = TRUE;
		gm->GetShapeElement(ekey, polygon_list, &edge_list);
		gm->m_DOPT.DR.m_bFrameLine = fl_bak;

		pos = polygon_list[0]->GetHeadPosition();
		node3D_i = polygon_list[0]->GetNext(pos);
		node3D_j = polygon_list[0]->GetNext(pos);

		for (int j = 0; j < polygon_list.GetSize(); j++)
		{
			polygon_list[j]->RemoveAll();
			delete polygon_list[j];
			edge_list[j]->RemoveAll();
			delete edge_list[j];
		}
		polygon_list.RemoveAll();
		edge_list.RemoveAll();

		if (gm->m_bVirtualMode)
		{
			node_2d_i = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_i);
			node_2d_j = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_j);
		}
		else
		{
			node_2d_i = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_i);
			node_2d_j = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_j);
		}
		if (node_2d_i.x < 0 || node_2d_i.y < 0) continue;
		if (node_2d_j.x < 0 || node_2d_j.y < 0) continue;
		slope = (int)(atan2(node_2d_i.y - node_2d_j.y, node_2d_j.x - node_2d_i.x)*1800.0 / 3.14159);
		slope = (slope + 3600) % 3600;
		if ((900 < slope) && (slope <= 2700)) {
			is_inverse = TRUE;
			slope = (slope + 1800) % 3600;
		}
		else {
			is_inverse = FALSE;
		}

		gm->SetNumberFontOrientation(slope);
		ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
		old_ft = (CFont *)pDC->SelectObject(&ft);

		if (m_DsgnComponent == 7)
		{
			text_p.x = (int)((node_2d_i.x + node_2d_j.x) / 2.0);
			text_p.y = (int)((node_2d_i.y + node_2d_j.y) / 2.0);
			CString strDucLevel[] = { _LS(IDS_TB_PFDL_1),_LS(IDS_TB_PFDL_2),_LS(IDS_TB_PFDL_3),_LS(IDS_TB_PFDL_4),_LS(IDS_TB_PFDL_5) };
			text_str = strDucLevel[stdata.nDucLevel];
			pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
			pDC->TextOut(text_p.x, text_p.y, text_str);
		}
		else if (gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
		{
			double dLimit = (m_dMaxValue - m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;

			DrawPoint.x = (int)((node3D_i.x + node3D_j.x) / 2.0);
			DrawPoint.y = (int)((node3D_i.y + node3D_j.y) / 2.0);
			DrawPoint.z = (int)((node3D_i.z + node3D_j.z) / 2.0);

			if (val < 1.0) pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
			else          pDC->SetTextColor(ColorNG);
			switch (gm->m_DOPT.TX.m_nOutputMinMaxType)
			{
			case 0: // Min & Max
				if ((m_dMaxValue - val) <= dLimit)
				{
					DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, val);
				}
				else if ((val - m_dMinValue) <= dLimit)
					DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, val);
				break;
			case 1: // Abs Max
				if (fabs(m_dMaxValue) >= fabs(m_dMinValue))
				{
					if (fabs(m_dMaxValue) - fabs(val) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, val);
				}
				else
				{
					if (fabs(m_dMinValue) - fabs(val) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, val);
				}
				break;
			case 2: // Max
				if ((m_dMaxValue - val) <= dLimit)
					DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, val);
				break;
			case 3: // Min
				if ((val - m_dMinValue) <= dLimit)
					DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, val);
				break;
			}

		}
		else
		{
			text_p.x = (int)((node_2d_i.x + node_2d_j.x) / 2.0);
			text_p.y = (int)((node_2d_i.y + node_2d_j.y) / 2.0);
			text_str.Format(fmt_str, val);

			if (m_DsgnComponent == 6)//Member Performance coefficient
			{
				pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
			}
			else if (m_DsgnComponent == 9)
			{
				if (val > stdata.dLambdaLimit + 1e-7) pDC->SetTextColor(ColorNG);
				else if (nElemKind == 3 && val < stdata.dLambdaMinLimit - 1e-7) pDC->SetTextColor(ColorNG);
				else          pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
			}
			else
			{
				if (val < 1.0 + 1e-7) pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
				else          pDC->SetTextColor(ColorNG);
			}
			pDC->TextOut(text_p.x, text_p.y, text_str);
		}
		pDC->SelectObject(old_ft);
		ft.DeleteObject();
	}
}
#else
void CDesignEngine::OutputPfdnNumbers(CDC* pDC)
{
	I_GPSModel* gm = (I_GPSModel*)m_pGPSModel;
	CDBDoc* pDoc = gm->GetDBDoc();
	int			i, elem_num, slope;
	double		val;
	T_ELEM_K	ekey;
	T_RSTL_PFDN_D	stdata;
	C3DPoint	node3D_i, node3D_j, DrawPoint;
	CPoint		text_p, node_2d_i, node_2d_j;
	TCHAR		fmt_str[10];
	CString		text_str;
	BOOL		fl_bak, is_inverse;

	CArray <CList <C3DPoint, C3DPoint>*, CList <C3DPoint, C3DPoint>*>		polygon_list;
	CArray <CArray <BOOL, BOOL>*, CArray <BOOL, BOOL>*>					edge_list;
	POSITION pos;

	COLORREF ColorNG;
	ColorNG = RGB(255, 0, 0);

	if (!m_bDsgnDataSet)
		return;

	GPostTextOut TextOutModel;
	TextOutModel.SetDC(pDC);
	TextOutModel.StartPfdnVal();
	TextOutModel.SettingPfdn(gm);

	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);

	BOOL bGrpFltMode = gm->m_pGPSCtrl->IsGroupFilterMode();
	if (!bGrpFltMode)
		elem_num = gm->m_EKeyListActive.GetSize();
	else
		elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize();

	for (i = 0; i < elem_num; i++)
	{
		if (!bGrpFltMode)
			ekey = gm->m_EKeyListActive[i];
		else
			ekey = gm->m_pDispFilter->m_aGrpEKey[i];

		if (!gm->m_pGPSCtrl->IsActiveElem(ekey))
			continue;
		if (!GetPfdnData(ekey, stdata))
			continue;
		int nElemKind = GetMbtpType(ekey);
		if (m_bCRLmtVal)
			continue;
		if ((m_DsgnComponent == 2 || m_DsgnComponent == 5 || m_DsgnComponent == 8 || m_DsgnComponent == 9) && nElemKind == 2)
			continue;
		else if (((m_DsgnComponent > 1 && m_DsgnComponent < 6) || m_DsgnComponent == 8) && nElemKind == 3)
			continue;
		//pDoc->m_pAttrCtrl->GetElem(ekey, edata);
		val = CalcPfdnDataValue(stdata);
		fl_bak = gm->m_DOPT.DR.m_bFrameLine;
		gm->m_DOPT.DR.m_bFrameLine = TRUE;
		gm->GetShapeElement(ekey, polygon_list, &edge_list);
		gm->m_DOPT.DR.m_bFrameLine = fl_bak;

		pos = polygon_list[0]->GetHeadPosition();
		node3D_i = polygon_list[0]->GetNext(pos);
		node3D_j = polygon_list[0]->GetNext(pos);

		for (int j = 0; j < polygon_list.GetSize(); j++)
		{
			polygon_list[j]->RemoveAll();
			delete polygon_list[j];
			edge_list[j]->RemoveAll();
			delete edge_list[j];
		}
		polygon_list.RemoveAll();
		edge_list.RemoveAll();

		if (gm->m_bVirtualMode)
		{
			node_2d_i = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_i);
			node_2d_j = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_j);
		}
		else
		{
			node_2d_i = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_i);
			node_2d_j = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_j);
		}
		if (node_2d_i.x < 0 || node_2d_i.y < 0) continue;
		if (node_2d_j.x < 0 || node_2d_j.y < 0) continue;
		slope = (int)(atan2(node_2d_i.y - node_2d_j.y, node_2d_j.x - node_2d_i.x) * 1800.0 / 3.14159);
		slope = (slope + 3600) % 3600;
		if ((900 < slope) && (slope <= 2700)) {
			is_inverse = TRUE;
			slope = (slope + 1800) % 3600;
		}
		else {
			is_inverse = FALSE;
		}

		TextOutModel.Font4Pfdn(gm, slope);

		if (m_DsgnComponent == 7)
		{
			text_p.x = (int)((node_2d_i.x + node_2d_j.x) / 2.0);
			text_p.y = (int)((node_2d_i.y + node_2d_j.y) / 2.0);
			CString strDucLevel[] = { _LS(IDS_TB_PFDL_1),_LS(IDS_TB_PFDL_2),_LS(IDS_TB_PFDL_3),_LS(IDS_TB_PFDL_4),_LS(IDS_TB_PFDL_5) };
			text_str = strDucLevel[stdata.nDucLevel];
			TextOutModel.TextOutPfdn(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorC);
		}
		else if (gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
		{
			double dLimit = (m_dMaxValue - m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;

			DrawPoint.x = (int)((node3D_i.x + node3D_j.x) / 2.0);
			DrawPoint.y = (int)((node3D_i.y + node3D_j.y) / 2.0);
			DrawPoint.z = (int)((node3D_i.z + node3D_j.z) / 2.0);

			if (val < 1.0)
				TextOutModel.SetColorText(gm->m_DOPT.TX.m_NumberTextColorC);
			else
				TextOutModel.SetColorText(ColorNG);
			switch (gm->m_DOPT.TX.m_nOutputMinMaxType)
			{
			case 0: // Min & Max
				if ((m_dMaxValue - val) <= dLimit)
				{
					DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, val);
				}
				else if ((val - m_dMinValue) <= dLimit)
					DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, val);
				break;
			case 1: // Abs Max
				if (fabs(m_dMaxValue) >= fabs(m_dMinValue))
				{
					if (fabs(m_dMaxValue) - fabs(val) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, val);
				}
				else
				{
					if (fabs(m_dMinValue) - fabs(val) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, val);
				}
				break;
			case 2: // Max
				if ((m_dMaxValue - val) <= dLimit)
					DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, val);
				break;
			case 3: // Min
				if ((val - m_dMinValue) <= dLimit)
					DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, val);
				break;
			}

		}
		else
		{
			text_p.x = (int)((node_2d_i.x + node_2d_j.x) / 2.0);
			text_p.y = (int)((node_2d_i.y + node_2d_j.y) / 2.0);
			text_str.Format(fmt_str, val);

			if (m_DsgnComponent == 6)//Member Performance coefficient
			{
				TextOutModel.TextOutPfdn(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorC);
			}
			else if (m_DsgnComponent == 9)
			{
				if (val > stdata.dLambdaLimit + 1e-7)
					TextOutModel.TextOutPfdn(text_p.x, text_p.y, text_str, ColorNG);
				else if (nElemKind == 3 && val < stdata.dLambdaMinLimit - 1e-7)
					TextOutModel.TextOutPfdn(text_p.x, text_p.y, text_str, ColorNG);
				else
					TextOutModel.TextOutPfdn(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorC);
			}
			else
			{
				if (val < 1.0 + 1e-7)
					TextOutModel.TextOutPfdn(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorC);
				else
					TextOutModel.TextOutPfdn(text_p.x, text_p.y, text_str, ColorNG);
			}
		}
		TextOutModel.DeleteFont();
	}
	TextOutModel.EndPfdnVal();
}
#endif

#if defined(__OLD_OUTPUT_VALUE)
void CDesignEngine::OutputFireNumbers(CDC *pDC)
{
	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;
	CDBDoc		*pDoc = gm->GetDBDoc();
	int			i, elem_num, slope;
	double		val;
	T_ELEM_K	ekey;
	T_ELEM_D	edata;
	T_RSTL_GB51249_17_D	stdata;
	C3DPoint	node3D_i, node3D_j, DrawPoint;
	CPoint		text_p, node_2d_i, node_2d_j;
	TCHAR		fmt_str[10];
	CString		text_str;
	CFont		ft, *old_ft;
	BOOL		fl_bak, is_inverse;

	CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray <CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					edge_list;
	POSITION pos;

	COLORREF ColorNG;
	ColorNG = RGB(255, 0, 0);

	if (!m_bDsgnDataSet)
		return;

	if (gm->m_DOPT.TX.m_bNumberOpaque)
		pDC->SetBkMode(OPAQUE);
	else
		pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
	pDC->SetBkColor(gm->m_DOPT.TX.m_NumberBackCol);
	pDC->SetTextAlign(TA_CENTER | TA_BOTTOM);

	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);

	BOOL bGrpFltMode = gm->m_pGPSCtrl->IsGroupFilterMode();
	if (!bGrpFltMode)
		elem_num = gm->m_EKeyListActive.GetSize();
	else
		elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize();

	for (i = 0; i < elem_num; i++)
	{
		if (!bGrpFltMode)
			ekey = gm->m_EKeyListActive[i];
		else
			ekey = gm->m_pDispFilter->m_aGrpEKey[i];

		if (!gm->m_pGPSCtrl->IsActiveElem(ekey))
			continue;
		if (!GetFireData(ekey, stdata))
			continue;
		int nElemKind = GetMbtpType(ekey);
		pDoc->m_pAttrCtrl->GetElem(ekey, edata);
		val = CalcFireDataValue(stdata);
		if (m_bCRLmtVal && val < m_dCRLmtVal)
			continue;

		fl_bak = gm->m_DOPT.DR.m_bFrameLine;
		gm->m_DOPT.DR.m_bFrameLine = TRUE;
		gm->GetShapeElement(ekey, polygon_list, &edge_list);
		gm->m_DOPT.DR.m_bFrameLine = fl_bak;

		pos = polygon_list[0]->GetHeadPosition();
		node3D_i = polygon_list[0]->GetNext(pos);
		node3D_j = polygon_list[0]->GetNext(pos);

		for (int j = 0; j < polygon_list.GetSize(); j++)
		{
			polygon_list[j]->RemoveAll();
			delete polygon_list[j];
			edge_list[j]->RemoveAll();
			delete edge_list[j];
		}
		polygon_list.RemoveAll();
		edge_list.RemoveAll();

		if (gm->m_bVirtualMode)
		{
			node_2d_i = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_i);
			node_2d_j = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_j);
		}
		else
		{
			node_2d_i = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_i);
			node_2d_j = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_j);
		}
		if (node_2d_i.x < 0 || node_2d_i.y < 0) continue;
		if (node_2d_j.x < 0 || node_2d_j.y < 0) continue;
		slope = (int)(atan2(node_2d_i.y - node_2d_j.y, node_2d_j.x - node_2d_i.x)*1800.0 / 3.14159);
		slope = (slope + 3600) % 3600;
		if ((900 < slope) && (slope <= 2700)) {
			is_inverse = TRUE;
			slope = (slope + 1800) % 3600;
		}
		else {
			is_inverse = FALSE;
		}

		gm->SetNumberFontOrientation(slope);
		ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
		old_ft = (CFont *)pDC->SelectObject(&ft);

		if (gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
		{
			double dLimit = (m_dMaxValue - m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;

			DrawPoint.x = (int)((node3D_i.x + node3D_j.x) / 2.0);
			DrawPoint.y = (int)((node3D_i.y + node3D_j.y) / 2.0);
			DrawPoint.z = (int)((node3D_i.z + node3D_j.z) / 2.0);

			if (m_DsgnComponent == 5 || m_DsgnComponent == 6)
				pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
			else
			{
				if (val < 1.0) pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
				else          pDC->SetTextColor(ColorNG);
			}

			switch (gm->m_DOPT.TX.m_nOutputMinMaxType)
			{
			case 0: // Min & Max
				if ((m_dMaxValue - val) <= dLimit)
				{
					DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, val);
				}
				else if ((val - m_dMinValue) <= dLimit)
					DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, val);
				break;
			case 1: // Abs Max
				if (fabs(m_dMaxValue) >= fabs(m_dMinValue))
				{
					if (fabs(m_dMaxValue) - fabs(val) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, val);
				}
				else
				{
					if (fabs(m_dMinValue) - fabs(val) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, val);
				}
				break;
			case 2: // Max
				if ((m_dMaxValue - val) <= dLimit)
					DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, val);
				break;
			case 3: // Min
				if ((val - m_dMinValue) <= dLimit)
					DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, val);
				break;
			}

		}
		else
		{
			text_p.x = (int)((node_2d_i.x + node_2d_j.x) / 2.0);
			text_p.y = (int)((node_2d_i.y + node_2d_j.y) / 2.0);
			text_str.Format(fmt_str, val);

			if (m_DsgnComponent == 5 || m_DsgnComponent == 6)
				pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
			else
			{
				if (val < 1.0) pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
				else          pDC->SetTextColor(ColorNG);
			}

			pDC->TextOut(text_p.x, text_p.y, text_str);
		}
		pDC->SelectObject(old_ft);
		ft.DeleteObject();
	}
}
#else
void CDesignEngine::OutputFireNumbers(CDC* pDC)
{
	I_GPSModel* gm = (I_GPSModel*)m_pGPSModel;
	CDBDoc* pDoc = gm->GetDBDoc();
	int			i, elem_num, slope;
	double		val;
	T_ELEM_K	ekey;
	T_ELEM_D	edata;
	T_RSTL_GB51249_17_D	stdata;
	C3DPoint	node3D_i, node3D_j, DrawPoint;
	CPoint		text_p, node_2d_i, node_2d_j;
	TCHAR		fmt_str[10];
	CString		text_str;
	BOOL		fl_bak, is_inverse;

	CArray <CList <C3DPoint, C3DPoint>*, CList <C3DPoint, C3DPoint>*>		polygon_list;
	CArray <CArray <BOOL, BOOL>*, CArray <BOOL, BOOL>*>					edge_list;
	POSITION pos;

	COLORREF ColorNG;
	ColorNG = RGB(255, 0, 0);

	if (!m_bDsgnDataSet)
		return;

	GPostTextOut TextOutModel;
	TextOutModel.SetDC(pDC);
	TextOutModel.StartFireVal();
	TextOutModel.SettingFire(gm);

	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);

	BOOL bGrpFltMode = gm->m_pGPSCtrl->IsGroupFilterMode();
	if (!bGrpFltMode)
		elem_num = gm->m_EKeyListActive.GetSize();
	else
		elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize();

	for (i = 0; i < elem_num; i++)
	{
		if (!bGrpFltMode)
			ekey = gm->m_EKeyListActive[i];
		else
			ekey = gm->m_pDispFilter->m_aGrpEKey[i];

		if (!gm->m_pGPSCtrl->IsActiveElem(ekey))
			continue;
		if (!GetFireData(ekey, stdata))
			continue;
		int nElemKind = GetMbtpType(ekey);
		pDoc->m_pAttrCtrl->GetElem(ekey, edata);
		val = CalcFireDataValue(stdata);
		if (m_bCRLmtVal && val < m_dCRLmtVal)
			continue;

		fl_bak = gm->m_DOPT.DR.m_bFrameLine;
		gm->m_DOPT.DR.m_bFrameLine = TRUE;
		gm->GetShapeElement(ekey, polygon_list, &edge_list);
		gm->m_DOPT.DR.m_bFrameLine = fl_bak;

		pos = polygon_list[0]->GetHeadPosition();
		node3D_i = polygon_list[0]->GetNext(pos);
		node3D_j = polygon_list[0]->GetNext(pos);

		for (int j = 0; j < polygon_list.GetSize(); j++)
		{
			polygon_list[j]->RemoveAll();
			delete polygon_list[j];
			edge_list[j]->RemoveAll();
			delete edge_list[j];
		}
		polygon_list.RemoveAll();
		edge_list.RemoveAll();

		if (gm->m_bVirtualMode)
		{
			node_2d_i = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_i);
			node_2d_j = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_j);
		}
		else
		{
			node_2d_i = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_i);
			node_2d_j = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_j);
		}
		if (node_2d_i.x < 0 || node_2d_i.y < 0) continue;
		if (node_2d_j.x < 0 || node_2d_j.y < 0) continue;
		slope = (int)(atan2(node_2d_i.y - node_2d_j.y, node_2d_j.x - node_2d_i.x) * 1800.0 / 3.14159);
		slope = (slope + 3600) % 3600;
		if ((900 < slope) && (slope <= 2700)) {
			is_inverse = TRUE;
			slope = (slope + 1800) % 3600;
		}
		else {
			is_inverse = FALSE;
		}

		TextOutModel.Font4Fire(gm, slope);

		if (gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
		{
			double dLimit = (m_dMaxValue - m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;

			DrawPoint.x = (int)((node3D_i.x + node3D_j.x) / 2.0);
			DrawPoint.y = (int)((node3D_i.y + node3D_j.y) / 2.0);
			DrawPoint.z = (int)((node3D_i.z + node3D_j.z) / 2.0);

			if (m_DsgnComponent == 5 || m_DsgnComponent == 6)
				TextOutModel.SetColorText(gm->m_DOPT.TX.m_NumberTextColorC);
			else
			{
				if (val < 1.0)
					TextOutModel.SetColorText(gm->m_DOPT.TX.m_NumberTextColorC);
				else
					TextOutModel.SetColorText(ColorNG);
			}

			switch (gm->m_DOPT.TX.m_nOutputMinMaxType)
			{
			case 0: // Min & Max
				if ((m_dMaxValue - val) <= dLimit)
				{
					DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, val);
				}
				else if ((val - m_dMinValue) <= dLimit)
					DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, val);
				break;
			case 1: // Abs Max
				if (fabs(m_dMaxValue) >= fabs(m_dMinValue))
				{
					if (fabs(m_dMaxValue) - fabs(val) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, val);
				}
				else
				{
					if (fabs(m_dMinValue) - fabs(val) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, val);
				}
				break;
			case 2: // Max
				if ((m_dMaxValue - val) <= dLimit)
					DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, val);
				break;
			case 3: // Min
				if ((val - m_dMinValue) <= dLimit)
					DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, val);
				break;
			}

		}
		else
		{
			text_p.x = (int)((node_2d_i.x + node_2d_j.x) / 2.0);
			text_p.y = (int)((node_2d_i.y + node_2d_j.y) / 2.0);
			text_str.Format(fmt_str, val);

			if (m_DsgnComponent == 5 || m_DsgnComponent == 6)
				TextOutModel.TextOutFire(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorC);
			else
			{
				if (val < 1.0)
					TextOutModel.TextOutFire(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorC);
				else
					TextOutModel.TextOutFire(text_p.x, text_p.y, text_str, ColorNG);
			}
		}
		TextOutModel.DeleteFont();
	}
	TextOutModel.EndFireVal();
}
#endif

#if defined(__OLD_OUTPUT_VALUE)
void CDesignEngine::OutputSTLSDNumbers(CDC *pDC)
{
	OutputSTLSDNumbersBdgn(pDC);

	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;
	CDBDoc		*pDoc = gm->GetDBDoc();
	int			i, elem_num, slope;
	double		val;
	T_ELEM_K	ekey;
	T_ELEM_D	edata;
	T_SDRD_D	stdata;
	C3DPoint	node3D_i, node3D_j, DrawPoint;
	CPoint		text_p, node_2d_i, node_2d_j;
	TCHAR		fmt_str[10];
	CString		text_str;
	CFont		ft, *old_ft;
	BOOL		fl_bak, is_inverse;

	CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray <CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					edge_list;
	POSITION pos;

	COLORREF ColorNG;
	ColorNG = RGB(255, 0, 0);

	if (!m_bDsgnDataSet) return;

	if (gm->m_DOPT.TX.m_bNumberOpaque)
		pDC->SetBkMode(OPAQUE);
	else
		pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
	pDC->SetBkColor(gm->m_DOPT.TX.m_NumberBackCol);
	pDC->SetTextAlign(TA_CENTER | TA_BOTTOM);

	if (gm->m_DOPT.TX.m_bNumberExponent) { _stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint); }
	else { _stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint); }

	BOOL bGrpFltMode = gm->m_pGPSCtrl->IsGroupFilterMode();
	if (!bGrpFltMode) { elem_num = gm->m_EKeyListActive.GetSize(); }
	else { elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize(); }

	T_ELEM_K nMElemK;
	for (i = 0; i < elem_num; i++)
	{
		if (!bGrpFltMode)ekey = gm->m_EKeyListActive[i];
		else            ekey = gm->m_pDispFilter->m_aGrpEKey[i];

		if (!gm->m_pGPSCtrl->IsActiveElem(ekey)) continue;

		if (!GetST_LSDData(ekey, stdata))continue;

		val = CalcSTDataValue(stdata);

		pDoc->m_pAttrCtrl->GetElem(ekey, edata);

		if (m_mapBdgnSlMsKey.Lookup(ekey, nMElemK)) continue;

		fl_bak = gm->m_DOPT.DR.m_bFrameLine;
		gm->m_DOPT.DR.m_bFrameLine = TRUE;
		gm->GetShapeElement(ekey, polygon_list, &edge_list);
		gm->m_DOPT.DR.m_bFrameLine = fl_bak;

		pos = polygon_list[0]->GetHeadPosition();
		node3D_i = polygon_list[0]->GetNext(pos);
		node3D_j = polygon_list[0]->GetNext(pos);

		for (int j = 0; j < polygon_list.GetSize(); j++)
		{
			polygon_list[j]->RemoveAll();
			delete polygon_list[j];
			edge_list[j]->RemoveAll();
			delete edge_list[j];
		}
		polygon_list.RemoveAll();
		edge_list.RemoveAll();

		if (gm->m_bVirtualMode)
		{
			node_2d_i = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_i);
			node_2d_j = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_j);
		}
		else
		{
			node_2d_i = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_i);
			node_2d_j = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_j);
		}
		if (node_2d_i.x < 0 || node_2d_i.y < 0) continue;
		if (node_2d_j.x < 0 || node_2d_j.y < 0) continue;
		slope = (int)(atan2(node_2d_i.y - node_2d_j.y, node_2d_j.x - node_2d_i.x)*1800.0 / 3.14159);
		slope = (slope + 3600) % 3600;
		if ((900 < slope) && (slope <= 2700))
		{
			is_inverse = TRUE;
			slope = (slope + 1800) % 3600;
		}
		else
		{
			is_inverse = FALSE;
		}

		gm->SetNumberFontOrientation(slope);
		ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
		old_ft = (CFont *)pDC->SelectObject(&ft);

		text_p.x = (int)((node_2d_i.x + node_2d_j.x) / 2.0);
		text_p.y = (int)((node_2d_i.y + node_2d_j.y) / 2.0);
		text_str.Format(fmt_str, val);

		if (val < 1.0) pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
		else          pDC->SetTextColor(ColorNG);

		pDC->TextOut(text_p.x, text_p.y, text_str);

		pDC->SelectObject(old_ft);
		ft.DeleteObject();
	}
}
#else
void CDesignEngine::OutputSTLSDNumbers(CDC* pDC)
{
	OutputSTLSDNumbersBdgn(pDC);

	I_GPSModel* gm = (I_GPSModel*)m_pGPSModel;
	CDBDoc* pDoc = gm->GetDBDoc();
	int			i, elem_num, slope;
	double		val;
	T_ELEM_K	ekey;
	T_ELEM_D	edata;
	T_SDRD_D	stdata;
	C3DPoint	node3D_i, node3D_j, DrawPoint;
	CPoint		text_p, node_2d_i, node_2d_j;
	TCHAR		fmt_str[10];
	CString		text_str;
	BOOL		fl_bak, is_inverse;

	CArray <CList <C3DPoint, C3DPoint>*, CList <C3DPoint, C3DPoint>*>		polygon_list;
	CArray <CArray <BOOL, BOOL>*, CArray <BOOL, BOOL>*>					edge_list;
	POSITION pos;

	COLORREF ColorNG;
	ColorNG = RGB(255, 0, 0);

	if (!m_bDsgnDataSet) return;

	GPostTextOut TextOutModel;
	TextOutModel.SetDC(pDC);
	TextOutModel.StartSTLSVal();
	TextOutModel.SettingSTLS(gm);

	if (gm->m_DOPT.TX.m_bNumberExponent) { _stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint); }
	else { _stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint); }

	BOOL bGrpFltMode = gm->m_pGPSCtrl->IsGroupFilterMode();
	if (!bGrpFltMode) { elem_num = gm->m_EKeyListActive.GetSize(); }
	else { elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize(); }

	T_ELEM_K nMElemK;
	for (i = 0; i < elem_num; i++)
	{
		if (!bGrpFltMode)ekey = gm->m_EKeyListActive[i];
		else            ekey = gm->m_pDispFilter->m_aGrpEKey[i];

		if (!gm->m_pGPSCtrl->IsActiveElem(ekey)) continue;

		if (!GetST_LSDData(ekey, stdata))continue;

		val = CalcSTDataValue(stdata);

		pDoc->m_pAttrCtrl->GetElem(ekey, edata);

		if (m_mapBdgnSlMsKey.Lookup(ekey, nMElemK)) continue;

		fl_bak = gm->m_DOPT.DR.m_bFrameLine;
		gm->m_DOPT.DR.m_bFrameLine = TRUE;
		gm->GetShapeElement(ekey, polygon_list, &edge_list);
		gm->m_DOPT.DR.m_bFrameLine = fl_bak;

		pos = polygon_list[0]->GetHeadPosition();
		node3D_i = polygon_list[0]->GetNext(pos);
		node3D_j = polygon_list[0]->GetNext(pos);

		for (int j = 0; j < polygon_list.GetSize(); j++)
		{
			polygon_list[j]->RemoveAll();
			delete polygon_list[j];
			edge_list[j]->RemoveAll();
			delete edge_list[j];
		}
		polygon_list.RemoveAll();
		edge_list.RemoveAll();

		if (gm->m_bVirtualMode)
		{
			node_2d_i = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_i);
			node_2d_j = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_j);
		}
		else
		{
			node_2d_i = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_i);
			node_2d_j = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_j);
		}
		if (node_2d_i.x < 0 || node_2d_i.y < 0) continue;
		if (node_2d_j.x < 0 || node_2d_j.y < 0) continue;
		slope = (int)(atan2(node_2d_i.y - node_2d_j.y, node_2d_j.x - node_2d_i.x) * 1800.0 / 3.14159);
		slope = (slope + 3600) % 3600;
		if ((900 < slope) && (slope <= 2700))
		{
			is_inverse = TRUE;
			slope = (slope + 1800) % 3600;
		}
		else
		{
			is_inverse = FALSE;
		}

		TextOutModel.Font4STLS(gm, slope);

		text_p.x = (int)((node_2d_i.x + node_2d_j.x) / 2.0);
		text_p.y = (int)((node_2d_i.y + node_2d_j.y) / 2.0);
		text_str.Format(fmt_str, val);

		if (val < 1.0)
			TextOutModel.TextOutSTLS(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorC);
		else
			TextOutModel.TextOutSTLS(text_p.x, text_p.y, text_str, ColorNG);

		TextOutModel.DeleteFont();
	}
	TextOutModel.EndSTLSVal();
}
#endif

#if defined(__OLD_OUTPUT_VALUE)
void CDesignEngine::OutputCTNumbers(CDC *pDC, BOOL bSRC/*=FALSE*/)
{
	OutputCTNumbersBdgn(pDC, bSRC);

	BOOL		fl_bak, is_inverse;
	int			i, elem_num, slope;
	TCHAR		fmt_str[10];
	double	val, dTmpMax;

	T_ELEM_K	ekey;
	T_ELEM_D	edata;
	T_RCON_D	ctdata;

	C3DPoint	node3D_i, node3D_j, DrawPoint, node3D[4];
	CPoint		text_p, node_2d_i, node_2d_j;
	CString		text_str;
	CFont		  ft, *old_ft;

	CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray <CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					edge_list;
	POSITION pos;

	COLORREF NGColor;
	NGColor = RGB(255, 0, 0);

	I_GPSModel*gm = (I_GPSModel *)m_pGPSModel;
	CDBDoc		*pDoc = gm->GetDBDoc();
	if (!m_bDsgnDataSet)return;

	if (gm->m_DOPT.TX.m_bNumberOpaque)
		pDC->SetBkMode(OPAQUE);
	else
		pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
	pDC->SetBkColor(gm->m_DOPT.TX.m_NumberBackCol);
	pDC->SetTextAlign(TA_CENTER | TA_BOTTOM);

	// 지수형태로 출력인가?
	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);

	BOOL bGrpFltMode = gm->m_pGPSCtrl->IsGroupFilterMode();
	if (!bGrpFltMode)elem_num = gm->m_EKeyListActive.GetSize();
	else            elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize();

	T_ELEM_K nMElemK;
	for (i = 0; i < elem_num; i++)
	{
		if (!bGrpFltMode)ekey = gm->m_EKeyListActive[i];
		else            ekey = gm->m_pDispFilter->m_aGrpEKey[i];

		if (!gm->m_pGPSCtrl->IsActiveElem(ekey))
			continue; // Lable Hidden 처리를 위해 추가 

		//if(!GetCTData(ekey, ctdata))continue;
		BOOL bRtnVal = FALSE;
		if (bSRC) bRtnVal = GetSRCData(ekey, ctdata);
		else     bRtnVal = GetCTData(ekey, ctdata);
		if (!bRtnVal)continue;

		pDoc->m_pAttrCtrl->GetElem(ekey, edata);

		dTmpMax = CalcMaxCTDataValue(ctdata);
		if (m_bCRLmtVal && dTmpMax < m_dCRLmtVal) continue;

		if (m_mapBdgnSlMsKey.Lookup(ekey, nMElemK))
			continue;

		fl_bak = gm->m_DOPT.DR.m_bFrameLine;
		gm->m_DOPT.DR.m_bFrameLine = TRUE;
		gm->GetShapeElement(ekey, polygon_list, &edge_list);
		gm->m_DOPT.DR.m_bFrameLine = fl_bak;

		if (edata.eltyp != WALL_EL)
		{
			pos = polygon_list[0]->GetHeadPosition();
			node3D_i = polygon_list[0]->GetNext(pos);
			node3D_j = polygon_list[0]->GetNext(pos);
		}
		else
		{
			pos = polygon_list[0]->GetHeadPosition();
			node3D[0] = polygon_list[0]->GetNext(pos);
			node3D[1] = polygon_list[0]->GetNext(pos);
			node3D[2] = polygon_list[0]->GetNext(pos);
			node3D[3] = polygon_list[0]->GetNext(pos);

			node3D_i.Set((node3D[0].x + node3D[3].x) / 2.0, (node3D[0].y + node3D[3].y) / 2.0, (node3D[0].z + node3D[3].z) / 2.0);
			node3D_j.Set((node3D[1].x + node3D[2].x) / 2.0, (node3D[1].y + node3D[2].y) / 2.0, (node3D[1].z + node3D[2].z) / 2.0);
		}
		for (int j = 0; j < polygon_list.GetSize(); j++)
		{
			polygon_list[j]->RemoveAll();
			delete polygon_list[j];
			edge_list[j]->RemoveAll();
			delete edge_list[j];
		}
		polygon_list.RemoveAll();
		edge_list.RemoveAll();

		if (gm->m_bVirtualMode)
		{
			node_2d_i = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_i);
			node_2d_j = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_j);
		}
		else
		{
			node_2d_i = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_i);
			node_2d_j = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_j);
		}
		if (node_2d_i.x < 0 || node_2d_i.y < 0) continue;
		if (node_2d_j.x < 0 || node_2d_j.y < 0) continue;
		slope = (int)(atan2(node_2d_i.y - node_2d_j.y, node_2d_j.x - node_2d_i.x)*1800.0 / 3.14159);
		slope = (slope + 3600) % 3600;
		if ((900 < slope) && (slope <= 2700)) {
			is_inverse = TRUE;
			slope = (slope + 1800) % 3600;
		}
		else {
			is_inverse = FALSE;
		}

		gm->SetNumberFontOrientation(slope);
		ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
		old_ft = (CFont *)pDC->SelectObject(&ft);

		if (gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
		{
			double dLimit = (m_dMaxValue - m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;

			for (int n = 0; n < 3; n++)
			{
				if (n == 0) // I단 
				{
					if (!m_bBeamOutputI) continue;
					if (ctdata.nMembType != D_MBTP_BEAM) continue;

					if (is_inverse)
						pDC->SetTextAlign(TA_RIGHT | TA_BOTTOM);
					else
						pDC->SetTextAlign(TA_LEFT | TA_BOTTOM);
					DrawPoint = node3D_i;
					val = CalcCTDataValue(ctdata, 0);

				}
				else if (n == 1)// CNT or MAX or Wall,Truss
				{
					if (!(m_bBeamOutputC || m_bBeamOutputMax) && (ctdata.nMembType == D_MBTP_BEAM)) continue;

					pDC->SetTextAlign(TA_CENTER | TA_BOTTOM);
					DrawPoint.x = (node3D_i.x + node3D_j.x) / 2.0;
					DrawPoint.y = (node3D_i.y + node3D_j.y) / 2.0;
					DrawPoint.z = (node3D_i.z + node3D_j.z) / 2.0;

					if (m_bBeamOutputMax && ctdata.nMembType == D_MBTP_BEAM)
						val = CalcMaxCTDataValue(ctdata);
					else if (m_bBeamOutputC && ctdata.nMembType == D_MBTP_BEAM)
						val = CalcCTDataValue(ctdata, 1);
					else
						val = CalcCTDataValue(ctdata, 0);

				}
				else if (n == 2)// J단 
				{
					if (!m_bBeamOutputJ) continue;
					if (ctdata.nMembType != D_MBTP_BEAM) continue;

					if (is_inverse)
						pDC->SetTextAlign(TA_LEFT | TA_BOTTOM);
					else
						pDC->SetTextAlign(TA_RIGHT | TA_BOTTOM);
					DrawPoint = node3D_j;
					val = CalcCTDataValue(ctdata, 2);
				}


				if (val < 1.0) pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
				else          pDC->SetTextColor(NGColor);
				switch (gm->m_DOPT.TX.m_nOutputMinMaxType)
				{
				case 0: // Min & Max
					if ((m_dMaxValue - val) <= dLimit)
					{
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, val);
					}
					else if ((val - m_dMinValue) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, val);
					break;
				case 1: // Abs Max
					if (fabs(m_dMaxValue) >= fabs(m_dMinValue))
					{
						if (fabs(m_dMaxValue) - fabs(val) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, val);
					}
					else
					{
						if (fabs(m_dMinValue) - fabs(val) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, val);
					}
					break;
				case 2: // Max
					if ((m_dMaxValue - val) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, val);
					break;
				case 3: // Min
					if ((val - m_dMinValue) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, val);
					break;
				}
			}
			//////////////////////////////////////////////////////////////////////////////////////
		}
		else
		{
			if (ctdata.nMembType != D_MBTP_BEAM)
			{
				val = CalcCTDataValue(ctdata, 0);
				text_p.x = (int)((node_2d_i.x + node_2d_j.x) / 2.0);
				text_p.y = (int)((node_2d_i.y + node_2d_j.y) / 2.0);
				text_str.Format(fmt_str, val);

				if (val < 1.0) pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
				else          pDC->SetTextColor(NGColor);
				pDC->TextOut(text_p.x, text_p.y, text_str);
			}
			else
			{
				if (m_bBeamOutputMax)
				{
					val = CalcMaxCTDataValue(ctdata);

					if (val < 1.0) pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
					else          pDC->SetTextColor(NGColor);
					text_p.x = (int)((node_2d_i.x + node_2d_j.x) / 2.0);
					text_p.y = (int)((node_2d_i.y + node_2d_j.y) / 2.0);
					text_str.Format(fmt_str, val);
					pDC->TextOut(text_p.x, text_p.y, text_str);
				}
				else
				{
					if (m_bBeamOutputI)
					{
						val = CalcCTDataValue(ctdata, 0);

						if (val < 1.0) pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorI);
						else          pDC->SetTextColor(NGColor);

						if (is_inverse)pDC->SetTextAlign(TA_RIGHT | TA_BOTTOM);
						else				  pDC->SetTextAlign(TA_LEFT | TA_BOTTOM);

						text_p.x = (int)node_2d_i.x;
						text_p.y = (int)node_2d_i.y;
						text_str.Format(fmt_str, val);
						pDC->TextOut(text_p.x, text_p.y, text_str);
					}
					if (m_bBeamOutputJ)
					{
						val = CalcCTDataValue(ctdata, 2);
						if (val < 1.0) pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorJ);
						else          pDC->SetTextColor(NGColor);
						if (is_inverse) pDC->SetTextAlign(TA_LEFT | TA_BOTTOM);
						else						pDC->SetTextAlign(TA_RIGHT | TA_BOTTOM);

						text_p.x = (int)node_2d_j.x;
						text_p.y = (int)node_2d_j.y;
						text_str.Format(fmt_str, val);
						pDC->TextOut(text_p.x, text_p.y, text_str);
					}
					if (m_bBeamOutputC)
					{
						val = CalcCTDataValue(ctdata, 1);

						if (val < 1.0) pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
						else          pDC->SetTextColor(NGColor);
						pDC->SetTextAlign(TA_CENTER | TA_BOTTOM);

						text_p.x = (int)((node_2d_i.x + node_2d_j.x) / 2.0);
						text_p.y = (int)((node_2d_i.y + node_2d_j.y) / 2.0);
						text_str.Format(fmt_str, val);
						pDC->TextOut(text_p.x, text_p.y, text_str);
					}
				}
			}
		}

		pDC->SelectObject(old_ft);
		ft.DeleteObject();
	}
}
#else
void CDesignEngine::OutputCTNumbers(CDC* pDC, BOOL bSRC/*=FALSE*/)
{
	OutputCTNumbersBdgn(pDC, bSRC);

	BOOL		fl_bak, is_inverse;
	int			i, elem_num, slope;
	TCHAR		fmt_str[10];
	double	val, dTmpMax;

	T_ELEM_K	ekey;
	T_ELEM_D	edata;
	T_RCON_D	ctdata;

	C3DPoint	node3D_i, node3D_j, DrawPoint, node3D[4];
	CPoint		text_p, node_2d_i, node_2d_j;
	CString		text_str;

	CArray <CList <C3DPoint, C3DPoint>*, CList <C3DPoint, C3DPoint>*>		polygon_list;
	CArray <CArray <BOOL, BOOL>*, CArray <BOOL, BOOL>*>					edge_list;
	POSITION pos;

	COLORREF NGColor;
	NGColor = RGB(255, 0, 0);

	I_GPSModel* gm = (I_GPSModel*)m_pGPSModel;
	CDBDoc* pDoc = gm->GetDBDoc();
	if (!m_bDsgnDataSet)return;

	GPostTextOut TextOutModel;
	TextOutModel.SetDC(pDC);
	TextOutModel.StartConcreteVal();
	TextOutModel.SettingConcrete(gm);

	// 지수형태로 출력인가?
	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);

	BOOL bGrpFltMode = gm->m_pGPSCtrl->IsGroupFilterMode();
	if (!bGrpFltMode)elem_num = gm->m_EKeyListActive.GetSize();
	else            elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize();

	T_ELEM_K nMElemK;
	for (i = 0; i < elem_num; i++)
	{
		if (!bGrpFltMode)ekey = gm->m_EKeyListActive[i];
		else            ekey = gm->m_pDispFilter->m_aGrpEKey[i];

		if (!gm->m_pGPSCtrl->IsActiveElem(ekey))
			continue; // Lable Hidden 처리를 위해 추가 

		//if(!GetCTData(ekey, ctdata))continue;
		BOOL bRtnVal = FALSE;
		if (bSRC) bRtnVal = GetSRCData(ekey, ctdata);
		else     bRtnVal = GetCTData(ekey, ctdata);
		if (!bRtnVal)continue;

		pDoc->m_pAttrCtrl->GetElem(ekey, edata);

		dTmpMax = CalcMaxCTDataValue(ctdata);
		if (m_bCRLmtVal && dTmpMax < m_dCRLmtVal) continue;

		if (m_mapBdgnSlMsKey.Lookup(ekey, nMElemK))
			continue;

		fl_bak = gm->m_DOPT.DR.m_bFrameLine;
		gm->m_DOPT.DR.m_bFrameLine = TRUE;
		gm->GetShapeElement(ekey, polygon_list, &edge_list);
		gm->m_DOPT.DR.m_bFrameLine = fl_bak;

		if (edata.eltyp != WALL_EL)
		{
			pos = polygon_list[0]->GetHeadPosition();
			node3D_i = polygon_list[0]->GetNext(pos);
			node3D_j = polygon_list[0]->GetNext(pos);
		}
		else
		{
			pos = polygon_list[0]->GetHeadPosition();
			node3D[0] = polygon_list[0]->GetNext(pos);
			node3D[1] = polygon_list[0]->GetNext(pos);
			node3D[2] = polygon_list[0]->GetNext(pos);
			node3D[3] = polygon_list[0]->GetNext(pos);

			node3D_i.Set((node3D[0].x + node3D[3].x) / 2.0, (node3D[0].y + node3D[3].y) / 2.0, (node3D[0].z + node3D[3].z) / 2.0);
			node3D_j.Set((node3D[1].x + node3D[2].x) / 2.0, (node3D[1].y + node3D[2].y) / 2.0, (node3D[1].z + node3D[2].z) / 2.0);
		}
		for (int j = 0; j < polygon_list.GetSize(); j++)
		{
			polygon_list[j]->RemoveAll();
			delete polygon_list[j];
			edge_list[j]->RemoveAll();
			delete edge_list[j];
		}
		polygon_list.RemoveAll();
		edge_list.RemoveAll();

		if (gm->m_bVirtualMode)
		{
			node_2d_i = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_i);
			node_2d_j = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_j);
		}
		else
		{
			node_2d_i = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_i);
			node_2d_j = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_j);
		}
		if (node_2d_i.x < 0 || node_2d_i.y < 0) continue;
		if (node_2d_j.x < 0 || node_2d_j.y < 0) continue;
		slope = (int)(atan2(node_2d_i.y - node_2d_j.y, node_2d_j.x - node_2d_i.x) * 1800.0 / 3.14159);
		slope = (slope + 3600) % 3600;
		if ((900 < slope) && (slope <= 2700)) {
			is_inverse = TRUE;
			slope = (slope + 1800) % 3600;
		}
		else {
			is_inverse = FALSE;
		}

		TextOutModel.Font4Concrete(gm, slope);

		if (gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
		{
			double dLimit = (m_dMaxValue - m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;

			for (int n = 0; n < 3; n++)
			{
				if (n == 0) // I단 
				{
					if (!m_bBeamOutputI) continue;
					if (ctdata.nMembType != D_MBTP_BEAM) continue;

					if (is_inverse)
						TextOutModel.AlignTextBot(TA_RIGHT);
					else
						TextOutModel.AlignTextBot(TA_LEFT);
					DrawPoint = node3D_i;
					val = CalcCTDataValue(ctdata, 0);

				}
				else if (n == 1)// CNT or MAX or Wall,Truss
				{
					if (!(m_bBeamOutputC || m_bBeamOutputMax) && (ctdata.nMembType == D_MBTP_BEAM)) continue;

					TextOutModel.AlignTextBot(TA_CENTER);
					DrawPoint.x = (node3D_i.x + node3D_j.x) / 2.0;
					DrawPoint.y = (node3D_i.y + node3D_j.y) / 2.0;
					DrawPoint.z = (node3D_i.z + node3D_j.z) / 2.0;

					if (m_bBeamOutputMax && ctdata.nMembType == D_MBTP_BEAM)
						val = CalcMaxCTDataValue(ctdata);
					else if (m_bBeamOutputC && ctdata.nMembType == D_MBTP_BEAM)
						val = CalcCTDataValue(ctdata, 1);
					else
						val = CalcCTDataValue(ctdata, 0);

				}
				else if (n == 2)// J단 
				{
					if (!m_bBeamOutputJ) continue;
					if (ctdata.nMembType != D_MBTP_BEAM) continue;

					if (is_inverse)
						TextOutModel.AlignTextBot(TA_LEFT);
					else
						TextOutModel.AlignTextBot(TA_RIGHT);
					DrawPoint = node3D_j;
					val = CalcCTDataValue(ctdata, 2);
				}


				if (val < 1.0)
					TextOutModel.SetColorText(gm->m_DOPT.TX.m_NumberTextColorC);
				else
					TextOutModel.SetColorText(NGColor);
				switch (gm->m_DOPT.TX.m_nOutputMinMaxType)
				{
				case 0: // Min & Max
					if ((m_dMaxValue - val) <= dLimit)
					{
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, val);
					}
					else if ((val - m_dMinValue) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, val);
					break;
				case 1: // Abs Max
					if (fabs(m_dMaxValue) >= fabs(m_dMinValue))
					{
						if (fabs(m_dMaxValue) - fabs(val) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, val);
					}
					else
					{
						if (fabs(m_dMinValue) - fabs(val) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, val);
					}
					break;
				case 2: // Max
					if ((m_dMaxValue - val) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, val);
					break;
				case 3: // Min
					if ((val - m_dMinValue) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, val);
					break;
				}
			}
			//////////////////////////////////////////////////////////////////////////////////////
		}
		else
		{
			if (ctdata.nMembType != D_MBTP_BEAM)
			{
				val = CalcCTDataValue(ctdata, 0);
				text_p.x = (int)((node_2d_i.x + node_2d_j.x) / 2.0);
				text_p.y = (int)((node_2d_i.y + node_2d_j.y) / 2.0);
				text_str.Format(fmt_str, val);

				if (val < 1.0)
					TextOutModel.TextOutConcrete(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorC);
				else
					TextOutModel.TextOutConcrete(text_p.x, text_p.y, text_str, NGColor);
			}
			else
			{
				if (m_bBeamOutputMax)
				{
					val = CalcMaxCTDataValue(ctdata);
					text_p.x = (int)((node_2d_i.x + node_2d_j.x) / 2.0);
					text_p.y = (int)((node_2d_i.y + node_2d_j.y) / 2.0);
					text_str.Format(fmt_str, val);
					if (val < 1.0)
						TextOutModel.TextOutConcrete(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorC);
					else
						TextOutModel.TextOutConcrete(text_p.x, text_p.y, text_str, NGColor);
				}
				else
				{
					if (m_bBeamOutputI)
					{
						val = CalcCTDataValue(ctdata, 0);

						text_p.x = (int)node_2d_i.x;
						text_p.y = (int)node_2d_i.y;
						text_str.Format(fmt_str, val);
						if (val < 1.0)
						{
							if (is_inverse)
								TextOutModel.TextOutConcrete(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorI, TA_RIGHT);
							else
								TextOutModel.TextOutConcrete(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorI, TA_LEFT);
						}
						else
						{
							if (is_inverse)
								TextOutModel.TextOutConcrete(text_p.x, text_p.y, text_str, NGColor, TA_RIGHT);
							else
								TextOutModel.TextOutConcrete(text_p.x, text_p.y, text_str, NGColor, TA_LEFT);
						}
					}
					if (m_bBeamOutputJ)
					{
						val = CalcCTDataValue(ctdata, 2);

						text_p.x = (int)node_2d_j.x;
						text_p.y = (int)node_2d_j.y;
						text_str.Format(fmt_str, val);
						if (val < 1.0)
						{
							if (is_inverse)
								TextOutModel.TextOutConcrete(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorJ, TA_LEFT);
							else
								TextOutModel.TextOutConcrete(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorJ, TA_RIGHT);
						}
						else
						{
							if (is_inverse)
								TextOutModel.TextOutConcrete(text_p.x, text_p.y, text_str, NGColor, TA_LEFT);
							else
								TextOutModel.TextOutConcrete(text_p.x, text_p.y, text_str, NGColor, TA_RIGHT);
						}
					}
					if (m_bBeamOutputC)
					{
						val = CalcCTDataValue(ctdata, 1);

						text_p.x = (int)((node_2d_i.x + node_2d_j.x) / 2.0);
						text_p.y = (int)((node_2d_i.y + node_2d_j.y) / 2.0);
						text_str.Format(fmt_str, val);
						if (val < 1.0)
							TextOutModel.TextOutConcrete(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorC, TA_CENTER);
						else
							TextOutModel.TextOutConcrete(text_p.x, text_p.y, text_str, NGColor, TA_CENTER);
					}
				}
			}
		}
		TextOutModel.DeleteFont();
	}
	TextOutModel.EndConcreteVal();
}
#endif

void CDesignEngine::OutputSTNumbersBdgn(CDC *pDC)
{
	CGPSDsgnLabel DsgnLabel;

	double	dResult;
	int			i, j, nSlope, nSlp[3];

	COLORREF ColorNG;
	ColorNG = RGB(255, 0, 0);

	T_RSTL_D	stdata;
	T_ELEM_D  ElemD[3];
	T_NODE_D  NodeD[3][2];
	C3DPoint	TextP3D[3], NodeP3D[3][2], DrawPoint;
	CPoint		TextP2D[3], NodeP2D[3][2];
	CString		text_str;

	POSITION nPos;

	I_GPSModel*gm = (I_GPSModel *)m_pGPSModel;
	CDBDoc		*pDoc = gm->GetDBDoc();
	if (!m_bDsgnDataSet)return;

	DsgnLabel.SetDC(pDC);
	DsgnLabel.SetEng((CEngineBase *)this);
	DsgnLabel.SetFont(&(gm->m_NumberFont));
	DsgnLabel.SetColor(gm->m_DOPT.TX.m_NumberTextColorC, gm->m_DOPT.TX.m_NumberBackCol);
	DsgnLabel.SetDcmPnt(gm->m_NumberDecimalPoint);
	DsgnLabel.SetExpnt(gm->m_DOPT.TX.m_bNumberExponent);
	DsgnLabel.SetOpaque(gm->m_DOPT.TX.m_bNumberOpaque);
	DsgnLabel.BgnLabel();

	double    dVal[3];
	T_ELEM_K  nSKey, nMKey;
	CGPSMembCtrl  MembCtrl;
	T_GPS_BDGN_LABEL_D BdgnLblD;
	CMap<T_ELEM_K, T_ELEM_K, T_GPS_BDGN_LABEL_D, T_GPS_BDGN_LABEL_D &> mapBdgnLblD;

	nPos = m_mapBdgnSlMsKey.GetStartPosition();
	while (nPos)
	{
		m_mapBdgnSlMsKey.GetNextAssoc(nPos, nSKey, nMKey);
		if (mapBdgnLblD.Lookup(nMKey, BdgnLblD))continue;

		BOOL bRtnVal = FALSE;
		bRtnVal = GetSTData(nSKey, stdata);

		if (bRtnVal)
		{
			CalcSTDataValueNew(nSKey, dVal[2]);
			dVal[0] = dVal[1] = dVal[2];
		}
		else continue;
		MembCtrl.GetBeamDgnLabelPosVal(nMKey, dVal, BdgnLblD);
		mapBdgnLblD.SetAt(nMKey, BdgnLblD);
	}

	nPos = mapBdgnLblD.GetStartPosition();
	while (nPos)
	{
		mapBdgnLblD.GetNextAssoc(nPos, nMKey, BdgnLblD);
		for (i = 0; i < 3; i++)
			if (!m_pDoc->m_pAttrCtrl->GetElem(BdgnLblD.arElemK[i], ElemD[i])) { ASSERT(FALSE); break; }

		for (i = 0; i < 3; i++)for (j = 0; j < 2; j++)
			if (!m_pDoc->m_pAttrCtrl->GetNode(ElemD[i].elnod[j], NodeD[i][j])) { ASSERT(FALSE); continue; }

		for (i = 0; i < 3; i++)for (j = 0; j < 2; j++)
		{
			NodeP3D[i][j].Set(NodeD[i][j].x, NodeD[i][j].y, NodeD[i][j].z);
			if (gm->m_bVirtualMode)
				NodeP2D[i][j] = gm->m_pGPSCtrl->GetWorldToWindowP2D(NodeP3D[i][j]);
			else
				NodeP2D[i][j] = gm->m_pGPSCtrl->GetWorldToMemDCP2D(NodeP3D[i][j]);
		}

		for (i = 0; i < 3; i++)
		{
			TextP3D[i].Set(BdgnLblD.dXyz[i][0], BdgnLblD.dXyz[i][1], BdgnLblD.dXyz[i][2]);
			if (gm->m_bVirtualMode)
				TextP2D[i] = gm->m_pGPSCtrl->GetWorldToWindowP2D(TextP3D[i]);
			else
				TextP2D[i] = gm->m_pGPSCtrl->GetWorldToMemDCP2D(TextP3D[i]);
		}

		BOOL bContinue = FALSE;
		for (i = 0; i < 3; i++)
			if (TextP2D[i].x < 0 || TextP2D[i].y < 0) bContinue = TRUE;
		if (bContinue)continue;

		for (i = 0; i < 3; i++)
		{
			nSlp[i] = (int)(atan2(NodeP2D[i][0].y - NodeP2D[i][1].y, NodeP2D[i][1].x - NodeP2D[i][0].x)*1800.0 / 3.14159);
			nSlp[i] = (nSlp[i] + 3600) % 3600;
			if ((900 < nSlp[i]) && (nSlp[i] <= 2700))nSlp[i] = (nSlp[i] + 1800) % 3600;
		}

		if (m_pDoc->m_pPostCtrl->StlDgnMgr()->IsCHStlCodeDgn() && m_DsgnComponent >= 8)
		{
			auto pPair = m_mapStlFigData.PLookup(nMKey);
			if (pPair == nullptr) continue;
			nSlope = nSlp[1];
			DrawPoint = TextP3D[1];

			if (m_bStShowDeflection)
			{
				T_ELEM_D edata;	edata.Initialize();
				pDoc->m_pAttrCtrl->GetElem(nMKey, edata);
				T_SECT_D SectD; SectD.Initialize();
				if (!m_pDoc->m_pAttrCtrl->GetSectDesign(edata.elpro, SectD)) continue;
				if (SectD.SectBefore.Shape == D_SECT_SHAPE_REG_UP) continue;

				double dL = stdata.res_dDefLim * stdata.res_dDispLim;
				if (fabs(dL) < 1e-9)
					continue;
				int iMax = 0;
				int nVal = 0;
				if (edata.eltyp == D_MBTP_BEAM)
				{
					iMax = 2;
				}
				else if (edata.eltyp == D_MBTP_COLUMN)
				{
					iMax = fabs(stdata.res_dMaxDisp[0]) >= fabs(stdata.res_dMaxDisp[1]) ? 0 : 1;
				}
				else
				{
					ASSERT(0);
					continue;
				}

				if (fabs(stdata.res_dMaxDisp[iMax]) > 0.0) nVal = (int)CMathFunc::mathRoundOff(fabs(dL / stdata.res_dMaxDisp[iMax]), 1);

				if (fabs(nVal) > 0) text_str.Format(_T("L/%d"), nVal);
				else text_str.Format(_T("%d"), nVal);

				if (fabs(stdata.res_dMaxDisp[iMax]) / stdata.res_dDispLim > 1.0) pDC->SetTextColor(ColorNG);
				else                                                          pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);

				DsgnLabel.DoTextLabel(DrawPoint, text_str, 0, &nSlope);
			}
			/*if ( m_DsgnComponent == 7 )
			{
				text_str.Format(); = pPair->value.strResult_WHRatio;
			}
			else */if (m_DsgnComponent == 8)
			{
				text_str = pPair->value.strResult_SectG;
			}
			else if (m_DsgnComponent == 9)
			{
				text_str = pPair->value.strCompRto;
			}
			else
				continue;

			DsgnLabel.DoTextLabel(DrawPoint, text_str, 0, &nSlope);
		}
		else if (gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
		{
			// Steel 은 여긴 안들어 오는 듯? - 일단 코드 내비둠
			double dLimit = (m_dMaxValue - m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;

			for (int n = 0; n < 3; n++)
			{
				if (n == 0) // I단 
				{
					if (!m_bBeamOutputI)continue;
					nSlope = nSlp[0];
					dResult = BdgnLblD.dVal[0];
					DrawPoint = TextP3D[0];

				}
				else if (n == 1)// CNT or MAX or Wall,Truss
				{
					if (!(m_bBeamOutputC || m_bBeamOutputMax))continue;
					nSlope = nSlp[1];
					dResult = BdgnLblD.dVal[1];
					DrawPoint = TextP3D[1];
				}
				else if (n == 2)// J단 
				{
					if (!m_bBeamOutputJ)continue;
					nSlope = nSlp[2];
					dResult = BdgnLblD.dVal[2];
					DrawPoint = TextP3D[2];
				}

				switch (gm->m_DOPT.TX.m_nOutputMinMaxType)
				{
				case 0: // Min & Max
					if ((m_dMaxValue - dResult) <= dLimit)
					{
						if (dResult < 1.0)
							DsgnLabel.DoMnMxLabel(DrawPoint, dResult, 0, &nSlope);
						else
							DsgnLabel.DoMnMxLabel(DrawPoint, dResult, 0, &nSlope, &(ColorNG));
					}
					else if ((dResult - m_dMinValue) <= dLimit)
					{
						if (dResult < 1.0)
							DsgnLabel.DoMnMxLabel(DrawPoint, dResult, 1, &nSlope);
						else
							DsgnLabel.DoMnMxLabel(DrawPoint, dResult, 1, &nSlope, &(ColorNG));

					}
					break;
				case 1: // Abs Max
					if (fabs(m_dMaxValue) >= fabs(m_dMinValue))
					{
						if (fabs(m_dMaxValue) - fabs(dResult) <= dLimit)
						{
							if (dResult < 1.0)
								DsgnLabel.DoMnMxLabel(DrawPoint, dResult, 2, &nSlope);
							else
								DsgnLabel.DoMnMxLabel(DrawPoint, dResult, 2, &nSlope, &(ColorNG));
						}
					}
					else
					{
						if (fabs(m_dMinValue) - fabs(dResult) <= dLimit)
						{
							if (dResult < 1.0)
								DsgnLabel.DoMnMxLabel(DrawPoint, dResult, 2, &nSlope);
							else
								DsgnLabel.DoMnMxLabel(DrawPoint, dResult, 2, &nSlope, &(ColorNG));
						}
					}
					break;
				case 2: // Max
					if ((m_dMaxValue - dResult) <= dLimit)
					{
						if (dResult < 1.0)
							DsgnLabel.DoMnMxLabel(DrawPoint, dResult, 0, &nSlope);
						else
							DsgnLabel.DoMnMxLabel(DrawPoint, dResult, 0, &nSlope, &(ColorNG));
					}
					break;
				case 3: // Min
					if ((dResult - m_dMinValue) <= dLimit)
					{
						if (dResult < 1.0)
							DsgnLabel.DoMnMxLabel(DrawPoint, dResult, 1, &nSlope);
						else
							DsgnLabel.DoMnMxLabel(DrawPoint, dResult, 1, &nSlope, &(ColorNG));
					}
					break;
				}
			}
		}
		else
		{
			if (m_bBeamOutputMax)
			{
				if (BdgnLblD.GetMaxVal() < 1.0)
					DsgnLabel.DoLabel(TextP2D[1], BdgnLblD.GetMaxVal(), &nSlp[1], &(gm->m_DOPT.TX.m_NumberTextColorC));
				else
					DsgnLabel.DoLabel(TextP2D[1], BdgnLblD.GetMaxVal(), &nSlp[1], &(ColorNG));
			}
			else
			{
				if (m_bBeamOutputI)
				{
					if (BdgnLblD.dVal[0] < 1.0)
						DsgnLabel.DoLabel(TextP2D[0], BdgnLblD.dVal[0], &nSlp[0], &(gm->m_DOPT.TX.m_NumberTextColorI));
					else
						DsgnLabel.DoLabel(TextP2D[0], BdgnLblD.dVal[0], &nSlp[0], &(ColorNG));

				}
				if (m_bBeamOutputJ)
				{
					if (BdgnLblD.dVal[2] < 1.0)
						DsgnLabel.DoLabel(TextP2D[2], BdgnLblD.dVal[2], &nSlp[2], &(gm->m_DOPT.TX.m_NumberTextColorJ));
					else
						DsgnLabel.DoLabel(TextP2D[2], BdgnLblD.dVal[2], &nSlp[2], &(ColorNG));

				}
				if (m_bBeamOutputC)
				{
					if (BdgnLblD.dVal[1] < 1.0)
						DsgnLabel.DoLabel(TextP2D[1], BdgnLblD.dVal[1], &nSlp[1], &(gm->m_DOPT.TX.m_NumberTextColorC));
					else
						DsgnLabel.DoLabel(TextP2D[1], BdgnLblD.dVal[1], &nSlp[1], &(ColorNG));
				}
			}
		}
	}
}

void CDesignEngine::OutputSTLSDNumbersBdgn(CDC *pDC)
{
	CGPSDsgnLabel DsgnLabel;

	int		i, j, nSlp[3];

	COLORREF ColorNG;
	ColorNG = RGB(255, 0, 0);

	T_SDRD_D	stdata;
	T_ELEM_D  ElemD[3];
	T_NODE_D  NodeD[3][2];
	C3DPoint	TextP3D[3], NodeP3D[3][2], DrawPoint;
	CPoint	TextP2D[3], NodeP2D[3][2];
	CString	text_str;

	POSITION nPos;

	I_GPSModel*gm = (I_GPSModel *)m_pGPSModel;
	CDBDoc		*pDoc = gm->GetDBDoc();
	if (!m_bDsgnDataSet)return;

	DsgnLabel.SetDC(pDC);
	DsgnLabel.SetEng((CEngineBase *)this);
	DsgnLabel.SetFont(&(gm->m_NumberFont));
	DsgnLabel.SetColor(gm->m_DOPT.TX.m_NumberTextColorC, gm->m_DOPT.TX.m_NumberBackCol);
	DsgnLabel.SetDcmPnt(gm->m_NumberDecimalPoint);
	DsgnLabel.SetExpnt(gm->m_DOPT.TX.m_bNumberExponent);
	DsgnLabel.SetOpaque(gm->m_DOPT.TX.m_bNumberOpaque);
	DsgnLabel.BgnLabel();

	double    dVal[3];
	T_ELEM_K  nSKey, nMKey;
	CGPSMembCtrl  MembCtrl;
	T_GPS_BDGN_LABEL_D BdgnLblD;
	CMap<T_ELEM_K, T_ELEM_K, T_GPS_BDGN_LABEL_D, T_GPS_BDGN_LABEL_D &> mapBdgnLblD;

	nPos = m_mapBdgnSlMsKey.GetStartPosition();
	while (nPos)
	{
		m_mapBdgnSlMsKey.GetNextAssoc(nPos, nSKey, nMKey);
		if (mapBdgnLblD.Lookup(nMKey, BdgnLblD))continue;

		if (!GetST_LSDData(nSKey, stdata)) continue;

		dVal[0] = dVal[1] = dVal[2] = CalcSTDataValue(stdata);

		MembCtrl.GetBeamDgnLabelPosVal(nMKey, dVal, BdgnLblD);
		mapBdgnLblD.SetAt(nMKey, BdgnLblD);
	}

	nPos = mapBdgnLblD.GetStartPosition();
	while (nPos)
	{
		mapBdgnLblD.GetNextAssoc(nPos, nMKey, BdgnLblD);
		for (i = 0; i < 3; i++)
			if (!m_pDoc->m_pAttrCtrl->GetElem(BdgnLblD.arElemK[i], ElemD[i])) { ASSERT(FALSE); break; }

		for (i = 0; i < 3; i++)for (j = 0; j < 2; j++)
			if (!m_pDoc->m_pAttrCtrl->GetNode(ElemD[i].elnod[j], NodeD[i][j])) { ASSERT(FALSE); continue; }

		for (i = 0; i < 3; i++)for (j = 0; j < 2; j++)
		{
			NodeP3D[i][j].Set(NodeD[i][j].x, NodeD[i][j].y, NodeD[i][j].z);
			if (gm->m_bVirtualMode)
				NodeP2D[i][j] = gm->m_pGPSCtrl->GetWorldToWindowP2D(NodeP3D[i][j]);
			else
				NodeP2D[i][j] = gm->m_pGPSCtrl->GetWorldToMemDCP2D(NodeP3D[i][j]);
		}

		for (i = 0; i < 3; i++)
		{
			TextP3D[i].Set(BdgnLblD.dXyz[i][0], BdgnLblD.dXyz[i][1], BdgnLblD.dXyz[i][2]);
			if (gm->m_bVirtualMode)
				TextP2D[i] = gm->m_pGPSCtrl->GetWorldToWindowP2D(TextP3D[i]);
			else
				TextP2D[i] = gm->m_pGPSCtrl->GetWorldToMemDCP2D(TextP3D[i]);
		}

		BOOL bContinue = FALSE;
		for (i = 0; i < 3; i++)
			if (TextP2D[i].x < 0 || TextP2D[i].y < 0) bContinue = TRUE;
		if (bContinue)continue;

		for (i = 0; i < 3; i++)
		{
			nSlp[i] = (int)(atan2(NodeP2D[i][0].y - NodeP2D[i][1].y, NodeP2D[i][1].x - NodeP2D[i][0].x)*1800.0 / 3.14159);
			nSlp[i] = (nSlp[i] + 3600) % 3600;
			if ((900 < nSlp[i]) && (nSlp[i] <= 2700))nSlp[i] = (nSlp[i] + 1800) % 3600;
		}

		if (BdgnLblD.GetMaxVal() < 1.0)
		{
			DsgnLabel.DoLabel(TextP2D[1], BdgnLblD.GetMaxVal(), &nSlp[1], &(gm->m_DOPT.TX.m_NumberTextColorC));
		}
		else
		{
			DsgnLabel.DoLabel(TextP2D[1], BdgnLblD.GetMaxVal(), &nSlp[1], &(ColorNG));
		}
	}
}


void CDesignEngine::OutputCTNumbersBdgn(CDC *pDC, BOOL bSRC/*=FALSE*/)
{
	CGPSDsgnLabel DsgnLabel;

	double	dResult;
	int			i, j, nSlope, nSlp[3];

	COLORREF ColorNG;
	ColorNG = RGB(255, 0, 0);

	T_RCON_D	ctdata;
	T_ELEM_D  ElemD[3];
	T_NODE_D  NodeD[3][2];
	C3DPoint	TextP3D[3], NodeP3D[3][2], DrawPoint;
	CPoint		TextP2D[3], NodeP2D[3][2];
	CString		text_str;

	POSITION nPos;

	I_GPSModel*gm = (I_GPSModel *)m_pGPSModel;
	CDBDoc		*pDoc = gm->GetDBDoc();
	if (!m_bDsgnDataSet)return;

	DsgnLabel.SetDC(pDC);
	DsgnLabel.SetEng((CEngineBase *)this);
	DsgnLabel.SetFont(&(gm->m_NumberFont));
	DsgnLabel.SetColor(gm->m_DOPT.TX.m_NumberTextColorC, gm->m_DOPT.TX.m_NumberBackCol);
	DsgnLabel.SetDcmPnt(gm->m_NumberDecimalPoint);
	DsgnLabel.SetExpnt(gm->m_DOPT.TX.m_bNumberExponent);
	DsgnLabel.SetOpaque(gm->m_DOPT.TX.m_bNumberOpaque);
	DsgnLabel.BgnLabel();

	double    dVal[3];
	T_ELEM_K  nSKey, nMKey;
	CGPSMembCtrl  MembCtrl;
	T_GPS_BDGN_LABEL_D BdgnLblD;
	CMap<T_ELEM_K, T_ELEM_K, T_GPS_BDGN_LABEL_D, T_GPS_BDGN_LABEL_D &> mapBdgnLblD;

	nPos = m_mapBdgnSlMsKey.GetStartPosition();
	while (nPos)
	{
		m_mapBdgnSlMsKey.GetNextAssoc(nPos, nSKey, nMKey);
		if (mapBdgnLblD.Lookup(nMKey, BdgnLblD))continue;

		BOOL bRtnVal = FALSE;
		if (bSRC) bRtnVal = GetSRCData(nSKey, ctdata);
		else     bRtnVal = GetCTData(nSKey, ctdata);

		if (bRtnVal)
		{
			dVal[0] = CalcCTDataValue(ctdata, 0);
			dVal[1] = CalcCTDataValue(ctdata, 1);
			dVal[2] = CalcCTDataValue(ctdata, 2);
		}
		else continue;
		MembCtrl.GetBeamDgnLabelPosVal(nMKey, dVal, BdgnLblD);
		mapBdgnLblD.SetAt(nMKey, BdgnLblD);
	}

	nPos = mapBdgnLblD.GetStartPosition();
	while (nPos)
	{
		mapBdgnLblD.GetNextAssoc(nPos, nMKey, BdgnLblD);
		for (i = 0; i < 3; i++)
			if (!m_pDoc->m_pAttrCtrl->GetElem(BdgnLblD.arElemK[i], ElemD[i])) { ASSERT(FALSE); break; }

		for (i = 0; i < 3; i++)for (j = 0; j < 2; j++)
			if (!m_pDoc->m_pAttrCtrl->GetNode(ElemD[i].elnod[j], NodeD[i][j])) { ASSERT(FALSE); continue; }

		for (i = 0; i < 3; i++)for (j = 0; j < 2; j++)
		{
			NodeP3D[i][j].Set(NodeD[i][j].x, NodeD[i][j].y, NodeD[i][j].z);
			if (gm->m_bVirtualMode)
				NodeP2D[i][j] = gm->m_pGPSCtrl->GetWorldToWindowP2D(NodeP3D[i][j]);
			else
				NodeP2D[i][j] = gm->m_pGPSCtrl->GetWorldToMemDCP2D(NodeP3D[i][j]);
		}

		for (i = 0; i < 3; i++)
		{
			TextP3D[i].Set(BdgnLblD.dXyz[i][0], BdgnLblD.dXyz[i][1], BdgnLblD.dXyz[i][2]);
			if (gm->m_bVirtualMode)
				TextP2D[i] = gm->m_pGPSCtrl->GetWorldToWindowP2D(TextP3D[i]);
			else
				TextP2D[i] = gm->m_pGPSCtrl->GetWorldToMemDCP2D(TextP3D[i]);
		}

		BOOL bContinue = FALSE;
		for (i = 0; i < 3; i++)
			if (TextP2D[i].x < 0 || TextP2D[i].y < 0) bContinue = TRUE;
		if (bContinue)continue;

		for (i = 0; i < 3; i++)
		{
			nSlp[i] = (int)(atan2(NodeP2D[i][0].y - NodeP2D[i][1].y, NodeP2D[i][1].x - NodeP2D[i][0].x)*1800.0 / 3.14159);
			nSlp[i] = (nSlp[i] + 3600) % 3600;
			if ((900 < nSlp[i]) && (nSlp[i] <= 2700))nSlp[i] = (nSlp[i] + 1800) % 3600;
		}

		if (gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
		{
			double dLimit = (m_dMaxValue - m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;

			for (int n = 0; n < 3; n++)
			{
				if (n == 0) // I단 
				{
					if (!m_bBeamOutputI)continue;
					nSlope = nSlp[0];
					dResult = BdgnLblD.dVal[0];
					DrawPoint = TextP3D[0];

				}
				else if (n == 1)// CNT or MAX or Wall,Truss
				{
					if (!(m_bBeamOutputC || m_bBeamOutputMax))continue;
					nSlope = nSlp[1];
					dResult = BdgnLblD.dVal[1];
					DrawPoint = TextP3D[1];
				}
				else if (n == 2)// J단 
				{
					if (!m_bBeamOutputJ)continue;
					nSlope = nSlp[2];
					dResult = BdgnLblD.dVal[2];
					DrawPoint = TextP3D[2];

				}

				switch (gm->m_DOPT.TX.m_nOutputMinMaxType)
				{
				case 0: // Min & Max
					if ((m_dMaxValue - dResult) <= dLimit)
					{
						if (dResult < 1.0)
							DsgnLabel.DoMnMxLabel(DrawPoint, dResult, 0, &nSlope);
						else
							DsgnLabel.DoMnMxLabel(DrawPoint, dResult, 0, &nSlope, &(ColorNG));
					}
					else if ((dResult - m_dMinValue) <= dLimit)
					{
						if (dResult < 1.0)
							DsgnLabel.DoMnMxLabel(DrawPoint, dResult, 1, &nSlope);
						else
							DsgnLabel.DoMnMxLabel(DrawPoint, dResult, 1, &nSlope, &(ColorNG));

					}
					break;
				case 1: // Abs Max
					if (fabs(m_dMaxValue) >= fabs(m_dMinValue))
					{
						if (fabs(m_dMaxValue) - fabs(dResult) <= dLimit)
						{
							if (dResult < 1.0)
								DsgnLabel.DoMnMxLabel(DrawPoint, dResult, 2, &nSlope);
							else
								DsgnLabel.DoMnMxLabel(DrawPoint, dResult, 2, &nSlope, &(ColorNG));
						}
					}
					else
					{
						if (fabs(m_dMinValue) - fabs(dResult) <= dLimit)
						{
							if (dResult < 1.0)
								DsgnLabel.DoMnMxLabel(DrawPoint, dResult, 2, &nSlope);
							else
								DsgnLabel.DoMnMxLabel(DrawPoint, dResult, 2, &nSlope, &(ColorNG));
						}
					}
					break;
				case 2: // Max
					if ((m_dMaxValue - dResult) <= dLimit)
					{
						if (dResult < 1.0)
							DsgnLabel.DoMnMxLabel(DrawPoint, dResult, 0, &nSlope);
						else
							DsgnLabel.DoMnMxLabel(DrawPoint, dResult, 0, &nSlope, &(ColorNG));
					}
					break;
				case 3: // Min
					if ((dResult - m_dMinValue) <= dLimit)
					{
						if (dResult < 1.0)
							DsgnLabel.DoMnMxLabel(DrawPoint, dResult, 1, &nSlope);
						else
							DsgnLabel.DoMnMxLabel(DrawPoint, dResult, 1, &nSlope, &(ColorNG));
					}
					break;
				}
			}
		}
		else
		{
			if (m_bBeamOutputMax)
			{
				if (BdgnLblD.GetMaxVal() < 1.0)
					DsgnLabel.DoLabel(TextP2D[1], BdgnLblD.GetMaxVal(), &nSlp[1], &(gm->m_DOPT.TX.m_NumberTextColorC));
				else
					DsgnLabel.DoLabel(TextP2D[1], BdgnLblD.GetMaxVal(), &nSlp[1], &(ColorNG));
			}
			else
			{
				if (m_bBeamOutputI)
				{
					if (BdgnLblD.dVal[0] < 1.0)
						DsgnLabel.DoLabel(TextP2D[0], BdgnLblD.dVal[0], &nSlp[0], &(gm->m_DOPT.TX.m_NumberTextColorI));
					else
						DsgnLabel.DoLabel(TextP2D[0], BdgnLblD.dVal[0], &nSlp[0], &(ColorNG));

				}
				if (m_bBeamOutputJ)
				{
					if (BdgnLblD.dVal[2] < 1.0)
						DsgnLabel.DoLabel(TextP2D[2], BdgnLblD.dVal[2], &nSlp[2], &(gm->m_DOPT.TX.m_NumberTextColorJ));
					else
						DsgnLabel.DoLabel(TextP2D[2], BdgnLblD.dVal[2], &nSlp[2], &(ColorNG));

				}
				if (m_bBeamOutputC)
				{
					if (BdgnLblD.dVal[1] < 1.0)
						DsgnLabel.DoLabel(TextP2D[1], BdgnLblD.dVal[1], &nSlp[1], &(gm->m_DOPT.TX.m_NumberTextColorC));
					else
						DsgnLabel.DoLabel(TextP2D[1], BdgnLblD.dVal[1], &nSlp[1], &(ColorNG));
				}
			}
		}
	}
}

#if defined(__OLD_OUTPUT_VALUE)
void CDesignEngine::OutputSRCNumbers(CDC *pDC)
{
	// Concrete와 같은 방식으로 바꾼다 
	OutputCTNumbers(pDC, TRUE);
	return;


	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;
	CDBDoc		*pDoc = gm->GetDBDoc();
	int			i, elem_num, slope;
	double		val;
	T_ELEM_K	ekey;
	T_ELEM_D	edata;
	//T_RSRC_D	srcdata;
	T_RCON_D	srcdata;
	C3DPoint	node3D_i, node3D_j, DrawPoint;
	CPoint		text_p, node_2d_i, node_2d_j;
	TCHAR		fmt_str[10];
	CString		text_str;
	CFont		ft, *old_ft;
	BOOL		fl_bak, is_inverse;
	COLORREF ColorNG;
	ColorNG = RGB(255, 0, 0);

	CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray <CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					edge_list;
	POSITION pos;


	if (!m_bDsgnDataSet)
		return;

	if (gm->m_DOPT.TX.m_bNumberOpaque)
		pDC->SetBkMode(OPAQUE);
	else
		pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
	pDC->SetBkColor(gm->m_DOPT.TX.m_NumberBackCol);
	pDC->SetTextAlign(TA_CENTER | TA_BOTTOM);

	// 지수형태로 출력인가?
	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);

	//elem_num = gm->m_EKeyListActive.GetSize();
	BOOL bGrpFltMode = gm->m_pGPSCtrl->IsGroupFilterMode();
	if (!bGrpFltMode)elem_num = gm->m_EKeyListActive.GetSize();
	else            elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize();

	for (i = 0; i < elem_num; i++)
	{
		//ekey = gm->m_EKeyListActive[i];
		if (!bGrpFltMode)ekey = gm->m_EKeyListActive[i];
		else            ekey = gm->m_pDispFilter->m_aGrpEKey[i];

		if (!gm->m_pGPSCtrl->IsActiveElem(ekey))
			continue; // Lable Hidden 처리를 위해 추가  

		if (!GetSRCData(ekey, srcdata))
			continue;

		//val = CalcSRCDataValue(srcdata);
		val = CalcCTDataValue(srcdata, 0);
		if (m_bCRLmtVal && val < m_dCRLmtVal) // Limit value보다 작으면 그리지 않음 
			continue;

		pDoc->m_pAttrCtrl->GetElem(ekey, edata);
		fl_bak = gm->m_DOPT.DR.m_bFrameLine;
		gm->m_DOPT.DR.m_bFrameLine = TRUE;
		gm->GetShapeElement(ekey, polygon_list, &edge_list);
		gm->m_DOPT.DR.m_bFrameLine = fl_bak;

		pos = polygon_list[0]->GetHeadPosition();
		node3D_i = polygon_list[0]->GetNext(pos);
		node3D_j = polygon_list[0]->GetNext(pos);

		for (int j = 0; j < polygon_list.GetSize(); j++) {
			polygon_list[j]->RemoveAll();
			delete polygon_list[j];
			edge_list[j]->RemoveAll();
			delete edge_list[j];
		}
		polygon_list.RemoveAll();
		edge_list.RemoveAll();


		if (gm->m_bVirtualMode) {
			node_2d_i = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_i);
			node_2d_j = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_j);
		}
		else {
			node_2d_i = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_i);
			node_2d_j = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_j);
		}
		if (node_2d_i.x < 0 || node_2d_i.y < 0) continue;
		if (node_2d_j.x < 0 || node_2d_j.y < 0) continue;
		slope = (int)(atan2(node_2d_i.y - node_2d_j.y, node_2d_j.x - node_2d_i.x)*1800.0 / 3.14159);
		slope = (slope + 3600) % 3600;
		if ((900 < slope) && (slope <= 2700)) {
			is_inverse = TRUE;
			slope = (slope + 1800) % 3600;
		}
		else {
			is_inverse = FALSE;
		}

		gm->SetNumberFontOrientation(slope);
		ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
		old_ft = (CFont *)pDC->SelectObject(&ft);

		if (gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
		{
			double dLimit = (m_dMaxValue - m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;

			DrawPoint.x = (int)((node3D_i.x + node3D_j.x) / 2.0);
			DrawPoint.y = (int)((node3D_i.y + node3D_j.y) / 2.0);
			DrawPoint.z = (int)((node3D_i.z + node3D_j.z) / 2.0);

			text_p.x = (int)((node_2d_i.x + node_2d_j.x) / 2.0);
			text_p.y = (int)((node_2d_i.y + node_2d_j.y) / 2.0);

			if (val < 1.0) pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
			else          pDC->SetTextColor(ColorNG);
			switch (gm->m_DOPT.TX.m_nOutputMinMaxType)
			{
			case 0: // Min & Max
				if ((m_dMaxValue - val) <= dLimit)
					DrawMinMaxOutputValue(pDC, DrawPoint, text_p, fmt_str, 0, val);
				else if ((val - m_dMinValue) <= dLimit)
					DrawMinMaxOutputValue(pDC, DrawPoint, text_p, fmt_str, 1, val);
				break;
			case 1: // Abs Max
				if (fabs(m_dMaxValue) >= fabs(m_dMinValue))
				{
					if (fabs(m_dMaxValue) - fabs(val) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, text_p, fmt_str, 2, val);
				}
				else
				{
					if (fabs(m_dMinValue) - fabs(val) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, text_p, fmt_str, 2, val);
				}
				break;
			case 2: // Max
				if ((m_dMaxValue - val) <= dLimit)
					DrawMinMaxOutputValue(pDC, DrawPoint, text_p, fmt_str, 0, val);
				break;
			case 3: // Min
				if ((val - m_dMinValue) <= dLimit)
					DrawMinMaxOutputValue(pDC, DrawPoint, text_p, fmt_str, 1, val);
				break;
			}

		}
		else
		{
			if (val < 1.0) pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
			else          pDC->SetTextColor(ColorNG);

			text_p.x = (int)((node_2d_i.x + node_2d_j.x) / 2.0);
			text_p.y = (int)((node_2d_i.y + node_2d_j.y) / 2.0);
			text_str.Format(fmt_str, val);
			pDC->TextOut(text_p.x, text_p.y, text_str);
		}

		pDC->SelectObject(old_ft);
		ft.DeleteObject();
	}
}
#else
void CDesignEngine::OutputSRCNumbers(CDC* pDC)
{
	// Concrete와 같은 방식으로 바꾼다 
	OutputCTNumbers(pDC, TRUE);
	return;


	I_GPSModel* gm = (I_GPSModel*)m_pGPSModel;
	CDBDoc* pDoc = gm->GetDBDoc();
	int			i, elem_num, slope;
	double		val;
	T_ELEM_K	ekey;
	T_ELEM_D	edata;
	//T_RSRC_D	srcdata;
	T_RCON_D	srcdata;
	C3DPoint	node3D_i, node3D_j, DrawPoint;
	CPoint		text_p, node_2d_i, node_2d_j;
	TCHAR		fmt_str[10];
	CString		text_str;
	BOOL		fl_bak, is_inverse;
	COLORREF ColorNG;
	ColorNG = RGB(255, 0, 0);

	CArray <CList <C3DPoint, C3DPoint>*, CList <C3DPoint, C3DPoint>*>		polygon_list;
	CArray <CArray <BOOL, BOOL>*, CArray <BOOL, BOOL>*>					edge_list;
	POSITION pos;


	if (!m_bDsgnDataSet)
		return;

	GPostTextOut TextOutModel;
	TextOutModel.SetDC(pDC);
	TextOutModel.StartSRCVal();
	TextOutModel.SettingSRC(gm);

	// 지수형태로 출력인가?
	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);

	//elem_num = gm->m_EKeyListActive.GetSize();
	BOOL bGrpFltMode = gm->m_pGPSCtrl->IsGroupFilterMode();
	if (!bGrpFltMode)elem_num = gm->m_EKeyListActive.GetSize();
	else            elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize();

	for (i = 0; i < elem_num; i++)
	{
		//ekey = gm->m_EKeyListActive[i];
		if (!bGrpFltMode)ekey = gm->m_EKeyListActive[i];
		else            ekey = gm->m_pDispFilter->m_aGrpEKey[i];

		if (!gm->m_pGPSCtrl->IsActiveElem(ekey))
			continue; // Lable Hidden 처리를 위해 추가  

		if (!GetSRCData(ekey, srcdata))
			continue;

		//val = CalcSRCDataValue(srcdata);
		val = CalcCTDataValue(srcdata, 0);
		if (m_bCRLmtVal && val < m_dCRLmtVal) // Limit value보다 작으면 그리지 않음 
			continue;

		pDoc->m_pAttrCtrl->GetElem(ekey, edata);
		fl_bak = gm->m_DOPT.DR.m_bFrameLine;
		gm->m_DOPT.DR.m_bFrameLine = TRUE;
		gm->GetShapeElement(ekey, polygon_list, &edge_list);
		gm->m_DOPT.DR.m_bFrameLine = fl_bak;

		pos = polygon_list[0]->GetHeadPosition();
		node3D_i = polygon_list[0]->GetNext(pos);
		node3D_j = polygon_list[0]->GetNext(pos);

		for (int j = 0; j < polygon_list.GetSize(); j++) {
			polygon_list[j]->RemoveAll();
			delete polygon_list[j];
			edge_list[j]->RemoveAll();
			delete edge_list[j];
		}
		polygon_list.RemoveAll();
		edge_list.RemoveAll();


		if (gm->m_bVirtualMode) {
			node_2d_i = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_i);
			node_2d_j = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_j);
		}
		else {
			node_2d_i = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_i);
			node_2d_j = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_j);
		}
		if (node_2d_i.x < 0 || node_2d_i.y < 0) continue;
		if (node_2d_j.x < 0 || node_2d_j.y < 0) continue;
		slope = (int)(atan2(node_2d_i.y - node_2d_j.y, node_2d_j.x - node_2d_i.x) * 1800.0 / 3.14159);
		slope = (slope + 3600) % 3600;
		if ((900 < slope) && (slope <= 2700)) {
			is_inverse = TRUE;
			slope = (slope + 1800) % 3600;
		}
		else {
			is_inverse = FALSE;
		}

		TextOutModel.Font4SRC(gm, slope);

		if (gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
		{
			double dLimit = (m_dMaxValue - m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;

			DrawPoint.x = (int)((node3D_i.x + node3D_j.x) / 2.0);
			DrawPoint.y = (int)((node3D_i.y + node3D_j.y) / 2.0);
			DrawPoint.z = (int)((node3D_i.z + node3D_j.z) / 2.0);

			text_p.x = (int)((node_2d_i.x + node_2d_j.x) / 2.0);
			text_p.y = (int)((node_2d_i.y + node_2d_j.y) / 2.0);

			if (val < 1.0)
				TextOutModel.SetColorText(gm->m_DOPT.TX.m_NumberTextColorC);
			else
				TextOutModel.SetColorText(ColorNG);
			switch (gm->m_DOPT.TX.m_nOutputMinMaxType)
			{
			case 0: // Min & Max
				if ((m_dMaxValue - val) <= dLimit)
					DrawMinMaxOutputValue(pDC, DrawPoint, text_p, fmt_str, 0, val);
				else if ((val - m_dMinValue) <= dLimit)
					DrawMinMaxOutputValue(pDC, DrawPoint, text_p, fmt_str, 1, val);
				break;
			case 1: // Abs Max
				if (fabs(m_dMaxValue) >= fabs(m_dMinValue))
				{
					if (fabs(m_dMaxValue) - fabs(val) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, text_p, fmt_str, 2, val);
				}
				else
				{
					if (fabs(m_dMinValue) - fabs(val) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, text_p, fmt_str, 2, val);
				}
				break;
			case 2: // Max
				if ((m_dMaxValue - val) <= dLimit)
					DrawMinMaxOutputValue(pDC, DrawPoint, text_p, fmt_str, 0, val);
				break;
			case 3: // Min
				if ((val - m_dMinValue) <= dLimit)
					DrawMinMaxOutputValue(pDC, DrawPoint, text_p, fmt_str, 1, val);
				break;
			}

		}
		else
		{
			text_p.x = (int)((node_2d_i.x + node_2d_j.x) / 2.0);
			text_p.y = (int)((node_2d_i.y + node_2d_j.y) / 2.0);
			text_str.Format(fmt_str, val);
			if (val < 1.0)
				TextOutModel.TextOutSRC(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorC);
			else
				TextOutModel.TextOutSRC(text_p.x, text_p.y, text_str, ColorNG);
		}
		TextOutModel.DeleteFont();
	}
	TextOutModel.EndSRCVal();
}
#endif

BOOL CDesignEngine::ReadConcreteDesignResult(T_ELEM_K elem_key, T_LCOM_K lcom_key, BOOL bMaxMoving, T_RCON_D& ctdata)
{
	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;
	CDBDoc		  *pDoc = gm->GetDBDoc();
	T_ELEM_D    elem_d;

	CDesignResult* pDgnResult = pDoc->m_pPostCtrl->GetDesignResult();
	if (pDgnResult == nullptr) { return FALSE; }

	pDgnResult->SetULSnELS(m_nULSnELS);

	pDoc->m_pAttrCtrl->GetElem(elem_key, elem_d);
	int nElemType = elem_d.eltyp;
	// Modify by GAY. MNET:2683. ('07.05.10). 
	BOOL bCrane = pDoc->m_pAttrCtrl->IsCraneComb(gm->m_LoadCombi);

	if (nElemType == WALL_EL)
	{
		unsigned int nInternalWallId = 0;
		if (!pDoc->m_pPostCtrl->GetInternalWallId(elem_key, nInternalWallId)) return FALSE;
		// Modify by GAY. MNET:2683. ('07.05.12). 
		T_RWAL_D RwalD;
		if (!pDgnResult->GetConcreteDesignResultWall(nInternalWallId, lcom_key, bMaxMoving, bCrane, m_DsgnComponent, RwalD) || !RwalD.bCheck)
		{
			return FALSE;
		}

		ctdata.Initialize();
		pDgnResult->GetConWallResult(m_nULSnELS, RwalD, ctdata);
	}
	else
	{
		// Add by GAY. MNET:2683. ('07.05.12).
		if (!pDgnResult->GetConcreteDesignResult(elem_key, lcom_key, bMaxMoving, bCrane, m_DsgnComponent, ctdata) ||
			!ctdata.bCheck)
			return FALSE;
	}

	return TRUE;

}

void CDesignEngine::DrawMinMaxOutputValue(CDC *pDC, C3DPoint point1, CPoint point2d, TCHAR * fmt_str, int nMaxMin, double dValue)
{
	I_GPSModel						*gm = (I_GPSModel *)m_pGPSModel;
	CDBDoc							*pDoc = gm->GetDBDoc();
	int pos = 0;
	CPoint text_p, node_2d_i, node_2d_j;


	text_p = point2d;
	TCHAR text_str[255];

	// 	text_p.x = (int)((node_2d_i.x + node_2d_j.x) / 2.0);
	// 	text_p.y = (int)((node_2d_i.y + node_2d_j.y) / 2.0);

	if (text_p.x < 0 || text_p.y < 0) return;
	if (nMaxMin == 0) // max
		pos = _stprintf(text_str, _LS(IDS_WG_GPS_Max_));
	else if (nMaxMin == 1) // min
		pos = _stprintf(text_str, _LS(IDS_WG_GPS_Min_));
	else if (nMaxMin == 2) // abs max
		pos = _stprintf(text_str, _LS(IDS_WG_GPS_MAX_));

	_stprintf(text_str + pos, fmt_str, dValue);
	pDC->TextOut(text_p.x, text_p.y, text_str);

	int dc_save = pDC->SaveDC();
	CPen pen;
	pen.CreatePen(PS_SOLID, 2, gm->m_DOPT.TX.m_NumberTextColorNode);
	pDC->SelectObject(&pen);
	if (gm->m_bVirtualMode)
		gm->m_pGPSCtrl->DrawCrossInClientWindow(pDC, point1, 8);
	else
		gm->m_pGPSCtrl->DrawCross(pDC, point1, 8);

	pDC->RestoreDC(dc_save);
}

void CDesignEngine::DrawMinMaxOutputValue(CDC *pDC, C3DPoint point, TCHAR * fmt_str, int nMaxMin, double dValue)
{
	I_GPSModel						*gm = (I_GPSModel *)m_pGPSModel;
	CDBDoc							*pDoc = gm->GetDBDoc();
	int pos = 0;
	CPoint text_p;

	TCHAR text_str[255];
	if (gm->m_bVirtualMode)
		text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(point);
	else
		text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(point);
	if (text_p.x < 0 || text_p.y < 0) return;
	if (nMaxMin == 0) // max
		pos = _stprintf(text_str, _LS(IDS_WG_GPS_Max_));
	else if (nMaxMin == 1) // min
		pos = _stprintf(text_str, _LS(IDS_WG_GPS_Min_));
	else if (nMaxMin == 2) // abs max
		pos = _stprintf(text_str, _LS(IDS_WG_GPS_MAX_));

	_stprintf(text_str + pos, fmt_str, dValue);
	pDC->TextOut(text_p.x, text_p.y, text_str);

	int dc_save = pDC->SaveDC();
	CPen pen;
	pen.CreatePen(PS_SOLID, 2, gm->m_DOPT.TX.m_NumberTextColorNode);
	pDC->SelectObject(&pen);
	if (gm->m_bVirtualMode)
		gm->m_pGPSCtrl->DrawCrossInClientWindow(pDC, point, 8);
	else
		gm->m_pGPSCtrl->DrawCross(pDC, point, 8);

	pDC->RestoreDC(dc_save);

}


void CDesignEngine::ResetEngine()
{
	CEngineBase::ResetEngine();
	m_bDsgnDataSet = FALSE;
	m_DsgnComponent = DESIGN_COMPONENT_RCOMB;
	m_SeisRCPerformComponent_1st = SEIS_RC_PFM_COMP_REPRESENT;
	m_SeisStlPerformComponent_1st = SEIS_STL_PFM_COMP_REPRESENT;
	m_SeisMasonryPerformComponent_1st = SEIS_MASONRY_PFM_COMP_AXIAL;
	m_SeisPerformComponent_2nd = DUTL_FACTOR_ALL;
	m_SeisMasonryPerformComponent_2nd = DUTL_FACTOR_DX;
	m_pContourEngine = NULL;

	m_nDisplayMode = 1; // 0: Performance, 1: Member Status
	m_bCtShowIO = m_bCtShowLS = m_bCtShowCP = m_bCtShowCL = TRUE;

	m_bBeamOutputMax = TRUE;
	m_bBeamOutputAll = FALSE;
	m_bBeamOutputI = FALSE;
	m_bBeamOutputC = FALSE;
	m_bBeamOutputJ = FALSE;
	m_nPunchFlag = 0;

	//m_EccenList.RemoveAll();
	m_EKeyList.RemoveAll();
	m_mapCTData.RemoveAll();
	m_mapSRCData.RemoveAll();
	m_mapSTData.RemoveAll();
	m_mapAluData.RemoveAll();
	m_mapPfdnData.RemoveAll();
	m_mapFireData.RemoveAll();
	m_mapST_LSD_Data.RemoveAll();
	m_mapBdgnSlMsKey.RemoveAll();
	m_mapTendonData.RemoveAll();
	m_mapbBrdgData.RemoveAll();

	m_bCRLmtVal = FALSE;
	m_dCRLmtVal = 1.0;

	m_nDprfComp = DPRF_COMPONENT_TTL;
	m_nDprfType = 0;

	m_bDprfDispLdcSet = FALSE;
	m_bDprfUnitLdcSet = FALSE;

	for (int i = 0; i < 3; i++)
	{
		m_nDprfDispLdc[i] = 0;
		m_nDprfUnitLdc[i] = 0;
	}

	m_bCtReinforce = FALSE;
	m_nCtReinfType = 0;

	m_bCtShowBeam = TRUE;
	m_bCtShowColm = TRUE;
	m_bCtShowBrce = TRUE;
	m_bCtShowWall = TRUE;
	m_bCtShowColmM = TRUE;
	m_bCtShowBrceBeam = TRUE;
	m_bCtShowBrceTrss = TRUE;
	m_bCtShowStrut = TRUE;

	m_bCtRatioAxStrs = TRUE;
	m_bCtMainRebar = TRUE;
	m_bCtShearReinf = TRUE;

	m_nCtOnlyAxialRatio = FALSE;
	m_bCtValExp = FALSE;
	m_nCtValDeciPt = 2;


	m_bStCodeCheck = FALSE;
	m_bStShowBeam = TRUE;
	m_bStShowColm = TRUE;
	m_bStShowBrce = TRUE;
	m_bStShowTruss = TRUE;

	m_bStShowService = FALSE;
	m_bStShowDeflection = TRUE;
	m_bStShowBeam2 = TRUE;
	m_bStShowColm2 = TRUE;

	m_bSRCReinforce = FALSE;
	m_dColmSectScFc = 1.0;


	m_bBeamOutputMaxMin = FALSE;
	m_dCritLineVal = 1.0;
	m_nPSCCode = 0;
	m_nPSCComp = PSC_DSGN_COMP_BEND_Y;
	m_nPSCCirteriaType = 0; //0:Force, 1:Ratio 2:Stress 3:Ratio
	m_nFillType = PSC_DSGN_DGRM_LINE; // Line
	m_dPSCDgrmScFc = 1.0;

	m_nRCCode = 0;
	m_dRCDgrmScFc = 1.0;
	m_dCPGDgrmScFc = 1.0;

	m_mapDgrmData.RemoveAll();

	m_dMaxDgrmVal = 0.0;
	m_dMinDgrmVal = 0.0;
	m_dDgrmAdjustFactor = 1.0;

	m_nDgrmDirType = 1;
	m_nDgrmDirOptn = 0;

	m_bDgrmLineOnly = TRUE;
	m_bDgrmVertLineFill = TRUE;

	m_nResistanceLineCol = RGB(0, 128, 0);
	m_nResistanceLineThk = 2;
	m_bPSCSignPos = TRUE;
	m_bPSCSignNeg = FALSE;

	m_bSTCSignPos = TRUE;
	m_bSTCSignNeg = FALSE;

	m_nPSCPart = 0;
	m_nPSCCompStr = 0;
	m_nPSCPosition = 0;

	m_nPSCCompCH = 0;
	m_nPSCCompJP = 0;

	m_bOutLocalY = TRUE;
	m_bOutLocalZ = TRUE;
	m_bOutMin = TRUE;
	m_nOut = 0;
	m_dAngleVal = 0.f;
	m_bSrchNode = TRUE;
	m_nRatio = 1;
	m_fLimitVal = 1.2f;
	T_DCON_D DconD; // 20081013 mylee - by 김승준
	DconD.Initialize();
	if (m_pDoc && m_pDoc->m_pAttrCtrl->GetDcon(DconD))
	{
		if (DconD.DesignCode == _T("Eurocode2:04"))
		{
			m_fLimitVal = DconD.dStorColmWeakBeamFactor;
		}
		else if (DconD.DesignCode == _T("IS456:2000"))
		{
			m_fLimitVal = 1.4f;
		}
		else if (DconD.DesignCode == _T("NTC-DCEC(2017)"))
		{
			if (DconD.nClass == 0 || DconD.nClass == 1)
				m_fLimitVal = 1.2f;
			else
				m_fLimitVal = 1.0f;
		}
	}
	m_nDirection = 0;

	m_bDC_Max = TRUE;
	m_bDW_MAX = TRUE;
	m_bTemp_Max = TRUE;
	m_nBrdgLoadRateComp = 0;
	m_nRatingRstType = 0;
	m_nSteelRatingRstType = 0;
	m_nSODResultType = 0;
	m_nCPG_ShearConnForceType = 0;
	m_nCPG_RUSResultBeforeAfterType = 1;
	m_nCPG_RUSResultBeforeType = 0;
	m_nCPG_RUSResultAfterType = 0;
	m_nMaxMin = GPS_STEP_NONE;

	m_nRCCompBeam = RC_DSGN_COMP_BEND_Y;
	m_nRCCompColumn = RC_DSGN_COMP_AXIAL;

	m_nSteelCode = 2;
	m_nSteelCodeSub = 0;
	m_nSteelComp = 0;
	m_nSteelCompSub = 0;
	m_nSteelCompCom = 4;

	m_nSteel_Component = 0;
	m_nSteel_Component_Sub = 0;

	m_bSlabDgnResult = TRUE;
	m_nElemAvg = 0;
	m_nPosi = 2;
	m_nElemCell = 0;
	m_nXDirYDir = 0;
	m_nRebarRatio = 2;
	m_nXDType = 0;
	m_nCutPosi = 0;
	m_nUpdateRebar = 0;
	m_nULSnELS = 0;
	if (m_pDoc) m_dCellLength = m_pDoc->m_pUnitCtrl->ConvertTgtUnitData2CurUnit(0, D_UNITSYS_LENGTH_INDEX_M, D_UNITSYS_BASE_LENGTH, 1.0);
	else       m_dCellLength = 1.0;

	m_aRebarAsList.RemoveAll();
	m_aRebarStringList.RemoveAll();
	m_mapSDRData.RemoveAll();
	m_mapStripResData.RemoveAll();
	m_mapSbdoResData.RemoveAll();
	m_mapStripUnbalancedMoment.RemoveAll();
	m_OnewayResPosition.RemoveAll();
	m_OnewaySlabResData.RemoveAll();
	m_OnewaySlabShearResData.RemoveAll();
	m_mSeisPerform.RemoveAll();

	m_bPunchShear = TRUE;
	m_nForceStress = 0;
	m_nAvgElemSide = 0;
	m_nComponent = 1;

	m_nMode = 0;
	m_nStress = 0;
	m_nCrack = 0;
	m_nDeflection = 0;
	m_nAniCrack = 0;
	m_bLongTermDefl = FALSE;
	m_nTimeCreep = 0;
	m_dTimeCreepCoef = 2.0;
	m_bCrackPoint = FALSE;

	m_mapCrackData.RemoveAll();
	m_mapCrackElem.RemoveAll();

	m_nActiveElemCount = 0;
	m_nSumActiveElemNum = 0;
	m_bStripDgnResult = TRUE;
	m_bStripSlabDgnResult = FALSE;
	m_bSeisPerformDataSet = FALSE;

	m_nHingeTimeIndex = 0;
	m_dHingeTimeStep = 0.0;
	m_nSeisFiberMatl = enMatl::ALL;
	m_mapFiberAsValue.clear();
	
	m_nMaterial = 0;
	m_nDispText = 1;
}


BOOL  CDesignEngine::MakeDprfDataList()
{
	if (!m_bDprfDispLdcSet)return FALSE;
	if (!m_bDprfUnitLdcSet)return FALSE;

	CWaitCursor Wait;

	int			i, nElemNum;
	BOOL		bHasData = FALSE;
	double	dMaxVal = -DBL_MAX, dMinVal = DBL_MAX, dVal;
	T_ELEM_K	ElemK;
	T_ELEM_D  ElemD;
	T_GPS_DPRF_D  DprfD;

	I_GPSModel  *gm = (I_GPSModel *)m_pGPSModel;
	CDBDoc		  *pDoc = gm->GetDBDoc();

	m_EKeyList.RemoveAll();
	m_mapDprfData.RemoveAll();

	nElemNum = gm->m_EKeyListActive.GetSize();

	DprfD.Initialize();

	//TEST
	CStfDgnMethod StfDgn;
	double dTotal, dF[3], dM[3];
	CMap<UINT, UINT, double, double> arTotal, arFx, arFy, arFz, arMx, arMy, arMz;

	int nLType = 0;
	if (m_nDprfDispLdc[1] == D_LOADCASE_STATIC)        nLType = 0;
	else if (m_nDprfDispLdc[1] == D_LOADCASE_SPECTRUM) nLType = 1;
	else ASSERT(FALSE);

	//StfDgn.Run_StfDgnMethod(m_nDprfDispLdc[0], m_nDprfUnitLdc[0], m_nDprfType,arTotal,arFx,arFy,arFz,arMx,arMy,arMz);
	StfDgn.Run_StfDgnMethod(m_nDprfDispLdc[0], nLType, m_nDprfUnitLdc[0], m_nDprfType, arTotal, arFx, arFy, arFz, arMx, arMy, arMz);

	for (i = 0; i < nElemNum; i++)
	{
		ElemK = gm->m_EKeyListActive[i];
		m_pDoc->m_pAttrCtrl->GetElem(ElemK, ElemD);

		if (!m_pDoc->m_pAttrCtrl->IsBeam(ElemD.eltyp) &&
			!m_pDoc->m_pAttrCtrl->IsTruss(ElemD.eltyp) &&
			!m_pDoc->m_pAttrCtrl->IsWall(ElemD.eltyp))
		{
			continue;
		}

		switch (m_nDprfType)
		{
		case 0: // Element
			if (!arTotal.Lookup(ElemK, dTotal))continue;
			if (!arFx.Lookup(ElemK, dF[0]))continue;
			if (!arFy.Lookup(ElemK, dF[1]))continue;
			if (!arFz.Lookup(ElemK, dF[2]))continue;
			if (!arMx.Lookup(ElemK, dM[0]))continue;
			if (!arMy.Lookup(ElemK, dM[1]))continue;
			if (!arMz.Lookup(ElemK, dM[2]))continue;

			DprfD.dValue[0] = dTotal;
			DprfD.dValue[1] = dF[0];
			DprfD.dValue[2] = dM[0];
			DprfD.dValue[3] = dM[1];
			DprfD.dValue[4] = dM[2];
			DprfD.dValue[5] = dF[1];
			DprfD.dValue[6] = dF[2];
			break;

		case 1: // Property
			if (m_pDoc->m_pAttrCtrl->IsWall(ElemD.eltyp))continue;
			if (!arTotal.Lookup(ElemD.elpro, dTotal))continue;
			if (!arFx.Lookup(ElemD.elpro, dF[0]))continue;
			if (!arFy.Lookup(ElemD.elpro, dF[1]))continue;
			if (!arFz.Lookup(ElemD.elpro, dF[2]))continue;
			if (!arMx.Lookup(ElemD.elpro, dM[0]))continue;
			if (!arMy.Lookup(ElemD.elpro, dM[1]))continue;
			if (!arMz.Lookup(ElemD.elpro, dM[2]))continue;

			DprfD.dValue[0] = dTotal;
			DprfD.dValue[1] = dF[0];
			DprfD.dValue[2] = dM[0];
			DprfD.dValue[3] = dM[1];
			DprfD.dValue[4] = dM[2];
			DprfD.dValue[5] = dF[1];
			DprfD.dValue[6] = dF[2];
			break;
		}

		dVal = CalcDprfDataVal(DprfD);

		if (dVal > dMaxVal)
		{
			dMaxVal = dVal;
			gm->m_nLgdMaxValKey = ElemK;
		}
		if (dVal < dMinVal)
		{
			dMinVal = dVal;
			gm->m_nLgdMinValKey = ElemK;
		}

		bHasData = TRUE;
		m_EKeyList.Add(ElemK);
		m_mapDprfData.SetAt(ElemK, DprfD);
	}

	if (!bHasData)
	{
		dMinVal = dMaxVal = 0.0;
		gm->m_nLgdMaxValKey = 0;
		gm->m_nLgdMinValKey = 0;
	}

	m_dMaxValue = dMaxVal;
	m_dMinValue = dMinVal;

	if (m_pContourEngine == NULL)
		m_pContourEngine = new CContourEngine(dMinVal, dMaxVal);
	else
		m_pContourEngine->MakeRankMap(dMinVal, dMaxVal);

	m_bDsgnDataSet = TRUE;
	return TRUE;
}

double  CDesignEngine::CalcDprfDataVal(T_GPS_DPRF_D &Data)
{
	if (DPRF_COMPONENT_SHZ < m_nDprfComp)
	{
		ASSERT(FALSE);
		return 0.0;
	}
	return Data.dValue[m_nDprfComp];
}

void	CDesignEngine::DrawDprfContour(CDC *pDC)
{
	I_GPSModel*gm = (I_GPSModel *)m_pGPSModel;
	CDBDoc		*pDoc = gm->GetDBDoc();

	BOOL    bEscapePressed = FALSE;
	int	    i, nElemNum;
	double  dVal[3];
	T_ELEM_D	ElemD;
	T_GPS_DPRF_D DprfD;

	CPen ElemPen, *pOldPen;
	CArray<int, int>	TypeList;
	CArray<GRE_Atom, GRE_Atom&>  AtomList;

	if (!gm->m_bContour) { gm->GPSDrawOriginal(pDC); return; }

	ElemPen.CreatePen(PS_SOLID, gm->m_DOPT.DR.nElemHddn, m_pContourEngine->m_ElemColor);
	pOldPen = (CPen *)pDC->SelectObject(&ElemPen);

	TypeList.Add(gm->m_MinOTID + OBJECT_TYPE_ORIGINAL);
	gm->m_pGPSCtrl->GetZSortedList(TypeList, gm->m_EKeyListVisible, AtomList);

	nElemNum = AtomList.GetSize();
	for (i = 0; i < nElemNum; i++)
	{
		//if(gm->m_pGPSCtrl->WatchEscKeyPress()) bEscapePressed = TRUE;
		if (gm->m_pGPSCtrl->WatchEscKeyPress()) return;
		if (gm->m_pGPSCtrl->IsZoomAllState() ||
			gm->m_pGPSCtrl->IsObjectInClientWindow(AtomList[i].m_OType, AtomList[i].m_OKey))
		{

			if (GetDprfData(AtomList[i].m_OKey, DprfD))
			{
				dVal[0] = dVal[1] = dVal[2] = CalcDprfDataVal(DprfD);
			}
			else
			{
				gm->GPSDrawInactiveElement(pDC, AtomList[i].m_OKey);
				continue;
			}

			pDoc->m_pAttrCtrl->GetElem(AtomList[i].m_OKey, ElemD);
			if (pDoc->m_pAttrCtrl->IsTruss(ElemD.eltyp) && (gm->m_pGPSCtrl->IsActiveElem(AtomList[i].m_OKey)) && !bEscapePressed)
				DoTrussElementContour(pDC, AtomList[i].m_OKey, dVal);
			else if (pDoc->m_pAttrCtrl->IsBeam(ElemD.eltyp) && (gm->m_pGPSCtrl->IsActiveElem(AtomList[i].m_OKey)) && !bEscapePressed)
				DoBeamElementContour(pDC, AtomList[i].m_OKey, dVal);
			else if (pDoc->m_pAttrCtrl->IsWall(ElemD.eltyp) && (gm->m_pGPSCtrl->IsActiveElem(AtomList[i].m_OKey)) && !bEscapePressed)
				DoWallElementContour(pDC, AtomList[i].m_OKey, dVal);
			else
				gm->GPSDrawInactiveElement(pDC, AtomList[i].m_OKey);
		}
	}

	TypeList.RemoveAll();
	AtomList.RemoveAll();

	pDC->SelectObject(pOldPen);
	ElemPen.DeleteObject();
}

#if defined(__OLD_OUTPUT_VALUE)
void	CDesignEngine::OutputDprfNumbers(CDC *pDC)
{
	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;
	CDBDoc		*pDoc = gm->GetDBDoc();
	int			i, elem_num, slope;
	double		val;

	T_ELEM_K	ekey;
	T_ELEM_D	edata;
	T_GPS_DPRF_D DprfD;

	C3DPoint	node3D_i, node3D_j, DrawPoint, node3D[4];
	CPoint		text_p, node_2d_i, node_2d_j;
	TCHAR		fmt_str[10];		fmt_str[10];
	CString		text_str;
	CFont		ft, *old_ft;
	BOOL		fl_bak, is_inverse;

	CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray <CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					edge_list;
	POSITION pos;


	if (!m_bDsgnDataSet)return;

	if (gm->m_DOPT.TX.m_bNumberOpaque)pDC->SetBkMode(OPAQUE);
	else  pDC->SetBkMode(TRANSPARENT);

	pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
	pDC->SetBkColor(gm->m_DOPT.TX.m_NumberBackCol);
	pDC->SetTextAlign(TA_CENTER | TA_BOTTOM);

	// 지수형태로 출력인가?
	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);

	BOOL bGrpFltMode = gm->m_pGPSCtrl->IsGroupFilterMode();
	if (!bGrpFltMode)elem_num = gm->m_EKeyListActive.GetSize();
	else            elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize();

	for (i = 0; i < elem_num; i++)
	{
		if (!bGrpFltMode)ekey = gm->m_EKeyListActive[i];
		else            ekey = gm->m_pDispFilter->m_aGrpEKey[i];

		if (!gm->m_pGPSCtrl->IsActiveElem(ekey))
			continue; // Lable Hidden 처리를 위해 추가 

		if (!GetDprfData(ekey, DprfD))continue;

		pDoc->m_pAttrCtrl->GetElem(ekey, edata);
		fl_bak = gm->m_DOPT.DR.m_bFrameLine;
		gm->m_DOPT.DR.m_bFrameLine = TRUE;
		gm->GetShapeElement(ekey, polygon_list, &edge_list);
		gm->m_DOPT.DR.m_bFrameLine = fl_bak;

		if (edata.eltyp != WALL_EL)
		{
			pos = polygon_list[0]->GetHeadPosition();
			node3D_i = polygon_list[0]->GetNext(pos);
			node3D_j = polygon_list[0]->GetNext(pos);
		}
		else
		{
			pos = polygon_list[0]->GetHeadPosition();
			node3D[0] = polygon_list[0]->GetNext(pos);
			node3D[1] = polygon_list[0]->GetNext(pos);
			node3D[2] = polygon_list[0]->GetNext(pos);
			node3D[3] = polygon_list[0]->GetNext(pos);

			node3D_i.Set((node3D[0].x + node3D[3].x) / 2.0, (node3D[0].y + node3D[3].y) / 2.0, (node3D[0].z + node3D[3].z) / 2.0);
			node3D_j.Set((node3D[1].x + node3D[2].x) / 2.0, (node3D[1].y + node3D[2].y) / 2.0, (node3D[1].z + node3D[2].z) / 2.0);
		}
		for (int j = 0; j < polygon_list.GetSize(); j++)
		{
			polygon_list[j]->RemoveAll();
			delete polygon_list[j];
			edge_list[j]->RemoveAll();
			delete edge_list[j];
		}
		polygon_list.RemoveAll();
		edge_list.RemoveAll();

		if (gm->m_bVirtualMode)
		{
			node_2d_i = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_i);
			node_2d_j = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_j);
		}
		else
		{
			node_2d_i = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_i);
			node_2d_j = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_j);
		}
		if (node_2d_i.x < 0 || node_2d_i.y < 0) continue;
		if (node_2d_j.x < 0 || node_2d_j.y < 0) continue;

		slope = (int)(atan2(node_2d_i.y - node_2d_j.y, node_2d_j.x - node_2d_i.x)*1800.0 / 3.14159);
		slope = (slope + 3600) % 3600;
		if ((900 < slope) && (slope <= 2700))
		{
			is_inverse = TRUE;
			slope = (slope + 1800) % 3600;
		}
		else
		{
			is_inverse = FALSE;
		}

		gm->SetNumberFontOrientation(slope);
		ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
		old_ft = (CFont *)pDC->SelectObject(&ft);


		val = CalcDprfDataVal(DprfD);

		pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
		pDC->SetTextAlign(TA_CENTER | TA_BOTTOM);

		text_p.x = (int)((node_2d_i.x + node_2d_j.x) / 2.0);
		text_p.y = (int)((node_2d_i.y + node_2d_j.y) / 2.0);
		text_str.Format(fmt_str, val);
		pDC->TextOut(text_p.x, text_p.y, text_str);

		pDC->SelectObject(old_ft);
		ft.DeleteObject();
	}
}
#else
void	CDesignEngine::OutputDprfNumbers(CDC* pDC)
{
	I_GPSModel* gm = (I_GPSModel*)m_pGPSModel;
	CDBDoc* pDoc = gm->GetDBDoc();
	int			i, elem_num, slope;
	double		val;

	T_ELEM_K	ekey;
	T_ELEM_D	edata;
	T_GPS_DPRF_D DprfD;

	C3DPoint	node3D_i, node3D_j, DrawPoint, node3D[4];
	CPoint		text_p, node_2d_i, node_2d_j;
	TCHAR		fmt_str[10];		fmt_str[10];
	CString		text_str;
	
	BOOL		fl_bak, is_inverse;

	CArray <CList <C3DPoint, C3DPoint>*, CList <C3DPoint, C3DPoint>*>		polygon_list;
	CArray <CArray <BOOL, BOOL>*, CArray <BOOL, BOOL>*>					edge_list;
	POSITION pos;


	if (!m_bDsgnDataSet)return;

	GPostTextOut TextOutModel;
	TextOutModel.SetDC(pDC);
	TextOutModel.StartDprfVal();
	TextOutModel.SettingDprf(gm);

	// 지수형태로 출력인가?
	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);

	BOOL bGrpFltMode = gm->m_pGPSCtrl->IsGroupFilterMode();
	if (!bGrpFltMode)elem_num = gm->m_EKeyListActive.GetSize();
	else            elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize();

	for (i = 0; i < elem_num; i++)
	{
		if (!bGrpFltMode)ekey = gm->m_EKeyListActive[i];
		else            ekey = gm->m_pDispFilter->m_aGrpEKey[i];

		if (!gm->m_pGPSCtrl->IsActiveElem(ekey))
			continue; // Lable Hidden 처리를 위해 추가 

		if (!GetDprfData(ekey, DprfD))continue;

		pDoc->m_pAttrCtrl->GetElem(ekey, edata);
		fl_bak = gm->m_DOPT.DR.m_bFrameLine;
		gm->m_DOPT.DR.m_bFrameLine = TRUE;
		gm->GetShapeElement(ekey, polygon_list, &edge_list);
		gm->m_DOPT.DR.m_bFrameLine = fl_bak;

		if (edata.eltyp != WALL_EL)
		{
			pos = polygon_list[0]->GetHeadPosition();
			node3D_i = polygon_list[0]->GetNext(pos);
			node3D_j = polygon_list[0]->GetNext(pos);
		}
		else
		{
			pos = polygon_list[0]->GetHeadPosition();
			node3D[0] = polygon_list[0]->GetNext(pos);
			node3D[1] = polygon_list[0]->GetNext(pos);
			node3D[2] = polygon_list[0]->GetNext(pos);
			node3D[3] = polygon_list[0]->GetNext(pos);

			node3D_i.Set((node3D[0].x + node3D[3].x) / 2.0, (node3D[0].y + node3D[3].y) / 2.0, (node3D[0].z + node3D[3].z) / 2.0);
			node3D_j.Set((node3D[1].x + node3D[2].x) / 2.0, (node3D[1].y + node3D[2].y) / 2.0, (node3D[1].z + node3D[2].z) / 2.0);
		}
		for (int j = 0; j < polygon_list.GetSize(); j++)
		{
			polygon_list[j]->RemoveAll();
			delete polygon_list[j];
			edge_list[j]->RemoveAll();
			delete edge_list[j];
		}
		polygon_list.RemoveAll();
		edge_list.RemoveAll();

		if (gm->m_bVirtualMode)
		{
			node_2d_i = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_i);
			node_2d_j = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_j);
		}
		else
		{
			node_2d_i = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_i);
			node_2d_j = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_j);
		}
		if (node_2d_i.x < 0 || node_2d_i.y < 0) continue;
		if (node_2d_j.x < 0 || node_2d_j.y < 0) continue;

		slope = (int)(atan2(node_2d_i.y - node_2d_j.y, node_2d_j.x - node_2d_i.x) * 1800.0 / 3.14159);
		slope = (slope + 3600) % 3600;
		if ((900 < slope) && (slope <= 2700))
		{
			is_inverse = TRUE;
			slope = (slope + 1800) % 3600;
		}
		else
		{
			is_inverse = FALSE;
		}

		TextOutModel.Font4Dprf(gm, slope);

		val = CalcDprfDataVal(DprfD);

		text_p.x = (int)((node_2d_i.x + node_2d_j.x) / 2.0);
		text_p.y = (int)((node_2d_i.y + node_2d_j.y) / 2.0);
		text_str.Format(fmt_str, val);
		TextOutModel.TextOutDprf(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorC, TA_CENTER);

		TextOutModel.DeleteFont();
	}
	TextOutModel.EndDprfVal();
}
#endif

// ekey가 Master Node Key
// 
int CDesignEngine::GetMbtpType(int ekey)
{
	////////////////////////////////////////////////////////////////////////////////////////////
	// member type
	//#define D_MBTP_COLUMN  1
	//#define D_MBTP_BEAM    2
	//#define D_MBTP_BRACE   3
	//1=column(수직-1/100 오차허용), 2=beam(수평-1/100 오차허용), 3=brace 0=Frame 요소가 아닐때
	////////////////////////////////////////////////////////////////////////////////////////////

	int nType;
	if (m_pDoc->m_pAttrCtrl->ExistMbtp(ekey))
	{
		T_MBTP_D rData;
		rData.Initialize();
		m_pDoc->m_pAttrCtrl->GetMbtp(ekey, rData);							// 사용자 정의방식
		nType = rData.nMbType;
	}
	else	nType = m_pDoc->m_pAttrCtrl->GetMemberType(ekey);	// 일반적인 방식

	return nType;
}

//KYE-HONG-20020330
//임시로 만든기능이다 
/*
void CDesignEngine::MakeDispOptDataList(CArray<T_ELEM_K,T_ELEM_K> &arElemK,CArray<double,double> &arElemD)
{
I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
CDBDoc		*pDoc=gm->GetDBDoc();
int			i, elem_num;
BOOL		  has_content = FALSE;
double		max_val=-DBL_MAX, min_val=DBL_MAX, len;
T_RSTL_D	stdata;

gm->m_pMyView->BeginWaitCursor();

m_EKeyList.RemoveAll();
m_mapSTData.RemoveAll();
m_mapCTData.RemoveAll();
m_mapSRCData.RemoveAll();
m_mapBdgnSlMsKey.RemoveAll();

elem_num = arElemK.GetSize();
m_EKeyList.Copy(arElemK);

for(i=0; i<elem_num; i++)
{
stdata.Initialize();
stdata.dblCodeRatio[0]=arElemD[i];
m_mapSTData.SetAt(arElemK[i],stdata);
len=arElemD[i];

if (len > max_val) {
max_val = len;
}
if (len < min_val) {
min_val = len;
}
has_content = TRUE;
}

if (!has_content) {
min_val = max_val = 0.0;
}

m_dMaxValue = max_val;
m_dMinValue = min_val;

if (m_pContourEngine == NULL)
m_pContourEngine = new CContourEngine(min_val, max_val);
else
m_pContourEngine->MakeRankMap(min_val, max_val);

gm->m_pMyView->EndWaitCursor();

m_bDsgnDataSet = TRUE;
}
*/


//----------------------------------------------------------------------------------------
// INIT : 2006.01.10. by KYE-HONG
// FUNC : PSC Beam Design 결과값을 Diagram그리기 위한 데이터로 변환함 
//----------------------------------------------------------------------------------------
void    CDesignEngine::MakePscDsgnDgrmDataList()
{
	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;
	m_bDsgnDataSet = TRUE;  // 무조건 TRUE로 해야 결과가 없어도 요소가 Wire Frame으로 출력된다 
	CDBDoc *pDoc = CDBDoc::GetDocPoint();
	BOOL bHasData = FALSE;

	m_dMaxDgrmVal = -DBL_MAX;
	m_dMinDgrmVal = DBL_MAX;
	m_mapDgrmData.RemoveAll();
	m_mapDgrmData.InitHashTable(1001);
	m_EKeyList.RemoveAll();
	m_mapTendonData.RemoveAll();
	m_mapbBrdgData.RemoveAll();

	int nElemNum;
	T_ELEM_K ElemK;

	nElemNum = gm->m_EKeyListActive.GetSize();

	int nKeyNum = 0;
	UINT Key1[PSC_DSGN_TYPE_KEY_NUM];

	Key1[0] = Key1[1] = Key1[2] = Key1[3] = PSC_DSGN_NULL_KEY;
	if (m_bPSCSignPos)
	{
		Key1[PSC_DSGN_STRG_MAX_KEY] = PSC_DSGN_STRG_MAX_KEY;
		Key1[PSC_DSGN_CRIT_MAX_KEY] = PSC_DSGN_CRIT_MAX_KEY;
	}
	if (m_bPSCSignNeg)
	{
		Key1[PSC_DSGN_STRG_MIN_KEY] = PSC_DSGN_STRG_MIN_KEY;
		Key1[PSC_DSGN_CRIT_MIN_KEY] = PSC_DSGN_CRIT_MIN_KEY;
	}

	T_CMAP_K2<UINT> mKey;
	T_PSC_DSGN_RESL_D ReslD[4];

	if (m_bPSCSignPos || m_bPSCSignNeg)
		for (int i = 0; i < nElemNum; i++)
		{
			ElemK = gm->m_EKeyListActive[i];
			if (!CDBLib::IsPscDgnFor1st(ElemK, FALSE))continue;

			for (int j = 0; j < 4; j++)ReslD[j].Initialize();

			switch (m_nPSCCode)
			{
			case PSC_DSGN_CODE_KR:  if (!MakePscDsgnDgrmDataKR(ElemK, ReslD))continue;   break;
			case PSC_DSGN_CODE_JP:  if (!MakePscDsgnDgrmDataJP(ElemK, ReslD))continue;   break;
			case PSC_DSGN_CODE_CH:  if (!MakePscDsgnDgrmDataCH(ElemK, ReslD))continue;   break;
			}

			SetDgrmVector(ElemK, ReslD);
			m_EKeyList.Add(ElemK);
			bHasData = TRUE;


			double dMnVal = 0.0, dMxVal = 0.0;
			for (int j = 0; j < 4; j++)
			{
				if (Key1[j] == PSC_DSGN_NULL_KEY)continue;

				ReslD[j].GetMxMnVal(dMxVal, dMnVal);
				m_dMaxDgrmVal = max(m_dMaxDgrmVal, dMxVal);
				m_dMinDgrmVal = min(m_dMinDgrmVal, dMnVal);

				mKey.i1 = ElemK;
				mKey.i2 = Key1[j];
				m_mapDgrmData.SetAt(mKey, ReslD[j]);
			}
		}

	if (!bHasData)
	{
		m_dMaxDgrmVal = 0.0;
		m_dMinDgrmVal = 0.0;
		return;
	}

	if (fabs(m_dMaxDgrmVal) < fabs(m_dMinDgrmVal))
		InitDiagramAdjustFactor(m_dMinDgrmVal);
	else
		InitDiagramAdjustFactor(m_dMaxDgrmVal);

	if (m_pContourEngine == NULL)
		m_pContourEngine = new CContourEngine(m_dMinDgrmVal, m_dMaxDgrmVal);
	else
		m_pContourEngine->MakeRankMap(m_dMinDgrmVal, m_dMaxDgrmVal);
	m_bDsgnDataSet = TRUE;
}


void CDesignEngine::MakeSODList()
{
	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;
	m_bDsgnDataSet = TRUE;  // 무조건 TRUE로 해야 결과가 없어도 요소가 Wire Frame으로 출력된다 
	CDBDoc *pDoc = CDBDoc::GetDocPoint();
	BOOL bHasData = FALSE;

	m_dMaxDgrmVal = -DBL_MAX;
	m_dMinDgrmVal = DBL_MAX;
	m_mapDgrmData.RemoveAll();
	m_mapDgrmData.InitHashTable(1001);
	m_EKeyList.RemoveAll();
	m_mapTendonData.RemoveAll();
	m_mapbBrdgData.RemoveAll();

	int nElemNum;
	T_ELEM_K ElemK;

	nElemNum = gm->m_EKeyListActive.GetSize();

	int nKeyNum = 0;
	UINT Key1[PSC_DSGN_TYPE_KEY_NUM];

	Key1[0] = Key1[1] = Key1[2] = Key1[3] = PSC_DSGN_NULL_KEY;
	if (m_bPSCSignPos)
	{
		Key1[PSC_DSGN_STRG_MAX_KEY] = PSC_DSGN_STRG_MAX_KEY;
		Key1[PSC_DSGN_CRIT_MAX_KEY] = PSC_DSGN_CRIT_MAX_KEY;
	}
	if (m_bPSCSignNeg)
	{
		Key1[PSC_DSGN_STRG_MIN_KEY] = PSC_DSGN_STRG_MIN_KEY;
		Key1[PSC_DSGN_CRIT_MIN_KEY] = PSC_DSGN_CRIT_MIN_KEY;
	}

	T_CMAP_K2<UINT> mKey;
	T_PSC_DSGN_RESL_D ReslD[4];

	T_SECT_D SectD; SectD.Initialize();
	T_ELEM_D ElemD; ElemD.Initialize();

	//if(m_bPSCSignPos || m_bPSCSignNeg)
	for (int i = 0; i < nElemNum; i++)
	{
		ElemK = gm->m_EKeyListActive[i];

		SectD.Initialize();
		ElemD.Initialize();
		if (!m_pDoc->m_pAttrCtrl->GetElem(ElemK, ElemD)) continue;
		if (!m_pDoc->m_pAttrCtrl->GetSect(ElemD.elpro, SectD)) continue;
		if (SectD.nStype != D_SECT_TYPE_STLG_B && SectD.nStype != D_SECT_TYPE_STLG_I) continue;

		for (int j = 0; j < 4; j++)ReslD[j].Initialize();

		if (!SODDgrmData(ElemK, ReslD))continue; //

		SetDgrmVector(ElemK, ReslD);
		m_EKeyList.Add(ElemK);
		bHasData = TRUE;


		double dMnVal = 0.0, dMxVal = 0.0;
		for (int j = 0; j < 4; j++)
		{
			if (Key1[j] == PSC_DSGN_NULL_KEY)continue;

			ReslD[j].GetMxMnVal(dMxVal, dMnVal);
			m_dMaxDgrmVal = max(m_dMaxDgrmVal, dMxVal);
			m_dMinDgrmVal = min(m_dMinDgrmVal, dMnVal);

			mKey.i1 = ElemK;
			mKey.i2 = Key1[j];
			m_mapDgrmData.SetAt(mKey, ReslD[j]);
		}
	}

	if (!bHasData)
	{
		m_dMaxDgrmVal = 0.0;
		m_dMinDgrmVal = 0.0;
		return;
	}

	if (fabs(m_dMaxDgrmVal) < fabs(m_dMinDgrmVal))
		InitDiagramAdjustFactor(m_dMinDgrmVal);
	else
		InitDiagramAdjustFactor(m_dMaxDgrmVal);

	if (m_pContourEngine == NULL)
		m_pContourEngine = new CContourEngine(m_dMinDgrmVal, m_dMaxDgrmVal);
	else
		m_pContourEngine->MakeRankMap(m_dMinDgrmVal, m_dMaxDgrmVal);
	m_bDsgnDataSet = TRUE;
}

BOOL CDesignEngine::SODDgrmData(T_ELEM_K ElemK, T_PSC_DSGN_RESL_D RsltD[4])
{
	CDBDoc *pDoc = CDBDoc::GetDocPoint();
	BOOL bCheckIMax = FALSE, bCheckIMin = FALSE, bCheckJMax = FALSE, bCheckJMin = FALSE;

	//******************************************************************
	// SOD
	//******************************************************************
	double dValI = 0.0, dValJ = 0.0;
	BOOL bCheckI = FALSE, bCheckJ = FALSE;
	BOOL bCalcSuccess = TRUE;

	switch (m_nSODResultType)
	{
	case 0: // Strength -Top
		if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetSODStrength_FlangeMaxResult_Contour(0, ElemK, bCheckI, bCheckJ, dValI, dValJ))
		{
			bCalcSuccess = FALSE;
		}
		break;
	case 1: // Strength -Bottom
		if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetSODStrength_FlangeMaxResult_Contour(1, ElemK, bCheckI, bCheckJ, dValI, dValJ))
		{
			bCalcSuccess = FALSE;
		}
		break;
	case 2: // Strength -Web
	{
		BOOL bCalcSuccessTemp1 = TRUE, bCalcSuccessTemp2 = TRUE;
		BOOL bCheckI01 = FALSE, bCheckJ01 = FALSE, bCheckI02 = FALSE, bCheckJ02 = FALSE;
		double dValI01 = 0.0, dValJ01 = 0.0, dValI02 = 0.0, dValJ02 = 0.0;
		// Left
		if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetSODStrength_WebMaxResult_Contour(ElemK, bCheckI01, bCheckJ01, dValI01, dValJ01)) bCalcSuccessTemp1 = FALSE;
		// Right
		if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetSODStrength_WebMaxResult_Contour_Right(ElemK, bCheckI02, bCheckJ02, dValI02, dValJ02)) bCalcSuccessTemp2 = FALSE;

		bCalcSuccess = (!bCalcSuccessTemp1 && !bCalcSuccessTemp1) ? FALSE : TRUE;
		bCheckI = (!bCheckI01 && !bCheckI02) ? FALSE : TRUE;
		bCheckJ = (!bCheckJ01 && !bCheckJ02) ? FALSE : TRUE;
		dValI = max(dValI01, dValI02);
		dValJ = max(dValJ01, dValJ02);

		break;
	}
	case 3: // Stability -Global Stability
		if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetSODStability_GlobalDeckMaxResult_Contour(ElemK, bCheckI, bCheckJ, dValI, dValJ))
		{
			bCalcSuccess = FALSE;
		}
		break;
	case 4: // Stability -Top
		if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetSODStability_FlangeMaxResult_Contour(0, ElemK, bCheckI, bCheckJ, dValI, dValJ))
		{
			bCalcSuccess = FALSE;
		}
		break;
	case 5: // Stability -Bottom
		if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetSODStability_FlangeMaxResult_Contour(1, ElemK, bCheckI, bCheckJ, dValI, dValJ))
		{
			bCalcSuccess = FALSE;
		}
		break;
	case 6: // Stability -Web
	{
		BOOL bCalcSuccessTemp1 = TRUE, bCalcSuccessTemp2 = TRUE;
		BOOL bCheckI01 = FALSE, bCheckJ01 = FALSE, bCheckI02 = FALSE, bCheckJ02 = FALSE;
		double dValI01 = 0.0, dValJ01 = 0.0, dValI02 = 0.0, dValJ02 = 0.0;

		// Left
		if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetSODStability_WebMaxResult_Contour(ElemK, bCheckI01, bCheckJ01, dValI01, dValJ01)) bCalcSuccessTemp1 = FALSE;
		// Right
		if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetSODStability_WebMaxResult_Contour_Right(ElemK, bCheckI02, bCheckJ02, dValI02, dValJ02)) bCalcSuccessTemp1 = FALSE;

		bCalcSuccess = (!bCalcSuccessTemp1 && !bCalcSuccessTemp1) ? FALSE : TRUE;
		bCheckI = (!bCheckI01 && !bCheckI02) ? FALSE : TRUE;
		bCheckJ = (!bCheckJ01 && !bCheckJ02) ? FALSE : TRUE;
		dValI = max(dValI01, dValI02);
		dValJ = max(dValJ01, dValJ02);

		break;
	}
	case 7: // Fatigue
		if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetSODFatigue_MaxResult_Contour(ElemK, bCheckI, bCheckJ, dValI, dValJ))
		{
			bCalcSuccess = FALSE;
		}
		break;
	default:
		ASSERT(0);
	}


	if (!bCalcSuccess)
	{
		bCheckIMax = FALSE;
		bCheckJMax = FALSE;
		bCheckIMin = FALSE;
		bCheckJMin = FALSE;

		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = 0.0;
		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = 0.0;
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = 0.0;
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = 0.0;

		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = 0.0;
		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = 0.0;
		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = 0.0;
		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = 0.0;

		FinishMakingPscDsgnData(RsltD);

		return TRUE;
	}

	if (!bCheckI)
	{
		dValI = 0.0;
	}
	if (!bCheckJ)
	{
		dValJ = 0.0;
	}

	bCheckIMax = FALSE;
	bCheckJMax = FALSE;
	bCheckIMin = TRUE;
	bCheckJMin = TRUE;

	BOOL bIJ_Zero = (dValI == 0.0 && dValJ == 0.0) ? TRUE : FALSE;

	RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = (bIJ_Zero) ? 0.0 : 1.0;
	RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = (bIJ_Zero) ? 0.0 : 1.0;
	RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = dValI;
	RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = dValJ;

	RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = (bIJ_Zero) ? 0.0 : 1.0;
	RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = (bIJ_Zero) ? 0.0 : 1.0;
	RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = dValI;
	RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = dValJ;


	FinishMakingPscDsgnData(RsltD);

	// RsltD[4]중에서 [0]과 [2]만 씀.. void CDesignEngine::MakeRatingList()에서 if(Key1[j] == PSC_DSGN_NULL_KEY)continue; 를 보면 알 수 있음


	//////////////////////////////////////////////////////////////////////////////////////
	// 참고
	// 	//******************************************************************
	//   // PSC
	// 	//******************************************************************
	// 	if(m_nDgnCode==KSCE_USD03 || m_nDgnCode==KSCE_USD05 || m_nDgnCode==KSCE_USD10 || 
	//      m_nDgnCode==KSCE_RAIL_USD04 || m_nDgnCode==KSCE_RAIL_USD11)
	// 	{
	// 		switch(m_nPSCComp)
	// 		{
	// 			case PSC_DSGN_COMP_BEND_Y:
	// 				{
	// 					T_BDCY_KSCE BdcyKsceD;
	// 					if(!pDoc->m_pPostCtrl->GetAnalysisResult()->GetBdcyKsceData(ElemK,BdcyKsceD))	return FALSE;
	// 					
	// 					//T_BDCY_KSCE_BASE BdcyBase[4];	// 0=I-MAX, 1=I-MIN, 2=J-MAX, 3=J-MIN.
	// 					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(BdcyKsceD.BdcyBase[0].dpMny); // Max I 강도 
	// 					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(BdcyKsceD.BdcyBase[2].dpMny); // Max J 강도 
	// 					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(BdcyKsceD.BdcyBase[1].dpMny); // Min I 강도 
	// 					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(BdcyKsceD.BdcyBase[3].dpMny); // Min J 강도 
	// 					
	// 					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = BdcyKsceD.BdcyBase[0].dMuy; // Max I 계수부재력 
	// 					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = BdcyKsceD.BdcyBase[2].dMuy; // Max J 계수부재력 
	// 					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = BdcyKsceD.BdcyBase[1].dMuy; // Min I 계수부재력 
	// 					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = BdcyKsceD.BdcyBase[3].dMuy; // Min J 계수부재력 
	// 					
	// 					bCheckIMax = BdcyKsceD.BdcyBase[0].bCHK;
	// 					bCheckJMax = BdcyKsceD.BdcyBase[2].bCHK;
	// 					bCheckIMin = BdcyKsceD.BdcyBase[1].bCHK;
	// 					bCheckJMin = BdcyKsceD.BdcyBase[3].bCHK;
	// 				}
	// 				break;
	// 			default:
	// 				break;
	// 		}
	// 	}
	// 
	// 	if(bCheckIMax==FALSE && bCheckJMax==TRUE) 
	// 	{
	// 		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1];
	// 		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1];
	// 	}	
	// 	else if(bCheckIMax==TRUE && bCheckJMax==FALSE)
	// 	{
	// 		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0];
	// 		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0];
	// 	}
	// 	if(bCheckIMin==FALSE && bCheckJMin==TRUE) 
	// 	{
	// 		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1];
	// 		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1];
	// 	}	
	// 	else if(bCheckIMin==TRUE && bCheckJMin==FALSE)
	// 	{
	// 		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0];
	// 		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0];
	// 	}
	// 	
	//   FinishMakingPscDsgnData(RsltD);
	// 
	// 	//******************************************************************
	//   // Rating
	// 	//******************************************************************
	// 	T_ISBRDG_D BrdgData;	
	// 	BrdgData.Initialize();
	// 	BOOL bCheckIMax=FALSE, bCheckIMin=FALSE, bCheckJMax=FALSE, bCheckJMin=FALSE;
	// 	
	// 	double dValI, dValJ;
	// 	BOOL bCheckI, bCheckJ;
	// 	BOOL bCalcSuccess = TRUE;
	// 	if(m_nRatingRstType == 0) //Steel
	// 	{
	// 		switch(m_nSteelRatingRstType)
	// 		{
	// 		case 0: // Rating Factor
	// 			if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetRatingResult4Contour(0, m_SelRatingCaseK, ElemK, bCheckI, bCheckJ, dValI, dValJ))
	// 			{
	// 				bCalcSuccess = FALSE;
	// 			}
	// 			break; 
	// 		case 1: // 기본내하력
	// 			if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetRatingResult4Contour(1, m_SelRatingCaseK, ElemK, bCheckI, bCheckJ, dValI, dValJ))
	// 			{
	// 				bCalcSuccess = FALSE;
	// 			}
	// 			break;
	// 		default:
	// 			ASSERT(0);
	// 		}	
	// 	}
	// 	else if(m_nRatingRstType == 1) // PSC
	// 	{
	// 		switch(m_nSteelRatingRstType)
	// 		{
	// 		case 0: // Rating Factor
	// 			if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetPSCRatingResult4Contour(0, m_SelRatingCaseK, ElemK, bCheckI, bCheckJ, dValI, dValJ))
	// 			{
	// 				bCalcSuccess = FALSE;
	// 			}
	// 			break; 
	// 		case 1: // 기본내하력
	// 			if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetPSCRatingResult4Contour(1, m_SelRatingCaseK, ElemK, bCheckI, bCheckJ, dValI, dValJ))
	// 			{
	// 				bCalcSuccess = FALSE;
	// 			}
	// 			break;
	// 		default:
	// 			ASSERT(0);
	// 		}	
	// 	}
	// 	
	// 	
	// 	if(!bCalcSuccess)
	// 	{
	// 		bCheckIMax = FALSE;
	// 		bCheckJMax = FALSE;
	// 		bCheckIMin = FALSE;
	// 		bCheckJMin = FALSE;
	// 		
	// 		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = 0.0;
	// 		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = 0.0;
	// 		
	// 		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = 0.0;
	// 		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = 0.0;
	// 		
	// 		BrdgData.bBrdgDataI = FALSE;
	// 		BrdgData.bBrdgDataJ = FALSE;
	// 		
	// 		m_mapbBrdgData.SetAt(ElemK,BrdgData);
	// 		FinishMakingPscDsgnData(RsltD);
	// 		
	// 		return TRUE;
	// 	}
	// 	
	// 	if(!bCheckI)
	// 	{
	// 		dValI = 0.0;
	// 	}
	// 	if(!bCheckJ)
	// 	{
	// 		dValJ = 0.0;
	// 	}
	// 	
	// 	bCheckIMax = FALSE;
	// 	bCheckJMax = FALSE;
	// 	bCheckIMin = TRUE;
	// 	bCheckJMin = TRUE;
	// 	
	// 	RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = dValI;
	// 	RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = dValJ;
	// 	
	// 	RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = dValI;
	// 	RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = dValJ;
	// 	
	// 	m_mapbBrdgData.SetAt(ElemK,BrdgData);
	//   FinishMakingPscDsgnData(RsltD);
	// 	
	// 	// RsltD[4]중에서 [0]과 [2]만 씀.. void CDesignEngine::MakeRatingList()에서 if(Key1[j] == PSC_DSGN_NULL_KEY)continue; 를 보면 알 수 있음

	//////////////////////////////////////////////////////////////////////////////////////



	return TRUE;
}

void CDesignEngine::GetCurrentCPG_ShearCoonForcetStr(CString &csVal)
{
	csVal.Empty();

	switch (m_nCPG_ShearConnForceType)
	{
	case 0:    csVal = _T("By Element");  break;
	case 1:    csVal = _T("By Group");  break;
	default: ASSERT(0);        break;
	}

}

void CDesignEngine::MakeCPG_ShearCoonForceList()
{
	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;
	m_bDsgnDataSet = TRUE;  // 무조건 TRUE로 해야 결과가 없어도 요소가 Wire Frame으로 출력된다 
	CDBDoc *pDoc = CDBDoc::GetDocPoint();
	BOOL bHasData = FALSE;

	m_dMaxDgrmVal = -DBL_MAX;
	m_dMinDgrmVal = DBL_MAX;
	m_mapDgrmData.RemoveAll();
	m_mapDgrmData.InitHashTable(1001);
	m_EKeyList.RemoveAll();
	m_mapTendonData.RemoveAll();
	m_mapbBrdgData.RemoveAll();

	int nElemNum;
	T_ELEM_K ElemK;

	nElemNum = gm->m_EKeyListActive.GetSize();

	int nKeyNum = 0;
	UINT Key1[PSC_DSGN_TYPE_KEY_NUM];

	Key1[0] = Key1[1] = Key1[2] = Key1[3] = PSC_DSGN_NULL_KEY;
	if (m_bPSCSignPos)
	{
		Key1[PSC_DSGN_STRG_MAX_KEY] = PSC_DSGN_STRG_MAX_KEY;
		Key1[PSC_DSGN_CRIT_MAX_KEY] = PSC_DSGN_CRIT_MAX_KEY;
	}
	if (m_bPSCSignNeg)
	{
		Key1[PSC_DSGN_STRG_MIN_KEY] = PSC_DSGN_STRG_MIN_KEY;
		Key1[PSC_DSGN_CRIT_MIN_KEY] = PSC_DSGN_CRIT_MIN_KEY;
	}

	T_CMAP_K2<UINT> mKey;
	T_PSC_DSGN_RESL_D ReslD[4];

	T_SECT_D SectD; SectD.Initialize();
	T_ELEM_D ElemD; ElemD.Initialize();

	//if(m_bPSCSignPos || m_bPSCSignNeg)
	for (int i = 0; i < nElemNum; i++)
	{
		ElemK = gm->m_EKeyListActive[i];

		SectD.Initialize();
		ElemD.Initialize();
		if (!m_pDoc->m_pAttrCtrl->GetElem(ElemK, ElemD)) continue;
		if (!m_pDoc->m_pAttrCtrl->GetSect(ElemD.elpro, SectD)) continue;
		if (SectD.nStype != D_SECT_TYPE_COMPO_STLG_I && SectD.nStype != D_SECT_TYPE_COMPO_STLG_B && SectD.nStype != D_SECT_TYPE_COMPO_STLG_TUB) continue;

		for (int j = 0; j < 4; j++)ReslD[j].Initialize();

		if (!CCPG_ShearCoonForceDgrmData(ElemK, ReslD))continue; //

		SetDgrmVector(ElemK, ReslD);
		m_EKeyList.Add(ElemK);
		bHasData = TRUE;


		double dMnVal = 0.0, dMxVal = 0.0;
		for (int j = 0; j < 4; j++)
		{
			if (Key1[j] == PSC_DSGN_NULL_KEY)continue;

			ReslD[j].GetMxMnVal(dMxVal, dMnVal);
			m_dMaxDgrmVal = max(m_dMaxDgrmVal, dMxVal);
			m_dMinDgrmVal = min(m_dMinDgrmVal, dMnVal);

			mKey.i1 = ElemK;
			mKey.i2 = Key1[j];
			m_mapDgrmData.SetAt(mKey, ReslD[j]);
		}
	}

	if (!bHasData)
	{
		m_dMaxDgrmVal = 0.0;
		m_dMinDgrmVal = 0.0;
		return;
	}

	if (fabs(m_dMaxDgrmVal) < fabs(m_dMinDgrmVal))
		InitDiagramAdjustFactor(m_dMinDgrmVal);
	else
		InitDiagramAdjustFactor(m_dMaxDgrmVal);

	if (m_pContourEngine == NULL)
		m_pContourEngine = new CContourEngine(m_dMinDgrmVal, m_dMaxDgrmVal);
	else
		m_pContourEngine->MakeRankMap(m_dMinDgrmVal, m_dMaxDgrmVal);
	m_bDsgnDataSet = TRUE;
}

BOOL CDesignEngine::CCPG_ShearCoonForceDgrmData(T_ELEM_K ElemK, T_PSC_DSGN_RESL_D RsltD[4])
{
	CDBDoc *pDoc = CDBDoc::GetDocPoint();
	BOOL bCheckIMax = FALSE, bCheckIMin = FALSE, bCheckJMax = FALSE, bCheckJMin = FALSE;

	//******************************************************************
	// RUS Steel Composite
	//******************************************************************
	double dValI = 0.0, dValJ = 0.0;
	BOOL bCheckI = FALSE, bCheckJ = FALSE;
	BOOL bCalcSuccess = TRUE;
	CAnalysisResult* pAnalysisRes = pDoc->m_pPostCtrl->GetAnalysisResult();

	switch (m_nCPG_ShearConnForceType)
	{
	case 0: {if (!pAnalysisRes->GetStlComp_Longi_ShearForce_ByElem_Contour(ElemK, bCheckI, bCheckJ, dValI, dValJ)) bCalcSuccess = FALSE; break; }
	case 1: {if (!pAnalysisRes->GetStlComp_Longi_ShearForce_ByGroup_Contour(ElemK, bCheckI, bCheckJ, dValI, dValJ)) bCalcSuccess = FALSE; break; }
	default: ASSERT(0); break;
	}

	if (!bCalcSuccess)
	{
		bCheckIMax = FALSE;
		bCheckJMax = FALSE;
		bCheckIMin = FALSE;
		bCheckJMin = FALSE;

		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = 0.0;
		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = 0.0;
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = 0.0;
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = 0.0;

		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = 0.0;
		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = 0.0;
		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = 0.0;
		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = 0.0;

		FinishMakingPscDsgnData(RsltD);

		return TRUE;
	}

	if (!bCheckI)
	{
		dValI = 0.0;
	}
	if (!bCheckJ)
	{
		dValJ = 0.0;
	}

	bCheckIMax = FALSE;
	bCheckJMax = FALSE;
	bCheckIMin = TRUE;
	bCheckJMin = TRUE;

	BOOL bIJ_Zero = (dValI == 0.0 && dValJ == 0.0) ? TRUE : FALSE;

	RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = 0.0; //(bIJ_Zero)? 0.0 : 1.0;
	RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = 0.0; //(bIJ_Zero)? 0.0 : 1.0;
	RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = dValI;
	RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = dValJ;

	RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = 0.0; //(bIJ_Zero)? 0.0 : 1.0;
	RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = 0.0; //(bIJ_Zero)? 0.0 : 1.0;
	RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = dValI;
	RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = dValJ;

	FinishMakingPscDsgnData(RsltD);

	return TRUE;
}

void CDesignEngine::GetCurrentCPG_RUSResultStr(CString &csVal)
{
	csVal.Empty();
	switch (m_nCPG_RUSResultBeforeAfterType)
	{
	case 0:  	// 0 : Before
	{
		switch (m_nCPG_RUSResultBeforeType)
		{
		case 0:    csVal = _T("Before_Envelop");  break;
		case 1:    csVal = _T("Before_STRN.-Top Flange");  break;
		case 2:    csVal = _T("Before_STRN.-Bottom Flange");  break;
		case 3:    csVal = _T("Before_STRN.-Web");  break;
		case 4:    csVal = _T("Before_STAB.-LTB");  break;
		case 5:    csVal = _T("Before_STAB.-Top Flange");  break;
		case 6:    csVal = _T("Before_STAB.-Bottom Flange");  break;
		case 7:    csVal = _T("Before_STAB.-Web");  break;
		default: ASSERT(0);        break;
		}
		break;
	}
	case 1:	  //  1 : After Composite
	{
		switch (m_nCPG_RUSResultAfterType)
		{
		case 0:    csVal = _T("After_Envelop");  break;
		case 1:    csVal = _T("After_STRN.-Concrete");  break;
		case 2:    csVal = _T("After_STRN.-Reinforcement");  break;
		case 3:    csVal = _T("After_STRN.-Top Flange");  break;
		case 4:    csVal = _T("After_STRN.-Bottom Flange");  break;
		case 5:    csVal = _T("After_STRN.-Web");  break;
		case 6:    csVal = _T("After_STAB.-Bottom Flange");  break;
		case 7:    csVal = _T("After_STAB.-Web");  break;
		case 8:    csVal = _T("After_Fatigue");  break;
		case 9:    csVal = _T("After_Crack");  break;
		default: ASSERT(0);        break;
		}
		break;
	}
	default: ASSERT(0); break;
	}
}

void CDesignEngine::MakeCPG_RUSResultList()
{
	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;
	m_bDsgnDataSet = TRUE;  // 무조건 TRUE로 해야 결과가 없어도 요소가 Wire Frame으로 출력된다 
	CDBDoc *pDoc = CDBDoc::GetDocPoint();
	BOOL bHasData = FALSE;

	m_dMaxDgrmVal = -DBL_MAX;
	m_dMinDgrmVal = DBL_MAX;
	m_mapDgrmData.RemoveAll();
	m_mapDgrmData.InitHashTable(1001);
	m_EKeyList.RemoveAll();
	m_mapTendonData.RemoveAll();
	m_mapbBrdgData.RemoveAll();

	int nElemNum;
	T_ELEM_K ElemK;

	nElemNum = gm->m_EKeyListActive.GetSize();

	int nKeyNum = 0;
	UINT Key1[PSC_DSGN_TYPE_KEY_NUM];

	Key1[0] = Key1[1] = Key1[2] = Key1[3] = PSC_DSGN_NULL_KEY;
	if (m_bPSCSignPos)
	{
		Key1[PSC_DSGN_STRG_MAX_KEY] = PSC_DSGN_STRG_MAX_KEY;
		Key1[PSC_DSGN_CRIT_MAX_KEY] = PSC_DSGN_CRIT_MAX_KEY;
	}
	if (m_bPSCSignNeg)
	{
		Key1[PSC_DSGN_STRG_MIN_KEY] = PSC_DSGN_STRG_MIN_KEY;
		Key1[PSC_DSGN_CRIT_MIN_KEY] = PSC_DSGN_CRIT_MIN_KEY;
	}

	T_CMAP_K2<UINT> mKey;
	T_PSC_DSGN_RESL_D ReslD[4];

	T_SECT_D SectD; SectD.Initialize();
	T_ELEM_D ElemD; ElemD.Initialize();

	//if(m_bPSCSignPos || m_bPSCSignNeg)
	for (int i = 0; i < nElemNum; i++)
	{
		ElemK = gm->m_EKeyListActive[i];

		SectD.Initialize();
		ElemD.Initialize();
		if (!m_pDoc->m_pAttrCtrl->GetElem(ElemK, ElemD)) continue;
		if (!m_pDoc->m_pAttrCtrl->GetSect(ElemD.elpro, SectD)) continue;
		if (SectD.nStype != D_SECT_TYPE_COMPO_STLG_I && SectD.nStype != D_SECT_TYPE_COMPO_STLG_B && SectD.nStype != D_SECT_TYPE_COMPO_STLG_TUB) continue;

		for (int j = 0; j < 4; j++)ReslD[j].Initialize();

		if (!CPG_RUSResultDgrmData(ElemK, ReslD))continue; //

		SetDgrmVector(ElemK, ReslD);
		m_EKeyList.Add(ElemK);
		bHasData = TRUE;


		double dMnVal = 0.0, dMxVal = 0.0;
		for (int j = 0; j < 4; j++)
		{
			if (Key1[j] == PSC_DSGN_NULL_KEY)continue;

			ReslD[j].GetMxMnVal(dMxVal, dMnVal);
			m_dMaxDgrmVal = max(m_dMaxDgrmVal, dMxVal);
			m_dMinDgrmVal = min(m_dMinDgrmVal, dMnVal);

			mKey.i1 = ElemK;
			mKey.i2 = Key1[j];
			m_mapDgrmData.SetAt(mKey, ReslD[j]);
		}
	}

	if (!bHasData)
	{
		m_dMaxDgrmVal = 0.0;
		m_dMinDgrmVal = 0.0;
		return;
	}

	if (fabs(m_dMaxDgrmVal) < fabs(m_dMinDgrmVal))
		InitDiagramAdjustFactor(m_dMinDgrmVal);
	else
		InitDiagramAdjustFactor(m_dMaxDgrmVal);

	if (m_pContourEngine == NULL)
		m_pContourEngine = new CContourEngine(m_dMinDgrmVal, m_dMaxDgrmVal);
	else
		m_pContourEngine->MakeRankMap(m_dMinDgrmVal, m_dMaxDgrmVal);
	m_bDsgnDataSet = TRUE;
}


BOOL CDesignEngine::CPG_RUSResultDgrmData(T_ELEM_K ElemK, T_PSC_DSGN_RESL_D RsltD[4])
{
	CDBDoc *pDoc = CDBDoc::GetDocPoint();
	BOOL bCheckIMax = FALSE, bCheckIMin = FALSE, bCheckJMax = FALSE, bCheckJMin = FALSE;

	//******************************************************************
	// RUS Steel Composite
	//******************************************************************
	double dValI = 0.0, dValJ = 0.0;
	BOOL bCheckI = FALSE, bCheckJ = FALSE;
	BOOL bCalcSuccess = TRUE;
	CAnalysisResult* pAnalysisRes = pDoc->m_pPostCtrl->GetAnalysisResult();

	switch (m_nCPG_RUSResultBeforeAfterType)
	{
	case 0:  	// 0 : Before
	{
		switch (m_nCPG_RUSResultBeforeType)
		{
		case 0: {if (!pAnalysisRes->GetStlComp_BF_Envelop_MaxResult_Contour(ElemK, bCheckI, bCheckJ, dValI, dValJ)) bCalcSuccess = FALSE; break; }
		case 1: {if (!pAnalysisRes->GetStlComp_BF_STRN_Flange_MaxResult_Contour(0, ElemK, bCheckI, bCheckJ, dValI, dValJ)) bCalcSuccess = FALSE; break; }
		case 2: {if (!pAnalysisRes->GetStlComp_BF_STRN_Flange_MaxResult_Contour(1, ElemK, bCheckI, bCheckJ, dValI, dValJ)) bCalcSuccess = FALSE; break; }
		case 3: {if (!pAnalysisRes->GetStlComp_BF_STRN_Web_MaxResult_Contour(ElemK, bCheckI, bCheckJ, dValI, dValJ)) bCalcSuccess = FALSE; break; }
		case 4: {if (!pAnalysisRes->GetStlComp_BF_STAB_LTB_MaxResult_Contour(ElemK, bCheckI, bCheckJ, dValI, dValJ)) bCalcSuccess = FALSE; break; }
		case 5: {if (!pAnalysisRes->GetStlComp_BF_STAB_Flange_MaxResult_Contour(0, ElemK, bCheckI, bCheckJ, dValI, dValJ)) bCalcSuccess = FALSE; break; }
		case 6: {if (!pAnalysisRes->GetStlComp_BF_STAB_Flange_MaxResult_Contour(1, ElemK, bCheckI, bCheckJ, dValI, dValJ)) bCalcSuccess = FALSE; break; }
		case 7: {if (!pAnalysisRes->GetStlComp_BF_STAB_Web_MaxResult_Contour(ElemK, bCheckI, bCheckJ, dValI, dValJ)) bCalcSuccess = FALSE; break; }
		default: ASSERT(0);        break;
		}
		break;
	}
	case 1:	  //  1 : After Composite
	{
		switch (m_nCPG_RUSResultAfterType)
		{
		case 0: {if (!pAnalysisRes->GetStlComp_AF_Envelop_MaxResult_Contour(ElemK, bCheckI, bCheckJ, dValI, dValJ)) bCalcSuccess = FALSE; break; }
		case 1: {if (!pAnalysisRes->GetStlComp_AF_STRN_Concrete_MaxResult_Contour(ElemK, bCheckI, bCheckJ, dValI, dValJ)) bCalcSuccess = FALSE; break; }
		case 2: {if (!pAnalysisRes->GetStlComp_AF_STRN_Reinforcement_MaxResult_Contour(ElemK, bCheckI, bCheckJ, dValI, dValJ)) bCalcSuccess = FALSE; break; }
		case 3: {if (!pAnalysisRes->GetStlComp_AF_STRN_Flange_MaxResult_Contour(0, ElemK, bCheckI, bCheckJ, dValI, dValJ)) bCalcSuccess = FALSE; break; }
		case 4: {if (!pAnalysisRes->GetStlComp_AF_STRN_Flange_MaxResult_Contour(1, ElemK, bCheckI, bCheckJ, dValI, dValJ)) bCalcSuccess = FALSE; break; }
		case 5: {if (!pAnalysisRes->GetStlComp_AF_STRN_Web_MaxResult_Contour(ElemK, bCheckI, bCheckJ, dValI, dValJ)) bCalcSuccess = FALSE; break; }
		case 6: {if (!pAnalysisRes->GetStlComp_AF_STAB_Flange_MaxResult_Contour(1, ElemK, bCheckI, bCheckJ, dValI, dValJ)) bCalcSuccess = FALSE; break; }
		case 7: {if (!pAnalysisRes->GetStlComp_AF_STAB_Web_MaxResult_Contour(ElemK, bCheckI, bCheckJ, dValI, dValJ)) bCalcSuccess = FALSE; break; }
		case 8: {if (!pAnalysisRes->GetStlComp_AF_Fatigue_MaxResult_Contour(ElemK, bCheckI, bCheckJ, dValI, dValJ)) bCalcSuccess = FALSE; break; }
		case 9: {if (!pAnalysisRes->GetStlComp_AF_Serviceability_MaxResult_Contour(ElemK, bCheckI, bCheckJ, dValI, dValJ)) bCalcSuccess = FALSE; break; }
		default: ASSERT(0);        break;
		}
		break;
	}
	default: ASSERT(0); break;
	}


	if (!bCalcSuccess)
	{
		bCheckIMax = FALSE;
		bCheckJMax = FALSE;
		bCheckIMin = FALSE;
		bCheckJMin = FALSE;

		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = 0.0;
		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = 0.0;
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = 0.0;
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = 0.0;

		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = 0.0;
		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = 0.0;
		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = 0.0;
		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = 0.0;

		FinishMakingPscDsgnData(RsltD);

		return TRUE;
	}

	if (!bCheckI)
	{
		dValI = 0.0;
	}
	if (!bCheckJ)
	{
		dValJ = 0.0;
	}

	bCheckIMax = FALSE;
	bCheckJMax = FALSE;
	bCheckIMin = TRUE;
	bCheckJMin = TRUE;

	BOOL bIJ_Zero = (dValI == 0.0 && dValJ == 0.0) ? TRUE : FALSE;

	RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = (bIJ_Zero) ? 0.0 : 1.0;
	RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = (bIJ_Zero) ? 0.0 : 1.0;
	RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = dValI;
	RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = dValJ;

	RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = (bIJ_Zero) ? 0.0 : 1.0;
	RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = (bIJ_Zero) ? 0.0 : 1.0;
	RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = dValI;
	RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = dValJ;

	FinishMakingPscDsgnData(RsltD);

	return TRUE;
}

void CDesignEngine::SetDgrmVector(T_ELEM_K ElemK, T_PSC_DSGN_RESL_D ReslD[4])
{
	double dDirVec[3];
	memset(dDirVec, 0, sizeof(dDirVec));
	if (m_nDgrmDirType == PSC_DSGN_DGRM_DIR_GLOBAL)
	{
		switch (m_nDgrmDirOptn)
		{
		case PSC_DSGN_DGRM_DIR_XAXIS: dDirVec[0] = 1.0;  break;
		case PSC_DSGN_DGRM_DIR_YAXIS: dDirVec[1] = 1.0;  break;
		case PSC_DSGN_DGRM_DIR_ZAXIS: dDirVec[2] = 1.0;  break;
		}
	}
	else if (m_nDgrmDirType == PSC_DSGN_DGRM_DIR_LOCAL)
	{
		double dLocalVec[3][3];
		memset(dLocalVec, 0, sizeof(dLocalVec));
		if (!m_pDoc->calcFrameLocalVector(ElemK, dLocalVec))return;

		if (this->m_nDgrmDirOptn == PSC_DSGN_DGRM_DIR_MAJOR)
		{
			memcpy(dDirVec, dLocalVec[2], sizeof(dDirVec));
		}
		else if (m_nDgrmDirOptn == PSC_DSGN_DGRM_DIR_MINOR)
		{
			memcpy(dDirVec, dLocalVec[1], sizeof(dDirVec));
		}
	}
	for (int i = 0; i < 4; i++)
	{
		memcpy(ReslD[i].dDirVec, dDirVec, sizeof(dDirVec));
	}
}

void CDesignEngine::SetDgrmVector4LclMaj(T_ELEM_K ElemK, T_PSC_DSGN_RESL_D ReslD[4])
{
	double dDirVec[3];
	memset(dDirVec, 0, sizeof(dDirVec));

	double dLocalVec[3][3];
	memset(dLocalVec, 0, sizeof(dLocalVec));
	if (!m_pDoc->calcFrameLocalVector(ElemK, dLocalVec))return;
	memcpy(dDirVec, dLocalVec[2], sizeof(dDirVec));

	for (int i = 0; i < 4; i++)
	{
		memcpy(ReslD[i].dDirVec, dDirVec, sizeof(dDirVec));
	}
}

void CDesignEngine::InitDiagramAdjustFactor(double max_bforc)
{
	C3DPoint	min_p, max_p;
	double		max_l;

	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;
	gm->GetRangeModel(&min_p, &max_p);
	max_l = max(max(max_p.x - min_p.x, max_p.y - min_p.y), max_p.z - min_p.z);
	m_dMaxModelLength = max_l;

	if (max_bforc > -1e-15 && max_bforc < 1e-15)max_bforc = 1.0f;
	// 최대값이 전체모델의 1/20의 크기로 나오도록...
	m_dDgrmAdjustFactor = max_l / (fabs(max_bforc)*20.0);
}

void  CDesignEngine::GetCurrentPSCCompStr(CString &csComp)
{
	csComp.Empty();
	if (m_nPSCCode == PSC_DSGN_CODE_KR)
	{
		if (m_nDgnCode == EUROCODE2_2_05_PSC || m_nDgnCode == IRC_112_2011_PSC ||
			CDBLib::IsPscCodeAASHTOSince12(m_nDgnCode) ||
			m_nDgnCode == AS_5100_5_17_PSC || m_nDgnCode == BS5400_90_PSC ||
			m_nDgnCode == IRC_112_2020_PSC)
		{
			if (m_nPSCCirteriaType == 0 || m_nPSCCirteriaType == 1) // Force
			{
				switch (m_nPSCComp)
				{
				case PSC_DSGN_COMP_BEND_Y:         csComp = _LSX(Flexure - y);     break;
				case PSC_DSGN_COMP_BEND_Z:         csComp = _LSX(Flexure - z);     break;
				case PSC_DSGN_COMP_SHER_Z:         csComp = _LSX(Shear);         break;
				case PSC_DSGN_COMP_TORSION:        csComp = _LSX(Torsion(Vmx));  break;
				case PSC_DSGN_COMP_TORSION_MAXTOR: csComp = _LSX(Torsion(Tmx));  break;
				default:                                                         break;
				}
			}
			else if (m_nPSCCirteriaType == 2 || m_nPSCCirteriaType == 3) // Stress
			{
				switch (m_nPSCPosition)
				{
				case PSC_DSGN_COMP_STRESS_COMP_TOP:  csComp = _LSX(Top);       break;
				case PSC_DSGN_COMP_STRESS_COMP_BOT:  csComp = _LSX(Bottom);    break;
				case PSC_DSGN_COMP_STRESS_COMP1:     csComp = _LSX(1(-y, +z)); break;
				case PSC_DSGN_COMP_STRESS_COMP2:     csComp = _LSX(2(+y, +z)); break;
				case PSC_DSGN_COMP_STRESS_COMP3:     csComp = _LSX(3(+y, -z)); break;
				case PSC_DSGN_COMP_STRESS_COMP4:     csComp = _LSX(4(-y, -z)); break;
				default:                                                       break;
				}
			}
			else
			{
				ASSERT(0);
			}
		}
		else
		{
			switch (m_nPSCComp)
			{
			case PSC_DSGN_COMP_BEND_Y:  csComp = _LSX(Flexure - y);  break;
			case PSC_DSGN_COMP_BEND_Z:  csComp = _LSX(Flexure - z);  break;
			case PSC_DSGN_COMP_SHER_Z:  csComp = _LSX(Shear);  break;
			case PSC_DSGN_COMP_TORSION: csComp = _LSX(Torsion(Vmx));  break;
			case PSC_DSGN_COMP_TORSION_MAXTOR: csComp = _LSX(Torsion(Tmx));  break;
			}
		}
	}
	else if (m_nPSCCode == PSC_DSGN_CODE_CH)
	{
		switch (m_nPSCCompCH)
		{
		case PSC_DSGN_COMP_BEND_Y_CH: csComp = _LSX(Flexure - y);  break;
		case PSC_DSGN_COMP_SHER_Z_CH: csComp = _LSX(Shear);  break;
		case PSC_DSGN_COMP_TORSION_CH:csComp = _LSX(Torsion(Vmx));  break;
		case PSC_DSGN_COMP_TORSION_MAXTOR_CH: csComp = _LSX(Torsion(Tmx));  break;
		}
	}
	else if (m_nPSCCode == PSC_DSGN_CODE_JP)
	{
		switch (m_nPSCCompJP)
		{
		case PSC_DSGN_COMP_BEND_Y_JP: csComp = _LSX(Flexure - y);  break;
		case PSC_DSGN_COMP_BEND_Z_JP: csComp = _LSX(Flexure - z);  break;
		case PSC_DSGN_COMP_SHER_1_JP: csComp = _T("QU,QR(Vmx)");  break;
		case PSC_DSGN_COMP_TORN_1_JP: csComp = _T("TU,TR(Vmx)");  break;
		case PSC_DSGN_COMP_SHER_2_JP: csComp = _T("TU,TTR(Tmx)");  break;
		case PSC_DSGN_COMP_TORN_2_JP: csComp = _T("TU,TR(Tmx)");  break;
		case PSC_DSGN_COMP_SHER_3_JP: csComp = _T("QU,QR(IVmx)");  break;
		case PSC_DSGN_COMP_TORN_3_JP: csComp = _T("TU,TR(ITmx)");  break;
		}
	}
}


void  CDesignEngine::GetCurrentPSCUnitStr(CString &csUnit)
{
	if (this->m_nPSCCirteriaType == PSC_DSGN_CRIT_RATIO || this->m_nPSCCirteriaType == PSC_DSGN_CRIT_STR_RATIO)
	{
		csUnit = _LSX(None);
		return;
	}

	csUnit.Empty();
	if (m_nPSCCode == PSC_DSGN_CODE_KR)
	{
		if (m_nDgnCode == EUROCODE2_2_05_PSC || m_nDgnCode == IRC_112_2011_PSC ||
			CDBLib::IsPscCodeAASHTOSince12(m_nDgnCode) ||
			m_nDgnCode == AS_5100_5_17_PSC || m_nDgnCode == BS5400_90_PSC ||
			m_nDgnCode == IRC_112_2020_PSC)
		{
			if (m_nPSCCirteriaType == 0 || m_nPSCCirteriaType == 1) // Force
			{
				switch (m_nPSCComp)
				{
				case PSC_DSGN_COMP_BEND_Y:         CUnitCtrl::GetUnitSystem(D_UNITSYS_BASE_MOMENT, csUnit);  break;
				case PSC_DSGN_COMP_BEND_Z:         CUnitCtrl::GetUnitSystem(D_UNITSYS_BASE_MOMENT, csUnit);  break;
				case PSC_DSGN_COMP_SHER_Z:         CUnitCtrl::GetUnitSystem(D_UNITSYS_BASE_FORCE, csUnit);  break;
				case PSC_DSGN_COMP_TORSION:        CUnitCtrl::GetUnitSystem(D_UNITSYS_BASE_MOMENT, csUnit);  break;
				case PSC_DSGN_COMP_TORSION_MAXTOR: CUnitCtrl::GetUnitSystem(D_UNITSYS_BASE_MOMENT, csUnit);  break;
				default:                                                                                     break;
				}
			}
			else if (m_nPSCCirteriaType == 2 || m_nPSCCirteriaType == 3) // Stress
			{
				switch (m_nPSCPosition)
				{
				case PSC_DSGN_COMP_STRESS_COMP_TOP:  CUnitCtrl::GetUnitSystem(D_UNITSYS_BASE_STRESS, csUnit);  break;
				case PSC_DSGN_COMP_STRESS_COMP_BOT:  CUnitCtrl::GetUnitSystem(D_UNITSYS_BASE_STRESS, csUnit);  break;
				case PSC_DSGN_COMP_STRESS_COMP1:     CUnitCtrl::GetUnitSystem(D_UNITSYS_BASE_STRESS, csUnit);  break;
				case PSC_DSGN_COMP_STRESS_COMP2:     CUnitCtrl::GetUnitSystem(D_UNITSYS_BASE_STRESS, csUnit);  break;
				case PSC_DSGN_COMP_STRESS_COMP3:     CUnitCtrl::GetUnitSystem(D_UNITSYS_BASE_STRESS, csUnit);  break;
				case PSC_DSGN_COMP_STRESS_COMP4:     CUnitCtrl::GetUnitSystem(D_UNITSYS_BASE_STRESS, csUnit);  break;
				default:                                                                                       break;
				}
			}
			else
			{
				ASSERT(0);
			}
		}
		else
		{
			switch (m_nPSCComp)
			{
			case PSC_DSGN_COMP_BEND_Y:         CUnitCtrl::GetUnitSystem(D_UNITSYS_BASE_MOMENT, csUnit);  break;
			case PSC_DSGN_COMP_BEND_Z:         CUnitCtrl::GetUnitSystem(D_UNITSYS_BASE_MOMENT, csUnit);  break;
			case PSC_DSGN_COMP_SHER_Z:         CUnitCtrl::GetUnitSystem(D_UNITSYS_BASE_FORCE, csUnit);  break;
			case PSC_DSGN_COMP_TORSION:        CUnitCtrl::GetUnitSystem(D_UNITSYS_BASE_MOMENT, csUnit);  break;
			case PSC_DSGN_COMP_TORSION_MAXTOR: CUnitCtrl::GetUnitSystem(D_UNITSYS_BASE_MOMENT, csUnit);  break;
			default:                                                                                     break;
			}
		}
	}
	else if (m_nPSCCode == PSC_DSGN_CODE_CH)
	{
		switch (m_nPSCCompCH)
		{
		case PSC_DSGN_COMP_BEND_Y_CH: CUnitCtrl::GetUnitSystem(D_UNITSYS_BASE_MOMENT, csUnit);  break;
		case PSC_DSGN_COMP_SHER_Z_CH: CUnitCtrl::GetUnitSystem(D_UNITSYS_BASE_FORCE, csUnit);  break;
		case PSC_DSGN_COMP_TORSION_CH:CUnitCtrl::GetUnitSystem(D_UNITSYS_BASE_MOMENT, csUnit);  break;
		case PSC_DSGN_COMP_TORSION_MAXTOR_CH:CUnitCtrl::GetUnitSystem(D_UNITSYS_BASE_MOMENT, csUnit);  break;
		}
	}
	else if (m_nPSCCode == PSC_DSGN_CODE_JP)
	{
		switch (m_nPSCCompJP)
		{
		case PSC_DSGN_COMP_BEND_Y_JP: CUnitCtrl::GetUnitSystem(D_UNITSYS_BASE_MOMENT, csUnit);  break;
		case PSC_DSGN_COMP_BEND_Z_JP: CUnitCtrl::GetUnitSystem(D_UNITSYS_BASE_MOMENT, csUnit);  break;
		case PSC_DSGN_COMP_SHER_1_JP: CUnitCtrl::GetUnitSystem(D_UNITSYS_BASE_FORCE, csUnit);  break;
		case PSC_DSGN_COMP_TORN_1_JP: CUnitCtrl::GetUnitSystem(D_UNITSYS_BASE_MOMENT, csUnit);  break;
		case PSC_DSGN_COMP_SHER_2_JP: CUnitCtrl::GetUnitSystem(D_UNITSYS_BASE_FORCE, csUnit);  break;
		case PSC_DSGN_COMP_TORN_2_JP: CUnitCtrl::GetUnitSystem(D_UNITSYS_BASE_MOMENT, csUnit);  break;
		case PSC_DSGN_COMP_SHER_3_JP: CUnitCtrl::GetUnitSystem(D_UNITSYS_BASE_FORCE, csUnit);  break;
		case PSC_DSGN_COMP_TORN_3_JP: CUnitCtrl::GetUnitSystem(D_UNITSYS_BASE_MOMENT, csUnit);  break;
		}
	}
}

BOOL  CDesignEngine::MakePscDsgnDgrmDataKR(T_ELEM_K ElemK, T_PSC_DSGN_RESL_D RsltD[4])
{
	CDBDoc *pDoc = CDBDoc::GetDocPoint();
	BOOL bCheckIMax = FALSE, bCheckIMin = FALSE, bCheckJMax = FALSE, bCheckJMin = FALSE;

	switch (m_nDgnCode)
	{
	case KSCE_USD03:
	case KSCE_USD05:
	case KSCE_USD10:
	case KSCE_RAIL_USD04:
	case KSCE_RAIL_USD11:
	case KDS_24_14_21_2022_PSC:
	case KSCE_LSD15_PSC:
		MakePscDsgnDgrmDataKR_KS(ElemK, RsltD, bCheckIMin, bCheckIMax, bCheckJMin, bCheckJMax);
		break;
	case AASHTO_LRFD08:
	case AASHTO_LRFD12:
	case AASHTO_LRFD14:
	case AASHTO_LRFD16:
	case AASHTO_LRFD17:
	case CSA_S6_10:
	case CSA_S6_14:
		MakePscDsgnDgrmDataKR_US(ElemK, RsltD, bCheckIMin, bCheckIMax, bCheckJMin, bCheckJMax);
		break;
	case EUROCODE2_2_05_PSC:
		MakePscDsgnDgrmDataKR_EC(ElemK, RsltD, bCheckIMin, bCheckIMax, bCheckJMin, bCheckJMax);
		break;
	case IRC_112_2011_PSC:
	case IRC_112_2020_PSC:
		MakePscDsgnDgrmDataKR_IS(ElemK, RsltD, bCheckIMin, bCheckIMax, bCheckJMin, bCheckJMax);
		break;
	case BS5400_90_PSC:
		MakePscDsgnDgrmDataKR_BS(ElemK, RsltD, bCheckIMin, bCheckIMax, bCheckJMin, bCheckJMax);
		break;
	case SNiP_20503_84_PSC:
	case SP_35_13330_11_PSC:
	case SNiP_20503_84_PSC_MKS:
	case SP_35_13330_11_PSC_MKS:
		MakePscDsgnDgrmDataKR_RS(ElemK, RsltD, bCheckIMin, bCheckIMax, bCheckJMin, bCheckJMax);
		break;
	case AS_5100_5_17_PSC:
		MakePscDsgnDgrmDataKR_AS(ElemK, RsltD, bCheckIMin, bCheckIMax, bCheckJMin, bCheckJMax);
		break;
	default:
		ASSERT(0);
		break;
	}

	if (bCheckIMax == FALSE && bCheckJMax == TRUE)
	{
		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1];
		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1];
	}
	else if (bCheckIMax == TRUE && bCheckJMax == FALSE)
	{
		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0];
		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0];
	}
	if (bCheckIMin == FALSE && bCheckJMin == TRUE)
	{
		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1];
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1];
	}
	else if (bCheckIMin == TRUE && bCheckJMin == FALSE)
	{
		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0];
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0];
	}

	FinishMakingPscDsgnData(RsltD);
	return TRUE;
}

BOOL  CDesignEngine::MakePscDsgnDgrmDataKR_KS(T_ELEM_K ElemK, T_PSC_DSGN_RESL_D RsltD[4], BOOL &bCheckIMin, BOOL &bCheckIMax, BOOL &bCheckJMin, BOOL &bCheckJMax)
{
	CDBDoc *pDoc = CDBDoc::GetDocPoint();

	if (m_nDgnCode == KSCE_USD03 || m_nDgnCode == KSCE_USD05 || m_nDgnCode == KSCE_USD10 ||
		m_nDgnCode == KSCE_RAIL_USD04 || m_nDgnCode == KSCE_RAIL_USD11)
	{
		switch (m_nPSCComp)
		{
		case PSC_DSGN_COMP_BEND_Y:
		{
			T_BDCY_KSCE BdcyKsceD;
			if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetBdcyKsceData(ElemK, BdcyKsceD))	return FALSE;

			//T_BDCY_KSCE_BASE BdcyBase[4];	// 0=I-MAX, 1=I-MIN, 2=J-MAX, 3=J-MIN.
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(BdcyKsceD.BdcyBase[0].dpMny); // Max I 강도 
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(BdcyKsceD.BdcyBase[2].dpMny); // Max J 강도 
			RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(BdcyKsceD.BdcyBase[1].dpMny); // Min I 강도 
			RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(BdcyKsceD.BdcyBase[3].dpMny); // Min J 강도 

			RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = BdcyKsceD.BdcyBase[0].dMuy; // Max I 계수부재력 
			RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = BdcyKsceD.BdcyBase[2].dMuy; // Max J 계수부재력 
			RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = BdcyKsceD.BdcyBase[1].dMuy; // Min I 계수부재력 
			RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = BdcyKsceD.BdcyBase[3].dMuy; // Min J 계수부재력 

			bCheckIMax = BdcyKsceD.BdcyBase[0].bCHK;
			bCheckJMax = BdcyKsceD.BdcyBase[2].bCHK;
			bCheckIMin = BdcyKsceD.BdcyBase[1].bCHK;
			bCheckJMin = BdcyKsceD.BdcyBase[3].bCHK;
		}
		break;
		case PSC_DSGN_COMP_BEND_Z:
		{
			T_BDCZ_KSCE BdczKsceD;
			if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetBdczKsceData(ElemK, BdczKsceD))	return FALSE;

			//T_BDCZ_KSCE_BASE BdczBase[4];	// 0=I-MAX, 1=I-MIN, 2=J-MAX, 3=J-MIN.
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(BdczKsceD.BdczBase[0].dpMny); // Max I 강도 
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(BdczKsceD.BdczBase[2].dpMny); // Max J 강도 
			RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(BdczKsceD.BdczBase[1].dpMny); // Min I 강도 
			RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(BdczKsceD.BdczBase[3].dpMny); // Min J 강도 

			RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = BdczKsceD.BdczBase[0].dMuy; // Max I 계수부재력 
			RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = BdczKsceD.BdczBase[2].dMuy; // Max J 계수부재력 
			RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = BdczKsceD.BdczBase[1].dMuy; // Min I 계수부재력 
			RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = BdczKsceD.BdczBase[3].dMuy; // Min J 계수부재력 

			bCheckIMax = BdczKsceD.BdczBase[0].bCHK;
			bCheckJMax = BdczKsceD.BdczBase[2].bCHK;
			bCheckIMin = BdczKsceD.BdczBase[1].bCHK;
			bCheckJMin = BdczKsceD.BdczBase[3].bCHK;
		}
		break;
		case PSC_DSGN_COMP_SHER_Z:
		{
			T_CUMS_KSCE CumsKsceD;
			if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetCumsKsceData(ElemK, CumsKsceD))return FALSE;

			// T_CUMS_KSCE_BASE CumsBase[4];	// 0=I-MAX, 1=I-MIN, 2=J-MAX, 3=J-MIN.
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(CumsKsceD.CumsBase[0].dpVn); // Max I 강도 
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(CumsKsceD.CumsBase[2].dpVn); // Max J 강도 
			RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = fabs(CumsKsceD.CumsBase[1].dpVn); // Min I 강도 
			RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = fabs(CumsKsceD.CumsBase[3].dpVn); // Min J 강도 

			RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = fabs(CumsKsceD.CumsBase[0].dVu); // Max I 계수부재력 
			RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = fabs(CumsKsceD.CumsBase[2].dVu); // Max J 계수부재력 
			RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = fabs(CumsKsceD.CumsBase[1].dVu); // Min I 계수부재력 
			RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = fabs(CumsKsceD.CumsBase[3].dVu); // Min J 계수부재력 

			bCheckIMax = CumsKsceD.CumsBase[0].bCHK;
			bCheckJMax = CumsKsceD.CumsBase[2].bCHK;
			bCheckIMin = CumsKsceD.CumsBase[1].bCHK;
			bCheckJMin = CumsKsceD.CumsBase[3].bCHK;
		}
		break;
		case PSC_DSGN_COMP_TORSION:
		{
			T_CRMT_KSCE CrmtKsce;
			if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetCrmtKsceData(ElemK, CrmtKsce)) return FALSE;

			//T_CRMT_KSCE_BASE CrmtBase[6];	// 0=I-V-MAX, 1=I-V-MIN, 2=I-T-MAX, 3=J-V-MAX, 4=J-V-MIN, 5=J-T-MAX.
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(CrmtKsce.CrmtBase[0].dpTn); // Max I 강도 
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(CrmtKsce.CrmtBase[3].dpTn); // Max J 강도 
			RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = fabs(CrmtKsce.CrmtBase[1].dpTn); // Min I 강도 
			RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = fabs(CrmtKsce.CrmtBase[4].dpTn); // Min J 강도 

			RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = fabs(CrmtKsce.CrmtBase[0].dTu); // Max I 계수부재력 
			RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = fabs(CrmtKsce.CrmtBase[3].dTu); // Max J 계수부재력 
			RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = fabs(CrmtKsce.CrmtBase[1].dTu); // Min I 계수부재력 
			RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = fabs(CrmtKsce.CrmtBase[4].dTu); // Min J 계수부재력 

			bCheckIMax = CrmtKsce.CrmtBase[0].bCHK;
			bCheckJMax = CrmtKsce.CrmtBase[3].bCHK;
			bCheckIMin = CrmtKsce.CrmtBase[1].bCHK;
			bCheckJMin = CrmtKsce.CrmtBase[4].bCHK;
		}
		break;
		case PSC_DSGN_COMP_TORSION_MAXTOR:
		{
			T_CRMT_KSCE CrmtKsce;
			if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetCrmtKsceData(ElemK, CrmtKsce)) return FALSE;

			//T_CRMT_KSCE_BASE CrmtBase[6];	// 0=I-V-MAX, 1=I-V-MIN, 2=I-T-MAX, 3=J-V-MAX, 4=J-V-MIN, 5=J-T-MAX.
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(CrmtKsce.CrmtBase[2].dpTn); // Max I 강도 
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(CrmtKsce.CrmtBase[5].dpTn); // Max J 강도 

			RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = fabs(CrmtKsce.CrmtBase[2].dTu); // Max I 계수부재력 
			RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = fabs(CrmtKsce.CrmtBase[5].dTu); // Max J 계수부재력 

			bCheckIMax = CrmtKsce.CrmtBase[2].bCHK;
			bCheckJMax = CrmtKsce.CrmtBase[5].bCHK;
		}
		break;
		default:
			break;
		}
	}
	else if (CDBLib::IsPscCodeLSD_KR(m_nDgnCode))
	{
		switch (m_nPSCComp)
		{
		case PSC_DSGN_COMP_BEND_Y:
		{
			BOOL bPscComposite = pDoc->m_pPostCtrl->IsPSCCompositeSect();
			if (bPscComposite) // psc composite
			{
				T_BDCR_PSC_COMP BdcrD;
				if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadBdcr_PSC_Comp(ElemK, BdcrD))	return FALSE;

				//T_BDCY_KSCE_BASE BdcyBase[4];	// 0=I-MAX, 1=I-MIN, 2=J-MAX, 3=J-MIN.
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(BdcrD.BdcrBase[0].dphiMn); // Max I 강도, drMuy=pMny 임. 
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(BdcrD.BdcrBase[2].dphiMn); // Max J 강도 
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(BdcrD.BdcrBase[1].dphiMn); // Min I 강도 
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(BdcrD.BdcrBase[3].dphiMn); // Min J 강도 

				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = BdcrD.BdcrBase[0].dMu; // Max I 계수부재력 
				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = BdcrD.BdcrBase[2].dMu; // Max J 계수부재력 
				RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = BdcrD.BdcrBase[1].dMu; // Min I 계수부재력 
				RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = BdcrD.BdcrBase[3].dMu; // Min J 계수부재력 

				bCheckIMax = BdcrD.BdcrBase[0].bCHK;
				bCheckJMax = BdcrD.BdcrBase[2].bCHK;
				bCheckIMin = BdcrD.BdcrBase[1].bCHK;
				bCheckJMin = BdcrD.BdcrBase[3].bCHK;
			}
			else // psc box
			{
				T_BDCR_PSC BdcrD;
				if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadBdcr_PSC(ElemK, BdcrD))	return FALSE;

				//T_BDCY_KSCE_BASE BdcyBase[4];	// 0=I-MAX, 1=I-MIN, 2=J-MAX, 3=J-MIN.
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(BdcrD.BdcrBase[0].dphiMn); // Max I 강도, drMuy=pMny 임. 
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(BdcrD.BdcrBase[2].dphiMn); // Max J 강도 
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(BdcrD.BdcrBase[1].dphiMn); // Min I 강도 
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(BdcrD.BdcrBase[3].dphiMn); // Min J 강도 

				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = BdcrD.BdcrBase[0].dMu; // Max I 계수부재력 
				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = BdcrD.BdcrBase[2].dMu; // Max J 계수부재력 
				RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = BdcrD.BdcrBase[1].dMu; // Min I 계수부재력 
				RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = BdcrD.BdcrBase[3].dMu; // Min J 계수부재력 

				bCheckIMax = BdcrD.BdcrBase[0].bCHK;
				bCheckJMax = BdcrD.BdcrBase[2].bCHK;
				bCheckIMin = BdcrD.BdcrBase[1].bCHK;
				bCheckJMin = BdcrD.BdcrBase[3].bCHK;
			}
		}
		break;
		case PSC_DSGN_COMP_BEND_Z:
		{
			T_BDCZ_KSCE BdczKsceD;
			if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetBdczKsceData(ElemK, BdczKsceD))	return FALSE;

			//T_BDCZ_KSCE_BASE BdczBase[4];	// 0=I-MAX, 1=I-MIN, 2=J-MAX, 3=J-MIN.
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(BdczKsceD.BdczBase[0].dpMny); // Max I 강도 
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(BdczKsceD.BdczBase[2].dpMny); // Max J 강도 
			RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(BdczKsceD.BdczBase[1].dpMny); // Min I 강도 
			RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(BdczKsceD.BdczBase[3].dpMny); // Min J 강도 

			RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = BdczKsceD.BdczBase[0].dMuy; // Max I 계수부재력 
			RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = BdczKsceD.BdczBase[2].dMuy; // Max J 계수부재력 
			RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = BdczKsceD.BdczBase[1].dMuy; // Min I 계수부재력 
			RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = BdczKsceD.BdczBase[3].dMuy; // Min J 계수부재력 

			bCheckIMax = BdczKsceD.BdczBase[0].bCHK;
			bCheckJMax = BdczKsceD.BdczBase[2].bCHK;
			bCheckIMin = BdczKsceD.BdczBase[1].bCHK;
			bCheckJMin = BdczKsceD.BdczBase[3].bCHK;
		}
		break;
		case PSC_DSGN_COMP_SHER_Z:
		{
			BOOL bPscComposite = pDoc->m_pPostCtrl->IsPSCCompositeSect();

			if (bPscComposite)
			{
				T_CUMS_PSC_COMP CumsCompD;
				if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadCums_PSC_Comp(ElemK, CumsCompD))	return FALSE;

				// T_CUMS_KSCE_BASE CumsBase[4];	// 0=I-MAX, 1=I-MIN, 2=J-MAX, 3=J-MIN.
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(CumsCompD.CumsBase[0].dPhiVn); // Max I 강도 
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(CumsCompD.CumsBase[2].dPhiVn); // Max J 강도 
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = fabs(CumsCompD.CumsBase[1].dPhiVn); // Min I 강도 
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = fabs(CumsCompD.CumsBase[3].dPhiVn); // Min J 강도 

				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = fabs(CumsCompD.CumsBase[0].dVu); // Max I 계수부재력 
				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = fabs(CumsCompD.CumsBase[2].dVu); // Max J 계수부재력 
				RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = fabs(CumsCompD.CumsBase[1].dVu); // Min I 계수부재력 
				RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = fabs(CumsCompD.CumsBase[3].dVu); // Min J 계수부재력 

				bCheckIMax = CumsCompD.CumsBase[0].bCHK;
				bCheckJMax = CumsCompD.CumsBase[2].bCHK;
				bCheckIMin = CumsCompD.CumsBase[1].bCHK;
				bCheckJMin = CumsCompD.CumsBase[3].bCHK;
			}
			else
			{
				T_CUMS_PSC CumsD;
				if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadCums_PSC(ElemK, CumsD))return FALSE;

				// T_CUMS_KSCE_BASE CumsBase[4];	// 0=I-MAX, 1=I-MIN, 2=J-MAX, 3=J-MIN.
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(CumsD.CumsBase[0].dPhiVn); // Max I 강도 
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(CumsD.CumsBase[2].dPhiVn); // Max J 강도 
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(CumsD.CumsBase[1].dPhiVn); // Min I 강도 
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(CumsD.CumsBase[3].dPhiVn); // Min J 강도 

				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = CumsD.CumsBase[0].dVu; // Max I 계수부재력 
				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = CumsD.CumsBase[2].dVu; // Max J 계수부재력 
				RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = CumsD.CumsBase[1].dVu; // Min I 계수부재력 
				RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = CumsD.CumsBase[3].dVu; // Min J 계수부재력 

				bCheckIMax = CumsD.CumsBase[0].bCHK;
				bCheckJMax = CumsD.CumsBase[2].bCHK;
				bCheckIMin = CumsD.CumsBase[1].bCHK;
				bCheckJMin = CumsD.CumsBase[3].bCHK;
			}
		}
		break;
		case PSC_DSGN_COMP_TORSION:
		{
			BOOL bPscComposite = pDoc->m_pPostCtrl->IsPSCCompositeSect();

			if (bPscComposite)
			{
				T_CRMT_PSC_COMP CrmtCompD;
				if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadCrmt_PSC_Comp(ElemK, CrmtCompD)) return FALSE;

				//T_CRMT_KSCE_BASE CrmtBase[6];	// 0=I-V-MAX, 1=I-V-MIN, 2=I-T-MAX, 3=J-V-MAX, 4=J-V-MIN, 5=J-T-MAX.
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(CrmtCompD.CrmtBase[0].dPhi_tTn); // Max I 강도 
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(CrmtCompD.CrmtBase[3].dPhi_tTn); // Max J 강도 
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = fabs(CrmtCompD.CrmtBase[1].dPhi_tTn); // Min I 강도 
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = fabs(CrmtCompD.CrmtBase[4].dPhi_tTn); // Min J 강도 

				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = fabs(CrmtCompD.CrmtBase[0].dTu); // Max I 계수부재력 
				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = fabs(CrmtCompD.CrmtBase[3].dTu); // Max J 계수부재력 
				RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = fabs(CrmtCompD.CrmtBase[1].dTu); // Min I 계수부재력 
				RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = fabs(CrmtCompD.CrmtBase[4].dTu); // Min J 계수부재력 

				bCheckIMax = CrmtCompD.CrmtBase[0].bCHK;
				bCheckJMax = CrmtCompD.CrmtBase[3].bCHK;
				bCheckIMin = CrmtCompD.CrmtBase[1].bCHK;
				bCheckJMin = CrmtCompD.CrmtBase[4].bCHK;
			}
			else
			{
				T_CRMT_PSC CrmtD;
				if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadCrmt_PSC(ElemK, CrmtD)) return FALSE;

				//T_CRMT_KSCE_BASE CrmtBase[6];	// 0=I-V-MAX, 1=I-V-MIN, 2=I-T-MAX, 3=J-V-MAX, 4=J-V-MIN, 5=J-T-MAX.
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(CrmtD.CrmtBase[0].dPhi_tTn); // Max I 강도 
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(CrmtD.CrmtBase[3].dPhi_tTn); // Max J 강도 
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = fabs(CrmtD.CrmtBase[1].dPhi_tTn); // Min I 강도 
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = fabs(CrmtD.CrmtBase[4].dPhi_tTn); // Min J 강도 

				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = fabs(CrmtD.CrmtBase[0].dTu); // Max I 계수부재력 
				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = fabs(CrmtD.CrmtBase[3].dTu); // Max J 계수부재력 
				RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = fabs(CrmtD.CrmtBase[1].dTu); // Min I 계수부재력 
				RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = fabs(CrmtD.CrmtBase[4].dTu); // Min J 계수부재력 

				bCheckIMax = CrmtD.CrmtBase[0].bCHK;
				bCheckJMax = CrmtD.CrmtBase[3].bCHK;
				bCheckIMin = CrmtD.CrmtBase[1].bCHK;
				bCheckJMin = CrmtD.CrmtBase[4].bCHK;
			}
		}
		break;
		case PSC_DSGN_COMP_TORSION_MAXTOR:
		{
			BOOL bPscComposite = pDoc->m_pPostCtrl->IsPSCCompositeSect();

			if (bPscComposite)
			{
				T_CRMT_PSC_COMP CrmtCompD;
				if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadCrmt_PSC_Comp(ElemK, CrmtCompD)) return FALSE;

				//T_CRMT_KSCE_BASE CrmtBase[6];	// 0=I-V-MAX, 1=I-V-MIN, 2=I-T-MAX, 3=J-V-MAX, 4=J-V-MIN, 5=J-T-MAX.
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(CrmtCompD.CrmtBase[2].dPhi_tTn); // Max I 강도 
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(CrmtCompD.CrmtBase[5].dPhi_tTn); // Max J 강도 

				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = fabs(CrmtCompD.CrmtBase[2].dTu); // Max I 계수부재력 
				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = fabs(CrmtCompD.CrmtBase[5].dTu); // Max J 계수부재력 

				bCheckIMax = CrmtCompD.CrmtBase[2].bCHK;
				bCheckJMax = CrmtCompD.CrmtBase[5].bCHK;
			}
			else
			{
				T_CRMT_PSC CrmtD;
				if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadCrmt_PSC(ElemK, CrmtD)) return FALSE;

				//T_CRMT_KSCE_BASE CrmtBase[6];	// 0=I-V-MAX, 1=I-V-MIN, 2=I-T-MAX, 3=J-V-MAX, 4=J-V-MIN, 5=J-T-MAX.
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(CrmtD.CrmtBase[2].dPhi_tTn); // Max I 강도 
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(CrmtD.CrmtBase[5].dPhi_tTn); // Max J 강도 

				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = fabs(CrmtD.CrmtBase[2].dTu); // Max I 계수부재력 
				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = fabs(CrmtD.CrmtBase[5].dTu); // Max J 계수부재력 

				bCheckIMax = CrmtD.CrmtBase[2].bCHK;
				bCheckJMax = CrmtD.CrmtBase[5].bCHK;
			}
		}
		break;
		default:
			ASSERT(0);
			break;
		}
	}
	else
	{
		return FALSE;
	}
	return TRUE;
}

BOOL  CDesignEngine::MakePscDsgnDgrmDataKR_US(T_ELEM_K ElemK, T_PSC_DSGN_RESL_D RsltD[4], BOOL &bCheckIMin, BOOL &bCheckIMax, BOOL &bCheckJMin, BOOL &bCheckJMax)
{
	CDBDoc *pDoc = CDBDoc::GetDocPoint();

	if (m_nPSCCirteriaType == 0 || m_nPSCCirteriaType == 1) // Force : 0, 1 Stress 2, 3
	{
		switch (m_nPSCComp)
		{
		case PSC_DSGN_COMP_BEND_Y:
		{
			T_BDCY_AASHTO BdcyAASHD;
			if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadBdcy_AASHTO(ElemK, BdcyAASHD))	return FALSE;

			//T_BDCY_KSCE_BASE BdcyBase[4];	// 0=I-MAX, 1=I-MIN, 2=J-MAX, 3=J-MIN.
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(BdcyAASHD.BdcyBase[0].drMuy); // Max I 강도, drMuy=pMny 임. 
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(BdcyAASHD.BdcyBase[2].drMuy); // Max J 강도 
			RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(BdcyAASHD.BdcyBase[1].drMuy); // Min I 강도 
			RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(BdcyAASHD.BdcyBase[3].drMuy); // Min J 강도 

			RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = BdcyAASHD.BdcyBase[0].dMuy; // Max I 계수부재력 
			RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = BdcyAASHD.BdcyBase[2].dMuy; // Max J 계수부재력 
			RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = BdcyAASHD.BdcyBase[1].dMuy; // Min I 계수부재력 
			RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = BdcyAASHD.BdcyBase[3].dMuy; // Min J 계수부재력 

			bCheckIMax = BdcyAASHD.BdcyBase[0].bCHK;
			bCheckJMax = BdcyAASHD.BdcyBase[2].bCHK;
			bCheckIMin = BdcyAASHD.BdcyBase[1].bCHK;
			bCheckJMin = BdcyAASHD.BdcyBase[3].bCHK;
		}
		break;
		case PSC_DSGN_COMP_BEND_Z:
		{
			T_BDCZ_KSCE BdczKsceD;
			if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetBdczKsceData(ElemK, BdczKsceD))	return FALSE;

			//T_BDCZ_KSCE_BASE BdczBase[4];	// 0=I-MAX, 1=I-MIN, 2=J-MAX, 3=J-MIN.
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(BdczKsceD.BdczBase[0].dpMny); // Max I 강도 
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(BdczKsceD.BdczBase[2].dpMny); // Max J 강도 
			RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(BdczKsceD.BdczBase[1].dpMny); // Min I 강도 
			RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(BdczKsceD.BdczBase[3].dpMny); // Min J 강도 

			RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = BdczKsceD.BdczBase[0].dMuy; // Max I 계수부재력 
			RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = BdczKsceD.BdczBase[2].dMuy; // Max J 계수부재력 
			RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = BdczKsceD.BdczBase[1].dMuy; // Min I 계수부재력 
			RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = BdczKsceD.BdczBase[3].dMuy; // Min J 계수부재력 

			bCheckIMax = BdczKsceD.BdczBase[0].bCHK;
			bCheckJMax = BdczKsceD.BdczBase[2].bCHK;
			bCheckIMin = BdczKsceD.BdczBase[1].bCHK;
			bCheckJMin = BdczKsceD.BdczBase[3].bCHK;
		}
		break;
		case PSC_DSGN_COMP_SHER_Z:
		{
			T_CUMS_AASHTO CumsAASH;
			if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadCums_AASHTO(ElemK, CumsAASH))return FALSE;

			// T_CUMS_KSCE_BASE CumsBase[4];	// 0=I-MAX, 1=I-MIN, 2=J-MAX, 3=J-MIN.
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(CumsAASH.CumsBase[0].dPhiVn); // Max I 강도 
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(CumsAASH.CumsBase[2].dPhiVn); // Max J 강도 
			RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = fabs(CumsAASH.CumsBase[1].dPhiVn); // Min I 강도 
			RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = fabs(CumsAASH.CumsBase[3].dPhiVn); // Min J 강도 

			RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = fabs(CumsAASH.CumsBase[0].dVu); // Max I 계수부재력 
			RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = fabs(CumsAASH.CumsBase[2].dVu); // Max J 계수부재력 
			RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = fabs(CumsAASH.CumsBase[1].dVu); // Min I 계수부재력 
			RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = fabs(CumsAASH.CumsBase[3].dVu); // Min J 계수부재력 

			bCheckIMax = CumsAASH.CumsBase[0].bCHK;
			bCheckJMax = CumsAASH.CumsBase[2].bCHK;
			bCheckIMin = CumsAASH.CumsBase[1].bCHK;
			bCheckJMin = CumsAASH.CumsBase[3].bCHK;
		}
		break;
		case PSC_DSGN_COMP_TORSION:
		{
			T_CRMT_AASHTO CrmtAASH;
			if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadCrmt_AASHTO(ElemK, CrmtAASH)) return FALSE;

			//T_CRMT_KSCE_BASE CrmtBase[6];	// 0=I-V-MAX, 1=I-V-MIN, 2=I-T-MAX, 3=J-V-MAX, 4=J-V-MIN, 5=J-T-MAX.
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(CrmtAASH.CrmtBase[0].dPhi_tTn); // Max I 강도 
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(CrmtAASH.CrmtBase[3].dPhi_tTn); // Max J 강도 
			RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = fabs(CrmtAASH.CrmtBase[1].dPhi_tTn); // Min I 강도 
			RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = fabs(CrmtAASH.CrmtBase[4].dPhi_tTn); // Min J 강도 

			RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = fabs(CrmtAASH.CrmtBase[0].dTu); // Max I 계수부재력 
			RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = fabs(CrmtAASH.CrmtBase[3].dTu); // Max J 계수부재력 
			RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = fabs(CrmtAASH.CrmtBase[1].dTu); // Min I 계수부재력 
			RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = fabs(CrmtAASH.CrmtBase[4].dTu); // Min J 계수부재력 

			bCheckIMax = CrmtAASH.CrmtBase[0].bCHK;
			bCheckJMax = CrmtAASH.CrmtBase[3].bCHK;
			bCheckIMin = CrmtAASH.CrmtBase[1].bCHK;
			bCheckJMin = CrmtAASH.CrmtBase[4].bCHK;
		}
		break;
		case PSC_DSGN_COMP_TORSION_MAXTOR:
		{
			T_CRMT_AASHTO CrmtAASH;
			if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadCrmt_AASHTO(ElemK, CrmtAASH)) return FALSE;

			//T_CRMT_KSCE_BASE CrmtBase[6];	// 0=I-V-MAX, 1=I-V-MIN, 2=I-T-MAX, 3=J-V-MAX, 4=J-V-MIN, 5=J-T-MAX.
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(CrmtAASH.CrmtBase[2].dPhi_tTn); // Max I 강도 
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(CrmtAASH.CrmtBase[5].dPhi_tTn); // Max J 강도 

			RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = fabs(CrmtAASH.CrmtBase[2].dTu); // Max I 계수부재력 
			RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = fabs(CrmtAASH.CrmtBase[5].dTu); // Max J 계수부재력 

			bCheckIMax = CrmtAASH.CrmtBase[2].bCHK;
			bCheckJMax = CrmtAASH.CrmtBase[5].bCHK;
		}
		break;
		default:
			break;
		}
	}
	//PSC Composite Stress Result Diagram 추가
	else if (m_nPSCCirteriaType == 2 || m_nPSCCirteriaType == 3) // Stress : 2, 3
	{
		switch (m_nPSCCompStr)
		{
		case PSC_DSGN_COMP_CONSTRUCTION:
		{
			BOOL bPscComposite = pDoc->m_pPostCtrl->IsElem4CompositePSCSect(ElemK);

			if (bPscComposite)
			{
				T_FYSG_AASHTO FysgD_Gr; FysgD_Gr.Initialize();
				if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadFysg_AASHTO_Composite_Gr(ElemK, FysgD_Gr)) return FALSE;

				T_FYSG_AASHTO FysgD_Sl; FysgD_Sl.Initialize();
				if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadFysg_AASHTO_Composite_Sl(ElemK, FysgD_Sl)) return FALSE;

				if (m_nPSCPart == PSC_DSGN_COMP_STRESS_GIRDER)
				{
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(FysgD_Gr.FysgBase[0].dALW); // Max I
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(FysgD_Gr.FysgBase[2].dALW); // Max J
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(FysgD_Gr.FysgBase[1].dALW); // Min I
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(FysgD_Gr.FysgBase[3].dALW); // Min J

					if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_TOP)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgD_Gr.FysgBase[0].dFT; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgD_Gr.FysgBase[2].dFT; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgD_Gr.FysgBase[1].dFT; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgD_Gr.FysgBase[3].dFT; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_BOT)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgD_Gr.FysgBase[0].dFB; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgD_Gr.FysgBase[2].dFB; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgD_Gr.FysgBase[1].dFB; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgD_Gr.FysgBase[3].dFB; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP1)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgD_Gr.FysgBase[0].dFTL; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgD_Gr.FysgBase[2].dFTL; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgD_Gr.FysgBase[1].dFTL; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgD_Gr.FysgBase[3].dFTL; // Min J		
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP2)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgD_Gr.FysgBase[0].dFTR; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgD_Gr.FysgBase[2].dFTR; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgD_Gr.FysgBase[1].dFTR; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgD_Gr.FysgBase[3].dFTR; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP3)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgD_Gr.FysgBase[0].dFBR; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgD_Gr.FysgBase[2].dFBR; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgD_Gr.FysgBase[1].dFBR; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgD_Gr.FysgBase[3].dFBR; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP4)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgD_Gr.FysgBase[0].dFBL; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgD_Gr.FysgBase[2].dFBL; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgD_Gr.FysgBase[1].dFBL; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgD_Gr.FysgBase[3].dFBL; // Min J	
					}
					else
					{
						ASSERT(0);
					}

					bCheckIMax = FysgD_Gr.FysgBase[0].bCHK;
					bCheckJMax = FysgD_Gr.FysgBase[2].bCHK;
					bCheckIMin = FysgD_Gr.FysgBase[1].bCHK;
					bCheckJMin = FysgD_Gr.FysgBase[3].bCHK;
				}
				else if (m_nPSCPart == PSC_DSGN_COMP_STRESS_SLAB)
				{
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(FysgD_Sl.FysgBase[0].dALW); // Max I
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(FysgD_Sl.FysgBase[2].dALW); // Max J
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(FysgD_Sl.FysgBase[1].dALW); // Min I
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(FysgD_Sl.FysgBase[3].dALW); // Min J

					if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_TOP)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgD_Sl.FysgBase[0].dFT; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgD_Sl.FysgBase[2].dFT; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgD_Sl.FysgBase[1].dFT; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgD_Sl.FysgBase[3].dFT; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_BOT)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgD_Sl.FysgBase[0].dFB; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgD_Sl.FysgBase[2].dFB; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgD_Sl.FysgBase[1].dFB; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgD_Sl.FysgBase[3].dFB; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP1)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgD_Sl.FysgBase[0].dFTL; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgD_Sl.FysgBase[2].dFTL; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgD_Sl.FysgBase[1].dFTL; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgD_Sl.FysgBase[3].dFTL; // Min J		
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP2)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgD_Sl.FysgBase[0].dFTR; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgD_Sl.FysgBase[2].dFTR; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgD_Sl.FysgBase[1].dFTR; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgD_Sl.FysgBase[3].dFTR; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP3)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgD_Sl.FysgBase[0].dFBR; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgD_Sl.FysgBase[2].dFBR; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgD_Sl.FysgBase[1].dFBR; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgD_Sl.FysgBase[3].dFBR; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP4)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgD_Sl.FysgBase[0].dFBL; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgD_Sl.FysgBase[2].dFBL; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgD_Sl.FysgBase[1].dFBL; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgD_Sl.FysgBase[3].dFBL; // Min J	
					}
					else
					{
						ASSERT(0);
					}

					bCheckIMax = FysgD_Sl.FysgBase[0].bCHK;
					bCheckJMax = FysgD_Sl.FysgBase[2].bCHK;
					bCheckIMin = FysgD_Sl.FysgBase[1].bCHK;
					bCheckJMin = FysgD_Sl.FysgBase[3].bCHK;
				}
				else
				{
					ASSERT(0);
				}
			}
			else
			{
				T_FYSG_AASHTO FysgD; FysgD.Initialize();
				if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadFysg_AASHTO(ElemK, FysgD)) return FALSE;

				if (m_nPSCPart == PSC_DSGN_COMP_STRESS_GIRDER)
				{
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(FysgD.FysgBase[0].dALW); // Max I
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(FysgD.FysgBase[2].dALW); // Max J
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(FysgD.FysgBase[1].dALW); // Min I
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(FysgD.FysgBase[3].dALW); // Min J

					if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_TOP)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgD.FysgBase[0].dFT; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgD.FysgBase[2].dFT; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgD.FysgBase[1].dFT; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgD.FysgBase[3].dFT; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_BOT)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgD.FysgBase[0].dFB; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgD.FysgBase[2].dFB; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgD.FysgBase[1].dFB; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgD.FysgBase[3].dFB; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP1)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgD.FysgBase[0].dFTL; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgD.FysgBase[2].dFTL; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgD.FysgBase[1].dFTL; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgD.FysgBase[3].dFTL; // Min J		
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP2)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgD.FysgBase[0].dFTR; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgD.FysgBase[2].dFTR; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgD.FysgBase[1].dFTR; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgD.FysgBase[3].dFTR; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP3)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgD.FysgBase[0].dFBR; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgD.FysgBase[2].dFBR; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgD.FysgBase[1].dFBR; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgD.FysgBase[3].dFBR; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP4)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgD.FysgBase[0].dFBL; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgD.FysgBase[2].dFBL; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgD.FysgBase[1].dFBL; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgD.FysgBase[3].dFBL; // Min J	
					}
					else
					{
						ASSERT(0);
					}

					bCheckIMax = FysgD.FysgBase[0].bCHK;
					bCheckJMax = FysgD.FysgBase[2].bCHK;
					bCheckIMin = FysgD.FysgBase[1].bCHK;
					bCheckJMin = FysgD.FysgBase[3].bCHK;
				}
				else if (m_nPSCPart == PSC_DSGN_COMP_STRESS_SLAB)
				{
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = 0.0; // Max I
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = 0.0; // Max J
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = 0.0; // Min I
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = 0.0; // Min J

					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = 0.0; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = 0.0; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = 0.0; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = 0.0; // Min J

					bCheckIMax = FALSE;
					bCheckJMax = FALSE;
					bCheckIMin = FALSE;
					bCheckJMin = FALSE;
				}
				else
				{
					ASSERT(0);
				}
			}
		}
		break;
		case PSC_DSGN_COMP_SERVICE_LOAD:
		{
			BOOL bPscComposite = pDoc->m_pPostCtrl->IsElem4CompositePSCSect(ElemK);

			if (bPscComposite)
			{
				T_FYCM_AASHTO FycmD_Gr; FycmD_Gr.Initialize();
				if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadFycm_AASHTO_Composite_Gr(ElemK, FycmD_Gr)) return FALSE;

				T_FYCM_AASHTO FycmD_Sl; FycmD_Sl.Initialize();
				if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadFycm_AASHTO_Composite_Sl(ElemK, FycmD_Sl)) return FALSE;

				if (m_nPSCPart == PSC_DSGN_COMP_STRESS_GIRDER)
				{
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(FycmD_Gr.FycmBase[0].dALW); // Max I
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(FycmD_Gr.FycmBase[2].dALW); // Max J
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(FycmD_Gr.FycmBase[1].dALW); // Min I
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(FycmD_Gr.FycmBase[3].dALW); // Min J

					if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_TOP)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmD_Gr.FycmBase[0].dFT; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmD_Gr.FycmBase[2].dFT; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmD_Gr.FycmBase[1].dFT; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmD_Gr.FycmBase[3].dFT; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_BOT)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmD_Gr.FycmBase[0].dFB; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmD_Gr.FycmBase[2].dFB; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmD_Gr.FycmBase[1].dFB; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmD_Gr.FycmBase[3].dFB; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP1)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmD_Gr.FycmBase[0].dFTL; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmD_Gr.FycmBase[2].dFTL; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmD_Gr.FycmBase[1].dFTL; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmD_Gr.FycmBase[3].dFTL; // Min J		
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP2)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmD_Gr.FycmBase[0].dFTR; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmD_Gr.FycmBase[2].dFTR; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmD_Gr.FycmBase[1].dFTR; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmD_Gr.FycmBase[3].dFTR; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP3)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmD_Gr.FycmBase[0].dFBR; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmD_Gr.FycmBase[2].dFBR; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmD_Gr.FycmBase[1].dFBR; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmD_Gr.FycmBase[3].dFBR; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP4)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmD_Gr.FycmBase[0].dFBL; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmD_Gr.FycmBase[2].dFBL; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmD_Gr.FycmBase[1].dFBL; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmD_Gr.FycmBase[3].dFBL; // Min J	
					}
					else
					{
						ASSERT(0);
					}

					bCheckIMax = FycmD_Gr.FycmBase[0].bCHK;
					bCheckJMax = FycmD_Gr.FycmBase[2].bCHK;
					bCheckIMin = FycmD_Gr.FycmBase[1].bCHK;
					bCheckJMin = FycmD_Gr.FycmBase[3].bCHK;
				}
				else if (m_nPSCPart == PSC_DSGN_COMP_STRESS_SLAB)
				{
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(FycmD_Sl.FycmBase[0].dALW); // Max I
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(FycmD_Sl.FycmBase[2].dALW); // Max J
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(FycmD_Sl.FycmBase[1].dALW); // Min I
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(FycmD_Sl.FycmBase[3].dALW); // Min J

					if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_TOP)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmD_Sl.FycmBase[0].dFT; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmD_Sl.FycmBase[2].dFT; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmD_Sl.FycmBase[1].dFT; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmD_Sl.FycmBase[3].dFT; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_BOT)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmD_Sl.FycmBase[0].dFB; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmD_Sl.FycmBase[2].dFB; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmD_Sl.FycmBase[1].dFB; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmD_Sl.FycmBase[3].dFB; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP1)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmD_Sl.FycmBase[0].dFTL; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmD_Sl.FycmBase[2].dFTL; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmD_Sl.FycmBase[1].dFTL; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmD_Sl.FycmBase[3].dFTL; // Min J		
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP2)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmD_Sl.FycmBase[0].dFTR; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmD_Sl.FycmBase[2].dFTR; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmD_Sl.FycmBase[1].dFTR; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmD_Sl.FycmBase[3].dFTR; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP3)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmD_Sl.FycmBase[0].dFBR; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmD_Sl.FycmBase[2].dFBR; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmD_Sl.FycmBase[1].dFBR; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmD_Sl.FycmBase[3].dFBR; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP4)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmD_Sl.FycmBase[0].dFBL; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmD_Sl.FycmBase[2].dFBL; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmD_Sl.FycmBase[1].dFBL; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmD_Sl.FycmBase[3].dFBL; // Min J	
					}
					else
					{
						ASSERT(0);
					}

					bCheckIMax = FycmD_Sl.FycmBase[0].bCHK;
					bCheckJMax = FycmD_Sl.FycmBase[2].bCHK;
					bCheckIMin = FycmD_Sl.FycmBase[1].bCHK;
					bCheckJMin = FycmD_Sl.FycmBase[3].bCHK;
				}
				else
				{
					ASSERT(0);
				}
			}
			else
			{
				T_FYCM_AASHTO FycmD; FycmD.Initialize();
				if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadFycm_AASHTO(ElemK, FycmD)) return FALSE;

				if (m_nPSCPart == PSC_DSGN_COMP_STRESS_GIRDER)
				{
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(FycmD.FycmBase[0].dALW); // Max I
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(FycmD.FycmBase[2].dALW); // Max J
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(FycmD.FycmBase[1].dALW); // Min I
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(FycmD.FycmBase[3].dALW); // Min J

					if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_TOP)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmD.FycmBase[0].dFT; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmD.FycmBase[2].dFT; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmD.FycmBase[1].dFT; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmD.FycmBase[3].dFT; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_BOT)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmD.FycmBase[0].dFB; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmD.FycmBase[2].dFB; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmD.FycmBase[1].dFB; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmD.FycmBase[3].dFB; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP1)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmD.FycmBase[0].dFTL; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmD.FycmBase[2].dFTL; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmD.FycmBase[1].dFTL; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmD.FycmBase[3].dFTL; // Min J		
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP2)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmD.FycmBase[0].dFTR; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmD.FycmBase[2].dFTR; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmD.FycmBase[1].dFTR; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmD.FycmBase[3].dFTR; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP3)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmD.FycmBase[0].dFBR; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmD.FycmBase[2].dFBR; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmD.FycmBase[1].dFBR; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmD.FycmBase[3].dFBR; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP4)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmD.FycmBase[0].dFBL; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmD.FycmBase[2].dFBL; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmD.FycmBase[1].dFBL; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmD.FycmBase[3].dFBL; // Min J	
					}
					else
					{
						ASSERT(0);
					}

					bCheckIMax = FycmD.FycmBase[0].bCHK;
					bCheckJMax = FycmD.FycmBase[2].bCHK;
					bCheckIMin = FycmD.FycmBase[1].bCHK;
					bCheckJMin = FycmD.FycmBase[3].bCHK;
				}
				else if (m_nPSCPart == PSC_DSGN_COMP_STRESS_SLAB)
				{
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = 0.0; // Max I
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = 0.0; // Max J
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = 0.0; // Min I
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = 0.0; // Min J

					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = 0.0; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = 0.0; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = 0.0; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = 0.0; // Min J

					bCheckIMax = FALSE;
					bCheckJMax = FALSE;
					bCheckIMin = FALSE;
					bCheckJMin = FALSE;
				}
				else
				{
					ASSERT(0);
				}
			}
		}
		break;
		default:
			break;
		}
	}
	else
	{
		ASSERT(0);
	}

	return TRUE;
}

BOOL  CDesignEngine::MakePscDsgnDgrmDataKR_EC(T_ELEM_K ElemK, T_PSC_DSGN_RESL_D RsltD[4], BOOL &bCheckIMin, BOOL &bCheckIMax, BOOL &bCheckJMin, BOOL &bCheckJMax)
{
	CDBDoc *pDoc = CDBDoc::GetDocPoint();

	if (m_nPSCCirteriaType == 0 || m_nPSCCirteriaType == 1) // Force
	{
		switch (m_nPSCComp)
		{
		case PSC_DSGN_COMP_BEND_Y:
		{
			//BOOL bPscComposite = pDoc->m_pPostCtrl->ISPSCCompositeSect_EuroCode(ElemK);
			//mqc17817
			BOOL bPscComposite = pDoc->m_pPostCtrl->IsElem4CompositePSCSect(ElemK);
			if (bPscComposite)
			{
				T_BDCR_PSC_COMP BdcrCompD;
				if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadBdcr_PSC_Comp(ElemK, BdcrCompD))	return FALSE;

				//T_BDCY_KSCE_BASE BdcyBase[4];	// 0=I-MAX, 1=I-MIN, 2=J-MAX, 3=J-MIN.
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(BdcrCompD.BdcrBase[0].dphiMn); // Max I 강도, drMuy=pMny 임. 
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(BdcrCompD.BdcrBase[2].dphiMn); // Max J 강도 
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(BdcrCompD.BdcrBase[1].dphiMn); // Min I 강도 
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(BdcrCompD.BdcrBase[3].dphiMn); // Min J 강도 

				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = BdcrCompD.BdcrBase[0].dMu; // Max I 계수부재력 
				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = BdcrCompD.BdcrBase[2].dMu; // Max J 계수부재력 
				RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = BdcrCompD.BdcrBase[1].dMu; // Min I 계수부재력 
				RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = BdcrCompD.BdcrBase[3].dMu; // Min J 계수부재력 

				bCheckIMax = BdcrCompD.BdcrBase[0].bCHK;
				bCheckJMax = BdcrCompD.BdcrBase[2].bCHK;
				bCheckIMin = BdcrCompD.BdcrBase[1].bCHK;
				bCheckJMin = BdcrCompD.BdcrBase[3].bCHK;
			}
			else
			{
				T_BDCR_PSC BdcrD;
				if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadBdcr_PSC(ElemK, BdcrD))	return FALSE;

				//T_BDCY_KSCE_BASE BdcyBase[4];	// 0=I-MAX, 1=I-MIN, 2=J-MAX, 3=J-MIN.
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(BdcrD.BdcrBase[0].dphiMn); // Max I 강도, drMuy=pMny 임. 
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(BdcrD.BdcrBase[2].dphiMn); // Max J 강도 
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(BdcrD.BdcrBase[1].dphiMn); // Min I 강도 
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(BdcrD.BdcrBase[3].dphiMn); // Min J 강도 

				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = BdcrD.BdcrBase[0].dMu; // Max I 계수부재력 
				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = BdcrD.BdcrBase[2].dMu; // Max J 계수부재력 
				RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = BdcrD.BdcrBase[1].dMu; // Min I 계수부재력 
				RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = BdcrD.BdcrBase[3].dMu; // Min J 계수부재력 

				bCheckIMax = BdcrD.BdcrBase[0].bCHK;
				bCheckJMax = BdcrD.BdcrBase[2].bCHK;
				bCheckIMin = BdcrD.BdcrBase[1].bCHK;
				bCheckJMin = BdcrD.BdcrBase[3].bCHK;
			}
		}
		break;
		case PSC_DSGN_COMP_BEND_Z:
		{
			T_BDCZ_KSCE BdczKsceD;
			if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetBdczKsceData(ElemK, BdczKsceD))	return FALSE;

			//T_BDCZ_KSCE_BASE BdczBase[4];	// 0=I-MAX, 1=I-MIN, 2=J-MAX, 3=J-MIN.
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(BdczKsceD.BdczBase[0].dpMny); // Max I 강도 
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(BdczKsceD.BdczBase[2].dpMny); // Max J 강도 
			RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(BdczKsceD.BdczBase[1].dpMny); // Min I 강도 
			RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(BdczKsceD.BdczBase[3].dpMny); // Min J 강도 

			RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = BdczKsceD.BdczBase[0].dMuy; // Max I 계수부재력 
			RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = BdczKsceD.BdczBase[2].dMuy; // Max J 계수부재력 
			RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = BdczKsceD.BdczBase[1].dMuy; // Min I 계수부재력 
			RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = BdczKsceD.BdczBase[3].dMuy; // Min J 계수부재력 

			bCheckIMax = BdczKsceD.BdczBase[0].bCHK;
			bCheckJMax = BdczKsceD.BdczBase[2].bCHK;
			bCheckIMin = BdczKsceD.BdczBase[1].bCHK;
			bCheckJMin = BdczKsceD.BdczBase[3].bCHK;
		}
		break;
		case PSC_DSGN_COMP_SHER_Z:
		{
			//mqc17817
			BOOL bPscComposite = pDoc->m_pPostCtrl->IsElem4CompositePSCSect(ElemK);

			if (bPscComposite)
			{
				T_CUMS_PSC_COMP CumsCompD;
				if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadCums_PSC_Comp(ElemK, CumsCompD))	return FALSE;

				// T_CUMS_KSCE_BASE CumsBase[4];	// 0=I-MAX, 1=I-MIN, 2=J-MAX, 3=J-MIN.
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(CumsCompD.CumsBase[0].dPhiVn); // Max I 강도 
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(CumsCompD.CumsBase[2].dPhiVn); // Max J 강도 
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = fabs(CumsCompD.CumsBase[1].dPhiVn); // Min I 강도 
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = fabs(CumsCompD.CumsBase[3].dPhiVn); // Min J 강도 

				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = fabs(CumsCompD.CumsBase[0].dVu); // Max I 계수부재력 
				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = fabs(CumsCompD.CumsBase[2].dVu); // Max J 계수부재력 
				RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = fabs(CumsCompD.CumsBase[1].dVu); // Min I 계수부재력 
				RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = fabs(CumsCompD.CumsBase[3].dVu); // Min J 계수부재력 

				bCheckIMax = CumsCompD.CumsBase[0].bCHK;
				bCheckJMax = CumsCompD.CumsBase[2].bCHK;
				bCheckIMin = CumsCompD.CumsBase[1].bCHK;
				bCheckJMin = CumsCompD.CumsBase[3].bCHK;
			}
			else
			{
				T_CUMS_PSC CumsD;
				if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadCums_PSC(ElemK, CumsD))return FALSE;

				// T_CUMS_KSCE_BASE CumsBase[4];	// 0=I-MAX, 1=I-MIN, 2=J-MAX, 3=J-MIN.
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(CumsD.CumsBase[0].dPhiVn); // Max I 강도 
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(CumsD.CumsBase[2].dPhiVn); // Max J 강도 
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = fabs(CumsD.CumsBase[1].dPhiVn); // Min I 강도 
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = fabs(CumsD.CumsBase[3].dPhiVn); // Min J 강도 

				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = fabs(CumsD.CumsBase[0].dVu); // Max I 계수부재력 
				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = fabs(CumsD.CumsBase[2].dVu); // Max J 계수부재력 
				RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = fabs(CumsD.CumsBase[1].dVu); // Min I 계수부재력 
				RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = fabs(CumsD.CumsBase[3].dVu); // Min J 계수부재력 

				bCheckIMax = CumsD.CumsBase[0].bCHK;
				bCheckJMax = CumsD.CumsBase[2].bCHK;
				bCheckIMin = CumsD.CumsBase[1].bCHK;
				bCheckJMin = CumsD.CumsBase[3].bCHK;
			}
		}
		break;
		case PSC_DSGN_COMP_TORSION:
		{
			//mqc17817
			BOOL bPscComposite = pDoc->m_pPostCtrl->IsElem4CompositePSCSect(ElemK);

			if (bPscComposite)
			{
				T_CRMT_PSC_COMP CrmtCompD;
				if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadCrmt_PSC_Comp(ElemK, CrmtCompD)) return FALSE;

				//T_CRMT_KSCE_BASE CrmtBase[6];	// 0=I-V-MAX, 1=I-V-MIN, 2=I-T-MAX, 3=J-V-MAX, 4=J-V-MIN, 5=J-T-MAX.
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(CrmtCompD.CrmtBase[0].dPhi_tTn); // Max I 강도 
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(CrmtCompD.CrmtBase[3].dPhi_tTn); // Max J 강도 
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = fabs(CrmtCompD.CrmtBase[1].dPhi_tTn); // Min I 강도 
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = fabs(CrmtCompD.CrmtBase[4].dPhi_tTn); // Min J 강도 

				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = fabs(CrmtCompD.CrmtBase[0].dTu); // Max I 계수부재력 
				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = fabs(CrmtCompD.CrmtBase[3].dTu); // Max J 계수부재력 
				RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = fabs(CrmtCompD.CrmtBase[1].dTu); // Min I 계수부재력 
				RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = fabs(CrmtCompD.CrmtBase[4].dTu); // Min J 계수부재력 

				bCheckIMax = CrmtCompD.CrmtBase[0].bCHK;
				bCheckJMax = CrmtCompD.CrmtBase[3].bCHK;
				bCheckIMin = CrmtCompD.CrmtBase[1].bCHK;
				bCheckJMin = CrmtCompD.CrmtBase[4].bCHK;
			}
			else
			{
				T_CRMT_PSC CrmtD;
				if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadCrmt_PSC(ElemK, CrmtD)) return FALSE;

				//T_CRMT_KSCE_BASE CrmtBase[6];	// 0=I-V-MAX, 1=I-V-MIN, 2=I-T-MAX, 3=J-V-MAX, 4=J-V-MIN, 5=J-T-MAX.
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(CrmtD.CrmtBase[0].dPhi_tTn); // Max I 강도 
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(CrmtD.CrmtBase[3].dPhi_tTn); // Max J 강도 
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = fabs(CrmtD.CrmtBase[1].dPhi_tTn); // Min I 강도 
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = fabs(CrmtD.CrmtBase[4].dPhi_tTn); // Min J 강도 

				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = fabs(CrmtD.CrmtBase[0].dTu); // Max I 계수부재력 
				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = fabs(CrmtD.CrmtBase[3].dTu); // Max J 계수부재력 
				RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = fabs(CrmtD.CrmtBase[1].dTu); // Min I 계수부재력 
				RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = fabs(CrmtD.CrmtBase[4].dTu); // Min J 계수부재력 

				bCheckIMax = CrmtD.CrmtBase[0].bCHK;
				bCheckJMax = CrmtD.CrmtBase[3].bCHK;
				bCheckIMin = CrmtD.CrmtBase[1].bCHK;
				bCheckJMin = CrmtD.CrmtBase[4].bCHK;
			}
		}
		break;
		case PSC_DSGN_COMP_TORSION_MAXTOR:
		{
			//mqc17817
			BOOL bPscComposite = pDoc->m_pPostCtrl->IsElem4CompositePSCSect(ElemK);

			if (bPscComposite)
			{
				T_CRMT_PSC_COMP CrmtCompD;
				if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadCrmt_PSC_Comp(ElemK, CrmtCompD)) return FALSE;

				//T_CRMT_KSCE_BASE CrmtBase[6];	// 0=I-V-MAX, 1=I-V-MIN, 2=I-T-MAX, 3=J-V-MAX, 4=J-V-MIN, 5=J-T-MAX.
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(CrmtCompD.CrmtBase[2].dPhi_tTn); // Max I 강도 
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(CrmtCompD.CrmtBase[5].dPhi_tTn); // Max J 강도 

				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = fabs(CrmtCompD.CrmtBase[2].dTu); // Max I 계수부재력 
				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = fabs(CrmtCompD.CrmtBase[5].dTu); // Max J 계수부재력 

				bCheckIMax = CrmtCompD.CrmtBase[2].bCHK;
				bCheckJMax = CrmtCompD.CrmtBase[5].bCHK;
			}
			else
			{
				T_CRMT_PSC CrmtD;
				if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadCrmt_PSC(ElemK, CrmtD)) return FALSE;

				//T_CRMT_KSCE_BASE CrmtBase[6];	// 0=I-V-MAX, 1=I-V-MIN, 2=I-T-MAX, 3=J-V-MAX, 4=J-V-MIN, 5=J-T-MAX.
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(CrmtD.CrmtBase[2].dPhi_tTn); // Max I 강도 
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(CrmtD.CrmtBase[5].dPhi_tTn); // Max J 강도 

				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = fabs(CrmtD.CrmtBase[2].dTu); // Max I 계수부재력 
				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = fabs(CrmtD.CrmtBase[5].dTu); // Max J 계수부재력 

				bCheckIMax = CrmtD.CrmtBase[2].bCHK;
				bCheckJMax = CrmtD.CrmtBase[5].bCHK;
			}
		}
		break;
		default:
			break;
		}
	}
	else if (m_nPSCCirteriaType == 2 || m_nPSCCirteriaType == 3) // Stress
	{
		switch (m_nPSCCompStr)
		{
		case PSC_DSGN_COMP_CONSTRUCTION:
		{
			//mqc17817
			BOOL bPscComposite = pDoc->m_pPostCtrl->IsElem4CompositePSCSect(ElemK);

			if (bPscComposite)
			{
				T_FYSG_PSC_COMP FysgComp; FysgComp.Initialize();
				if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadFysg_PSC_Comp(ElemK, FysgComp)) return FALSE;

				if (m_nPSCPart == PSC_DSGN_COMP_STRESS_GIRDER)
				{
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(FysgComp.FysgGrBase[0].dALW); // Max I
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(FysgComp.FysgGrBase[2].dALW); // Max J
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(FysgComp.FysgGrBase[1].dALW); // Min I
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(FysgComp.FysgGrBase[3].dALW); // Min J

					if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_TOP)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgComp.FysgGrBase[0].dFT; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgComp.FysgGrBase[2].dFT; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgComp.FysgGrBase[1].dFT; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgComp.FysgGrBase[3].dFT; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_BOT)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgComp.FysgGrBase[0].dFB; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgComp.FysgGrBase[2].dFB; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgComp.FysgGrBase[1].dFB; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgComp.FysgGrBase[3].dFB; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP1)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgComp.FysgGrBase[0].dFTL; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgComp.FysgGrBase[2].dFTL; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgComp.FysgGrBase[1].dFTL; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgComp.FysgGrBase[3].dFTL; // Min J		
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP2)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgComp.FysgGrBase[0].dFTR; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgComp.FysgGrBase[2].dFTR; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgComp.FysgGrBase[1].dFTR; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgComp.FysgGrBase[3].dFTR; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP3)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgComp.FysgGrBase[0].dFBR; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgComp.FysgGrBase[2].dFBR; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgComp.FysgGrBase[1].dFBR; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgComp.FysgGrBase[3].dFBR; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP4)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgComp.FysgGrBase[0].dFBL; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgComp.FysgGrBase[2].dFBL; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgComp.FysgGrBase[1].dFBL; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgComp.FysgGrBase[3].dFBL; // Min J	
					}
					else
					{
						ASSERT(0);
					}

					bCheckIMax = FysgComp.FysgGrBase[0].bCHK;
					bCheckJMax = FysgComp.FysgGrBase[2].bCHK;
					bCheckIMin = FysgComp.FysgGrBase[1].bCHK;
					bCheckJMin = FysgComp.FysgGrBase[3].bCHK;
				}
				else if (m_nPSCPart == PSC_DSGN_COMP_STRESS_SLAB)
				{
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(FysgComp.FysgSlBase[0].dALW); // Max I
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(FysgComp.FysgSlBase[2].dALW); // Max J
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(FysgComp.FysgSlBase[1].dALW); // Min I
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(FysgComp.FysgSlBase[3].dALW); // Min J

					if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_TOP)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgComp.FysgSlBase[0].dFT; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgComp.FysgSlBase[2].dFT; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgComp.FysgSlBase[1].dFT; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgComp.FysgSlBase[3].dFT; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_BOT)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgComp.FysgSlBase[0].dFB; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgComp.FysgSlBase[2].dFB; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgComp.FysgSlBase[1].dFB; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgComp.FysgSlBase[3].dFB; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP1)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgComp.FysgSlBase[0].dFTL; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgComp.FysgSlBase[2].dFTL; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgComp.FysgSlBase[1].dFTL; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgComp.FysgSlBase[3].dFTL; // Min J		
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP2)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgComp.FysgSlBase[0].dFTR; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgComp.FysgSlBase[2].dFTR; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgComp.FysgSlBase[1].dFTR; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgComp.FysgSlBase[3].dFTR; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP3)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgComp.FysgSlBase[0].dFBR; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgComp.FysgSlBase[2].dFBR; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgComp.FysgSlBase[1].dFBR; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgComp.FysgSlBase[3].dFBR; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP4)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgComp.FysgSlBase[0].dFBL; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgComp.FysgSlBase[2].dFBL; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgComp.FysgSlBase[1].dFBL; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgComp.FysgSlBase[3].dFBL; // Min J	
					}
					else
					{
						ASSERT(0);
					}

					bCheckIMax = FysgComp.FysgSlBase[0].bCHK;
					bCheckJMax = FysgComp.FysgSlBase[2].bCHK;
					bCheckIMin = FysgComp.FysgSlBase[1].bCHK;
					bCheckJMin = FysgComp.FysgSlBase[3].bCHK;
				}
				else
				{
					ASSERT(0);
				}
			}
			else
			{
				T_FYSG_PSC Fysg; Fysg.Initialize();
				if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadFysg_PSC(ElemK, Fysg)) return FALSE;

				if (m_nPSCPart == PSC_DSGN_COMP_STRESS_GIRDER)
				{
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(Fysg.FysgBase[0].dALW); // Max I
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(Fysg.FysgBase[2].dALW); // Max J
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(Fysg.FysgBase[1].dALW); // Min I
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(Fysg.FysgBase[3].dALW); // Min J

					if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_TOP)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = Fysg.FysgBase[0].dFT; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = Fysg.FysgBase[2].dFT; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = Fysg.FysgBase[1].dFT; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = Fysg.FysgBase[3].dFT; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_BOT)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = Fysg.FysgBase[0].dFB; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = Fysg.FysgBase[2].dFB; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = Fysg.FysgBase[1].dFB; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = Fysg.FysgBase[3].dFB; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP1)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = Fysg.FysgBase[0].dFTL; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = Fysg.FysgBase[2].dFTL; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = Fysg.FysgBase[1].dFTL; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = Fysg.FysgBase[3].dFTL; // Min J		
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP2)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = Fysg.FysgBase[0].dFTR; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = Fysg.FysgBase[2].dFTR; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = Fysg.FysgBase[1].dFTR; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = Fysg.FysgBase[3].dFTR; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP3)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = Fysg.FysgBase[0].dFBR; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = Fysg.FysgBase[2].dFBR; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = Fysg.FysgBase[1].dFBR; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = Fysg.FysgBase[3].dFBR; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP4)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = Fysg.FysgBase[0].dFBL; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = Fysg.FysgBase[2].dFBL; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = Fysg.FysgBase[1].dFBL; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = Fysg.FysgBase[3].dFBL; // Min J	
					}
					else
					{
						ASSERT(0);
					}

					bCheckIMax = Fysg.FysgBase[0].bCHK;
					bCheckJMax = Fysg.FysgBase[2].bCHK;
					bCheckIMin = Fysg.FysgBase[1].bCHK;
					bCheckJMin = Fysg.FysgBase[3].bCHK;
				}
				else if (m_nPSCPart == PSC_DSGN_COMP_STRESS_SLAB)
				{
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = 0.0; // Max I
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = 0.0; // Max J
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = 0.0; // Min I
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = 0.0; // Min J

					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = 0.0; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = 0.0; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = 0.0; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = 0.0; // Min J

					bCheckIMax = FALSE;
					bCheckJMax = FALSE;
					bCheckIMin = FALSE;
					bCheckJMin = FALSE;
				}
				else
				{
					ASSERT(0);
				}
			}
		}
		break;
		case PSC_DSGN_COMP_SERVICE_LOAD:
		{
			//mqc17817
			BOOL bPscComposite = pDoc->m_pPostCtrl->IsElem4CompositePSCSect(ElemK);

			if (bPscComposite)
			{
				T_FYCM_PSC_COMP FycmComp; FycmComp.Initialize();
				if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadFycm_PSC_Comp(ElemK, FycmComp)) return FALSE;

				if (m_nPSCPart == PSC_DSGN_COMP_STRESS_GIRDER)
				{
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(FycmComp.FycmGrBase[0].dALW); // Max I
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(FycmComp.FycmGrBase[2].dALW); // Max J
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(FycmComp.FycmGrBase[1].dALW); // Min I
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(FycmComp.FycmGrBase[3].dALW); // Min J

					if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_TOP)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmComp.FycmGrBase[0].dFT; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmComp.FycmGrBase[2].dFT; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmComp.FycmGrBase[1].dFT; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmComp.FycmGrBase[3].dFT; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_BOT)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmComp.FycmGrBase[0].dFB; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmComp.FycmGrBase[2].dFB; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmComp.FycmGrBase[1].dFB; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmComp.FycmGrBase[3].dFB; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP1)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmComp.FycmGrBase[0].dFTL; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmComp.FycmGrBase[2].dFTL; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmComp.FycmGrBase[1].dFTL; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmComp.FycmGrBase[3].dFTL; // Min J		
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP2)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmComp.FycmGrBase[0].dFTR; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmComp.FycmGrBase[2].dFTR; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmComp.FycmGrBase[1].dFTR; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmComp.FycmGrBase[3].dFTR; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP3)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmComp.FycmGrBase[0].dFBR; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmComp.FycmGrBase[2].dFBR; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmComp.FycmGrBase[1].dFBR; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmComp.FycmGrBase[3].dFBR; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP4)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmComp.FycmGrBase[0].dFBL; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmComp.FycmGrBase[2].dFBL; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmComp.FycmGrBase[1].dFBL; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmComp.FycmGrBase[3].dFBL; // Min J	
					}
					else
					{
						ASSERT(0);
					}

					bCheckIMax = FycmComp.FycmGrBase[0].bCHK;
					bCheckJMax = FycmComp.FycmGrBase[2].bCHK;
					bCheckIMin = FycmComp.FycmGrBase[1].bCHK;
					bCheckJMin = FycmComp.FycmGrBase[3].bCHK;
				}
				else if (m_nPSCPart == PSC_DSGN_COMP_STRESS_SLAB)
				{
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(FycmComp.FycmSlBase[0].dALW); // Max I
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(FycmComp.FycmSlBase[2].dALW); // Max J
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(FycmComp.FycmSlBase[1].dALW); // Min I
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(FycmComp.FycmSlBase[3].dALW); // Min J

					if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_TOP)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmComp.FycmSlBase[0].dFT; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmComp.FycmSlBase[2].dFT; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmComp.FycmSlBase[1].dFT; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmComp.FycmSlBase[3].dFT; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_BOT)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmComp.FycmSlBase[0].dFB; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmComp.FycmSlBase[2].dFB; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmComp.FycmSlBase[1].dFB; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmComp.FycmSlBase[3].dFB; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP1)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmComp.FycmSlBase[0].dFTL; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmComp.FycmSlBase[2].dFTL; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmComp.FycmSlBase[1].dFTL; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmComp.FycmSlBase[3].dFTL; // Min J		
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP2)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmComp.FycmSlBase[0].dFTR; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmComp.FycmSlBase[2].dFTR; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmComp.FycmSlBase[1].dFTR; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmComp.FycmSlBase[3].dFTR; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP3)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmComp.FycmSlBase[0].dFBR; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmComp.FycmSlBase[2].dFBR; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmComp.FycmSlBase[1].dFBR; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmComp.FycmSlBase[3].dFBR; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP4)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmComp.FycmSlBase[0].dFBL; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmComp.FycmSlBase[2].dFBL; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmComp.FycmSlBase[1].dFBL; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmComp.FycmSlBase[3].dFBL; // Min J	
					}
					else
					{
						ASSERT(0);
					}

					bCheckIMax = FycmComp.FycmSlBase[0].bCHK;
					bCheckJMax = FycmComp.FycmSlBase[2].bCHK;
					bCheckIMin = FycmComp.FycmSlBase[1].bCHK;
					bCheckJMin = FycmComp.FycmSlBase[3].bCHK;
				}
				else
				{
					ASSERT(0);
				}
			}
			else
			{
				T_FYCM_PSC Fycm; Fycm.Initialize();
				if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadFycm_PSC(ElemK, Fycm)) return FALSE;

				if (m_nPSCPart == PSC_DSGN_COMP_STRESS_GIRDER)
				{
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(Fycm.FycmBase[0].dALW); // Max I
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(Fycm.FycmBase[2].dALW); // Max J
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(Fycm.FycmBase[1].dALW); // Min I
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(Fycm.FycmBase[3].dALW); // Min J

					if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_TOP)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = Fycm.FycmBase[0].dFT; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = Fycm.FycmBase[2].dFT; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = Fycm.FycmBase[1].dFT; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = Fycm.FycmBase[3].dFT; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_BOT)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = Fycm.FycmBase[0].dFB; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = Fycm.FycmBase[2].dFB; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = Fycm.FycmBase[1].dFB; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = Fycm.FycmBase[3].dFB; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP1)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = Fycm.FycmBase[0].dFTL; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = Fycm.FycmBase[2].dFTL; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = Fycm.FycmBase[1].dFTL; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = Fycm.FycmBase[3].dFTL; // Min J		
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP2)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = Fycm.FycmBase[0].dFTR; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = Fycm.FycmBase[2].dFTR; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = Fycm.FycmBase[1].dFTR; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = Fycm.FycmBase[3].dFTR; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP3)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = Fycm.FycmBase[0].dFBR; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = Fycm.FycmBase[2].dFBR; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = Fycm.FycmBase[1].dFBR; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = Fycm.FycmBase[3].dFBR; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP4)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = Fycm.FycmBase[0].dFBL; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = Fycm.FycmBase[2].dFBL; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = Fycm.FycmBase[1].dFBL; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = Fycm.FycmBase[3].dFBL; // Min J	
					}
					else
					{
						ASSERT(0);
					}

					bCheckIMax = Fycm.FycmBase[0].bCHK;
					bCheckJMax = Fycm.FycmBase[2].bCHK;
					bCheckIMin = Fycm.FycmBase[1].bCHK;
					bCheckJMin = Fycm.FycmBase[3].bCHK;
				}
				else if (m_nPSCPart == PSC_DSGN_COMP_STRESS_SLAB)
				{
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = 0.0; // Max I
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = 0.0; // Max J
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = 0.0; // Min I
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = 0.0; // Min J

					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = 0.0; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = 0.0; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = 0.0; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = 0.0; // Min J

					bCheckIMax = FALSE;
					bCheckJMax = FALSE;
					bCheckIMin = FALSE;
					bCheckJMin = FALSE;
				}
				else
				{
					ASSERT(0);
				}
			}
		}
		break;
		default:
			break;
		}
	}
	else
	{
		ASSERT(0);
	}

	return TRUE;
}

BOOL  CDesignEngine::MakePscDsgnDgrmDataKR_IS(T_ELEM_K ElemK, T_PSC_DSGN_RESL_D RsltD[4], BOOL &bCheckIMin, BOOL &bCheckIMax, BOOL &bCheckJMin, BOOL &bCheckJMax)
{
	CDBDoc *pDoc = CDBDoc::GetDocPoint();

	if (m_nPSCCirteriaType == 0 || m_nPSCCirteriaType == 1) // Force
	{
		switch (m_nPSCComp)
		{
		case PSC_DSGN_COMP_BEND_Y:
		{
			//mqc17817
			BOOL bPscComposite = pDoc->m_pPostCtrl->IsElem4CompositePSCSect(ElemK);

			if (bPscComposite)//Not Required
			{
				T_BDCR_PSC_COMP BdcrCompD;
				if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadBdcr_PSC_Comp(ElemK, BdcrCompD))	return FALSE;

				//T_BDCY_KSCE_BASE BdcyBase[4];	// 0=I-MAX, 1=I-MIN, 2=J-MAX, 3=J-MIN.
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(BdcrCompD.BdcrBase[0].dphiMn); // Max I 강도, drMuy=pMny 임. 
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(BdcrCompD.BdcrBase[2].dphiMn); // Max J 강도 
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(BdcrCompD.BdcrBase[1].dphiMn); // Min I 강도 
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(BdcrCompD.BdcrBase[3].dphiMn); // Min J 강도 

				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = BdcrCompD.BdcrBase[0].dMu; // Max I 계수부재력 
				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = BdcrCompD.BdcrBase[2].dMu; // Max J 계수부재력 
				RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = BdcrCompD.BdcrBase[1].dMu; // Min I 계수부재력 
				RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = BdcrCompD.BdcrBase[3].dMu; // Min J 계수부재력 

				bCheckIMax = BdcrCompD.BdcrBase[0].bCHK;
				bCheckJMax = BdcrCompD.BdcrBase[2].bCHK;
				bCheckIMin = BdcrCompD.BdcrBase[1].bCHK;
				bCheckJMin = BdcrCompD.BdcrBase[3].bCHK;
			}
			else
			{
				T_BDCR_PSC_IRC BdcrD;
				if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadBdcr_PSC(ElemK, BdcrD))	return FALSE;

				//T_BDCY_KSCE_BASE BdcyBase[4];	// 0=I-MAX, 1=I-MIN, 2=J-MAX, 3=J-MIN.
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(BdcrD.BdcrBase[0].dphiMn); // Max I 강도, drMuy=pMny 임. 
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(BdcrD.BdcrBase[2].dphiMn); // Max J 강도 
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(BdcrD.BdcrBase[1].dphiMn); // Min I 강도 
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(BdcrD.BdcrBase[3].dphiMn); // Min J 강도 

				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = BdcrD.BdcrBase[0].dMu; // Max I 계수부재력 
				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = BdcrD.BdcrBase[2].dMu; // Max J 계수부재력 
				RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = BdcrD.BdcrBase[1].dMu; // Min I 계수부재력 
				RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = BdcrD.BdcrBase[3].dMu; // Min J 계수부재력 

				bCheckIMax = BdcrD.BdcrBase[0].bCHK;
				bCheckJMax = BdcrD.BdcrBase[2].bCHK;
				bCheckIMin = BdcrD.BdcrBase[1].bCHK;
				bCheckJMin = BdcrD.BdcrBase[3].bCHK;
			}
		}
		break;
		case PSC_DSGN_COMP_BEND_Z:
		{
			T_BDCZ_KSCE BdczKsceD;
			if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetBdczKsceData(ElemK, BdczKsceD))	return FALSE;

			//T_BDCZ_KSCE_BASE BdczBase[4];	// 0=I-MAX, 1=I-MIN, 2=J-MAX, 3=J-MIN.
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(BdczKsceD.BdczBase[0].dpMny); // Max I 강도 
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(BdczKsceD.BdczBase[2].dpMny); // Max J 강도 
			RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(BdczKsceD.BdczBase[1].dpMny); // Min I 강도 
			RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(BdczKsceD.BdczBase[3].dpMny); // Min J 강도 

			RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = BdczKsceD.BdczBase[0].dMuy; // Max I 계수부재력 
			RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = BdczKsceD.BdczBase[2].dMuy; // Max J 계수부재력 
			RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = BdczKsceD.BdczBase[1].dMuy; // Min I 계수부재력 
			RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = BdczKsceD.BdczBase[3].dMuy; // Min J 계수부재력 

			bCheckIMax = BdczKsceD.BdczBase[0].bCHK;
			bCheckJMax = BdczKsceD.BdczBase[2].bCHK;
			bCheckIMin = BdczKsceD.BdczBase[1].bCHK;
			bCheckJMin = BdczKsceD.BdczBase[3].bCHK;
		}
		break;
		case PSC_DSGN_COMP_SHER_Z:
		{
			//mqc17817
			BOOL bPscComposite = pDoc->m_pPostCtrl->IsElem4CompositePSCSect(ElemK);

			if (bPscComposite)//Not Required
			{
				T_CUMS_PSC_COMP CumsCompD;
				if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadCums_PSC_Comp(ElemK, CumsCompD))	return FALSE;

				// T_CUMS_KSCE_BASE CumsBase[4];	// 0=I-MAX, 1=I-MIN, 2=J-MAX, 3=J-MIN.
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(CumsCompD.CumsBase[0].dPhiVn); // Max I 강도 
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(CumsCompD.CumsBase[2].dPhiVn); // Max J 강도 
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = fabs(CumsCompD.CumsBase[1].dPhiVn); // Min I 강도 
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = fabs(CumsCompD.CumsBase[3].dPhiVn); // Min J 강도 

				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = fabs(CumsCompD.CumsBase[0].dVu); // Max I 계수부재력 
				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = fabs(CumsCompD.CumsBase[2].dVu); // Max J 계수부재력 
				RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = fabs(CumsCompD.CumsBase[1].dVu); // Min I 계수부재력 
				RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = fabs(CumsCompD.CumsBase[3].dVu); // Min J 계수부재력 

				bCheckIMax = CumsCompD.CumsBase[0].bCHK;
				bCheckJMax = CumsCompD.CumsBase[2].bCHK;
				bCheckIMin = CumsCompD.CumsBase[1].bCHK;
				bCheckJMin = CumsCompD.CumsBase[3].bCHK;
			}
			else
			{
				T_CUMS_PSC_IRC CumsD;
				if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadCums_PSC(ElemK, CumsD))return FALSE;

				// T_CUMS_KSCE_BASE CumsBase[4];	// 0=I-MAX, 1=I-MIN, 2=J-MAX, 3=J-MIN.
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(CumsD.CumsBase[0].dPhiVn); // Max I 강도 
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(CumsD.CumsBase[2].dPhiVn); // Max J 강도 
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(CumsD.CumsBase[1].dPhiVn); // Min I 강도 
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(CumsD.CumsBase[3].dPhiVn); // Min J 강도 

				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = CumsD.CumsBase[0].dVu; // Max I 계수부재력 
				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = CumsD.CumsBase[2].dVu; // Max J 계수부재력 
				RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = CumsD.CumsBase[1].dVu; // Min I 계수부재력 
				RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = CumsD.CumsBase[3].dVu; // Min J 계수부재력 

				bCheckIMax = CumsD.CumsBase[0].bCHK;
				bCheckJMax = CumsD.CumsBase[2].bCHK;
				bCheckIMin = CumsD.CumsBase[1].bCHK;
				bCheckJMin = CumsD.CumsBase[3].bCHK;
			}
		}
		break;
		case PSC_DSGN_COMP_TORSION:
		{
			//mqc17817
			BOOL bPscComposite = pDoc->m_pPostCtrl->IsElem4CompositePSCSect(ElemK);

			if (bPscComposite)//Not Required
			{
				T_CRMT_PSC_COMP CrmtCompD;
				if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadCrmt_PSC_Comp(ElemK, CrmtCompD)) return FALSE;

				//T_CRMT_KSCE_BASE CrmtBase[6];	// 0=I-V-MAX, 1=I-V-MIN, 2=I-T-MAX, 3=J-V-MAX, 4=J-V-MIN, 5=J-T-MAX.
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(CrmtCompD.CrmtBase[0].dPhi_tTn); // Max I 강도 
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(CrmtCompD.CrmtBase[3].dPhi_tTn); // Max J 강도 
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = fabs(CrmtCompD.CrmtBase[1].dPhi_tTn); // Min I 강도 
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = fabs(CrmtCompD.CrmtBase[4].dPhi_tTn); // Min J 강도 

				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = fabs(CrmtCompD.CrmtBase[0].dTu); // Max I 계수부재력 
				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = fabs(CrmtCompD.CrmtBase[3].dTu); // Max J 계수부재력 
				RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = fabs(CrmtCompD.CrmtBase[1].dTu); // Min I 계수부재력 
				RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = fabs(CrmtCompD.CrmtBase[4].dTu); // Min J 계수부재력 

				bCheckIMax = CrmtCompD.CrmtBase[0].bCHK;
				bCheckJMax = CrmtCompD.CrmtBase[3].bCHK;
				bCheckIMin = CrmtCompD.CrmtBase[1].bCHK;
				bCheckJMin = CrmtCompD.CrmtBase[4].bCHK;
			}
			else
			{
				T_CRMT_PSC_IRC CrmtD;
				if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadCrmt_PSC(ElemK, CrmtD)) return FALSE;

				//T_CRMT_KSCE_BASE CrmtBase[6];	// 0=I-V-MAX, 1=I-V-MIN, 2=I-T-MAX, 3=J-V-MAX, 4=J-V-MIN, 5=J-T-MAX.
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(CrmtD.CrmtBase[0].dPhi_tTn); // Max I 강도 
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(CrmtD.CrmtBase[3].dPhi_tTn); // Max J 강도 
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = fabs(CrmtD.CrmtBase[1].dPhi_tTn); // Min I 강도 
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = fabs(CrmtD.CrmtBase[4].dPhi_tTn); // Min J 강도 

				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = fabs(CrmtD.CrmtBase[0].dTu); // Max I 계수부재력 
				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = fabs(CrmtD.CrmtBase[3].dTu); // Max J 계수부재력 
				RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = fabs(CrmtD.CrmtBase[1].dTu); // Min I 계수부재력 
				RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = fabs(CrmtD.CrmtBase[4].dTu); // Min J 계수부재력 

				bCheckIMax = CrmtD.CrmtBase[0].bCHK;
				bCheckJMax = CrmtD.CrmtBase[3].bCHK;
				bCheckIMin = CrmtD.CrmtBase[1].bCHK;
				bCheckJMin = CrmtD.CrmtBase[4].bCHK;
			}
		}
		break;
		case PSC_DSGN_COMP_TORSION_MAXTOR:
		{
			//mqc17817
			BOOL bPscComposite = pDoc->m_pPostCtrl->IsElem4CompositePSCSect(ElemK);

			if (bPscComposite)//Not Required
			{
				T_CRMT_PSC_COMP CrmtCompD;
				if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadCrmt_PSC_Comp(ElemK, CrmtCompD)) return FALSE;

				//T_CRMT_KSCE_BASE CrmtBase[6];	// 0=I-V-MAX, 1=I-V-MIN, 2=I-T-MAX, 3=J-V-MAX, 4=J-V-MIN, 5=J-T-MAX.
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(CrmtCompD.CrmtBase[2].dPhi_tTn); // Max I 강도 
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(CrmtCompD.CrmtBase[5].dPhi_tTn); // Max J 강도 

				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = fabs(CrmtCompD.CrmtBase[2].dTu); // Max I 계수부재력 
				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = fabs(CrmtCompD.CrmtBase[5].dTu); // Max J 계수부재력 

				bCheckIMax = CrmtCompD.CrmtBase[2].bCHK;
				bCheckJMax = CrmtCompD.CrmtBase[5].bCHK;
			}
			else
			{
				T_CRMT_PSC_IRC CrmtD;
				if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadCrmt_PSC(ElemK, CrmtD)) return FALSE;

				//T_CRMT_KSCE_BASE CrmtBase[6];	// 0=I-V-MAX, 1=I-V-MIN, 2=I-T-MAX, 3=J-V-MAX, 4=J-V-MIN, 5=J-T-MAX.
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(CrmtD.CrmtBase[2].dPhi_tTn); // Max I 강도 
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(CrmtD.CrmtBase[5].dPhi_tTn); // Max J 강도 

				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = fabs(CrmtD.CrmtBase[2].dTu); // Max I 계수부재력 
				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = fabs(CrmtD.CrmtBase[5].dTu); // Max J 계수부재력 

				bCheckIMax = CrmtD.CrmtBase[2].bCHK;
				bCheckJMax = CrmtD.CrmtBase[5].bCHK;
			}
		}
		break;
		default:
			break;
		}
	}
	else if (m_nPSCCirteriaType == 2 || m_nPSCCirteriaType == 3) // Stress
	{
		switch (m_nPSCCompStr)
		{
		case PSC_DSGN_COMP_CONSTRUCTION:
		{
			//mqc17817
			BOOL bPscComposite = pDoc->m_pPostCtrl->IsElem4CompositePSCSect(ElemK);

			if (bPscComposite)//Not Required
			{
				T_FYSG_PSC_COMP FysgComp; FysgComp.Initialize();
				if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadFysg_PSC_Comp(ElemK, FysgComp)) return FALSE;

				if (m_nPSCPart == PSC_DSGN_COMP_STRESS_GIRDER)
				{
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(FysgComp.FysgGrBase[0].dALW); // Max I
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(FysgComp.FysgGrBase[2].dALW); // Max J
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(FysgComp.FysgGrBase[1].dALW); // Min I
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(FysgComp.FysgGrBase[3].dALW); // Min J

					if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_TOP)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgComp.FysgGrBase[0].dFT; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgComp.FysgGrBase[2].dFT; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgComp.FysgGrBase[1].dFT; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgComp.FysgGrBase[3].dFT; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_BOT)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgComp.FysgGrBase[0].dFB; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgComp.FysgGrBase[2].dFB; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgComp.FysgGrBase[1].dFB; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgComp.FysgGrBase[3].dFB; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP1)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgComp.FysgGrBase[0].dFTL; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgComp.FysgGrBase[2].dFTL; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgComp.FysgGrBase[1].dFTL; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgComp.FysgGrBase[3].dFTL; // Min J		
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP2)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgComp.FysgGrBase[0].dFTR; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgComp.FysgGrBase[2].dFTR; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgComp.FysgGrBase[1].dFTR; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgComp.FysgGrBase[3].dFTR; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP3)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgComp.FysgGrBase[0].dFBR; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgComp.FysgGrBase[2].dFBR; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgComp.FysgGrBase[1].dFBR; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgComp.FysgGrBase[3].dFBR; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP4)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgComp.FysgGrBase[0].dFBL; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgComp.FysgGrBase[2].dFBL; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgComp.FysgGrBase[1].dFBL; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgComp.FysgGrBase[3].dFBL; // Min J	
					}
					else
					{
						ASSERT(0);
					}

					bCheckIMax = FysgComp.FysgGrBase[0].bCHK;
					bCheckJMax = FysgComp.FysgGrBase[2].bCHK;
					bCheckIMin = FysgComp.FysgGrBase[1].bCHK;
					bCheckJMin = FysgComp.FysgGrBase[3].bCHK;
				}
				else if (m_nPSCPart == PSC_DSGN_COMP_STRESS_SLAB)
				{
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(FysgComp.FysgSlBase[0].dALW); // Max I
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(FysgComp.FysgSlBase[2].dALW); // Max J
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(FysgComp.FysgSlBase[1].dALW); // Min I
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(FysgComp.FysgSlBase[3].dALW); // Min J

					if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_TOP)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgComp.FysgSlBase[0].dFT; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgComp.FysgSlBase[2].dFT; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgComp.FysgSlBase[1].dFT; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgComp.FysgSlBase[3].dFT; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_BOT)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgComp.FysgSlBase[0].dFB; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgComp.FysgSlBase[2].dFB; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgComp.FysgSlBase[1].dFB; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgComp.FysgSlBase[3].dFB; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP1)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgComp.FysgSlBase[0].dFTL; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgComp.FysgSlBase[2].dFTL; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgComp.FysgSlBase[1].dFTL; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgComp.FysgSlBase[3].dFTL; // Min J		
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP2)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgComp.FysgSlBase[0].dFTR; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgComp.FysgSlBase[2].dFTR; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgComp.FysgSlBase[1].dFTR; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgComp.FysgSlBase[3].dFTR; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP3)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgComp.FysgSlBase[0].dFBR; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgComp.FysgSlBase[2].dFBR; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgComp.FysgSlBase[1].dFBR; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgComp.FysgSlBase[3].dFBR; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP4)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgComp.FysgSlBase[0].dFBL; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgComp.FysgSlBase[2].dFBL; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgComp.FysgSlBase[1].dFBL; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgComp.FysgSlBase[3].dFBL; // Min J	
					}
					else
					{
						ASSERT(0);
					}

					bCheckIMax = FysgComp.FysgSlBase[0].bCHK;
					bCheckJMax = FysgComp.FysgSlBase[2].bCHK;
					bCheckIMin = FysgComp.FysgSlBase[1].bCHK;
					bCheckJMin = FysgComp.FysgSlBase[3].bCHK;
				}
				else
				{
					ASSERT(0);
				}
			}
			else
			{
				T_FYSG_PSC_IRC Fysg; Fysg.Initialize();
				if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadFysg_PSC(ElemK, Fysg)) return FALSE;

				if (m_nPSCPart == PSC_DSGN_COMP_STRESS_GIRDER)
				{
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(Fysg.FysgBase[0].dALW); // Max I
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(Fysg.FysgBase[2].dALW); // Max J
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(Fysg.FysgBase[1].dALW); // Min I
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(Fysg.FysgBase[3].dALW); // Min J

					if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_TOP)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = Fysg.FysgBase[0].dFT; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = Fysg.FysgBase[2].dFT; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = Fysg.FysgBase[1].dFT; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = Fysg.FysgBase[3].dFT; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_BOT)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = Fysg.FysgBase[0].dFB; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = Fysg.FysgBase[2].dFB; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = Fysg.FysgBase[1].dFB; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = Fysg.FysgBase[3].dFB; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP1)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = Fysg.FysgBase[0].dFTL; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = Fysg.FysgBase[2].dFTL; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = Fysg.FysgBase[1].dFTL; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = Fysg.FysgBase[3].dFTL; // Min J		
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP2)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = Fysg.FysgBase[0].dFTR; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = Fysg.FysgBase[2].dFTR; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = Fysg.FysgBase[1].dFTR; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = Fysg.FysgBase[3].dFTR; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP3)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = Fysg.FysgBase[0].dFBR; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = Fysg.FysgBase[2].dFBR; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = Fysg.FysgBase[1].dFBR; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = Fysg.FysgBase[3].dFBR; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP4)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = Fysg.FysgBase[0].dFBL; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = Fysg.FysgBase[2].dFBL; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = Fysg.FysgBase[1].dFBL; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = Fysg.FysgBase[3].dFBL; // Min J	
					}
					else
					{
						ASSERT(0);
					}

					bCheckIMax = Fysg.FysgBase[0].bCHK;
					bCheckJMax = Fysg.FysgBase[2].bCHK;
					bCheckIMin = Fysg.FysgBase[1].bCHK;
					bCheckJMin = Fysg.FysgBase[3].bCHK;
				}
				else if (m_nPSCPart == PSC_DSGN_COMP_STRESS_SLAB)
				{
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = 0.0; // Max I
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = 0.0; // Max J
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = 0.0; // Min I
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = 0.0; // Min J

					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = 0.0; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = 0.0; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = 0.0; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = 0.0; // Min J

					bCheckIMax = FALSE;
					bCheckJMax = FALSE;
					bCheckIMin = FALSE;
					bCheckJMin = FALSE;
				}
				else
				{
					ASSERT(0);
				}
			}
		}
		break;
		case PSC_DSGN_COMP_SERVICE_LOAD:
		{
			//mqc17817
			BOOL bPscComposite = pDoc->m_pPostCtrl->IsElem4CompositePSCSect(ElemK);

			if (bPscComposite)//Not Required
			{
				T_FYCM_PSC_COMP FycmComp; FycmComp.Initialize();
				if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadFycm_PSC_Comp(ElemK, FycmComp)) return FALSE;

				if (m_nPSCPart == PSC_DSGN_COMP_STRESS_GIRDER)
				{
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(FycmComp.FycmGrBase[0].dALW); // Max I
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(FycmComp.FycmGrBase[2].dALW); // Max J
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(FycmComp.FycmGrBase[1].dALW); // Min I
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(FycmComp.FycmGrBase[3].dALW); // Min J

					if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_TOP)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmComp.FycmGrBase[0].dFT; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmComp.FycmGrBase[2].dFT; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmComp.FycmGrBase[1].dFT; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmComp.FycmGrBase[3].dFT; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_BOT)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmComp.FycmGrBase[0].dFB; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmComp.FycmGrBase[2].dFB; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmComp.FycmGrBase[1].dFB; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmComp.FycmGrBase[3].dFB; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP1)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmComp.FycmGrBase[0].dFTL; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmComp.FycmGrBase[2].dFTL; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmComp.FycmGrBase[1].dFTL; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmComp.FycmGrBase[3].dFTL; // Min J		
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP2)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmComp.FycmGrBase[0].dFTR; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmComp.FycmGrBase[2].dFTR; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmComp.FycmGrBase[1].dFTR; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmComp.FycmGrBase[3].dFTR; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP3)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmComp.FycmGrBase[0].dFBR; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmComp.FycmGrBase[2].dFBR; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmComp.FycmGrBase[1].dFBR; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmComp.FycmGrBase[3].dFBR; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP4)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmComp.FycmGrBase[0].dFBL; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmComp.FycmGrBase[2].dFBL; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmComp.FycmGrBase[1].dFBL; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmComp.FycmGrBase[3].dFBL; // Min J	
					}
					else
					{
						ASSERT(0);
					}

					bCheckIMax = FycmComp.FycmGrBase[0].bCHK;
					bCheckJMax = FycmComp.FycmGrBase[2].bCHK;
					bCheckIMin = FycmComp.FycmGrBase[1].bCHK;
					bCheckJMin = FycmComp.FycmGrBase[3].bCHK;
				}
				else if (m_nPSCPart == PSC_DSGN_COMP_STRESS_SLAB)
				{
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(FycmComp.FycmSlBase[0].dALW); // Max I
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(FycmComp.FycmSlBase[2].dALW); // Max J
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(FycmComp.FycmSlBase[1].dALW); // Min I
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(FycmComp.FycmSlBase[3].dALW); // Min J

					if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_TOP)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmComp.FycmSlBase[0].dFT; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmComp.FycmSlBase[2].dFT; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmComp.FycmSlBase[1].dFT; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmComp.FycmSlBase[3].dFT; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_BOT)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmComp.FycmSlBase[0].dFB; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmComp.FycmSlBase[2].dFB; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmComp.FycmSlBase[1].dFB; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmComp.FycmSlBase[3].dFB; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP1)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmComp.FycmSlBase[0].dFTL; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmComp.FycmSlBase[2].dFTL; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmComp.FycmSlBase[1].dFTL; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmComp.FycmSlBase[3].dFTL; // Min J		
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP2)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmComp.FycmSlBase[0].dFTR; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmComp.FycmSlBase[2].dFTR; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmComp.FycmSlBase[1].dFTR; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmComp.FycmSlBase[3].dFTR; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP3)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmComp.FycmSlBase[0].dFBR; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmComp.FycmSlBase[2].dFBR; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmComp.FycmSlBase[1].dFBR; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmComp.FycmSlBase[3].dFBR; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP4)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmComp.FycmSlBase[0].dFBL; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmComp.FycmSlBase[2].dFBL; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmComp.FycmSlBase[1].dFBL; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmComp.FycmSlBase[3].dFBL; // Min J	
					}
					else
					{
						ASSERT(0);
					}

					bCheckIMax = FycmComp.FycmSlBase[0].bCHK;
					bCheckJMax = FycmComp.FycmSlBase[2].bCHK;
					bCheckIMin = FycmComp.FycmSlBase[1].bCHK;
					bCheckJMin = FycmComp.FycmSlBase[3].bCHK;
				}
				else
				{
					ASSERT(0);
				}
			}
			else
			{
				T_FYCM_PSC_IRC Fycm; Fycm.Initialize();
				if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadFycm_PSC(ElemK, Fycm)) return FALSE;

				if (m_nPSCPart == PSC_DSGN_COMP_STRESS_GIRDER)
				{
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(Fycm.FycmBase[0].dALW); // Max I
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(Fycm.FycmBase[2].dALW); // Max J
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(Fycm.FycmBase[1].dALW); // Min I
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(Fycm.FycmBase[3].dALW); // Min J

					if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_TOP)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = Fycm.FycmBase[0].dFT; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = Fycm.FycmBase[2].dFT; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = Fycm.FycmBase[1].dFT; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = Fycm.FycmBase[3].dFT; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_BOT)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = Fycm.FycmBase[0].dFB; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = Fycm.FycmBase[2].dFB; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = Fycm.FycmBase[1].dFB; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = Fycm.FycmBase[3].dFB; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP1)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = Fycm.FycmBase[0].dFTL; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = Fycm.FycmBase[2].dFTL; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = Fycm.FycmBase[1].dFTL; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = Fycm.FycmBase[3].dFTL; // Min J		
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP2)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = Fycm.FycmBase[0].dFTR; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = Fycm.FycmBase[2].dFTR; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = Fycm.FycmBase[1].dFTR; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = Fycm.FycmBase[3].dFTR; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP3)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = Fycm.FycmBase[0].dFBR; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = Fycm.FycmBase[2].dFBR; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = Fycm.FycmBase[1].dFBR; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = Fycm.FycmBase[3].dFBR; // Min J
					}
					else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP4)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = Fycm.FycmBase[0].dFBL; // Max I
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = Fycm.FycmBase[2].dFBL; // Max J
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = Fycm.FycmBase[1].dFBL; // Min I
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = Fycm.FycmBase[3].dFBL; // Min J	
					}
					else
					{
						ASSERT(0);
					}

					bCheckIMax = Fycm.FycmBase[0].bCHK;
					bCheckJMax = Fycm.FycmBase[2].bCHK;
					bCheckIMin = Fycm.FycmBase[1].bCHK;
					bCheckJMin = Fycm.FycmBase[3].bCHK;
				}
				else if (m_nPSCPart == PSC_DSGN_COMP_STRESS_SLAB)
				{
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = 0.0; // Max I
					RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = 0.0; // Max J
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = 0.0; // Min I
					RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = 0.0; // Min J

					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = 0.0; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = 0.0; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = 0.0; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = 0.0; // Min J

					bCheckIMax = FALSE;
					bCheckJMax = FALSE;
					bCheckIMin = FALSE;
					bCheckJMin = FALSE;
				}
				else
				{
					ASSERT(0);
				}
			}
		}
		break;
		default:
			ASSERT(0);
			break;
		}
	}
	else
	{
		ASSERT(0);
	}

	return TRUE;
}

BOOL  CDesignEngine::MakePscDsgnDgrmDataKR_AS(T_ELEM_K ElemK, T_PSC_DSGN_RESL_D RsltD[4], BOOL &bCheckIMin, BOOL &bCheckIMax, BOOL &bCheckJMin, BOOL &bCheckJMax)
{
	CDBDoc *pDoc = CDBDoc::GetDocPoint();

	if (m_nPSCCirteriaType == 0 || m_nPSCCirteriaType == 1) // Force : 0, 1 Stress 2, 3
	{
		switch (m_nPSCComp)
		{
		case PSC_DSGN_COMP_BEND_Y:
		{
			T_BDCR_PSC_AS BdcrAS;
			if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadBdcr_AS(ElemK, BdcrAS))	return FALSE;

			// 0=I-MAX, 1=I-MIN, 2=J-MAX, 3=J-MIN.
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(BdcrAS.BdcrB[0].dpMn);  // Max I phi*Mu
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(BdcrAS.BdcrB[2].dpMn);  // Max J phi*Mu 
			RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(BdcrAS.BdcrB[1].dpMn); // Min I phi*Mu 
			RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(BdcrAS.BdcrB[3].dpMn); // Min J phi*Mu 

			RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = BdcrAS.BdcrB[0].dMu; // Max I M* 
			RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = BdcrAS.BdcrB[2].dMu; // Max J M* 
			RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = BdcrAS.BdcrB[1].dMu; // Min I M* 
			RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = BdcrAS.BdcrB[3].dMu; // Min J M* 

			bCheckIMax = BdcrAS.BdcrB[0].bCHK;
			bCheckJMax = BdcrAS.BdcrB[2].bCHK;
			bCheckIMin = BdcrAS.BdcrB[1].bCHK;
			bCheckJMin = BdcrAS.BdcrB[3].bCHK;
		}
		break;
		case PSC_DSGN_COMP_BEND_Z:
		{
			ASSERT(0);
		}
		break;
		case PSC_DSGN_COMP_SHER_Z:
		{
			T_SHRR_PSC_AS ShrrAS;
			if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadShrr_AS(ElemK, ShrrAS))return FALSE;

			// 0=I-MAX, 1=I-MIN, 2=J-MAX, 3=J-MIN.
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(ShrrAS.ShrrB[0].dpVn); // Max I 강도 
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(ShrrAS.ShrrB[1].dpVn); // Max J 강도 
			//RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = fabs(ShrrAS.ShrrB[1].dpVn); // Min I 강도 
			//RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = fabs(ShrrAS.ShrrB[3].dpVn); // Min J 강도 

			RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = fabs(ShrrAS.ShrrB[0].dVeq); // Max I 계수부재력 
			RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = fabs(ShrrAS.ShrrB[1].dVeq); // Max J 계수부재력 
			//RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = fabs(ShrrAS.ShrrB[1].dVu); // Min I 계수부재력 
			//RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = fabs(ShrrAS.ShrrB[3].dVu); // Min J 계수부재력 

			bCheckIMax = ShrrAS.ShrrB[0].bCHK;
			bCheckJMax = ShrrAS.ShrrB[1].bCHK;
			//bCheckIMin = ShrrAS.ShrrB[1].bOK;
			//bCheckJMin = ShrrAS.ShrrB[3].bOK;
		}
		break;
		case PSC_DSGN_COMP_TORSION:
		{
			T_TORR_PSC_AS TorrAS;
			if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadTorr_AS(ElemK, TorrAS)) return FALSE;

			// 0=I-V-MAX, 1=I-V-MIN, 2=I-T-MAX, 3=J-V-MAX, 4=J-V-MIN, 5=J-T-MAX.
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(TorrAS.TorrB[0].dpTn); // Max I 강도 
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(TorrAS.TorrB[1].dpTn); // Max J 강도 
			//RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = fabs(TorrAS.TorrB[1].dpTn); // Min I 강도 
			//RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = fabs(TorrAS.TorrB[4].dpTn); // Min J 강도 

			RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = fabs(TorrAS.TorrB[0].dTu); // Max I 계수부재력 
			RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = fabs(TorrAS.TorrB[1].dTu); // Max J 계수부재력 
			//RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = fabs(TorrAS.TorrB[1].dTu); // Min I 계수부재력 
			//RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = fabs(TorrAS.TorrB[4].dTu); // Min J 계수부재력 

			bCheckIMax = TorrAS.TorrB[0].bCHK;
			bCheckJMax = TorrAS.TorrB[1].bCHK;
			//bCheckIMin = TorrAS.TorrB[1].bOK;
			//bCheckJMin = TorrAS.TorrB[4].bOK;
		}
		break;
		case PSC_DSGN_COMP_TORSION_MAXTOR:
		{
			ASSERT(0);
		}
		break;
		default:
			break;
		}
	}
	//PSC Composite Stress Result Diagram 추가
	else if (m_nPSCCirteriaType == 2 || m_nPSCCirteriaType == 3) // Stress : 2, 3
	{
		switch (m_nPSCCompStr)
		{
		case PSC_DSGN_COMP_CONSTRUCTION:
		{
			T_FYSG_PSC_AS FysgD; FysgD.Initialize();
			if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadFysg_AS(ElemK, FysgD)) return FALSE;

			if (m_nPSCPart == PSC_DSGN_COMP_STRESS_GIRDER)
			{
				// MQC 24117 Stress 인 경우 Allow Comp Stress 그래프 부분 안보이기
				//RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] =  fabs(FysgD.FysgGrB[0].dALW); // Max I
				//RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] =  fabs(FysgD.FysgGrB[2].dALW); // Max J
				//RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(FysgD.FysgGrB[1].dALW); // Min I
				//RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(FysgD.FysgGrB[3].dALW); // Min J
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = 0; // Max I
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = 0; // Max J
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = 0; // Min I
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = 0; // Min J

				if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_TOP)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgD.FysgGrB[0].dFT; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgD.FysgGrB[2].dFT; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgD.FysgGrB[1].dFT; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgD.FysgGrB[3].dFT; // Min J
				}
				else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_BOT)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgD.FysgGrB[0].dFB; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgD.FysgGrB[2].dFB; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgD.FysgGrB[1].dFB; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgD.FysgGrB[3].dFB; // Min J
				}
				else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP1)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgD.FysgGrB[0].dFTL; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgD.FysgGrB[2].dFTL; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgD.FysgGrB[1].dFTL; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgD.FysgGrB[3].dFTL; // Min J		
				}
				else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP2)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgD.FysgGrB[0].dFTR; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgD.FysgGrB[2].dFTR; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgD.FysgGrB[1].dFTR; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgD.FysgGrB[3].dFTR; // Min J
				}
				else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP3)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgD.FysgGrB[0].dFBR; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgD.FysgGrB[2].dFBR; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgD.FysgGrB[1].dFBR; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgD.FysgGrB[3].dFBR; // Min J
				}
				else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP4)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgD.FysgGrB[0].dFBL; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgD.FysgGrB[2].dFBL; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgD.FysgGrB[1].dFBL; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgD.FysgGrB[3].dFBL; // Min J	
				}
				else
				{
					ASSERT(0);
				}

				bCheckIMax = FysgD.FysgGrB[0].bCHK;
				bCheckJMax = FysgD.FysgGrB[2].bCHK;
				bCheckIMin = FysgD.FysgGrB[1].bCHK;
				bCheckJMin = FysgD.FysgGrB[3].bCHK;
			}
			else if (m_nPSCPart == PSC_DSGN_COMP_STRESS_SLAB)
			{
				// MQC 24117 Stress 인 경우 Allow Comp Stress 그래프 부분 안보이기
				//RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] =  fabs(FysgD.FysgSlB[0].dALW); // Max I
				//RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] =  fabs(FysgD.FysgSlB[2].dALW); // Max J
				//RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(FysgD.FysgSlB[1].dALW); // Min I
				//RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(FysgD.FysgSlB[3].dALW); // Min J
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = 0; // Max I
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = 0; // Max J
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = 0; // Min I
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = 0; // Min J

				if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_TOP)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgD.FysgSlB[0].dFT; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgD.FysgSlB[2].dFT; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgD.FysgSlB[1].dFT; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgD.FysgSlB[3].dFT; // Min J
				}
				else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_BOT)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgD.FysgSlB[0].dFB; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgD.FysgSlB[2].dFB; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgD.FysgSlB[1].dFB; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgD.FysgSlB[3].dFB; // Min J
				}
				else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP1)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgD.FysgSlB[0].dFTL; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgD.FysgSlB[2].dFTL; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgD.FysgSlB[1].dFTL; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgD.FysgSlB[3].dFTL; // Min J		
				}
				else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP2)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgD.FysgSlB[0].dFTR; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgD.FysgSlB[2].dFTR; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgD.FysgSlB[1].dFTR; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgD.FysgSlB[3].dFTR; // Min J
				}
				else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP3)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgD.FysgSlB[0].dFBR; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgD.FysgSlB[2].dFBR; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgD.FysgSlB[1].dFBR; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgD.FysgSlB[3].dFBR; // Min J
				}
				else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP4)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgD.FysgSlB[0].dFBL; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgD.FysgSlB[2].dFBL; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgD.FysgSlB[1].dFBL; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgD.FysgSlB[3].dFBL; // Min J	
				}
				else
				{
					ASSERT(0);
				}

				bCheckIMax = FysgD.FysgSlB[0].bCHK;
				bCheckJMax = FysgD.FysgSlB[2].bCHK;
				bCheckIMin = FysgD.FysgSlB[1].bCHK;
				bCheckJMin = FysgD.FysgSlB[3].bCHK;
			}
			else
			{
				ASSERT(0);
			}
		}
		break;
		case PSC_DSGN_COMP_SERVICE_LOAD:
		{
			T_FYCM_PSC_AS FycmD; FycmD.Initialize();
			if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadFycm_AS(ElemK, FycmD)) return FALSE;

			if (m_nPSCPart == PSC_DSGN_COMP_STRESS_GIRDER)
			{
				// MQC 24117 Stress 인 경우 Allow Comp Stress 그래프 부분 안보이기
				//RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] =  fabs(FycmD.FycmGrB[0].dALW); // Max I
				//RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] =  fabs(FycmD.FycmGrB[2].dALW); // Max J
				//RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(FycmD.FycmGrB[1].dALW); // Min I
				//RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(FycmD.FycmGrB[3].dALW); // Min J
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = 0; // Max I
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = 0; // Max J
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = 0; // Min I
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = 0; // Min J

				if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_TOP)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmD.FycmGrB[0].dFT; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmD.FycmGrB[2].dFT; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmD.FycmGrB[1].dFT; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmD.FycmGrB[3].dFT; // Min J
				}
				else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_BOT)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmD.FycmGrB[0].dFB; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmD.FycmGrB[2].dFB; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmD.FycmGrB[1].dFB; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmD.FycmGrB[3].dFB; // Min J
				}
				else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP1)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmD.FycmGrB[0].dFTL; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmD.FycmGrB[2].dFTL; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmD.FycmGrB[1].dFTL; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmD.FycmGrB[3].dFTL; // Min J		
				}
				else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP2)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmD.FycmGrB[0].dFTR; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmD.FycmGrB[2].dFTR; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmD.FycmGrB[1].dFTR; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmD.FycmGrB[3].dFTR; // Min J
				}
				else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP3)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmD.FycmGrB[0].dFBR; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmD.FycmGrB[2].dFBR; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmD.FycmGrB[1].dFBR; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmD.FycmGrB[3].dFBR; // Min J
				}
				else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP4)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmD.FycmGrB[0].dFBL; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmD.FycmGrB[2].dFBL; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmD.FycmGrB[1].dFBL; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmD.FycmGrB[3].dFBL; // Min J	
				}
				else
				{
					ASSERT(0);
				}

				bCheckIMax = FycmD.FycmGrB[0].bCHK;
				bCheckJMax = FycmD.FycmGrB[2].bCHK;
				bCheckIMin = FycmD.FycmGrB[1].bCHK;
				bCheckJMin = FycmD.FycmGrB[3].bCHK;
			}
			else if (m_nPSCPart == PSC_DSGN_COMP_STRESS_SLAB)
			{
				// MQC 24117 Stress 인 경우 Allow Comp Stress 그래프 부분 안보이기
				//RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] =  fabs(FycmD.FycmSlB[0].dALW); // Max I
				//RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] =  fabs(FycmD.FycmSlB[2].dALW); // Max J
				//RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(FycmD.FycmSlB[1].dALW); // Min I
				//RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(FycmD.FycmSlB[3].dALW); // Min J
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = 0; // Max I
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = 0; // Max J
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = 0; // Min I
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = 0; // Min J

				if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_TOP)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmD.FycmSlB[0].dFT; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmD.FycmSlB[2].dFT; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmD.FycmSlB[1].dFT; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmD.FycmSlB[3].dFT; // Min J
				}
				else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_BOT)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmD.FycmSlB[0].dFB; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmD.FycmSlB[2].dFB; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmD.FycmSlB[1].dFB; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmD.FycmSlB[3].dFB; // Min J
				}
				else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP1)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmD.FycmSlB[0].dFTL; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmD.FycmSlB[2].dFTL; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmD.FycmSlB[1].dFTL; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmD.FycmSlB[3].dFTL; // Min J		
				}
				else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP2)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmD.FycmSlB[0].dFTR; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmD.FycmSlB[2].dFTR; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmD.FycmSlB[1].dFTR; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmD.FycmSlB[3].dFTR; // Min J
				}
				else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP3)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmD.FycmSlB[0].dFBR; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmD.FycmSlB[2].dFBR; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmD.FycmSlB[1].dFBR; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmD.FycmSlB[3].dFBR; // Min J
				}
				else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP4)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmD.FycmSlB[0].dFBL; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmD.FycmSlB[2].dFBL; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmD.FycmSlB[1].dFBL; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmD.FycmSlB[3].dFBL; // Min J	
				}
				else
				{
					ASSERT(0);
				}

				bCheckIMax = FycmD.FycmSlB[0].bCHK;
				bCheckJMax = FycmD.FycmSlB[2].bCHK;
				bCheckIMin = FycmD.FycmSlB[1].bCHK;
				bCheckJMin = FycmD.FycmSlB[3].bCHK;
			}
			else
			{
				ASSERT(0);
			}
		}
		break;
		default:
			ASSERT(0);
			break;
		}
	}
	return TRUE;
}

BOOL  CDesignEngine::MakePscDsgnDgrmDataKR_BS(T_ELEM_K ElemK, T_PSC_DSGN_RESL_D RsltD[4], BOOL &bCheckIMin, BOOL &bCheckIMax, BOOL &bCheckJMin, BOOL &bCheckJMax)
{
	CDBDoc *pDoc = CDBDoc::GetDocPoint();

	if (m_nPSCCirteriaType == 0 || m_nPSCCirteriaType == 1)
	{
		switch (m_nPSCComp)
		{
		case PSC_DSGN_COMP_BEND_Y:
		{
			T_BDCR_PSC_BS BdcrBS;
			if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadBdcr_BS(ElemK, BdcrBS))	return FALSE;

			// 0=I-MAX, 1=I-MIN, 2=J-MAX, 3=J-MIN.
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(BdcrBS.BdcrB[0].dMu);  // Max I phi*Mu
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(BdcrBS.BdcrB[2].dMu);  // Max J phi*Mu 
			RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(BdcrBS.BdcrB[1].dMu); // Min I phi*Mu 
			RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(BdcrBS.BdcrB[3].dMu); // Min J phi*Mu 

			RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = BdcrBS.BdcrB[0].dMy; // Max I M* 
			RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = BdcrBS.BdcrB[2].dMy; // Max J M* 
			RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = BdcrBS.BdcrB[1].dMy; // Min I M* 
			RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = BdcrBS.BdcrB[3].dMy; // Min J M* 

			bCheckIMax = BdcrBS.BdcrB[0].bCHK;
			bCheckJMax = BdcrBS.BdcrB[2].bCHK;
			bCheckIMin = BdcrBS.BdcrB[1].bCHK;
			bCheckJMin = BdcrBS.BdcrB[3].bCHK;
		}
		break;
		case PSC_DSGN_COMP_BEND_Z:
		{
			ASSERT(0);
		}
		break;
		case PSC_DSGN_COMP_SHER_Z:
		{
			ASSERT(0);
		}
		break;
		case PSC_DSGN_COMP_TORSION:
		{
			ASSERT(0);
		}
		break;
		case PSC_DSGN_COMP_TORSION_MAXTOR:
		{
			ASSERT(0);
		}
		break;
		default:
			break;
		}
	}
	else if (m_nPSCCirteriaType == 2 || m_nPSCCirteriaType == 3) // Stress : 2, 3 )
	{
		switch (m_nPSCCompStr)
		{
		case PSC_DSGN_COMP_CONSTRUCTION:
		{
			T_FYSG_PSC_BS FysgD; FysgD.Initialize();
			if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadFysg_BS(ElemK, FysgD)) return FALSE;

			if (m_nPSCPart == PSC_DSGN_COMP_STRESS_GIRDER)
			{
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(FysgD.FysgGrB[0].dALW); // Max I
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(FysgD.FysgGrB[2].dALW); // Max J
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(FysgD.FysgGrB[1].dALW); // Min I
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(FysgD.FysgGrB[3].dALW); // Min J

				if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_TOP)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgD.FysgGrB[0].dFT; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgD.FysgGrB[2].dFT; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgD.FysgGrB[1].dFT; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgD.FysgGrB[3].dFT; // Min J
				}
				else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_BOT)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgD.FysgGrB[0].dFB; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgD.FysgGrB[2].dFB; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgD.FysgGrB[1].dFB; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgD.FysgGrB[3].dFB; // Min J
				}
				else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP1)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgD.FysgGrB[0].dFTL; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgD.FysgGrB[2].dFTL; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgD.FysgGrB[1].dFTL; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgD.FysgGrB[3].dFTL; // Min J		
				}
				else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP2)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgD.FysgGrB[0].dFTR; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgD.FysgGrB[2].dFTR; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgD.FysgGrB[1].dFTR; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgD.FysgGrB[3].dFTR; // Min J
				}
				else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP3)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgD.FysgGrB[0].dFBR; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgD.FysgGrB[2].dFBR; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgD.FysgGrB[1].dFBR; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgD.FysgGrB[3].dFBR; // Min J
				}
				else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP4)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgD.FysgGrB[0].dFBL; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgD.FysgGrB[2].dFBL; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgD.FysgGrB[1].dFBL; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgD.FysgGrB[3].dFBL; // Min J	
				}
				else
				{
					ASSERT(0);
				}

				bCheckIMax = FysgD.FysgGrB[0].bCHK;
				bCheckJMax = FysgD.FysgGrB[2].bCHK;
				bCheckIMin = FysgD.FysgGrB[1].bCHK;
				bCheckJMin = FysgD.FysgGrB[3].bCHK;
			}
			else if (m_nPSCPart == PSC_DSGN_COMP_STRESS_SLAB)
			{
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(FysgD.FysgSlB[0].dALW); // Max I
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(FysgD.FysgSlB[2].dALW); // Max J
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(FysgD.FysgSlB[1].dALW); // Min I
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(FysgD.FysgSlB[3].dALW); // Min J

				if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_TOP)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgD.FysgSlB[0].dFT; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgD.FysgSlB[2].dFT; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgD.FysgSlB[1].dFT; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgD.FysgSlB[3].dFT; // Min J
				}
				else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_BOT)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgD.FysgSlB[0].dFB; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgD.FysgSlB[2].dFB; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgD.FysgSlB[1].dFB; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgD.FysgSlB[3].dFB; // Min J
				}
				else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP1)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgD.FysgSlB[0].dFTL; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgD.FysgSlB[2].dFTL; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgD.FysgSlB[1].dFTL; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgD.FysgSlB[3].dFTL; // Min J		
				}
				else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP2)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgD.FysgSlB[0].dFTR; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgD.FysgSlB[2].dFTR; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgD.FysgSlB[1].dFTR; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgD.FysgSlB[3].dFTR; // Min J
				}
				else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP3)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgD.FysgSlB[0].dFBR; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgD.FysgSlB[2].dFBR; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgD.FysgSlB[1].dFBR; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgD.FysgSlB[3].dFBR; // Min J
				}
				else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP4)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FysgD.FysgSlB[0].dFBL; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FysgD.FysgSlB[2].dFBL; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FysgD.FysgSlB[1].dFBL; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FysgD.FysgSlB[3].dFBL; // Min J	
				}
				else
				{
					ASSERT(0);
				}

				bCheckIMax = FysgD.FysgSlB[0].bCHK;
				bCheckJMax = FysgD.FysgSlB[2].bCHK;
				bCheckIMin = FysgD.FysgSlB[1].bCHK;
				bCheckJMin = FysgD.FysgSlB[3].bCHK;
			}
			else
			{
				ASSERT(0);
			}
		}
		break;
		case PSC_DSGN_COMP_SERVICE_LOAD:
		{
			T_FYCM_PSC_BS FycmD; FycmD.Initialize();
			if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadFycm_BS(ElemK, FycmD)) return FALSE;

			if (m_nPSCPart == PSC_DSGN_COMP_STRESS_GIRDER)
			{
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(FycmD.FycmGrB[0].dALW); // Max I
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(FycmD.FycmGrB[2].dALW); // Max J
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(FycmD.FycmGrB[1].dALW); // Min I
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(FycmD.FycmGrB[3].dALW); // Min J

				if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_TOP)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmD.FycmGrB[0].dFT; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmD.FycmGrB[2].dFT; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmD.FycmGrB[1].dFT; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmD.FycmGrB[3].dFT; // Min J
				}
				else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_BOT)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmD.FycmGrB[0].dFB; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmD.FycmGrB[2].dFB; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmD.FycmGrB[1].dFB; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmD.FycmGrB[3].dFB; // Min J
				}
				else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP1)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmD.FycmGrB[0].dFTL; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmD.FycmGrB[2].dFTL; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmD.FycmGrB[1].dFTL; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmD.FycmGrB[3].dFTL; // Min J		
				}
				else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP2)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmD.FycmGrB[0].dFTR; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmD.FycmGrB[2].dFTR; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmD.FycmGrB[1].dFTR; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmD.FycmGrB[3].dFTR; // Min J
				}
				else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP3)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmD.FycmGrB[0].dFBR; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmD.FycmGrB[2].dFBR; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmD.FycmGrB[1].dFBR; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmD.FycmGrB[3].dFBR; // Min J
				}
				else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP4)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmD.FycmGrB[0].dFBL; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmD.FycmGrB[2].dFBL; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmD.FycmGrB[1].dFBL; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmD.FycmGrB[3].dFBL; // Min J	
				}
				else
				{
					ASSERT(0);
				}

				bCheckIMax = FycmD.FycmGrB[0].bCHK;
				bCheckJMax = FycmD.FycmGrB[2].bCHK;
				bCheckIMin = FycmD.FycmGrB[1].bCHK;
				bCheckJMin = FycmD.FycmGrB[3].bCHK;
			}
			else if (m_nPSCPart == PSC_DSGN_COMP_STRESS_SLAB)
			{
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(FycmD.FycmSlB[0].dALW); // Max I
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(FycmD.FycmSlB[2].dALW); // Max J
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(FycmD.FycmSlB[1].dALW); // Min I
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(FycmD.FycmSlB[3].dALW); // Min J

				if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_TOP)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmD.FycmSlB[0].dFT; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmD.FycmSlB[2].dFT; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmD.FycmSlB[1].dFT; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmD.FycmSlB[3].dFT; // Min J
				}
				else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP_BOT)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmD.FycmSlB[0].dFB; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmD.FycmSlB[2].dFB; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmD.FycmSlB[1].dFB; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmD.FycmSlB[3].dFB; // Min J
				}
				else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP1)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmD.FycmSlB[0].dFTL; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmD.FycmSlB[2].dFTL; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmD.FycmSlB[1].dFTL; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmD.FycmSlB[3].dFTL; // Min J		
				}
				else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP2)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmD.FycmSlB[0].dFTR; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmD.FycmSlB[2].dFTR; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmD.FycmSlB[1].dFTR; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmD.FycmSlB[3].dFTR; // Min J
				}
				else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP3)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmD.FycmSlB[0].dFBR; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmD.FycmSlB[2].dFBR; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmD.FycmSlB[1].dFBR; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmD.FycmSlB[3].dFBR; // Min J
				}
				else if (m_nPSCPosition == PSC_DSGN_COMP_STRESS_COMP4)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = FycmD.FycmSlB[0].dFBL; // Max I
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = FycmD.FycmSlB[2].dFBL; // Max J
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = FycmD.FycmSlB[1].dFBL; // Min I
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = FycmD.FycmSlB[3].dFBL; // Min J	
				}
				else
				{
					ASSERT(0);
				}

				bCheckIMax = FycmD.FycmSlB[0].bCHK;
				bCheckJMax = FycmD.FycmSlB[2].bCHK;
				bCheckIMin = FycmD.FycmSlB[1].bCHK;
				bCheckJMin = FycmD.FycmSlB[3].bCHK;
			}
			else
			{
				ASSERT(0);
			}
		}
		break;
		default:
			ASSERT(0);
			break;
		}
	}

	return TRUE;
}

BOOL  CDesignEngine::MakePscDsgnDgrmDataKR_RS(T_ELEM_K ElemK, T_PSC_DSGN_RESL_D RsltD[4], BOOL &bCheckIMin, BOOL &bCheckIMax, BOOL &bCheckJMin, BOOL &bCheckJMax)
{
	CDBDoc *pDoc = CDBDoc::GetDocPoint();

	switch (m_nPSCComp)
	{
	case PSC_DSGN_COMP_BEND_Y:
	{
		T_BDCR_SNIP BdcrD;
		if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadBdcr_SNiP(ElemK, BdcrD))	return FALSE;

		//T_BDCY_KSCE_BASE BdcyBase[4];	// 0=I-MAX, 1=I-MIN, 2=J-MAX, 3=J-MIN.
		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(BdcrD.BdcrBase[0].dMr); // Max I 강도,
		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(BdcrD.BdcrBase[2].dMr); // Max J 강도 
		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(BdcrD.BdcrBase[1].dMr); // Min I 강도 
		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(BdcrD.BdcrBase[3].dMr); // Min J 강도 

		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = BdcrD.BdcrBase[0].dMu; // Max I 계수부재력 
		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = BdcrD.BdcrBase[2].dMu; // Max J 계수부재력 
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = BdcrD.BdcrBase[1].dMu; // Min I 계수부재력 
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = BdcrD.BdcrBase[3].dMu; // Min J 계수부재력 

		bCheckIMax = BdcrD.BdcrBase[0].bCHK;
		bCheckJMax = BdcrD.BdcrBase[2].bCHK;
		bCheckIMin = BdcrD.BdcrBase[1].bCHK;
		bCheckJMin = BdcrD.BdcrBase[3].bCHK;
	}
	break;
	case PSC_DSGN_COMP_BEND_Z:
	{
		T_BDCZ_KSCE BdczKsceD;
		if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetBdczKsceData(ElemK, BdczKsceD))	return FALSE;

		//T_BDCZ_KSCE_BASE BdczBase[4];	// 0=I-MAX, 1=I-MIN, 2=J-MAX, 3=J-MIN.
		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(BdczKsceD.BdczBase[0].dpMny); // Max I 강도 
		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(BdczKsceD.BdczBase[2].dpMny); // Max J 강도 
		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(BdczKsceD.BdczBase[1].dpMny); // Min I 강도 
		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(BdczKsceD.BdczBase[3].dpMny); // Min J 강도 

		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = BdczKsceD.BdczBase[0].dMuy; // Max I 계수부재력 
		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = BdczKsceD.BdczBase[2].dMuy; // Max J 계수부재력 
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = BdczKsceD.BdczBase[1].dMuy; // Min I 계수부재력 
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = BdczKsceD.BdczBase[3].dMuy; // Min J 계수부재력 

		bCheckIMax = BdczKsceD.BdczBase[0].bCHK;
		bCheckJMax = BdczKsceD.BdczBase[2].bCHK;
		bCheckIMin = BdczKsceD.BdczBase[1].bCHK;
		bCheckJMin = BdczKsceD.BdczBase[3].bCHK;
	}
	break;
	case PSC_DSGN_COMP_SHER_Z:
	{
		T_CUMS_SNIP CumsD;
		if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadCums_SNiP(ElemK, CumsD))return FALSE;

		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(CumsD.CumsBase[0].dQr); // Max I 강도 
		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(CumsD.CumsBase[1].dQr); // Max J 강도 
		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = fabs(CumsD.CumsBase[0].dQr); // Min I 강도 
		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = fabs(CumsD.CumsBase[1].dQr); // Min J 강도 

		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = fabs(CumsD.CumsBase[0].dQu); // Max I 계수부재력 
		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = fabs(CumsD.CumsBase[1].dQu); // Max J 계수부재력 
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = fabs(CumsD.CumsBase[0].dQu); // Min I 계수부재력 
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = fabs(CumsD.CumsBase[1].dQu); // Min J 계수부재력 

		bCheckIMax = CumsD.CumsBase[0].bCHK;
		bCheckJMax = CumsD.CumsBase[1].bCHK;
		bCheckIMin = CumsD.CumsBase[0].bCHK;
		bCheckJMin = CumsD.CumsBase[1].bCHK;
	}
	break;
	case PSC_DSGN_COMP_TORSION:
	{
		T_CRMT_SNIP CrmtD;
		if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadCrmt_SNiP(ElemK, CrmtD)) return FALSE;

		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(CrmtD.CrmtBase[0].dTr); // Max I 강도 
		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(CrmtD.CrmtBase[1].dTr); // Max J 강도 
		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = fabs(CrmtD.CrmtBase[0].dTr); // Min I 강도 
		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = fabs(CrmtD.CrmtBase[1].dTr); // Min J 강도 

		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = fabs(CrmtD.CrmtBase[0].dTu); // Max I 계수부재력 
		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = fabs(CrmtD.CrmtBase[1].dTu); // Max J 계수부재력 
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = fabs(CrmtD.CrmtBase[0].dTu); // Min I 계수부재력 
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = fabs(CrmtD.CrmtBase[1].dTu); // Min J 계수부재력 

		bCheckIMax = CrmtD.CrmtBase[0].bCHK;
		bCheckJMax = CrmtD.CrmtBase[1].bCHK;
		bCheckIMin = CrmtD.CrmtBase[0].bCHK;
		bCheckJMin = CrmtD.CrmtBase[1].bCHK;
	}
	break;
	case PSC_DSGN_COMP_TORSION_MAXTOR:
	{
		T_CRMT_SNIP CrmtD;
		if (!pDoc->m_pPostCtrl->GetPCDesign()->ReadCrmt_SNiP(ElemK, CrmtD)) return FALSE;

		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(CrmtD.CrmtBase[0].dTr); // Max I 강도 
		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(CrmtD.CrmtBase[1].dTr); // Max J 강도 

		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = fabs(CrmtD.CrmtBase[0].dTu); // Max I 계수부재력 
		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = fabs(CrmtD.CrmtBase[1].dTu); // Max J 계수부재력 

		bCheckIMax = CrmtD.CrmtBase[0].bCHK;
		bCheckJMax = CrmtD.CrmtBase[1].bCHK;
	}
	break;
	default:
		ASSERT(0);
		break;
	}

	return TRUE;
}

BOOL  CDesignEngine::MakePscDsgnDgrmDataCH(T_ELEM_K ElemK, T_PSC_DSGN_RESL_D RsltD[4])
{
	CDBDoc *pDoc = CDBDoc::GetDocPoint();
	BOOL bCheckIMax = FALSE, bCheckIMin = FALSE, bCheckJMax = FALSE, bCheckJMin = FALSE;

	switch (m_nPSCCompCH)
	{
	case PSC_DSGN_COMP_BEND_Y_CH:
	{
		T_BDCY_JTG BdcrJtg;
		if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetBdcyJtgData(ElemK, BdcrJtg))	return FALSE;

		//T_BDCY_JTG_BASE BdcyBase[4];	// 0=I-MAX, 1=I-MIN, 2=J-MAX, 3=J-MIN.
		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(BdcrJtg.BdcyBase[0].dMny); // Max I 강도 
		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(BdcrJtg.BdcyBase[2].dMny); // Max J 강도 
		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(BdcrJtg.BdcyBase[1].dMny); // Min I 강도 
		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(BdcrJtg.BdcyBase[3].dMny); // Min J 강도 

		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = BdcrJtg.BdcyBase[0].drMuy; // Max I 계수부재력 
		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = BdcrJtg.BdcyBase[2].drMuy; // Max J 계수부재력 
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = BdcrJtg.BdcyBase[1].drMuy; // Min I 계수부재력 
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = BdcrJtg.BdcyBase[3].drMuy; // Min J 계수부재력 

		bCheckIMax = BdcrJtg.BdcyBase[0].bCHK;
		bCheckJMax = BdcrJtg.BdcyBase[2].bCHK;
		bCheckIMin = BdcrJtg.BdcyBase[1].bCHK;
		bCheckJMin = BdcrJtg.BdcyBase[3].bCHK;
	}
	break;
	case PSC_DSGN_COMP_SHER_Z_CH:
	{
		T_CUMS_JTG CumsJtgD;
		if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetCumsJtgData(ElemK, CumsJtgD))return FALSE;

		// T_CUMS_JTG_BASE CumsBase[4];	// 0=I-MAX, 1=I-MIN, 2=J-MAX, 3=J-MIN.
		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(CumsJtgD.CumsBase[0].dVn); // Max I 강도 
		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(CumsJtgD.CumsBase[2].dVn); // Max J 강도 
		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = -fabs(CumsJtgD.CumsBase[1].dVn); // Min I 강도 
		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = -fabs(CumsJtgD.CumsBase[3].dVn); // Min J 강도 

		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = CumsJtgD.CumsBase[0].drVu; // Max I 계수부재력 
		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = CumsJtgD.CumsBase[2].drVu; // Max J 계수부재력 
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = CumsJtgD.CumsBase[1].drVu; // Min I 계수부재력 
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = CumsJtgD.CumsBase[3].drVu; // Min J 계수부재력 

		bCheckIMax = CumsJtgD.CumsBase[0].bCHK;
		bCheckJMax = CumsJtgD.CumsBase[2].bCHK;
		bCheckIMin = CumsJtgD.CumsBase[1].bCHK;
		bCheckJMin = CumsJtgD.CumsBase[3].bCHK;
	}
	break;
	case PSC_DSGN_COMP_TORSION_CH:
	{
		T_CRMT_JTG CrmtJtgD;
		if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetCrmtJtgData(ElemK, CrmtJtgD)) return FALSE;

		// T_CRMT_JTG_BASE CrmtBase[6];	// 0=I-V-MAX, 1=I-V-MIN, 2=I-T-MAX, 3=J-V-MAX, 4=J-V-MIN, 5=J-T-MAX.
		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(CrmtJtgD.CrmtBase[0].dTn); // Max I 강도 
		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(CrmtJtgD.CrmtBase[3].dTn); // Max J 강도 
		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = fabs(CrmtJtgD.CrmtBase[1].dTn); // Min I 강도 
		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = fabs(CrmtJtgD.CrmtBase[4].dTn); // Min J 강도 

		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = fabs(CrmtJtgD.CrmtBase[0].drTu); // Max I 계수부재력 
		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = fabs(CrmtJtgD.CrmtBase[3].drTu); // Max J 계수부재력 
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = fabs(CrmtJtgD.CrmtBase[1].drTu); // Min I 계수부재력 
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = fabs(CrmtJtgD.CrmtBase[4].drTu); // Min J 계수부재력 

		bCheckIMax = CrmtJtgD.CrmtBase[0].bCHK;
		bCheckJMax = CrmtJtgD.CrmtBase[3].bCHK;
		bCheckIMin = CrmtJtgD.CrmtBase[1].bCHK;
		bCheckJMin = CrmtJtgD.CrmtBase[4].bCHK;
	}
	break;
	case PSC_DSGN_COMP_TORSION_MAXTOR_CH:
	{
		T_CRMT_JTG CrmtJtgD;
		if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetCrmtJtgData(ElemK, CrmtJtgD)) return FALSE;

		// T_CRMT_JTG_BASE CrmtBase[6];	// 0=I-V-MAX, 1=I-V-MIN, 2=I-T-MAX, 3=J-V-MAX, 4=J-V-MIN, 5=J-T-MAX.
		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = fabs(CrmtJtgD.CrmtBase[2].dTn); // Max I 강도 
		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = fabs(CrmtJtgD.CrmtBase[5].dTn); // Max J 강도 

		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = fabs(CrmtJtgD.CrmtBase[2].drTu); // Max I 계수부재력 
		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = fabs(CrmtJtgD.CrmtBase[5].drTu); // Max J 계수부재력 

		bCheckIMax = CrmtJtgD.CrmtBase[2].bCHK;
		bCheckJMax = CrmtJtgD.CrmtBase[5].bCHK;
	}
	break;
	}

	if (bCheckIMax == FALSE && bCheckJMax == TRUE)
	{
		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1];
		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1];
	}
	else if (bCheckIMax == TRUE && bCheckJMax == FALSE)
	{
		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0];
		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0];
	}
	if (bCheckIMin == FALSE && bCheckJMin == TRUE)
	{
		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1];
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1];
	}
	else if (bCheckIMin == TRUE && bCheckJMin == FALSE)
	{
		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0];
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0];
	}

	FinishMakingPscDsgnData_CH(RsltD);
	return TRUE;
}

BOOL  CDesignEngine::MakePscDsgnDgrmDataJP(T_ELEM_K ElemK, T_PSC_DSGN_RESL_D RsltD[4])
{
	CDBDoc *pDoc = CDBDoc::GetDocPoint();
	BOOL bCheckIMax = FALSE, bCheckIMin = FALSE, bCheckJMax = FALSE, bCheckJMin = FALSE;

	switch (m_nPSCCompJP)
	{
	case PSC_DSGN_COMP_BEND_Y_JP:
	{
		T_BDCR_D BdcrD;
		if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetBdcrData(ElemK, BdcrD))return FALSE;

		//T_BDCR_BASE BdcrBase[4];	// 0=I-MAX, 1=I-MIN, 2=J-MAX, 3=J-MIN.
		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = BdcrD.BdcrBase[0].dMRY; // Max I 강도 
		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = BdcrD.BdcrBase[2].dMRY; // Max J 강도 
		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = BdcrD.BdcrBase[1].dMRY; // Min I 강도 
		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = BdcrD.BdcrBase[3].dMRY; // Min J 강도 

		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = BdcrD.BdcrBase[0].dMUY; // Max I 계수부재력 
		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = BdcrD.BdcrBase[2].dMUY; // Max J 계수부재력 
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = BdcrD.BdcrBase[1].dMUY; // Min I 계수부재력 
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = BdcrD.BdcrBase[3].dMUY; // Min J 계수부재력 

		bCheckIMax = BdcrD.BdcrBase[0].bCHK;
		bCheckJMax = BdcrD.BdcrBase[2].bCHK;
		bCheckIMin = BdcrD.BdcrBase[1].bCHK;
		bCheckJMin = BdcrD.BdcrBase[3].bCHK;
	}
	break;
	case PSC_DSGN_COMP_BEND_Z_JP:
	{
		T_BDCR_D BdcrD;
		if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetBdcrData(ElemK, BdcrD))return FALSE;

		//T_BDCR_BASE BdcrBase[4];	// 0=I-MAX, 1=I-MIN, 2=J-MAX, 3=J-MIN.
		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = BdcrD.BdcrBase[0].dMRZ; // Max I 강도 
		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = BdcrD.BdcrBase[2].dMRZ; // Max J 강도 
		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = BdcrD.BdcrBase[1].dMRZ; // Min I 강도 
		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = BdcrD.BdcrBase[3].dMRZ; // Min J 강도 

		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = BdcrD.BdcrBase[0].dMUZ; // Max I 계수부재력 
		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = BdcrD.BdcrBase[2].dMUZ; // Max J 계수부재력 
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = BdcrD.BdcrBase[1].dMUZ; // Min I 계수부재력 
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = BdcrD.BdcrBase[3].dMUZ; // Min J 계수부재력 

		bCheckIMax = BdcrD.BdcrBase[0].bCHK;
		bCheckJMax = BdcrD.BdcrBase[2].bCHK;
		bCheckIMin = BdcrD.BdcrBase[1].bCHK;
		bCheckJMin = BdcrD.BdcrBase[3].bCHK;
	}
	break;
	//-----------------------------------------------------------------------------------------
	// 웹,프랜지 압괴내력(전단최대)
	//-----------------------------------------------------------------------------------------
	case PSC_DSGN_COMP_SHER_1_JP:
	{
		T_CUMS_D CumsD;
		if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetCumsData(ElemK, CumsD))return FALSE;

		// T_CUMS_BASE CumsBase[4];	// 0=I-MAX, 1=I-MIN, 2=J-MAX, 3=J-MIN.
		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = CumsD.CumsBase[0].dQR; // Max I 강도 
		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = CumsD.CumsBase[2].dQR; // Max J 강도 
		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = CumsD.CumsBase[1].dQR; // Min I 강도 
		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = CumsD.CumsBase[3].dQR; // Min J 강도 

		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = CumsD.CumsBase[0].dQU; // Max I 계수부재력 
		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = CumsD.CumsBase[2].dQU; // Max J 계수부재력 
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = CumsD.CumsBase[1].dQU; // Min I 계수부재력 
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = CumsD.CumsBase[3].dQU; // Min J 계수부재력 

		bCheckIMax = CumsD.CumsBase[0].bCHK;
		bCheckJMax = CumsD.CumsBase[2].bCHK;
		bCheckIMin = CumsD.CumsBase[1].bCHK;
		bCheckJMin = CumsD.CumsBase[3].bCHK;
	}
	break;
	case PSC_DSGN_COMP_TORN_1_JP:
	{
		T_CUMS_D CumsD;
		if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetCumsData(ElemK, CumsD))return FALSE;

		// T_CUMS_BASE CumsBase[4];	// 0=I-MAX, 1=I-MIN, 2=J-MAX, 3=J-MIN.
		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = CumsD.CumsBase[0].dTR; // Max I 강도 
		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = CumsD.CumsBase[2].dTR; // Max J 강도 
		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = CumsD.CumsBase[1].dTR; // Min I 강도 
		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = CumsD.CumsBase[3].dTR; // Min J 강도 

		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = CumsD.CumsBase[0].dTU; // Max I 계수부재력 
		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = CumsD.CumsBase[2].dTU; // Max J 계수부재력 
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = CumsD.CumsBase[1].dTU; // Min I 계수부재력 
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = CumsD.CumsBase[3].dTU; // Min J 계수부재력 

		bCheckIMax = CumsD.CumsBase[0].bCHK;
		bCheckJMax = CumsD.CumsBase[2].bCHK;
		bCheckIMin = CumsD.CumsBase[1].bCHK;
		bCheckJMin = CumsD.CumsBase[3].bCHK;
	}
	break;
	//-----------------------------------------------------------------------------------------
	// 웹,프랜지 압괴내력(비틀림최대 )
	//-----------------------------------------------------------------------------------------
	case PSC_DSGN_COMP_SHER_2_JP:
	{
		T_CUMT_D CumtD;
		if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetCumtData(ElemK, CumtD))return FALSE;

		// T_CUMT_BASE CumtBase[4];	// 0=I-MAX, 1=I-MIN, 2=J-MAX, 3=J-MIN.
		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = CumtD.CumtBase[0].dQR; // Max I 강도 
		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = CumtD.CumtBase[2].dQR; // Max J 강도 
		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = CumtD.CumtBase[1].dQR; // Min I 강도 
		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = CumtD.CumtBase[3].dQR; // Min J 강도 

		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = CumtD.CumtBase[0].dQU; // Max I 계수부재력 
		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = CumtD.CumtBase[2].dQU; // Max J 계수부재력 
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = CumtD.CumtBase[1].dQU; // Min I 계수부재력 
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = CumtD.CumtBase[3].dQU; // Min J 계수부재력 

		bCheckIMax = CumtD.CumtBase[0].bCHK;
		bCheckJMax = CumtD.CumtBase[2].bCHK;
		bCheckIMin = CumtD.CumtBase[1].bCHK;
		bCheckJMin = CumtD.CumtBase[3].bCHK;
	}
	break;
	case PSC_DSGN_COMP_TORN_2_JP:
	{
		T_CUMT_D CumtD;
		if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetCumtData(ElemK, CumtD))return FALSE;

		// T_CUMT_BASE CumtBase[4];	// 0=I-MAX, 1=I-MIN, 2=J-MAX, 3=J-MIN.
		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = CumtD.CumtBase[0].dTR; // Max I 강도 
		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = CumtD.CumtBase[2].dTR; // Max J 강도 
		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = CumtD.CumtBase[1].dTR; // Min I 강도 
		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = CumtD.CumtBase[3].dTR; // Min J 강도 

		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = CumtD.CumtBase[0].dTU; // Max I 계수부재력 
		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = CumtD.CumtBase[2].dTU; // Max J 계수부재력 
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = CumtD.CumtBase[1].dTU; // Min I 계수부재력 
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = CumtD.CumtBase[3].dTU; // Min J 계수부재력 

		bCheckIMax = CumtD.CumtBase[0].bCHK;
		bCheckJMax = CumtD.CumtBase[2].bCHK;
		bCheckIMin = CumtD.CumtBase[1].bCHK;
		bCheckJMin = CumtD.CumtBase[3].bCHK;
	}
	break;
	//-----------------------------------------------------------------------------------------
	// 전사파괴내력 (전단력 최대시)
	//-----------------------------------------------------------------------------------------
	case PSC_DSGN_COMP_SHER_3_JP:
	{
		T_CRMS_D CrmsD;
		if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetCrmsData(ElemK, CrmsD))return FALSE;

		//T_CRMS_BASE CrmsBase[4];	// 0=I-MAX, 1=I-MIN, 2=J-MAX, 3=J-MIN.
		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = CrmsD.CrmsBase[0].dQR; // Max I 강도 
		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = CrmsD.CrmsBase[2].dQR; // Max J 강도 
		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = CrmsD.CrmsBase[1].dQR; // Min I 강도 
		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = CrmsD.CrmsBase[3].dQR; // Min J 강도 

		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = CrmsD.CrmsBase[0].dQU; // Max I 계수부재력 
		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = CrmsD.CrmsBase[2].dQU; // Max J 계수부재력 
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = CrmsD.CrmsBase[1].dQU; // Min I 계수부재력 
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = CrmsD.CrmsBase[3].dQU; // Min J 계수부재력 

		bCheckIMax = CrmsD.CrmsBase[0].bCHK;
		bCheckJMax = CrmsD.CrmsBase[2].bCHK;
		bCheckIMin = CrmsD.CrmsBase[1].bCHK;
		bCheckJMin = CrmsD.CrmsBase[3].bCHK;
	}
	break;
	//-----------------------------------------------------------------------------------------
	// 전사파괴내력 (비틀림 최대시)
	//-----------------------------------------------------------------------------------------
	case PSC_DSGN_COMP_TORN_3_JP:
	{
		T_CRMT_D CrmtD;
		if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetCrmtData(ElemK, CrmtD))return FALSE;

		//T_CRMT_BASE CrmtBase[4];	// 0=I-MAX, 1=I-MIN, 2=J-MAX, 3=J-MIN.
		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = CrmtD.CrmtBase[0].dTR; // Max I 강도 
		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = CrmtD.CrmtBase[2].dTR; // Max J 강도 
		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = CrmtD.CrmtBase[1].dTR; // Min I 강도 
		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = CrmtD.CrmtBase[3].dTR; // Min J 강도 

		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = CrmtD.CrmtBase[0].dTU; // Max I 계수부재력 
		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = CrmtD.CrmtBase[2].dTU; // Max J 계수부재력 
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = CrmtD.CrmtBase[1].dTU; // Min I 계수부재력 
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = CrmtD.CrmtBase[3].dTU; // Min J 계수부재력 

		bCheckIMax = CrmtD.CrmtBase[0].bCHK;
		bCheckJMax = CrmtD.CrmtBase[2].bCHK;
		bCheckIMin = CrmtD.CrmtBase[1].bCHK;
		bCheckJMin = CrmtD.CrmtBase[3].bCHK;
	}
	break;
	}

	if (bCheckIMax == FALSE && bCheckJMax == TRUE)
	{
		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1];
		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1];
	}
	else if (bCheckIMax == TRUE && bCheckJMax == FALSE)
	{
		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0];
		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0];
	}
	if (bCheckIMin == FALSE && bCheckJMin == TRUE)
	{
		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1];
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1];
	}
	else if (bCheckIMin == TRUE && bCheckJMin == FALSE)
	{
		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0];
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0];
	}

	FinishMakingPscDsgnData(RsltD);
	return TRUE;
}


BOOL    CDesignEngine::FinishMakingPscDsgnData_CH(T_PSC_DSGN_RESL_D RsltD[4])
{
	int i = 0;

	// Ratio와 같은 경우 비율값을 넣는다. 
	if (m_nPSCCirteriaType == 1)
	{
		if (fabs(RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0]) > 1.0E-15)
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] /= RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0];
		else
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = 5.0;
		if (RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] > 5.0) RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = 5.0;
		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = m_dCritLineVal;

		if (fabs(RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1]) > 1.0E-15)
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] /= RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1];
		else
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = 5.0;
		if (RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] > 5.0) RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = 5.0;
		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = m_dCritLineVal;

		if (fabs(RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0]) > 1.0E-15)
			RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] /= RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0];
		else
			RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = 5.0;
		if (RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] > 5.0) RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = 5.0;
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = m_dCritLineVal;

		if (fabs(RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1]) > 1.0E-15)
			RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] /= RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1];
		else
			RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = 5.0;
		if (RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] > 5.0) RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = 5.0;
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = m_dCritLineVal;
	}
	// Force와 같은 경우 값의 위치를 서로 바꿔야 한다. 
	// Diagram이 반대로 나온다고 한다. Recommanded by Jun-In
	else
	{
		T_PSC_DSGN_RESL_D TmpReslD;
		TmpReslD = RsltD[PSC_DSGN_STRG_MAX_KEY];
		RsltD[PSC_DSGN_STRG_MAX_KEY] = RsltD[PSC_DSGN_CRIT_MAX_KEY];
		RsltD[PSC_DSGN_CRIT_MAX_KEY] = TmpReslD;

		TmpReslD = RsltD[PSC_DSGN_STRG_MIN_KEY];
		RsltD[PSC_DSGN_STRG_MIN_KEY] = RsltD[PSC_DSGN_CRIT_MIN_KEY];
		RsltD[PSC_DSGN_CRIT_MIN_KEY] = TmpReslD;
	}

	for (i = 0; i < PSC_DSGN_TYPE_KEY_NUM; i++)
		RsltD[i].InterpolateMidValue();

	return TRUE;
}

BOOL    CDesignEngine::FinishMakingPscDsgnData(T_PSC_DSGN_RESL_D RsltD[4])
{
	int i = 0;

	// Ratio와 같은 경우 비율값을 넣는다. 
	if (m_nPSCCirteriaType == 1 || m_nPSCCirteriaType == 3)
	{
		// Ratio출력시 Mn/Mu -> Mu/Mn으로 변경 바랍니다.
		// Ratio출력시 허용강도 0이고 부재력이 있는 경우 부호를 고려하여 99.99로 표현하여 NG를 판단!
		const double dNG_val = 99.99999;
		if (fabs(RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0]) > 1.0E-15)
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] / RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0];
		else
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = (RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] > 1.0E-15) ? dNG_val : 0.0;
		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = m_dCritLineVal;

		if (fabs(RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1]) > 1.0E-15)
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] / RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1];
		else
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = (RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] > 1.0E-15) ? dNG_val : 0.0;
		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = m_dCritLineVal;

		if (fabs(RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0]) > 1.0E-15)
			RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] / RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0];
		else
			RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = (RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] < 0.0) ? dNG_val : 0.0;
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = m_dCritLineVal;

		if (fabs(RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1]) > 1.0E-15)
			RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] / RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1];
		else
			RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = (RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] < 0.0) ? dNG_val : 0.0;
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = m_dCritLineVal;
	}
	// Force와 같은 경우 값의 위치를 서로 바꿔야 한다. 
	// Diagram이 반대로 나온다고 한다. Recommanded by Jun-In
	else
	{
		T_PSC_DSGN_RESL_D TmpReslD;
		TmpReslD = RsltD[PSC_DSGN_STRG_MAX_KEY];
		RsltD[PSC_DSGN_STRG_MAX_KEY] = RsltD[PSC_DSGN_CRIT_MAX_KEY];
		RsltD[PSC_DSGN_CRIT_MAX_KEY] = TmpReslD;

		TmpReslD = RsltD[PSC_DSGN_STRG_MIN_KEY];
		RsltD[PSC_DSGN_STRG_MIN_KEY] = RsltD[PSC_DSGN_CRIT_MIN_KEY];
		RsltD[PSC_DSGN_CRIT_MIN_KEY] = TmpReslD;
	}

	for (i = 0; i < PSC_DSGN_TYPE_KEY_NUM; i++)
		RsltD[i].InterpolateMidValue();

	return TRUE;
}

BOOL CDesignEngine::FinishMakingPscDsgnDataAASHTO19(T_PSC_DSGN_RESL_D RsltD[4], BOOL bFatigue)
{
	int i = 0;

	if (bFatigue == FALSE)
	{
		// Ratio와 같은 경우 비율값을 넣는다. 
		if (m_nPSCCirteriaType == 1 || m_nPSCCirteriaType == 3)
		{
			// Ratio출력시 Mn/Mu -> Mu/Mn으로 변경 바랍니다.
			// Ratio출력시 허용강도 0이고 부재력이 있는 경우 부호를 고려하여 99.99로 표현하여 NG를 판단!
			const double dNG_val = 99.99999;
			if (fabs(RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0]) > 1.0E-15)
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] / RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0];
			else
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = (RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] > 1.0E-15) ? dNG_val : 0.0;
			RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = m_dCritLineVal;

			if (fabs(RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1]) > 1.0E-15)
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] / RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1];
			else
				RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = (RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] > 1.0E-15) ? dNG_val : 0.0;
			RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = m_dCritLineVal;

			if (fabs(RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0]) > 1.0E-15)
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] / RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0];
			else
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = (RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] < 0.0) ? dNG_val : 0.0;
			RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = m_dCritLineVal;

			if (fabs(RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1]) > 1.0E-15)
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] / RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1];
			else
				RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = (RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] < 0.0) ? dNG_val : 0.0;
			RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = m_dCritLineVal;
		}
		// Force와 같은 경우 값의 위치를 서로 바꿔야 한다. 
		// Diagram이 반대로 나온다고 한다. Recommanded by Jun-In
		else
		{
			T_PSC_DSGN_RESL_D TmpReslD;
			TmpReslD = RsltD[PSC_DSGN_STRG_MAX_KEY];
			RsltD[PSC_DSGN_STRG_MAX_KEY] = RsltD[PSC_DSGN_CRIT_MAX_KEY];
			RsltD[PSC_DSGN_CRIT_MAX_KEY] = TmpReslD;

			TmpReslD = RsltD[PSC_DSGN_STRG_MIN_KEY];
			RsltD[PSC_DSGN_STRG_MIN_KEY] = RsltD[PSC_DSGN_CRIT_MIN_KEY];
			RsltD[PSC_DSGN_CRIT_MIN_KEY] = TmpReslD;
		}
	}

	for (i = 0; i < PSC_DSGN_TYPE_KEY_NUM; i++)
		RsltD[i].InterpolateMidValue();

	return TRUE;
}

double  CDesignEngine::GetForceCapacityRatio(BOOL bPositive, double dFor, double dCa)
{
	double dRat = 0.0;
	double dCa_Val = fabs(dCa);
	if (bPositive)
	{
		if (dCa_Val < 1.0E-15)
		{
			dRat = 999.0;
		}
		else
		{
			dRat = dFor / dCa_Val;
		}
		//if (dFor<0.0) 
	}
	else
	{

	}

	return dRat;
}

void    CDesignEngine::DrawPscDsgnDgrmDataList(CDC *pDC)
{
	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;

	int			i, nElem;
	T_ELEM_D	elem_d;
	CArray <int, int>				    type_list;
	CArray <GRE_Atom, GRE_Atom&>atom_list;
	BOOL bEscapePressed = FALSE;


	switch (m_nFillType)
	{
	case 0: // No Fill
		m_bDgrmLineOnly = TRUE;
		m_bDgrmVertLineFill = FALSE;
		break;
	case 1: // Line Fill
		m_bDgrmLineOnly = TRUE;
		m_bDgrmVertLineFill = TRUE;
		break;
	case 2: // Solid Fill
	default:
		m_bDgrmLineOnly = FALSE;
		m_bDgrmVertLineFill = TRUE;
		break;
	}

	CDC	*pdc = gm->m_pMyView->GetDC();
	double dUnitLength = fabs(gm->m_pGPSCtrl->GetWorldLength(((double)pdc->GetDeviceCaps(LOGPIXELSX)) / 5.0));

	gm->m_pMyView->ReleaseDC(pdc);

	BOOL fl_bak = gm->m_DOPT.DR.m_bFrameLine;
	gm->m_DOPT.DR.m_bFrameLine = TRUE;

	type_list.Add(gm->m_MinOTID + OBJECT_TYPE_ORIGINAL);
	gm->m_pGPSCtrl->GetZSortedList(type_list, gm->m_EKeyListVisible_Mirror, atom_list);
	nElem = atom_list.GetSize();

	T_MIRE_K mkey;
	UINT Key2[] = { PSC_DSGN_STRG_MAX_KEY,
		PSC_DSGN_STRG_MIN_KEY,
		PSC_DSGN_CRIT_MAX_KEY,
		PSC_DSGN_CRIT_MIN_KEY };

	T_CMAP_K2<UINT>   mKey;
	T_PSC_DSGN_RESL_D ReslD;
	T_TENDON_D tendonD;
	BOOL bResult = FALSE;

	if ((gm->m_GPSMode == GPS_COMMAND_STEEL_RATING || gm->m_GPSMode == GPS_COMMAND_PSC_RATING || gm->m_GPSMode == GPS_COMMAND_RC_RATING)
		&& GetSteelRatingDrawType() == 1)
	{
		ASSERT(0);
	}

	for (i = 0; i < nElem; i++)
	{
		if (gm->m_pGPSCtrl->WatchEscKeyPress()) return;
		if (gm->m_pGPSCtrl->IsZoomAllState() ||
			gm->m_pGPSCtrl->IsObjectInClientWindow(atom_list[i].m_OType, atom_list[i].m_OKey))
		{
			mkey.keymap = atom_list[i].m_OKey;
			if (!m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d))continue;
			if (gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey) && !bEscapePressed)
			{
				BOOL bResult = FALSE;
				for (int j = 0; j < PSC_DSGN_TYPE_KEY_NUM; j++)
				{
					mKey.i1 = mkey.key.elem_k;
					mKey.i2 = Key2[j];

					if (((gm->m_GPSMode == GPS_COMMAND_BRDG_LOAD_DGRM) || (gm->m_GPSMode == GPS_COMMAND_STEEL_AASHTO_RATING) ||
						((gm->m_GPSMode == GPS_COMMAND_STEEL_RATING || gm->m_GPSMode == GPS_COMMAND_PSC_RATING || gm->m_GPSMode == GPS_COMMAND_RC_RATING) && GetSteelRatingDrawType() == 0)))
					{
						if (m_nDgnCode == STL_AASHTO_LRFD19 && m_nSteelRatingRstType == ENUM_Fatigue)
						{
							//Fatigue는 그래프 4개를 출력하므로 이에 대한 continue 처리 없앰
						}
						else
						{
							if ((j == PSC_DSGN_CRIT_MAX_KEY) || (j == PSC_DSGN_CRIT_MIN_KEY)) continue;
						}
					}

					if (m_mapDgrmData.Lookup(mKey, ReslD))
					{
						bResult = TRUE;
						DoDrawDiagram(pDC, mkey.key.elem_k, ReslD, Key2[j]);
					}
				}
				if (bResult) gm->GPSDrawElement(pDC, atom_list[i].m_OKey);
				else        gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
			}
			else
			{
				gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
			}
		}
	}
	//if (m_mapTendonData.GetCount())	DrawTendonData(pDC);
}


void CDesignEngine::DoDrawDiagram(CDC *pDC, T_ELEM_K ElemK, T_PSC_DSGN_RESL_D &ReslD, UINT nKeyType)
{
	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;

	int		    poly_num;
	double    dMnMxVal[2];

	POSITION	pos;
	C3DPoint	pnt[2], *txt_pnt;
	CArray<BOOL, BOOL>				ef_list;
	CArray<BOOL, BOOL>				rect_flag;
	CArray<double, double &>	val_list;
	CArray<C3DPoint, C3DPoint&>vtx_list;
	CArray<CList<C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>polygon_list;

	BOOL bDeformedElem = FALSE;
	gm->GetShapeElement(ElemK, polygon_list, NULL, NULL, NULL);

	poly_num = polygon_list.GetSize();
	if ((poly_num != 1) || (polygon_list[0]->GetCount() != 2))return;

	if (gm->m_DOPT.TX.m_bOutputNumber)
	{
		txt_pnt = new C3DPoint[4];
	}
	else
	{
		txt_pnt = NULL;
	}

	pos = polygon_list[0]->GetHeadPosition();
	pnt[0] = polygon_list[0]->GetNext(pos);
	pnt[1] = polygon_list[0]->GetNext(pos);

	T_PSC_DSGN_VALS_D OutValD;

	// RC Design Diagram (Ratio)
	if (gm->m_GPSMode == GPS_COMMAND_RC_DSGN_DGRM && (m_nPSCCirteriaType == 1 || m_nPSCCirteriaType == 3) &&
		(nKeyType == PSC_DSGN_STRG_MAX_KEY || nKeyType == PSC_DSGN_STRG_MIN_KEY))
		DiagramPolygon4RC(nKeyType, ReslD, ReslD.dDirVec, pnt[0], pnt[1], vtx_list, val_list,
			ef_list, rect_flag, txt_pnt, ElemK, m_nFillType, dMnMxVal);
	// RC Design Diagram (Value)
	else if (gm->m_GPSMode == GPS_COMMAND_RC_DSGN_DGRM && (m_nPSCCirteriaType == 0 || m_nPSCCirteriaType == 2) &&
		(nKeyType == PSC_DSGN_CRIT_MAX_KEY || nKeyType == PSC_DSGN_CRIT_MIN_KEY))
		DiagramPolygon4RC(nKeyType, ReslD, ReslD.dDirVec, pnt[0], pnt[1], vtx_list, val_list,
			ef_list, rect_flag, txt_pnt, ElemK, m_nFillType, dMnMxVal);
	// Railway PSC Design Diagram (Value)
	else if (gm->m_GPSMode == GPS_COMMAND_RAIL_PSC_DSGN_DGRM && (m_nPSCCirteriaType == 0 || m_nPSCCirteriaType == 2) &&
		(nKeyType == PSC_DSGN_CRIT_MAX_KEY || nKeyType == PSC_DSGN_CRIT_MIN_KEY))
		DiagramPolygon4RC(nKeyType, ReslD, ReslD.dDirVec, pnt[0], pnt[1], vtx_list, val_list,
			ef_list, rect_flag, txt_pnt, ElemK, m_nFillType, dMnMxVal);
	// Railway RC Design Diagram (Value)
	else if (gm->m_GPSMode == GPS_COMMAND_RAIL_RC_DSGN_DGRM && (m_nPSCCirteriaType == 0 || m_nPSCCirteriaType == 2) &&
		(nKeyType == PSC_DSGN_CRIT_MAX_KEY || nKeyType == PSC_DSGN_CRIT_MIN_KEY))
		DiagramPolygon4RC(nKeyType, ReslD, ReslD.dDirVec, pnt[0], pnt[1], vtx_list, val_list,
			ef_list, rect_flag, txt_pnt, ElemK, m_nFillType, dMnMxVal);
	// Steel Design Diagram (Value) Not Both Type
	else if (gm->m_GPSMode == GPS_COMMAND_STEEL_DSGN_DGRM && (m_nPSCCirteriaType == 0 || m_nPSCCirteriaType == 2) &&
		(m_nSteelComp != 0 || m_nSteelCompSub != 2) &&
		(nKeyType == PSC_DSGN_CRIT_MAX_KEY || nKeyType == PSC_DSGN_CRIT_MIN_KEY))
		DiagramPolygon4RC(nKeyType, ReslD, ReslD.dDirVec, pnt[0], pnt[1], vtx_list, val_list,
			ef_list, rect_flag, txt_pnt, ElemK, m_nFillType, dMnMxVal);
	// Steel Composite Design Diagram (Value) Not Both Type
	else if (gm->m_GPSMode == GPS_COMMAND_STEEL_COMP_DSGN_DGRM && (m_nPSCCirteriaType == 0 || m_nPSCCirteriaType == 2) &&
		(nKeyType == PSC_DSGN_CRIT_MAX_KEY || nKeyType == PSC_DSGN_CRIT_MIN_KEY))
		DiagramPolygon4RC(nKeyType, ReslD, ReslD.dDirVec, pnt[0], pnt[1], vtx_list, val_list,
			ef_list, rect_flag, txt_pnt, ElemK, m_nFillType, dMnMxVal);
	// RSC Diagram & 기본 결과 출력시
	else
		DiagramPolygon(nKeyType, ReslD, ReslD.dDirVec, pnt[0], pnt[1], vtx_list, val_list,
			ef_list, rect_flag, txt_pnt, ElemK, m_nFillType, dMnMxVal);

	if (txt_pnt) GetDgrmOutputData(ElemK, txt_pnt, dMnMxVal, OutValD);

	gm->GPS_XGL_Begin_Diagram(ElemK);

	// 공칭강도 or 계수하중/공칭강도 

	if (m_nDgnCode == STL_AASHTO_LRFD19 && m_nSteelRatingRstType == ENUM_Fatigue)
	{
		DoDgrmContour(pDC, vtx_list, val_list, ef_list, rect_flag);
	}
	else
	{
		if (nKeyType == PSC_DSGN_STRG_MAX_KEY ||
			nKeyType == PSC_DSGN_STRG_MIN_KEY)
			DoDgrmContour(pDC, vtx_list, val_list, ef_list, rect_flag);

		if ((gm->m_GPSMode == GPS_COMMAND_STEEL_RATING || gm->m_GPSMode == GPS_COMMAND_PSC_RATING || gm->m_GPSMode == GPS_COMMAND_RC_RATING) && GetSteelRatingDrawType() == 1)
		{
			ASSERT(0);
		}

		// 계수하중 or Criteria
		else if (nKeyType == PSC_DSGN_CRIT_MAX_KEY ||
			nKeyType == PSC_DSGN_CRIT_MIN_KEY)
		{
			if (gm->m_GPSMode != GPS_COMMAND_BRDG_LOAD_DGRM && gm->m_GPSMode != GPS_COMMAND_STEEL_AASHTO_RATING &&
				!((gm->m_GPSMode == GPS_COMMAND_STEEL_RATING || gm->m_GPSMode == GPS_COMMAND_PSC_RATING || gm->m_GPSMode == GPS_COMMAND_RC_RATING) && GetSteelRatingDrawType() == 0))
				DoDgrmMonoColorLine(pDC, vtx_list, val_list, ef_list, rect_flag);
		}
	}

	gm->GPS_XGL_End_Elem();

	vtx_list.RemoveAll();
	val_list.RemoveAll();
	ef_list.RemoveAll();
	rect_flag.RemoveAll();

	FreeMemoryPolyList(&polygon_list);

	if (txt_pnt) delete[]txt_pnt;

	// Output Text
	if (txt_pnt)
	{
		BOOL bGrpFltMode = gm->m_pGPSCtrl->IsGroupFilterMode();
		if (bGrpFltMode) if (!gm->m_pDispFilter->IsExistEKey(ElemK))return;

		if (gm->m_GPSMode == GPS_COMMAND_STEEL_DSGN_DGRM)
			OutputDgrmNumberSteel(pDC, ReslD, OutValD, bDeformedElem, nKeyType);
		else
			OutputDgrmNumber(pDC, ReslD, OutValD, bDeformedElem);
	}
}


void CDesignEngine::DoDgrmMonoColorLine(CDC *pDC, CArray <C3DPoint, C3DPoint &> &vtx_list,
	CArray <double, double &> &val_list,
	CArray <BOOL, BOOL> &ef_list,
	CArray <BOOL, BOOL> &rect_flag)
{
	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;
	int nCount = 0;
	int nNodeNum = 0;
	CList <C3DPoint, C3DPoint>	vlist;
	CArray<BOOL, BOOL> arEdgeFlag;

	CPen LinePen, *pOldPen;
	int nLineThk = GetLineThick(m_nResistanceLineThk);
	LinePen.CreatePen(PS_SOLID, nLineThk, m_nResistanceLineCol);
	pOldPen = (CPen *)pDC->SelectObject(&LinePen);
	for (int i = 0; i < rect_flag.GetSize(); i++)
	{
		if (rect_flag[i])nNodeNum = 4;
		else            nNodeNum = 3;

		vlist.RemoveAll();
		arEdgeFlag.RemoveAll();
		for (int j = 0; j < nNodeNum; j++)
		{
			vlist.AddTail(vtx_list[j + nCount]);
			arEdgeFlag.Add(ef_list[j + nCount]);
		}

		// Solid Fill
		/*
		if(DiagD.DispOpt.nFillType == 2)
		{
		gm->DrawPolygon3DFill(pDC,vlist,DiagD.DispOpt.Color);
		}
		else
		*/
		{
			gm->GPSDrawPolygonEdge(pDC, &vlist, &arEdgeFlag); // bOnClient : Client윈도에 직접 같이 그리는 것 조절.

		}
		nCount += nNodeNum;
	}
	pDC->SelectObject(pOldPen);
	LinePen.DeleteObject();
}

void CDesignEngine::DiagramPolygon(UINT nKeyType, T_PSC_DSGN_RESL_D &ReslD, double dDirVec[3],
	C3DPoint &node_i, C3DPoint &node_j,
	CArray<C3DPoint, C3DPoint &> &vtx_list,
	CArray<double, double &> &val_list,
	CArray<BOOL, BOOL> &ef_list,
	CArray<BOOL, BOOL> &rect_flag,
	C3DPoint *txt_pnt, T_ELEM_K ElemKey, int nFillType, double *pMnMxVal)
{
	if (pMnMxVal) { pMnMxVal[0] = 0;  pMnMxVal[1] = 0; }

	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;

	int			i, j, sl_num;
	double	val_i, val_j;
	double  dVal[2];
	double  ulen, udist, uval, ldist, vdist;
	double  sub_ival, sub_jval, sub_mval;
	double  dMaxVal = -DBL_MAX, dMinVal = DBL_MAX;
	double  dAbsMax = 0;

	C3DPoint	ps, pss, pe, pee;
	C3DPoint  sub_ps, sub_pss, sub_pe, sub_pee, sub_pm;

	CDC	*pdc = gm->m_pMyView->GetDC();
	ulen = fabs(gm->m_pGPSCtrl->GetWorldLength(((double)pdc->GetDeviceCaps(LOGPIXELSX)) / 6.0));
	gm->m_pMyView->ReleaseDC(pdc);

	pe = node_i;

	double prv_j_val;
	double pst_i_val;
	for (i = 0; i < 4; i++)
	{
		dVal[0] = val_i = ReslD.dValue[i][0];
		dVal[1] = val_j = ReslD.dValue[i][1];
		if (i == 0)prv_j_val = val_i;
		else    prv_j_val = ReslD.dValue[i - 1][1];

		if (i == 3)pst_i_val = val_j;
		else    pst_i_val = ReslD.dValue[i + 1][0];

		ps = pe;
		CUtilFuncs::GetInnerLinePoint((double)(i + 1), 4.0 - ((double)(i + 1)), node_i, node_j, pe);

		double dFactor = 1.0;
		dFactor = m_dDgrmAdjustFactor * m_dPSCDgrmScFc;

		CUtilFuncs::GetVectorDirectionPoint(dDirVec, val_i, dFactor, ps, pss);
		CUtilFuncs::GetVectorDirectionPoint(dDirVec, val_j, dFactor, pe, pee);

		if (txt_pnt)
		{
			// Min/Max
			if (m_bBeamOutputMaxMin)
			{
				if (dVal[0] > dMaxVal) { txt_pnt[1] = pss; dMaxVal = dVal[0]; }
				if (dVal[1] > dMaxVal) { txt_pnt[1] = pee; dMaxVal = dVal[1]; }
				if (dVal[0] < dMinVal) { txt_pnt[0] = pss; dMinVal = dVal[0]; }
				if (dVal[1] < dMinVal) { txt_pnt[0] = pee; dMinVal = dVal[1]; }
			}
			// Abs Max
			else if (m_bBeamOutputMax)
			{
				if (fabs(dVal[0]) > fabs(dAbsMax)) { dAbsMax = dVal[0]; }
				if (fabs(dVal[1]) > fabs(dAbsMax)) { dAbsMax = dVal[1]; }
				switch (i)
				{
				case 0: txt_pnt[0] = pss; break;
				case 2: txt_pnt[1] = pss; break;
				case 3: txt_pnt[2] = pee; break;
				}
			}
			else
			{
				switch (i)
				{
				case 0: txt_pnt[0] = pss; break;
				case 2: txt_pnt[1] = pss; break;
				case 3: txt_pnt[2] = pee; break;
				}
			}
		}

		ldist = sqrt((pe.x - ps.x)*(pe.x - ps.x) +
			(pe.y - ps.y)*(pe.y - ps.y) +
			(pe.z - ps.z)*(pe.z - ps.z));
		sl_num = (int)(ldist / ulen);
		if (((double)sl_num)*ulen == ldist)sl_num--;
		if (sl_num == -1) continue;
		udist = ldist / ((double)(sl_num + 1));

		vdist = val_j - val_i;
		uval = vdist * udist / ldist;

		sub_jval = val_i;
		sub_pe = ps;
		sub_pee = pss;
		for (j = 0; j <= sl_num; j++)
		{
			sub_ival = sub_jval;
			sub_ps = sub_pe;
			sub_pss = sub_pee;
			if (j == sl_num)
			{
				sub_jval = val_j;
				sub_pe = pe;
				sub_pee = pee;
			}
			else
			{
				sub_jval = val_i + uval * (j + 1);
				CUtilFuncs::GetInnerLinePoint(fabs(udist*(j + 1)), fabs(fabs(ldist) - fabs(udist*(j + 1))), ps, pe, sub_pe);
				CUtilFuncs::GetInnerLinePoint(fabs(udist*(j + 1)), fabs(fabs(ldist) - fabs(udist*(j + 1))), pss, pee, sub_pee);
			}
			BOOL bIsStart = (i == 0 && j == 0) ? TRUE : FALSE;
			BOOL bIsEnd = (i == 3 && j == sl_num) ? TRUE : FALSE;

			/*
			BOOL bAnyFill = m_bDgrmVertLineFill; // No Fill Option일 경우만 FALSE이다.
			if(m_bDgrmLineOnly == FALSE && m_bDgrmVertLineFill == TRUE && gm->m_bGradient) bAnyFill = FALSE; // Gradient Fill시 외곽선을 없앤다.
			*/
			BOOL bAnyFill = (nFillType != 0); // No Fill Option일 경우만 FALSE이다.
			if (nFillType == 1 && gm->m_bGradient) bAnyFill = TRUE;

			if ((nKeyType == PSC_DSGN_CRIT_MAX_KEY ||
				nKeyType == PSC_DSGN_CRIT_MIN_KEY) &&
				(m_nPSCCirteriaType == 1 || m_nPSCCirteriaType == 3))
			{
				bAnyFill = FALSE; //무조건 빈것으로 함 
			}


			// x/4지점에서 값이 변하는 경우 Check
			BOOL bIsValModifySubStart = FALSE;
			BOOL bIsValModifySubEnd = FALSE;

			if (i != 0 && j == 0)
			{
				if (sub_ival*prv_j_val < 0)  bIsValModifySubStart = TRUE;
				else                        bIsValModifySubStart = FALSE;
			}
			if (i != 3 && j == sl_num)
			{
				if (sub_jval*pst_i_val < 0)  bIsValModifySubEnd = TRUE;
				else                        bIsValModifySubEnd = FALSE;
			}

			if ((sub_ival == 0) && (sub_jval == 0))
			{
				continue;
			}
			else if (sub_ival == 0)
			{
				ef_list.Add(TRUE);	vtx_list.Add(sub_ps);	val_list.Add(sub_ival);
				ef_list.Add(bAnyFill || bIsEnd);	vtx_list.Add(sub_pee);	val_list.Add(sub_jval);
				ef_list.Add(FALSE);	vtx_list.Add(sub_pe);	val_list.Add(sub_jval);
				rect_flag.Add(FALSE);
			}
			else if (sub_jval == 0)
			{
				ef_list.Add(bAnyFill || bIsStart);	vtx_list.Add(sub_ps);	val_list.Add(sub_ival);
				ef_list.Add(TRUE);	vtx_list.Add(sub_pss);	val_list.Add(sub_ival);
				ef_list.Add(FALSE);	vtx_list.Add(sub_pe);	val_list.Add(sub_jval);
				rect_flag.Add(FALSE);
			}
			else if ((sub_ival*sub_jval) < 0)
			{
				sub_mval = 0.0;
				CUtilFuncs::GetInnerLinePoint(fabs(sub_ival), fabs(sub_jval), sub_ps, sub_pe, sub_pm);
				ef_list.Add(bAnyFill || bIsStart);	vtx_list.Add(sub_ps);	val_list.Add(sub_ival);
				ef_list.Add(TRUE);	vtx_list.Add(sub_pss);	val_list.Add(sub_ival);
				ef_list.Add(FALSE);	vtx_list.Add(sub_pm);	val_list.Add(sub_mval);
				rect_flag.Add(FALSE);
				ef_list.Add(TRUE);	vtx_list.Add(sub_pm);	val_list.Add(sub_mval);
				ef_list.Add(bAnyFill || bIsEnd);	vtx_list.Add(sub_pee);	val_list.Add(sub_jval);
				ef_list.Add(FALSE);	vtx_list.Add(sub_pe);	val_list.Add(sub_jval);
				rect_flag.Add(FALSE);
			}
			else
			{
				ef_list.Add(bAnyFill || bIsStart || bIsValModifySubStart);	vtx_list.Add(sub_ps);	val_list.Add(sub_ival);
				ef_list.Add(TRUE);	vtx_list.Add(sub_pss);	val_list.Add(sub_ival);
				ef_list.Add(bAnyFill || bIsEnd || bIsValModifySubEnd);	    vtx_list.Add(sub_pee);	val_list.Add(sub_jval);
				ef_list.Add(FALSE);	vtx_list.Add(sub_pe);	val_list.Add(sub_jval);
				rect_flag.Add(TRUE);
			}
		}
	}

	if (pMnMxVal)
	{
		if (m_bBeamOutputMaxMin)// Min,Max
		{
			pMnMxVal[0] = dMinVal;
			pMnMxVal[1] = dMaxVal;
		}
		if (m_bBeamOutputMax) // Abs Max
		{
			pMnMxVal[0] = 0.0;
			pMnMxVal[1] = dAbsMax;
		}
	}
}

void CDesignEngine::DiagramPolygon4RC(UINT nKeyType, T_PSC_DSGN_RESL_D &ReslD, double dDirVec[3],
	C3DPoint &node_i, C3DPoint &node_j,
	CArray<C3DPoint, C3DPoint &> &vtx_list,
	CArray<double, double &> &val_list,
	CArray<BOOL, BOOL> &ef_list,
	CArray<BOOL, BOOL> &rect_flag,
	C3DPoint *txt_pnt, T_ELEM_K ElemKey, int nFillType, double *pMnMxVal)
{
	if (pMnMxVal) { pMnMxVal[0] = 0;  pMnMxVal[1] = 0; }

	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;

	int			j, sl_num;
	double	val_i, val_j;
	double  dVal[2];
	double  ulen, udist, uval, ldist, vdist;
	double  sub_ival, sub_jval, sub_mval;
	double  dMaxVal = -DBL_MAX, dMinVal = DBL_MAX;
	double  dAbsMax = 0;

	C3DPoint	ps, pss, pe, pee;
	C3DPoint  sub_ps, sub_pss, sub_pe, sub_pee, sub_pm;

	CDC	*pdc = gm->m_pMyView->GetDC();
	ulen = fabs(gm->m_pGPSCtrl->GetWorldLength(((double)pdc->GetDeviceCaps(LOGPIXELSX)) / 6.0));
	gm->m_pMyView->ReleaseDC(pdc);

	pe = node_i;

	double prv_j_val;
	double pst_i_val;
	double dSectRatio = fabs(ReslD.dSectRatio) * 4;
	BOOL bSectBefore = TRUE;
	int i = -1;

	for (int k = 0; k < 5; k++)
	{
		++i;
		if (dSectRatio == 0)
		{
			if (k == 4) continue;

			if (ReslD.bSignPositive)
			{
				dVal[0] = val_i = ReslD.dValue[i][0];
				dVal[1] = val_j = ReslD.dValue[i][1];
			}
			else
			{
				dVal[0] = val_i = (-1)*ReslD.dValue[i][0];
				dVal[1] = val_j = (-1)*ReslD.dValue[i][1];
			}

			prv_j_val = val_i;
			pst_i_val = val_j;
			ps = pe;
			CUtilFuncs::GetInnerLinePoint((double)(i + 1), 4.0 - ((double)(i + 1)), node_i, node_j, pe);
		}
		else if (dSectRatio > i && dSectRatio < i + 1)
		{
			if (bSectBefore)
			{
				if (ReslD.dSectRatio > 0)
				{
					dVal[0] = val_i = ReslD.dValue[i][0];
					dVal[1] = val_j = ReslD.dValue[i][0] * (1 + i - dSectRatio) + ReslD.dValue[i][1] * (dSectRatio - i);
				}
				else
				{
					dVal[0] = val_i = (-1)*(ReslD.dValue[i][0]);
					dVal[1] = val_j = (-1)*(ReslD.dValue[i][0] * (1 + i - dSectRatio) + ReslD.dValue[i][1] * (dSectRatio - i));
				}

				prv_j_val = val_i;
				pst_i_val = (-1)*val_j;
				ps = pe;
				CUtilFuncs::GetInnerLinePoint(dSectRatio, 4.0 - dSectRatio, node_i, node_j, pe);
				bSectBefore = FALSE;
				--i;
			}
			else
			{
				if (ReslD.dSectRatio > 0)
				{
					dVal[0] = val_i = (-1)*(ReslD.dValue[i][0] * (1 + i - dSectRatio) + ReslD.dValue[i][1] * (dSectRatio - i));
					dVal[1] = val_j = (-1)*(ReslD.dValue[i][1]);
				}
				else
				{
					dVal[0] = val_i = ReslD.dValue[i][0] * (1 + i - dSectRatio) + ReslD.dValue[i][1] * (dSectRatio - i);
					dVal[1] = val_j = ReslD.dValue[i][1];
				}

				prv_j_val = (-1)*val_i;
				pst_i_val = val_j;
				ps = pe;
				CUtilFuncs::GetInnerLinePoint(dSectRatio, 4.0 - dSectRatio, node_i, node_j, pe);
			}
		}
		else if (dSectRatio > i + 1)
		{
			if (ReslD.dSectRatio > 0)
			{
				dVal[0] = val_i = ReslD.dValue[i][0];
				dVal[1] = val_j = ReslD.dValue[i][1];
			}
			else
			{
				dVal[0] = val_i = (-1)*ReslD.dValue[i][0];
				dVal[1] = val_j = (-1)*ReslD.dValue[i][1];
			}

			prv_j_val = val_i;
			pst_i_val = val_j;
			ps = pe;
			CUtilFuncs::GetInnerLinePoint((double)(i + 1), 4.0 - ((double)(i + 1)), node_i, node_j, pe);
		}
		else if (dSectRatio < i)
		{
			if (ReslD.dSectRatio > 0)
			{
				dVal[0] = val_i = (-1)*ReslD.dValue[i][0];
				dVal[1] = val_j = (-1)*ReslD.dValue[i][1];
			}
			else
			{
				dVal[0] = val_i = ReslD.dValue[i][0];
				dVal[1] = val_j = ReslD.dValue[i][1];
			}

			prv_j_val = val_i;
			pst_i_val = val_j;
			ps = pe;
			CUtilFuncs::GetInnerLinePoint((double)(i + 1), 4.0 - ((double)(i + 1)), node_i, node_j, pe);
		}

		double dFactor = 1.0;
		dFactor = m_dDgrmAdjustFactor * m_dPSCDgrmScFc;

		CUtilFuncs::GetVectorDirectionPoint(dDirVec, val_i, dFactor, ps, pss);
		CUtilFuncs::GetVectorDirectionPoint(dDirVec, val_j, dFactor, pe, pee);

		if (txt_pnt)
		{
			// Min/Max
			if (m_bBeamOutputMaxMin)
			{
				if (dVal[0] > dMaxVal) { txt_pnt[1] = pss; dMaxVal = dVal[0]; }
				if (dVal[1] > dMaxVal) { txt_pnt[1] = pee; dMaxVal = dVal[1]; }
				if (dVal[0] < dMinVal) { txt_pnt[0] = pss; dMinVal = dVal[0]; }
				if (dVal[1] < dMinVal) { txt_pnt[0] = pee; dMinVal = dVal[1]; }
			}
			// Abs Max
			else if (m_bBeamOutputMax)
			{
				if (fabs(dVal[0]) > fabs(dAbsMax)) { dAbsMax = dVal[0]; }
				if (fabs(dVal[1]) > fabs(dAbsMax)) { dAbsMax = dVal[1]; }
				switch (k)
				{
				case 0: txt_pnt[0] = pss; break;
				case 2: txt_pnt[1] = pss; break;
				case 3: txt_pnt[2] = pee; break;
				}
			}
			else
			{
				switch (k)
				{
				case 0: txt_pnt[0] = pss; break;
				case 2: txt_pnt[1] = pss; break;
				case 3: txt_pnt[2] = pee; break;
				}
			}
		}

		ldist = sqrt((pe.x - ps.x)*(pe.x - ps.x) + (pe.y - ps.y)*(pe.y - ps.y) + (pe.z - ps.z)*(pe.z - ps.z));
		sl_num = (int)(ldist / ulen);
		if (((double)sl_num)*ulen == ldist)sl_num--;
		if (sl_num == -1) continue;
		udist = ldist / ((double)(sl_num + 1));

		vdist = val_j - val_i;
		uval = vdist * udist / ldist;

		sub_jval = val_i;
		sub_pe = ps;
		sub_pee = pss;
		for (j = 0; j <= sl_num; j++)
		{
			sub_ival = sub_jval;
			sub_ps = sub_pe;
			sub_pss = sub_pee;
			if (j == sl_num)
			{
				sub_jval = val_j;
				sub_pe = pe;
				sub_pee = pee;
			}
			else
			{
				sub_jval = val_i + uval * (j + 1);
				CUtilFuncs::GetInnerLinePoint(fabs(udist*(j + 1)), fabs(fabs(ldist) - fabs(udist*(j + 1))), ps, pe, sub_pe);
				CUtilFuncs::GetInnerLinePoint(fabs(udist*(j + 1)), fabs(fabs(ldist) - fabs(udist*(j + 1))), pss, pee, sub_pee);
			}
			BOOL bIsStart = (k == 0 && j == 0) ? TRUE : FALSE;
			BOOL bIsEnd = (i == 3 && j == sl_num) ? TRUE : FALSE;
			BOOL bAnyFill = (nFillType != 0); // No Fill Option일 경우만 FALSE이다.
			if (nFillType == 1 && gm->m_bGradient) bAnyFill = TRUE;

			if ((nKeyType == PSC_DSGN_CRIT_MAX_KEY ||
				nKeyType == PSC_DSGN_CRIT_MIN_KEY) &&
				(m_nPSCCirteriaType == 1 || m_nPSCCirteriaType == 3))
			{
				bAnyFill = FALSE; //무조건 빈것으로 함 
			}

			// x/4지점에서 값이 변하는 경우 Check
			BOOL bIsValModifySubStart = FALSE;
			BOOL bIsValModifySubEnd = FALSE;

			if (k != 0 && j == 0)
			{
				if (sub_ival*prv_j_val < 0)  bIsValModifySubStart = TRUE;
				else                        bIsValModifySubStart = FALSE;
			}
			if (i != 3 && j == sl_num)
			{
				if (sub_jval*pst_i_val < 0)  bIsValModifySubEnd = TRUE;
				else                        bIsValModifySubEnd = FALSE;
			}

			if ((sub_ival == 0) && (sub_jval == 0))
			{
				continue;
			}
			else if (sub_ival == 0)
			{
				ef_list.Add(TRUE);	vtx_list.Add(sub_ps);	val_list.Add(sub_ival);
				ef_list.Add(bAnyFill || bIsEnd);	vtx_list.Add(sub_pee);	val_list.Add(sub_jval);
				ef_list.Add(FALSE);	vtx_list.Add(sub_pe);	val_list.Add(sub_jval);
				rect_flag.Add(FALSE);
			}
			else if (sub_jval == 0)
			{
				ef_list.Add(bAnyFill || bIsStart);	vtx_list.Add(sub_ps);	val_list.Add(sub_ival);
				ef_list.Add(TRUE);	vtx_list.Add(sub_pss);	val_list.Add(sub_ival);
				ef_list.Add(FALSE);	vtx_list.Add(sub_pe);	val_list.Add(sub_jval);
				rect_flag.Add(FALSE);
			}
			else if ((sub_ival*sub_jval) < 0)
			{
				sub_mval = 0.0;
				CUtilFuncs::GetInnerLinePoint(fabs(sub_ival), fabs(sub_jval), sub_ps, sub_pe, sub_pm);
				ef_list.Add(bAnyFill || bIsStart);	vtx_list.Add(sub_ps);	val_list.Add(sub_ival);
				ef_list.Add(TRUE);	vtx_list.Add(sub_pss);	val_list.Add(sub_ival);
				ef_list.Add(FALSE);	vtx_list.Add(sub_pm);	val_list.Add(sub_mval);
				rect_flag.Add(FALSE);
				ef_list.Add(TRUE);	vtx_list.Add(sub_pm);	val_list.Add(sub_mval);
				ef_list.Add(bAnyFill || bIsEnd);	vtx_list.Add(sub_pee);	val_list.Add(sub_jval);
				ef_list.Add(FALSE);	vtx_list.Add(sub_pe);	val_list.Add(sub_jval);
				rect_flag.Add(FALSE);
			}
			else
			{
				ef_list.Add(bAnyFill || bIsStart || bIsValModifySubStart);	vtx_list.Add(sub_ps);	val_list.Add(sub_ival);
				ef_list.Add(TRUE);	vtx_list.Add(sub_pss);	val_list.Add(sub_ival);
				ef_list.Add(bAnyFill || bIsEnd || bIsValModifySubEnd);	    vtx_list.Add(sub_pee);	val_list.Add(sub_jval);
				ef_list.Add(FALSE);	vtx_list.Add(sub_pe);	val_list.Add(sub_jval);
				rect_flag.Add(TRUE);
			}
		}
	}

	if (pMnMxVal)
	{
		if (m_bBeamOutputMaxMin)// Min,Max
		{
			pMnMxVal[0] = dMinVal;
			pMnMxVal[1] = dMaxVal;
		}
		if (m_bBeamOutputMax) // Abs Max
		{
			pMnMxVal[0] = 0.0;
			pMnMxVal[1] = dAbsMax;
		}
	}
}

void  CDesignEngine::GetDgrmOutputData(T_ELEM_K ElemK, C3DPoint *pTxtPt,
	double *pMnMxVal, T_PSC_DSGN_VALS_D &OutVal)
{
	OutVal.Pos[0] = pTxtPt[0];
	OutVal.Pos[1] = pTxtPt[1];
	OutVal.Pos[2] = pTxtPt[2];
	OutVal.Pos[3] = pTxtPt[3];
	OutVal.ElemK = ElemK;
	OutVal.dMinMaxVal[0] = pMnMxVal[0];
	OutVal.dMinMaxVal[1] = pMnMxVal[1];
}

void CDesignEngine::DoDgrmContour(CDC *pDC,
	CArray <C3DPoint, C3DPoint &> &vtx_list,
	CArray <double, double &> &val_list,
	CArray <BOOL, BOOL> &ef_list,
	CArray <BOOL, BOOL> &rect_flag)
{
	I_GPSModel					*gm = (I_GPSModel *)m_pGPSModel;
	int							i, j, k, l, m, poly_num = rect_flag.GetSize();
	C3DPoint					vtx_array[4];
	double						val_array[4];
	BOOL						ef_array[4];
	CArray <int, int>			vnum_list;
	CArray <VtxInfo, VtxInfo>	vinfo_list;

	k = 0;
	l = 0;
	m = 0;

	//BOOL m_bDgrmVertLineFill = TRUE; 

	if (m_nFillType == 0)m_bDgrmVertLineFill = FALSE;

	for (i = 0; i < poly_num; i++)
	{
		if (rect_flag[i])
		{
			for (j = 0; j < 4; j++)
			{
				val_array[j] = val_list[k++];
				vtx_array[j] = vtx_list[l++];
				ef_array[j] = ef_list[m++];
			}
			m_pContourEngine->SfdBmdFramePoly(vtx_array, val_array, ef_array, 4, vnum_list, vinfo_list, m_bDgrmVertLineFill);
		}
		else
		{
			for (j = 0; j < 3; j++)
			{
				val_array[j] = val_list[k++];
				vtx_array[j] = vtx_list[l++];
				ef_array[j] = ef_list[m++];
			}
			m_pContourEngine->SfdBmdFramePoly(vtx_array, val_array, ef_array, 3, vnum_list, vinfo_list, m_bDgrmVertLineFill);
		}
	}

	if (gm->m_bGradient)
	{
		DrawContourListGrad(pDC, vnum_list, vinfo_list);
	}
	else
	{
		DrawContourList(pDC, vnum_list, vinfo_list);
	}

	vnum_list.RemoveAll();
	vinfo_list.RemoveAll();
}



void CDesignEngine::DrawContourList(CDC *pDC, CArray <int, int> &vnum_list, CArray <VtxInfo, VtxInfo> &vtx_list)
{
	DECLARE_GPSMD();

	// SFD/BMD용 DrawContourList
	int		i, j, k, poly_num = vnum_list.GetSize();
	BOOL	is_bsfdbmd = FALSE;
	CPen	edge_pen, *old_pen, *old_pen2;
	CClientDC	 ClientDC(((I_GPSModel*)m_pGPSModel)->m_pMyView);
	CList<C3DPoint, C3DPoint>	vlist;

	if (!m_pContourEngine)return;

	if ((gm->m_GPSMode == GPS_COMMAND_STEEL_RATING || gm->m_GPSMode == GPS_COMMAND_PSC_RATING || gm->m_GPSMode == GPS_COMMAND_RC_RATING) && GetSteelRatingDrawType() == 1)
	{
		ASSERT(0);
	}

	if (gm->m_GPSInstruction == GPS_COMMAND_PSC_DSGN_DGRM || gm->m_GPSInstruction == GPS_COMMAND_BRDG_LOAD_DGRM ||
		((gm->m_GPSInstruction == GPS_COMMAND_STEEL_RATING || gm->m_GPSInstruction == GPS_COMMAND_PSC_RATING || gm->m_GPSInstruction == GPS_COMMAND_RC_RATING) && GetSteelRatingDrawType() == 0) ||
		gm->m_GPSInstruction == GPS_COMMAND_STEEL_AASHTO_RATING || gm->m_GPSInstruction == GPS_COMMAND_RC_DSGN_DGRM ||
		gm->m_GPSInstruction == GPS_COMMAND_RAIL_PSC_DSGN_DGRM || gm->m_GPSInstruction == GPS_COMMAND_RAIL_RC_DSGN_DGRM ||
		gm->m_GPSInstruction == GPS_COMMAND_STEEL_DSGN_DGRM || gm->m_GPSInstruction == GPS_COMMAND_SHEAR_CONN_FORCE ||
		gm->m_GPSInstruction == GPS_COMMAND_CPG_RUS_DESING_RESULT || gm->m_GPSInstruction == GPS_COMMAND_SOD_Design ||
		gm->m_GPSInstruction == GPS_COMMAND_DSGNST_LSD || gm->m_GPSInstruction == GPS_COMMAND_STEEL_COMP_DSGN_DGRM)
		is_bsfdbmd = TRUE;

	if (!is_bsfdbmd || !(is_bsfdbmd && m_bDgrmLineOnly))
	{
		if ((is_bsfdbmd) && !gm->m_bContour)
			DrawSFDBMDContourList_mono(pDC, vnum_list, vtx_list);
		else
			CEngineBase::DrawContourList(pDC, vnum_list, vtx_list);
	}
	else
	{
		k = 0;
		for (i = 0; i < poly_num; i++)
		{
			if ((gm->m_DOPT.m_PrintMode == 0) && pDC->IsPrinting()) // B&W Mode
				edge_pen.CreatePen(PS_SOLID, gm->m_nLineWidth, RGB(60, 60, 60));
			else if (!gm->m_bContour)
				edge_pen.CreatePen(PS_SOLID, gm->m_nLineWidth, gm->m_DOPT.CL.m_BeamDiagramColor);
			else // Color Mode
				edge_pen.CreatePen(PS_SOLID, gm->m_nLineWidth, m_pContourEngine->GetValueColor(vtx_list[k].val));

			old_pen = (CPen *)pDC->SelectObject(&edge_pen);
			if (!gm->m_bVirtualMode && !gm->m_bAnimation)
				old_pen2 = (CPen *)ClientDC.SelectObject(&edge_pen);

			for (j = 0; j < vnum_list[i]; j++)
			{
				if (vtx_list[k + j].ef)
				{
					if (gm->m_bVirtualMode)
						gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, vtx_list[k + (j%vnum_list[i])].vtx, vtx_list[k + ((j + 1) % vnum_list[i])].vtx);
					else
					{
						if (!gm->m_bAnimation)
							gm->m_pGPSCtrl->DrawLine3DOnClientWindow(&ClientDC, vtx_list[k + (j%vnum_list[i])].vtx, vtx_list[k + ((j + 1) % vnum_list[i])].vtx);
						gm->m_pGPSCtrl->DrawLine3D(pDC, vtx_list[k + (j%vnum_list[i])].vtx, vtx_list[k + ((j + 1) % vnum_list[i])].vtx);
					}
				}
			}
			k += vnum_list[i];
			pDC->SelectObject(old_pen);
			if (!gm->m_bVirtualMode && !gm->m_bAnimation)
				ClientDC.SelectObject(old_pen2);
			edge_pen.DeleteObject();
		}
	}
}

void CDesignEngine::DrawContourListGrad(CDC *pDC, CArray <int, int> &vnum_list, CArray <VtxInfo, VtxInfo> &vtx_list)
{
	int							i, j, k = 0, poly_num = vnum_list.GetSize();
	I_GPSModel					*gm = (I_GPSModel *)m_pGPSModel;
	BOOL						is_bsfdbmd = FALSE, is_wsfdbmd = FALSE, is_esfdbmd = FALSE, is_thsfdbmd = FALSE;
	CPoint						p1, p2;
	CPen						edge_pen, *old_pen, *old_pen2;
	CClientDC		ClientDC(((I_GPSModel*)m_pGPSModel)->m_pMyView);

	CArray<CPoint, CPoint &>		vtx_output;
	CArray<C3DPoint, C3DPoint &>vtx_input;
	CArray<COLORREF, COLORREF &>col_input, col_output;

	if ((gm->m_GPSMode == GPS_COMMAND_STEEL_RATING || gm->m_GPSMode == GPS_COMMAND_PSC_RATING || gm->m_GPSMode == GPS_COMMAND_RC_RATING) && GetSteelRatingDrawType() == 1)
	{
		ASSERT(0);
	}

	if (m_pContourEngine == NULL)return;
	if (gm->m_GPSInstruction == GPS_COMMAND_PSC_DSGN_DGRM ||
		gm->m_GPSInstruction == GPS_COMMAND_BRDG_LOAD_DGRM ||
		((gm->m_GPSInstruction == GPS_COMMAND_STEEL_RATING || gm->m_GPSInstruction == GPS_COMMAND_PSC_RATING || gm->m_GPSInstruction == GPS_COMMAND_RC_RATING) && GetSteelRatingDrawType() == 0) ||
		gm->m_GPSInstruction == GPS_COMMAND_STEEL_AASHTO_RATING || gm->m_GPSInstruction == GPS_COMMAND_RC_DSGN_DGRM ||
		gm->m_GPSInstruction == GPS_COMMAND_RAIL_PSC_DSGN_DGRM || gm->m_GPSInstruction == GPS_COMMAND_RAIL_RC_DSGN_DGRM ||
		gm->m_GPSInstruction == GPS_COMMAND_STEEL_DSGN_DGRM || gm->m_GPSInstruction == GPS_COMMAND_SHEAR_CONN_FORCE ||
		gm->m_GPSInstruction == GPS_COMMAND_CPG_RUS_DESING_RESULT || gm->m_GPSInstruction == GPS_COMMAND_SOD_Design ||
		gm->m_GPSInstruction == GPS_COMMAND_DSGNST_LSD || gm->m_GPSInstruction == GPS_COMMAND_STEEL_COMP_DSGN_DGRM)
		is_bsfdbmd = TRUE;


	if (!(is_bsfdbmd) || !(is_bsfdbmd && m_bDgrmLineOnly))
	{
		if ((is_bsfdbmd) && !gm->m_bContour)
			DrawSFDBMDContourList_mono(pDC, vnum_list, vtx_list);
		else
			CEngineBase::DrawContourListGrad(pDC, vnum_list, vtx_list);
	}
	else
	{
		k = 0;
		for (i = 0; i < poly_num; i++)
		{
			if ((gm->m_DOPT.m_PrintMode == 0) && pDC->IsPrinting()) // B&W Mode
				edge_pen.CreatePen(PS_SOLID, gm->m_nLineWidth, RGB(60, 60, 60));
			else if (!gm->m_bContour)
				edge_pen.CreatePen(PS_SOLID, gm->m_nLineWidth, gm->m_DOPT.CL.m_BeamDiagramColor);
			else // Color Mode
				edge_pen.CreatePen(PS_SOLID, gm->m_nLineWidth, m_pContourEngine->GetValueColor(vtx_list[k].val));

			old_pen = (CPen *)pDC->SelectObject(&edge_pen);
			if (!gm->m_bVirtualMode && !gm->m_bAnimation)
				old_pen2 = (CPen *)ClientDC.SelectObject(&edge_pen);


			for (j = 0; j < vnum_list[i]; j++) {
				if (vtx_list[k + j].ef) {
					if (gm->m_bVirtualMode) {
						gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, vtx_list[k + (j%vnum_list[i])].vtx, vtx_list[k + ((j + 1) % vnum_list[i])].vtx);
					}
					else {
						if (!gm->m_bAnimation)
							gm->m_pGPSCtrl->DrawLine3DOnClientWindow(&ClientDC, vtx_list[k + (j%vnum_list[i])].vtx, vtx_list[k + ((j + 1) % vnum_list[i])].vtx);
						gm->m_pGPSCtrl->DrawLine3D(pDC, vtx_list[k + (j%vnum_list[i])].vtx, vtx_list[k + ((j + 1) % vnum_list[i])].vtx);
					}
				}
			}
			k += vnum_list[i];
			pDC->SelectObject(old_pen);
			if (!gm->m_bVirtualMode && !gm->m_bAnimation)
				ClientDC.SelectObject(old_pen2);

			edge_pen.DeleteObject();
		}
	}

}

void CDesignEngine::DrawSFDBMDContourList_mono(CDC *pDC, CArray <int, int> &vnum_list, CArray <VtxInfo, VtxInfo> &vtx_list)
{
	int							i, j, k, poly_num = vnum_list.GetSize();
	I_GPSModel					*gm = (I_GPSModel *)m_pGPSModel;
	CList <C3DPoint, C3DPoint>	vlist;

	CClientDC		ClientDC(((I_GPSModel*)m_pGPSModel)->m_pMyView);

	if (m_pContourEngine == NULL) {
		return;
	}

	k = 0;

	for (i = 0; i < poly_num; i++) {
		for (j = 0; j < vnum_list[i]; j++) {
			vlist.AddTail(vtx_list[k + j].vtx);
		}

		//COLORREF color =gm->m_BeamDiagramColor;
		COLORREF color = gm->m_DOPT.CL.m_BeamDiagramColor;

		if (gm->m_bVirtualMode)
			gm->m_pGPSCtrl->DrawPolygon3DFillOnClientWindow(pDC, vlist, color);
		else
		{
			if (!gm->m_bAnimation)
				gm->m_pGPSCtrl->DrawPolygon3DFillOnClientWindow(&ClientDC, vlist, color);
			gm->m_pGPSCtrl->DrawPolygon3DFill(pDC, vlist, color);
		}
		vlist.RemoveAll();
		k += vnum_list[i];
	}

}



void CDesignEngine::OutputDgrmNumber(CDC *pDC, T_PSC_DSGN_RESL_D &ReslD, T_PSC_DSGN_VALS_D &OutVal, BOOL bDeformed)
{
	DECLARE_GPSMD();
	DECLARE_DPTTX();
	DECLARE_DPTDR();

	int			  j, slope;
	TCHAR			fmt_str[10];
	BOOL			fl_bak, is_inverse;
	C3DPoint	node3D_i, node3D_j, DrawPoint;
	CPoint		text_p, node_2d_i, node_2d_j;
	CFont			ft, *old_ft;
	T_ELEM_D	edata;

	// Bridge Load Rating 의 경우는 해석 결과가 없으면 출력을 안해야 하므로 결과가 있는지 체크한다
	T_ISBRDG_D bBrdgData;
	bBrdgData.Initialize();
	BOOL	bBrdgDataMin = TRUE, bBrdgDataMax = TRUE, bBrdgLoadLate = FALSE;

	if ((gm->m_GPSMode == GPS_COMMAND_STEEL_RATING || gm->m_GPSMode == GPS_COMMAND_PSC_RATING || gm->m_GPSMode == GPS_COMMAND_RC_RATING) && GetSteelRatingDrawType() == 1)
	{
		ASSERT(0);
	}

	if (gm->m_GPSMode == GPS_COMMAND_BRDG_LOAD_DGRM || gm->m_GPSMode == GPS_COMMAND_STEEL_AASHTO_RATING || ((gm->m_GPSMode == GPS_COMMAND_STEEL_RATING || gm->m_GPSMode == GPS_COMMAND_PSC_RATING) && GetSteelRatingDrawType() == 0))
	{
		bBrdgLoadLate = TRUE;
		if (!HaveBrdgData(OutVal.ElemK, bBrdgData)) ASSERT(0);
		if (!bBrdgData.bBrdgDataI)
		{
			if (ReslD.dValue[0][0] < ReslD.dValue[3][1])	bBrdgDataMin = FALSE;
			else if (ReslD.dValue[0][0] > ReslD.dValue[3][1])	bBrdgDataMax = FALSE;
		}
		if (!bBrdgData.bBrdgDataJ)
		{
			if (ReslD.dValue[0][0] > ReslD.dValue[3][1])	bBrdgDataMin = FALSE;
			else if (ReslD.dValue[0][0] < ReslD.dValue[3][1])	bBrdgDataMax = FALSE;
		}
		if ((!bBrdgData.bBrdgDataI) && (!bBrdgData.bBrdgDataJ))
		{
			bBrdgDataMin = FALSE;
			bBrdgDataMax = FALSE;
		}
	}


	POSITION	pos;
	CArray<GPS_3DPT_LISTP, GPS_3DPT_LISTP>  polygon_list;
	CArray<GPS_BOOL_ARRYP, GPS_BOOL_ARRYP>	edge_list;

	if (pTX->m_bNumberOpaque)pDC->SetBkMode(OPAQUE);
	else		                pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(pTX->m_NumberTextColorC);
	pDC->SetBkColor(pTX->m_NumberBackCol);
	pDC->SetTextAlign(TA_CENTER | TA_BOTTOM);

	if (pTX->m_bNumberExponent)_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else		                  _stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);

	if (!gm->m_pGPSCtrl->IsActiveElem(OutVal.ElemK))
		return; // Lable Hidden 처리를 위해 추가 

	m_pDoc->m_pAttrCtrl->GetElem(OutVal.ElemK, edata);
	if (!m_pDoc->m_pAttrCtrl->IsBeam(edata.eltyp) &&
		!m_pDoc->m_pAttrCtrl->IsTruss(edata.eltyp))return;

	fl_bak = pDR->m_bFrameLine;
	gm->m_DOPT.DR.m_bFrameLine = TRUE;

	//if(bDeformed)
	//gm->m_pDeformEngine->GetDeformedShapeElement(OutVal.ElemK, &polygon_list, &edge_list);
	//else
	gm->GetShapeElement(OutVal.ElemK, polygon_list, &edge_list);

	CRect	rct;
	gm->m_pMyView->GetClientRect(&rct);

	pos = polygon_list[0]->GetHeadPosition();
	node3D_i = polygon_list[0]->GetNext(pos);
	node3D_j = polygon_list[0]->GetNext(pos);

	//XGLRenderer
	BOOL bSaveTextOutput = FALSE;
	if (gm->m_pGPSCtrl->IsGLRenderer() && gm->m_pGPSCtrl->IsXGRMode())
	{
		bSaveTextOutput = TRUE;
	}

	if (gm->m_bVirtualMode)
	{
		node_2d_i = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_i);
		node_2d_j = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_j);
	}
	else
	{
		node_2d_i = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_i);
		node_2d_j = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_j);
	}

	//XGLRenderer 
	if (bSaveTextOutput == FALSE) //저장 모드에서는 현재 화면 상태와 관계된 Filtering처리를 하지 않는다. 
	{
		if (node_2d_i.x < 0 || node_2d_i.y < 0) return;
		if (node_2d_j.x < 0 || node_2d_j.y < 0) return;
	}

	slope = (int)(atan2(node_2d_i.y - node_2d_j.y, node_2d_j.x - node_2d_i.x)*1800.0 / 3.14159);
	slope = (slope + 3600) % 3600;
	if ((900 < slope) && (slope <= 2700))
	{
		slope = (slope + 1800) % 3600;
		is_inverse = TRUE;
	}
	else
	{
		is_inverse = FALSE;
	}

	gm->SetNumberFontOrientation(slope);
	ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
	old_ft = (CFont *)pDC->SelectObject(&ft);

	if (pTX->m_bOutputMinMaxValueOnly)
	{
		double dLimit = (m_dMaxDgrmVal - m_dMinDgrmVal) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;
		double dBValue;

		for (int n = 0; n < 3; n++)
		{
			if (m_bBeamOutputMaxMin) //m_bBStrsOutputMinMax)
			{
				// Min
				if (n == 0)
				{
					pDC->SetTextAlign(TA_CENTER | TA_TOP);
					DrawPoint = OutVal.Pos[0];
					dBValue = OutVal.dMinMaxVal[0];
				}
				// Max
				else if (n == 1)
				{
					pDC->SetTextAlign(TA_CENTER | TA_BOTTOM);
					DrawPoint = OutVal.Pos[1];
					dBValue = OutVal.dMinMaxVal[1];
				}
				else continue;
			}
			// Abs Max
			else if (m_bBeamOutputMax)
			{
				if (n == 0)
				{
					DrawPoint = OutVal.Pos[1];
					dBValue = OutVal.dMinMaxVal[1];
				}
				else continue;
			}
			else if (n == 0) // I단 
			{
				if (!m_bBeamOutputI) continue;

				if (is_inverse) pDC->SetTextAlign(TA_RIGHT | TA_BOTTOM);
				else					 pDC->SetTextAlign(TA_LEFT | TA_BOTTOM);
				DrawPoint = OutVal.Pos[0];
				//dBValue = CalcBStrsValue(StrbD, 0, I_NODE);
				//dBValue = this->CalcBStrsValue(StrbD, 0);
				dBValue = ReslD.dValue[0][0];

			}
			else if (n == 1)// CNT 
			{
				if (!m_bBeamOutputC) continue;

				pDC->SetTextAlign(TA_CENTER | TA_BOTTOM);
				DrawPoint = OutVal.Pos[1];
				dBValue = ReslD.dValue[1][1];
			}
			else if (n == 2)// J단 
			{
				if (!m_bBeamOutputJ) continue;

				if (is_inverse)pDC->SetTextAlign(TA_LEFT | TA_BOTTOM);
				else					pDC->SetTextAlign(TA_RIGHT | TA_BOTTOM);
				DrawPoint = OutVal.Pos[2];
				dBValue = ReslD.dValue[3][1];
			}

			switch (gm->m_DOPT.TX.m_nOutputMinMaxType)
			{
			case 0: // Min & Max
				if (bSaveTextOutput)
				{
					double Pos6[6];
					Pos6[0] = node3D_i.x; Pos6[1] = node3D_i.y; Pos6[2] = node3D_i.z;
					Pos6[3] = node3D_j.x; Pos6[4] = node3D_j.y; Pos6[5] = node3D_j.z;
					if ((m_dMaxDgrmVal - dBValue) <= dLimit)
						gm->m_pXGR_GPSDrawMgr->m_OutputDgrmNumber.Add_OutputDgrmNumber(&(DrawPoint.x), Pos6, 0, dBValue, pTX->m_bSpecifiedAngle, (int)pTX->m_nValueAngle, pTX->m_bNumberExponent, gm->m_NumberDecimalPoint);
					else if ((dBValue - m_dMinDgrmVal) <= dLimit)
						gm->m_pXGR_GPSDrawMgr->m_OutputDgrmNumber.Add_OutputDgrmNumber(&(DrawPoint.x), Pos6, 1, dBValue, pTX->m_bSpecifiedAngle, (int)pTX->m_nValueAngle, pTX->m_bNumberExponent, gm->m_NumberDecimalPoint);
				}
				break;
			case 1: // Abs Max
				if (bSaveTextOutput)
				{
					double Pos6[6];
					Pos6[0] = node3D_i.x; Pos6[1] = node3D_i.y; Pos6[2] = node3D_i.z;
					Pos6[3] = node3D_j.x; Pos6[4] = node3D_j.y; Pos6[5] = node3D_j.z;

					if (fabs(m_dMaxDgrmVal) >= fabs(m_dMinDgrmVal))
					{
						if (fabs(m_dMaxDgrmVal) - fabs(dBValue) <= dLimit)
							gm->m_pXGR_GPSDrawMgr->m_OutputDgrmNumber.Add_OutputDgrmNumber(&(DrawPoint.x), Pos6, 2, dBValue, pTX->m_bSpecifiedAngle, (int)pTX->m_nValueAngle, pTX->m_bNumberExponent, gm->m_NumberDecimalPoint);
					}
					else
					{
						if (fabs(m_dMinDgrmVal) - fabs(dBValue) <= dLimit)
							gm->m_pXGR_GPSDrawMgr->m_OutputDgrmNumber.Add_OutputDgrmNumber(&(DrawPoint.x), Pos6, 2, dBValue, pTX->m_bSpecifiedAngle, (int)pTX->m_nValueAngle, pTX->m_bNumberExponent, gm->m_NumberDecimalPoint);
					}
				}
				break;
			case 2: // Max
				if (bSaveTextOutput)
				{
					double Pos6[6];
					Pos6[0] = node3D_i.x; Pos6[1] = node3D_i.y; Pos6[2] = node3D_i.z;
					Pos6[3] = node3D_j.x; Pos6[4] = node3D_j.y; Pos6[5] = node3D_j.z;
					if ((m_dMaxDgrmVal - dBValue) <= dLimit)
						gm->m_pXGR_GPSDrawMgr->m_OutputDgrmNumber.Add_OutputDgrmNumber(&(DrawPoint.x), Pos6, 0, dBValue, pTX->m_bSpecifiedAngle, (int)pTX->m_nValueAngle, pTX->m_bNumberExponent, gm->m_NumberDecimalPoint);
				}
				break;
			case 3: // Min
				if (bSaveTextOutput)
				{
					double Pos6[6];
					Pos6[0] = node3D_i.x; Pos6[1] = node3D_i.y; Pos6[2] = node3D_i.z;
					Pos6[3] = node3D_j.x; Pos6[4] = node3D_j.y; Pos6[5] = node3D_j.z;
					if ((dBValue - m_dMinDgrmVal) <= dLimit)
						gm->m_pXGR_GPSDrawMgr->m_OutputDgrmNumber.Add_OutputDgrmNumber(&(DrawPoint.x), Pos6, 1, dBValue, pTX->m_bSpecifiedAngle, (int)pTX->m_nValueAngle, pTX->m_bNumberExponent, gm->m_NumberDecimalPoint);
				}
				break;
			}
		}
		//////////////////////////////////////////////////////////////////////////////////////
	}
	else
	{
		// Min/Max
		if (m_bBeamOutputMaxMin)
		{
			if (bSaveTextOutput)
			{
				double Pos6[6];
				Pos6[0] = node3D_i.x; Pos6[1] = node3D_i.y; Pos6[2] = node3D_i.z;
				Pos6[3] = node3D_j.x; Pos6[4] = node3D_j.y; Pos6[5] = node3D_j.z;
				if ((!bBrdgLoadLate) || (bBrdgLoadLate&&bBrdgDataMin))
					gm->m_pXGR_GPSDrawMgr->m_OutputDgrmNumber.Add_OutputDgrmNumber(&(OutVal.Pos[0].x), Pos6, 3, OutVal.dMinMaxVal[0], pTX->m_bSpecifiedAngle, (int)pTX->m_nValueAngle, pTX->m_bNumberExponent, gm->m_NumberDecimalPoint);
				if ((!bBrdgLoadLate) || (bBrdgLoadLate&&bBrdgDataMax))
					gm->m_pXGR_GPSDrawMgr->m_OutputDgrmNumber.Add_OutputDgrmNumber(&(OutVal.Pos[1].x), Pos6, 4, OutVal.dMinMaxVal[1], pTX->m_bSpecifiedAngle, (int)pTX->m_nValueAngle, pTX->m_bNumberExponent, gm->m_NumberDecimalPoint);
			}
		}
		// Abs Max
		else if (m_bBeamOutputMax)
		{
			if (bSaveTextOutput)
			{
				double Pos6[6];
				Pos6[0] = node3D_i.x; Pos6[1] = node3D_i.y; Pos6[2] = node3D_i.z;
				Pos6[3] = node3D_j.x; Pos6[4] = node3D_j.y; Pos6[5] = node3D_j.z;
				if ((!bBrdgLoadLate) || (bBrdgLoadLate && (bBrdgDataMin || bBrdgDataMax)))
					gm->m_pXGR_GPSDrawMgr->m_OutputDgrmNumber.Add_OutputDgrmNumber(&(OutVal.Pos[1].x), Pos6, 5, OutVal.dMinMaxVal[1], pTX->m_bSpecifiedAngle, (int)pTX->m_nValueAngle, pTX->m_bNumberExponent, gm->m_NumberDecimalPoint);
			}
		}
		else
		{
			double Pos6[6];
			Pos6[0] = node3D_i.x; Pos6[1] = node3D_i.y; Pos6[2] = node3D_i.z;
			Pos6[3] = node3D_j.x; Pos6[4] = node3D_j.y; Pos6[5] = node3D_j.z;
			if (m_bBeamOutputI)
			{
				if ((!bBrdgLoadLate) || (bBrdgLoadLate&&bBrdgData.bBrdgDataI))
					gm->m_pXGR_GPSDrawMgr->m_OutputDgrmNumber.Add_OutputDgrmNumber(&(OutVal.Pos[0].x), Pos6, 6, ReslD.dValue[0][0], pTX->m_bSpecifiedAngle, (int)pTX->m_nValueAngle, pTX->m_bNumberExponent, gm->m_NumberDecimalPoint);
			}
			if (m_bBeamOutputJ)
			{
				if ((!bBrdgLoadLate) || (bBrdgLoadLate&&bBrdgData.bBrdgDataJ))
					gm->m_pXGR_GPSDrawMgr->m_OutputDgrmNumber.Add_OutputDgrmNumber(&(OutVal.Pos[2].x), Pos6, 7, ReslD.dValue[3][1], pTX->m_bSpecifiedAngle, (int)pTX->m_nValueAngle, pTX->m_bNumberExponent, gm->m_NumberDecimalPoint);
			}
			if (m_bBeamOutputC)
			{
				if ((!bBrdgLoadLate) || (bBrdgLoadLate&&bBrdgData.bBrdgDataI&&bBrdgData.bBrdgDataJ))
					gm->m_pXGR_GPSDrawMgr->m_OutputDgrmNumber.Add_OutputDgrmNumber(&(OutVal.Pos[1].x), Pos6, 8, ReslD.dValue[1][1], pTX->m_bSpecifiedAngle, (int)pTX->m_nValueAngle, pTX->m_bNumberExponent, gm->m_NumberDecimalPoint);
			}
		}
	}

	pDC->SelectObject(old_ft);
	ft.DeleteObject();

	for (j = 0; j < polygon_list.GetSize(); j++)
	{
		polygon_list[j]->RemoveAll();
		delete polygon_list[j];
		edge_list[j]->RemoveAll();
		delete edge_list[j];
	}
	polygon_list.RemoveAll();
	edge_list.RemoveAll();

	gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}

/*---------------------------------------------------------------------------------------------
DATE : 2006.04.17. by kyungha
DESC : RC C/B Flexural Capacity Ratio
---------------------------------------------------------------------------------------------*/
#if defined(__OLD_OUTPUT_VALUE)
void CDesignEngine::OutputStripDesignNumbers(CDC* pDC)
{
	I_GPSModel* gm = (I_GPSModel*)m_pGPSModel;

	CPoint		text_p;
	TCHAR		  fmt_str[10]/*,text_str[512]*/;
	CFont		  ft, * old_ft;
	BOOL		  fl_bak;
	double    dOffsetX, dOffsetY;
	CString   strTop, strBot;
	TCHAR      text_strI[512], text_strC[512], text_strJ[512];;

	if (!m_bDsgnDataSet) return;

	if (gm->m_DOPT.TX.m_bNumberOpaque) pDC->SetBkMode(OPAQUE);
	else                               pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
	pDC->SetBkColor(gm->m_DOPT.TX.m_NumberBackCol);
	pDC->SetTextAlign(TA_CENTER | TA_BOTTOM);

	if (gm->m_DOPT.TX.m_bNumberExponent) _stprintf(fmt_str, _T("%s%de"), _T("%."), gm->m_NumberDecimalPoint);
	else                                 _stprintf(fmt_str, _T("%s%df"), _T("%."), gm->m_NumberDecimalPoint);

	fl_bak = gm->m_DOPT.DR.m_bFrameLine;
	gm->m_DOPT.DR.m_bFrameLine = TRUE;

	CArray<T_MSTR_K, T_MSTR_K> aMstrK;
	GetMstrKeyListForView(aMstrK);
	T_GPS_STRIP_RESULT StripResult;
	T_MSTR_K MstrK;
	int nSlope5Div[5];
	BOOL nInverse5Div[5];
	BOOL bCanDraw[5];
	CPoint DrawPt[5];

	// 글자 간격만큼 오프셋
	TEXTMETRIC tm;
	::GetTextMetrics(pDC->GetSafeHdc(), &tm);
	int nOffset = tm.tmHeight;

	for (int i = 0; i < aMstrK.GetSize(); i++)
	{
		MstrK = aMstrK[i];
		if (!GetStripDesignResult(MstrK, StripResult)) { ASSERT(0); continue; }

		CUtilFuncs::MakeBeamSlopeAt5Div(gm, StripResult.ptStrip[0], StripResult.ptStrip[4], nSlope5Div, nInverse5Div, bCanDraw, DrawPt);
		SET_BFOR_FONT_TYPE(nSlope5Div[0])
			BOOL bInverse = nInverse5Div[0];

		dOffsetX = sin(nSlope5Div[0] / 10.0 * PI / 180.0) * nOffset;
		dOffsetY = cos(nSlope5Div[0] / 10.0 * PI / 180.0) * nOffset;

		// 0:Rebar
		if (m_nRebarRatio == 0)
		{
			text_p = GetWorldToP2D(StripResult.ptStrip[2]);

			strTop = _T(""), strBot = _T("");
			if (!StripResult.aText0[0].IsEmpty() && !StripResult.aText0[1].IsEmpty() && !StripResult.aText0[2].IsEmpty())
			{
				if (!bInverse) strTop.Format(_T("%s : %s : %s"), StripResult.aText0[0], StripResult.aText0[1], StripResult.aText0[2]);
				else          strTop.Format(_T("%s : %s : %s"), StripResult.aText0[2], StripResult.aText0[1], StripResult.aText0[0]);
			}
			if (!StripResult.aText0[3].IsEmpty() && !StripResult.aText0[4].IsEmpty() && !StripResult.aText0[5].IsEmpty())
			{
				if (!bInverse) strBot.Format(_T("%s : %s : %s"), StripResult.aText0[3], StripResult.aText0[4], StripResult.aText0[5]);
				else          strBot.Format(_T("%s : %s : %s"), StripResult.aText0[5], StripResult.aText0[4], StripResult.aText0[3]);
			}
			pDC->TextOut(text_p.x, text_p.y, strTop);
			pDC->TextOut(text_p.x + dOffsetX, text_p.y + dOffsetY, strBot);

			if (m_bStripSlabDgnResult)
			{
				pDC->TextOut(text_p.x + dOffsetX * 2, text_p.y + dOffsetY * 2, StripResult.strSlabRebar[0]);
				pDC->TextOut(text_p.x + dOffsetX * 3, text_p.y + dOffsetY * 3, StripResult.strSlabRebar[1]);
			}
		}
		// 1:AS
		if (m_nRebarRatio == 1)
		{
			text_p = GetWorldToP2D(StripResult.ptStrip[2]);
			_stprintf(text_strI, fmt_str, StripResult.aVal1[0]);
			_stprintf(text_strC, fmt_str, StripResult.aVal1[2]);
			_stprintf(text_strJ, fmt_str, StripResult.aVal1[4]);
			if (!bInverse) strTop.Format(_T("%s : %s : %s"), text_strI, text_strC, text_strJ);
			else          strTop.Format(_T("%s : %s : %s"), text_strJ, text_strC, text_strI);
			pDC->TextOut(text_p.x, text_p.y, strTop);
			_stprintf(text_strI, fmt_str, StripResult.aVal1[1]);
			_stprintf(text_strC, fmt_str, StripResult.aVal1[3]);
			_stprintf(text_strJ, fmt_str, StripResult.aVal1[5]);
			if (!bInverse) strBot.Format(_T("%s : %s : %s"), text_strI, text_strC, text_strJ);
			else          strBot.Format(_T("%s : %s : %s"), text_strJ, text_strC, text_strI);
			pDC->TextOut(text_p.x + dOffsetX, text_p.y + dOffsetY, strBot);
		}
		// 2:Resistance Ratio
		if (m_nRebarRatio == 2)
		{
			text_p = GetWorldToP2D(StripResult.ptStrip[2]);
			_stprintf(text_strI, fmt_str, StripResult.aVal2[0]);
			_stprintf(text_strC, fmt_str, StripResult.aVal2[2]);
			_stprintf(text_strJ, fmt_str, StripResult.aVal2[4]);
			if (!bInverse) strTop.Format(_T("%s : %s : %s"), text_strI, text_strC, text_strJ);
			else          strTop.Format(_T("%s : %s : %s"), text_strJ, text_strC, text_strI);
			pDC->TextOut(text_p.x, text_p.y, strTop);
			_stprintf(text_strI, fmt_str, StripResult.aVal2[1]);
			_stprintf(text_strC, fmt_str, StripResult.aVal2[3]);
			_stprintf(text_strJ, fmt_str, StripResult.aVal2[5]);
			if (!bInverse) strBot.Format(_T("%s : %s : %s"), text_strI, text_strC, text_strJ);
			else          strBot.Format(_T("%s : %s : %s"), text_strJ, text_strC, text_strI);
			pDC->TextOut(text_p.x + dOffsetX, text_p.y + dOffsetY, strBot);
		}

		//3.
		//     if(m_nRebarRatio==3)
		//     {
		//       DrawStripBendingMementDiagram 함수 안에 이 케이스에 대한 그리기 코드가 있다.
		//       계산된 데이터의 사용이 필요해 해당 위치에 있으므로, 숫자 출력 처리 수정 할때 주의!
		//     }

		// 4:Unbalanced Moment
		if (m_nRebarRatio == 4)
		{
			// 스트립 양단의 부재력 차를 출력하던 코드. 불균형모멘트는 기둥의 부재력 차를 출력하는 것으로 변경(141125)
			//       text_p = GetWorldToP2D(StripResult.ptStripConv[5]);
			//       _stprintf(text_str,fmt_str,StripResult.aVal4[0]); 
			//       pDC->TextOut(text_p.x, text_p.y, text_str);
			// 
			//       text_p = GetWorldToP2D(StripResult.ptStripConv[6]);
			//       _stprintf(text_str,fmt_str,StripResult.aVal4[1]);
			//       pDC->TextOut(text_p.x, text_p.y, text_str);
		}

		DEL_BFOR_FONT_TYPE()
	}

	// 추가 결과
	// 서브도메인 결과 출력
	if (m_nRebarRatio == 0 && m_bStripSlabDgnResult == TRUE)
	{
		// ------(Axis)------글씨
		// 글씨를 Axis 끝나는데부터 출력해야 하는데, 정렬을 왼쪽/오른쪽으로 하면 뷰 각도에 따라 뒤집히게 됩니다.
		// 정렬을 가운데로 하고, 글자위치를 조작해줘야 항상 축의 끝 부분에 글씨가 나옵니다.
		CArray<T_SBDO_K, T_SBDO_K> aSbdoK;
		m_pDoc->m_pViewCtrl->GetAllActiveSbdo(aSbdoK);
		T_GPS_SBDO_RESULT SbdoResult;
		CPoint text_p_Center;
		double vec[2];
		int nSlope;
		for (int j = 0; j < aSbdoK.GetSize(); j++)
		{
			GetSbdoDesignResult(aSbdoK[j], SbdoResult);

			text_p_Center = GetWorldToP2D(SbdoResult.ptArrowDir1[0]); // 축의 중심
			text_p = GetWorldToP2D(SbdoResult.ptArrowDir1[1]);
			CUtilFuncs::GetSlope2Point(nSlope, text_p_Center.x, text_p_Center.y, text_p.x, text_p.y);
			SET_BFOR_FONT_TYPE(nSlope)

				vec[0] = text_p.x - text_p_Center.x;
			vec[1] = text_p.y - text_p_Center.y;
			CMathFunc::mathNormalize2D(vec, vec);
			text_p.x += int((vec[0] * 2.6) * SbdoResult.strRebarDir1[0].GetLength()) + 1;
			text_p.y += int((vec[1] * 2.6) * SbdoResult.strRebarDir1[0].GetLength()) + 1;
			pDC->SetTextAlign(TA_CENTER | TA_BASELINE);
			pDC->TextOut(text_p.x, text_p.y, SbdoResult.strRebarDir1[0]);
			pDC->SetTextAlign(TA_CENTER | TA_TOP);
			pDC->TextOut(text_p.x, text_p.y, SbdoResult.strRebarDir1[1]);
			DEL_BFOR_FONT_TYPE()

				text_p = GetWorldToP2D(SbdoResult.ptArrowDir2[1]);
			CUtilFuncs::GetSlope2Point(nSlope, text_p_Center.x, text_p_Center.y, text_p.x, text_p.y);
			SET_BFOR_FONT_TYPE(nSlope)

				vec[0] = text_p.x - text_p_Center.x;
			vec[1] = text_p.y - text_p_Center.y;
			CMathFunc::mathNormalize2D(vec, vec);
			text_p.x += int((vec[0] * 2.6) * SbdoResult.strRebarDir2[0].GetLength()) + 1;
			text_p.y += int((vec[1] * 2.6) * SbdoResult.strRebarDir2[0].GetLength()) + 1;
			pDC->SetTextAlign(TA_CENTER | TA_BASELINE);
			pDC->TextOut(text_p.x, text_p.y, SbdoResult.strRebarDir2[0]);
			pDC->SetTextAlign(TA_CENTER | TA_TOP);
			pDC->TextOut(text_p.x, text_p.y, SbdoResult.strRebarDir2[1]);
			DEL_BFOR_FONT_TYPE()
		}
	}

	// 기둥에 불균형 모멘트 출력
	if (m_nRebarRatio == 4)
	{
		SET_BFOR_FONT_TYPE(0)
			TCHAR fmt_str_bracket[12];

		if (gm->m_DOPT.TX.m_bNumberExponent) _stprintf(fmt_str_bracket, _T("%s%de"), _T("%."), gm->m_NumberDecimalPoint);
		else _stprintf(fmt_str_bracket, _T("%s%df"), _T("%."), gm->m_NumberDecimalPoint);

		T_NODE_K NodeK;
		T_NODE_D NodeD;
		CString strFmt1, strFmt2;
		CString strVal1, strVal2;
		C3DPoint point;
		BOOL bDgnResult;
		double dMy, dMz, dDgnVal;
		T_GPS_STRIP_UBM UBMResD;
		POSITION pos = m_mapStripUnbalancedMoment.GetStartPosition();
		while (pos)
		{
			m_mapStripUnbalancedMoment.GetNextAssoc(pos, NodeK, UBMResD);

			if (!m_pDoc->m_pAttrCtrl->GetNode(NodeK, NodeD)) { ASSERT(0); continue; }
			point.Set(NodeD.x, NodeD.y, NodeD.z);
			if (gm->m_bVirtualMode) text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(point);
			else                   text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(point);

			dMy = UBMResD.dUBM_My;
			dMz = UBMResD.dUBM_Mz;
			strFmt1.Format(_T("My:%s, Mz:%s"), fmt_str_bracket, fmt_str_bracket);
			strVal1.Format(strFmt1, dMy, dMz);
			pDC->TextOut(text_p.x, text_p.y, strVal1);

			bDgnResult = m_pDoc->m_pPostCtrl->GetDesignResult()->GetUnbalanceResult(NodeK, dDgnVal);
			if (bDgnResult)
			{
				strFmt2.Format(_T("(%s)"), fmt_str_bracket);
				strVal2.Format(strFmt2, dDgnVal);
				pDC->TextOut(text_p.x, text_p.y + nOffset, strVal2);
			}
		}
		DEL_BFOR_FONT_TYPE()
	}
}
#else
void CDesignEngine::OutputCBNumbers(CDC *pDC)
{
	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;
	CDBDoc		*pDoc = gm->GetDBDoc();
	int			i, SelectYorZ, node_num;
	T_NODE_K	nkey;
	T_NODE_D	ndata;
	double	cbdataY, cbdataZ, cbdataY2, cbdataZ2;
	CGPSDsgnLabel DsgnLabel;

	C3DPoint	node_p;
	CPoint		text_p;

	CArray <T_NODE_K, T_NODE_K>	nlistK;	nlistK.RemoveAll();
	CArray <T_NODE_K, T_NODE_K>	nkey_list;	nkey_list.RemoveAll();
	CArray <C3DPoint, C3DPoint &>	node_list;

	TCHAR		fmt_str[10];
	CString		text_str;
	double	dDispValue;

	pDoc->m_pAttrCtrl->GetNodeKeyList(nlistK);

	COLORREF ColorNG;
	ColorNG = RGB(255, 0, 0);

	if (!m_bDsgnDataSet)		return;

	GPostTextOut TextOutModel;
	TextOutModel.SetDC(pDC);
	TextOutModel.StartCBVal();
	TextOutModel.SettingCB(gm);

	gm->SetNumberFontNodeOrientation(0);

	if (gm->m_DOPT.TX.m_bNumberSelOnly) {
	}
	else {
		// 각 노드의 위치를 구한다.
		BOOL bGrpFltMode = gm->m_pGPSCtrl->IsGroupFilterMode();

		if (!bGrpFltMode)  node_num = nlistK.GetSize();
		else              node_num = gm->m_pDispFilter->m_aGrpNKey.GetSize();

		for (i = 0; i < node_num; i++)
		{
			if (!bGrpFltMode)nkey = nlistK[i];
			else            nkey = gm->m_pDispFilter->m_aGrpNKey[i];

			if (!gm->m_pGPSCtrl->IsActiveNode(nkey))
				continue; // Lable Hidden 처리를 위해 추가 

			m_pDoc->m_pAttrCtrl->GetNode(nkey, ndata);

			node_p.x = ndata.x;
			node_p.y = ndata.y;
			node_p.z = ndata.z;

			nkey_list.Add(nkey);
			node_list.Add(node_p);
		}
	}

	TextOutModel.Font4CB(gm, 0);
	node_num = node_list.GetSize();
	for (i = 0; i < node_num; i++)
	{
		cbdataY = 0, cbdataZ = 0, cbdataY2 = 0, cbdataZ2 = 0;
		//		m_mapCBData.Lookup(nkey_list[i],cbdata);
		if (m_nDirection == 1)       // Clockwise
		{
			if (!m_mapMnyRatioCW.Lookup(nkey_list[i], cbdataY)) continue;
			m_mapMnzRatioCW.Lookup(nkey_list[i], cbdataZ);
		}
		else if (m_nDirection == 2)  // Counter-Clockwise
		{
			if (!m_mapMnyRatioCCW.Lookup(nkey_list[i], cbdataY)) continue;
			m_mapMnzRatioCCW.Lookup(nkey_list[i], cbdataZ);
		}
		else if (m_nDirection == 0)  // Minimum Ratio of CW & CCW
		{
			if (!m_mapMnyRatioCW.Lookup(nkey_list[i], cbdataY)) continue;
			m_mapMnzRatioCW.Lookup(nkey_list[i], cbdataZ);
			m_mapMnyRatioCCW.Lookup(nkey_list[i], cbdataY2);
			m_mapMnzRatioCCW.Lookup(nkey_list[i], cbdataZ2);
			cbdataY = min(cbdataY, cbdataY2);
			cbdataZ = min(cbdataZ, cbdataZ2);
		}

		for (SelectYorZ = 0; SelectYorZ < 2; SelectYorZ++)
		{
			switch (SelectYorZ)
			{
			case 0:			// case Y
			{
				//if (m_mapMnyRatioCW.Lookup(nkey_list[i],cbdataY))
				{
					if ((!m_bOutLocalY) && (m_nOut == 1)) continue;
					//if (m_mapMnzRatioCW.Lookup(nkey_list[i],cbdataZ))
					//{
					if (m_nOut && m_bOutMin && (cbdataY > cbdataZ))	continue;
					//}
					dDispValue = cbdataY;
					if ((m_nRatio == 1) && (dDispValue >= m_fLimitVal)) continue;  // Acceptance Limit 미만인 경우만 출력
					TextOutModel.AlignTextBot(TA_LEFT);

					// 지수 형태의 출력인가 form: y= value 
					if (gm->m_DOPT.TX.m_bNumberExponent)
						_stprintf(fmt_str, _T(" y=%s%de "), _T("%."), gm->m_NumberDecimalPoint);
					else
						_stprintf(fmt_str, _T(" y=%s%df "), _T("%."), gm->m_NumberDecimalPoint);
				}
			}
			break;
			case 1:			// case Z
			{
				//if (m_mapMnzRatioCW.Lookup(nkey_list[i],cbdataZ))
				{
					if ((!m_bOutLocalZ) && (m_nOut == 1)) continue;
					//if (m_mapMnyRatioCW.Lookup(nkey_list[i],cbdataY))
					//{
					if (m_nOut && m_bOutMin && (cbdataY < cbdataZ))	continue;
					//}
					dDispValue = cbdataZ;
					if ((m_nRatio == 1) && (dDispValue >= m_fLimitVal)) continue;  // Acceptance Limit 미만인 경우만 출력
					TextOutModel.AlignTextTop(TA_LEFT);

					// 지수 형태의 출력인가 form: z= value 
					if (gm->m_DOPT.TX.m_bNumberExponent)
						_stprintf(fmt_str, _T(" z=%s%de "), _T("%."), gm->m_NumberDecimalPoint);
					else
						_stprintf(fmt_str, _T(" z=%s%df "), _T("%."), gm->m_NumberDecimalPoint);
				}
			}
			break;
			}

			if (gm->m_bVirtualMode)
				text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(node_list[i]);
			else
				text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node_list[i]);
			if (text_p.x < 0 || text_p.y < 0) continue;

			if (gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
			{
				//				pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
				double dLimit = (m_dMaxValue - m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;
				switch (gm->m_DOPT.TX.m_nOutputMinMaxType)
				{
				case 0: // Min & Max
					if ((m_dMaxValue - dDispValue) <= dLimit)
						DrawMinMaxOutputValue(pDC, node_list[i], fmt_str, 0, dDispValue);
					else if ((dDispValue - m_dMinValue) <= dLimit)
						DrawMinMaxOutputValue(pDC, node_list[i], fmt_str, 1, dDispValue);
					break;
				case 1: // Abs Max
					if (fabs(m_dMaxValue) >= fabs(m_dMinValue))
					{
						if (fabs(m_dMaxValue) - fabs(dDispValue) <= dLimit)
							DrawMinMaxOutputValue(pDC, node_list[i], fmt_str, 2, dDispValue);
					}
					else
					{
						if (fabs(m_dMinValue) - fabs(dDispValue) <= dLimit)
							DrawMinMaxOutputValue(pDC, node_list[i], fmt_str, 2, dDispValue);
					}
					break;
				case 2: // Max
					if ((m_dMaxValue - dDispValue) <= dLimit)
						DrawMinMaxOutputValue(pDC, node_list[i], fmt_str, 0, dDispValue);
					break;
				case 3: // Min
					if ((dDispValue - m_dMinValue) <= dLimit)
						DrawMinMaxOutputValue(pDC, node_list[i], fmt_str, 1, dDispValue);
					break;
				default:
					break;
				}
				continue;
			}
			text_str.Format(fmt_str, dDispValue);
			TextOutModel.TextOutCB(text_p.x, text_p.y, text_str);
		}
	}
	TextOutModel.DeleteFont();

	nkey_list.RemoveAll();
	node_list.RemoveAll();

	TextOutModel.EndCBVal();
}
#endif

void CDesignEngine::MakeRatingList()
{
	//
	// BridgeLoadRateDgrmData() 를 제외하고 MakeBrdgLoadRateList()와 내용이 거의 같음..
	//
	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;
	m_bDsgnDataSet = TRUE;  // 무조건 TRUE로 해야 결과가 없어도 요소가 Wire Frame으로 출력된다 
	CDBDoc *pDoc = CDBDoc::GetDocPoint();
	BOOL bHasData = FALSE;

	m_dMaxDgrmVal = -DBL_MAX;
	m_dMinDgrmVal = DBL_MAX;
	m_mapDgrmData.RemoveAll();
	m_mapDgrmData.InitHashTable(1001);
	m_EKeyList.RemoveAll();
	m_mapTendonData.RemoveAll();
	m_mapbBrdgData.RemoveAll();

	int nElemNum;
	T_ELEM_K ElemK;

	nElemNum = gm->m_EKeyListActive.GetSize();

	int nKeyNum = 0;
	UINT Key1[PSC_DSGN_TYPE_KEY_NUM];

	Key1[0] = Key1[1] = Key1[2] = Key1[3] = PSC_DSGN_NULL_KEY;

	if (m_bPSCSignPos)
	{
		Key1[PSC_DSGN_STRG_MAX_KEY] = PSC_DSGN_STRG_MAX_KEY;
		Key1[PSC_DSGN_CRIT_MAX_KEY] = PSC_DSGN_CRIT_MAX_KEY;
	}
	if (m_bPSCSignNeg)
	{
		Key1[PSC_DSGN_STRG_MIN_KEY] = PSC_DSGN_STRG_MIN_KEY;
		Key1[PSC_DSGN_CRIT_MIN_KEY] = PSC_DSGN_CRIT_MIN_KEY;
	}

	T_CMAP_K2<UINT> mKey;
	T_PSC_DSGN_RESL_D ReslD[4];

	// Shear, Tendon 에서는 Sign 에 관계없이 출력하도록 한다 
	if (m_bPSCSignPos || m_bPSCSignNeg)
	{
		for (int i = 0; i < nElemNum; i++)
		{
			ElemK = gm->m_EKeyListActive[i];

			for (int j = 0; j < 4; j++)ReslD[j].Initialize();

			if (!RatingDgrmData(ElemK, ReslD))	continue;

			SetDgrmVector4LclMaj(ElemK, ReslD);
			m_EKeyList.Add(ElemK);
			bHasData = TRUE;

			double dMnVal = 0.0, dMxVal = 0.0;
			for (int j = 0; j < 4; j++)
			{
				if (Key1[j] == PSC_DSGN_NULL_KEY)continue;

				ReslD[j].GetMxMnVal(dMxVal, dMnVal);
				m_dMaxDgrmVal = max(m_dMaxDgrmVal, dMxVal);
				m_dMinDgrmVal = min(m_dMinDgrmVal, dMnVal);

				mKey.i1 = ElemK;
				mKey.i2 = Key1[j];
				m_mapDgrmData.SetAt(mKey, ReslD[j]);
			}
		}
	}

	if (!bHasData)
	{
		m_dMaxDgrmVal = 0.0;
		m_dMinDgrmVal = 0.0;
		return;
	}

	if (fabs(m_dMaxDgrmVal) < fabs(m_dMinDgrmVal))
		InitDiagramAdjustFactor(m_dMinDgrmVal);
	else
		InitDiagramAdjustFactor(m_dMaxDgrmVal);

	if (m_pContourEngine == NULL)
		m_pContourEngine = new CContourEngine(m_dMinDgrmVal, m_dMaxDgrmVal);
	else
		m_pContourEngine->MakeRankMap(m_dMinDgrmVal, m_dMaxDgrmVal);
	m_bDsgnDataSet = TRUE;
}

void CDesignEngine::MakeAASHTORatingList()
{
	//
	// BridgeLoadRateDgrmData() 를 제외하고 MakeBrdgLoadRateList()와 내용이 거의 같음..
	//
	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;
	m_bDsgnDataSet = TRUE;  // 무조건 TRUE로 해야 결과가 없어도 요소가 Wire Frame으로 출력된다 
	CDBDoc *pDoc = CDBDoc::GetDocPoint();
	BOOL bHasData = FALSE;

	m_dMaxDgrmVal = -DBL_MAX;
	m_dMinDgrmVal = DBL_MAX;
	m_mapDgrmData.RemoveAll();
	m_mapDgrmData.InitHashTable(1001);
	m_EKeyList.RemoveAll();
	m_mapTendonData.RemoveAll();
	m_mapbBrdgData.RemoveAll();

	int nElemNum;
	T_ELEM_K ElemK;

	nElemNum = gm->m_EKeyListActive.GetSize();

	int nKeyNum = 0;
	UINT Key1[PSC_DSGN_TYPE_KEY_NUM];
	Key1[PSC_DSGN_STRG_MAX_KEY] = PSC_DSGN_STRG_MAX_KEY;
	Key1[PSC_DSGN_CRIT_MAX_KEY] = PSC_DSGN_CRIT_MAX_KEY;
	Key1[PSC_DSGN_STRG_MIN_KEY] = PSC_DSGN_STRG_MIN_KEY;
	Key1[PSC_DSGN_CRIT_MIN_KEY] = PSC_DSGN_CRIT_MIN_KEY;

	T_CMAP_K2<UINT> mKey;
	T_PSC_DSGN_RESL_D ReslD[4];

	for (int i = 0; i < nElemNum; i++)
	{
		ElemK = gm->m_EKeyListActive[i];

		for (int j = 0; j < 4; j++)ReslD[j].Initialize();

		if (!RatingAASHTODgrmData(ElemK, ReslD))	continue;

		SetDgrmVector4LclMaj(ElemK, ReslD);
		m_EKeyList.Add(ElemK);
		bHasData = TRUE;

		double dMnVal = 0.0, dMxVal = 0.0;
		for (int j = 0; j < 4; j++)
		{
			if (Key1[j] == PSC_DSGN_NULL_KEY)continue;

			ReslD[j].GetMxMnVal(dMxVal, dMnVal);
			m_dMaxDgrmVal = max(m_dMaxDgrmVal, dMxVal);
			m_dMinDgrmVal = min(m_dMinDgrmVal, dMnVal);

			mKey.i1 = ElemK;
			mKey.i2 = Key1[j];
			m_mapDgrmData.SetAt(mKey, ReslD[j]);
		}
	}

	if (!bHasData)
	{
		m_dMaxDgrmVal = 0.0;
		m_dMinDgrmVal = 0.0;
		return;
	}

	if (fabs(m_dMaxDgrmVal) < fabs(m_dMinDgrmVal))
		InitDiagramAdjustFactor(m_dMinDgrmVal);
	else
		InitDiagramAdjustFactor(m_dMaxDgrmVal);

	if (m_pContourEngine == NULL)
		m_pContourEngine = new CContourEngine(m_dMinDgrmVal, m_dMaxDgrmVal);
	else
		m_pContourEngine->MakeRankMap(m_dMinDgrmVal, m_dMaxDgrmVal);
	m_bDsgnDataSet = TRUE;
}

void CDesignEngine::MakeAASHTO19RatingList()
{
	//
	// BridgeLoadRateDgrmData() 를 제외하고 MakeBrdgLoadRateList()와 내용이 거의 같음..
	//
	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;
	m_bDsgnDataSet = TRUE;  // 무조건 TRUE로 해야 결과가 없어도 요소가 Wire Frame으로 출력된다 
	CDBDoc *pDoc = CDBDoc::GetDocPoint();
	BOOL bHasData = FALSE;

	m_dMaxDgrmVal = -DBL_MAX;
	m_dMinDgrmVal = DBL_MAX;
	m_mapDgrmData.RemoveAll();
	m_mapDgrmData.InitHashTable(1001);
	m_EKeyList.RemoveAll();
	m_mapTendonData.RemoveAll();
	m_mapbBrdgData.RemoveAll();

	int nElemNum;
	T_ELEM_K ElemK;

	nElemNum = gm->m_EKeyListActive.GetSize();

	int nKeyNum = 0;
	UINT Key1[PSC_DSGN_TYPE_KEY_NUM];
	Key1[PSC_DSGN_STRG_MAX_KEY] = PSC_DSGN_STRG_MAX_KEY;
	Key1[PSC_DSGN_CRIT_MAX_KEY] = PSC_DSGN_CRIT_MAX_KEY;
	Key1[PSC_DSGN_STRG_MIN_KEY] = PSC_DSGN_STRG_MIN_KEY;
	Key1[PSC_DSGN_CRIT_MIN_KEY] = PSC_DSGN_CRIT_MIN_KEY;

	T_CMAP_K2<UINT> mKey;
	T_PSC_DSGN_RESL_D ReslD[4];

	for (int i = 0; i < nElemNum; i++)
	{
		ElemK = gm->m_EKeyListActive[i];

		for (int j = 0; j < 4; j++)ReslD[j].Initialize();

		if (!RatingAASHTO19DgrmData(ElemK, ReslD)) continue;

		SetDgrmVector4LclMaj(ElemK, ReslD);
		m_EKeyList.Add(ElemK);
		bHasData = TRUE;

		double dMnVal = 0.0, dMxVal = 0.0;
		for (int j = 0; j < 4; j++)
		{
			if (Key1[j] == PSC_DSGN_NULL_KEY)continue;

			ReslD[j].GetMxMnVal(dMxVal, dMnVal);
			if (CCompFunc::CompRealTol(dMxVal, 0.0, 1.e-7) == 0 && CCompFunc::CompRealTol(dMnVal, 0.0, 1.e-7) == 0) continue;

			m_dMaxDgrmVal = max(m_dMaxDgrmVal, dMxVal);
			m_dMinDgrmVal = min(m_dMinDgrmVal, dMnVal);

			mKey.i1 = ElemK;
			mKey.i2 = Key1[j];
			m_mapDgrmData.SetAt(mKey, ReslD[j]);
		}
	}

	if (!bHasData)
	{
		m_dMaxDgrmVal = 0.0;
		m_dMinDgrmVal = 0.0;
		return;
	}

	if (CCompFunc::CompRealTol(m_dMaxDgrmVal, -DBL_MAX, 1.e-7) == 0 && CCompFunc::CompRealTol(m_dMinDgrmVal, DBL_MAX, 1.e-7) == 0)
	{
		m_dMaxDgrmVal = 0.0;
		m_dMinDgrmVal = 0.0;
		m_pContourEngine = new CContourEngine(m_dMinDgrmVal, m_dMaxDgrmVal);
		return;
	}

	if (fabs(m_dMaxDgrmVal) < fabs(m_dMinDgrmVal))
		InitDiagramAdjustFactor(m_dMinDgrmVal);
	else
		InitDiagramAdjustFactor(m_dMaxDgrmVal);

	if (m_pContourEngine == NULL)
		m_pContourEngine = new CContourEngine(m_dMinDgrmVal, m_dMaxDgrmVal);
	else
		m_pContourEngine->MakeRankMap(m_dMinDgrmVal, m_dMaxDgrmVal);
	m_bDsgnDataSet = TRUE;
}

//----------------------------------------------------------------------------------------
// INIT : 2006.06.19. by kyungha
// FUNC : Bridge Load Rating Result Diagram
//----------------------------------------------------------------------------------------
void CDesignEngine::MakeBrdgLoadRateList()
{
	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;
	m_bDsgnDataSet = TRUE;  // 무조건 TRUE로 해야 결과가 없어도 요소가 Wire Frame으로 출력된다 
	CDBDoc *pDoc = CDBDoc::GetDocPoint();
	BOOL bHasData = FALSE;

	m_dMaxDgrmVal = -DBL_MAX;
	m_dMinDgrmVal = DBL_MAX;
	m_mapDgrmData.RemoveAll();
	m_mapDgrmData.InitHashTable(1001);
	m_EKeyList.RemoveAll();
	m_mapTendonData.RemoveAll();
	m_mapbBrdgData.RemoveAll();

	int nElemNum;
	T_ELEM_K ElemK;

	nElemNum = gm->m_EKeyListActive.GetSize();

	int nKeyNum = 0;
	UINT Key1[PSC_DSGN_TYPE_KEY_NUM];

	Key1[0] = Key1[1] = Key1[2] = Key1[3] = PSC_DSGN_NULL_KEY;

	if (m_bPSCSignPos)
	{
		Key1[PSC_DSGN_STRG_MAX_KEY] = PSC_DSGN_STRG_MAX_KEY;
		Key1[PSC_DSGN_CRIT_MAX_KEY] = PSC_DSGN_CRIT_MAX_KEY;
	}
	if (m_bPSCSignNeg)
	{
		Key1[PSC_DSGN_STRG_MIN_KEY] = PSC_DSGN_STRG_MIN_KEY;
		Key1[PSC_DSGN_CRIT_MIN_KEY] = PSC_DSGN_CRIT_MIN_KEY;
	}

	if ((m_nBrdgLoadRateComp == BRDG_LOAD_RATE_SHEAR) || (m_nBrdgLoadRateComp == BRDG_LOAD_RATE_TENDON))
	{
		Key1[PSC_DSGN_STRG_MAX_KEY] = PSC_DSGN_STRG_MAX_KEY;
		Key1[PSC_DSGN_CRIT_MAX_KEY] = PSC_DSGN_CRIT_MAX_KEY;
		Key1[PSC_DSGN_STRG_MIN_KEY] = PSC_DSGN_NULL_KEY;
		Key1[PSC_DSGN_CRIT_MIN_KEY] = PSC_DSGN_NULL_KEY;
	}

	T_CMAP_K2<UINT> mKey;
	T_PSC_DSGN_RESL_D ReslD[4];

	// Shear, Tendon 에서는 Sign 에 관계없이 출력하도록 한다 
	if (m_bPSCSignPos || m_bPSCSignNeg ||
		((m_nBrdgLoadRateComp == BRDG_LOAD_RATE_SHEAR) || (m_nBrdgLoadRateComp == BRDG_LOAD_RATE_TENDON)))
		for (int i = 0; i < nElemNum; i++)
		{
			ElemK = gm->m_EKeyListActive[i];

			for (int j = 0; j < 4; j++)ReslD[j].Initialize();

			if (!BridgeLoadRateDgrmData(ElemK, ReslD))	continue;

			SetDgrmVector4LclMaj(ElemK, ReslD);
			m_EKeyList.Add(ElemK);
			bHasData = TRUE;

			double dMnVal = 0.0, dMxVal = 0.0;
			for (int j = 0; j < 4; j++)
			{
				if (Key1[j] == PSC_DSGN_NULL_KEY)continue;

				ReslD[j].GetMxMnVal(dMxVal, dMnVal);
				m_dMaxDgrmVal = max(m_dMaxDgrmVal, dMxVal);
				m_dMinDgrmVal = min(m_dMinDgrmVal, dMnVal);

				mKey.i1 = ElemK;
				mKey.i2 = Key1[j];
				m_mapDgrmData.SetAt(mKey, ReslD[j]);
			}
		}

	if (!bHasData)
	{
		m_dMaxDgrmVal = 0.0;
		m_dMinDgrmVal = 0.0;
		return;
	}

	if (fabs(m_dMaxDgrmVal) < fabs(m_dMinDgrmVal))
		InitDiagramAdjustFactor(m_dMinDgrmVal);
	else
		InitDiagramAdjustFactor(m_dMaxDgrmVal);

	if (m_pContourEngine == NULL)
		m_pContourEngine = new CContourEngine(m_dMinDgrmVal, m_dMaxDgrmVal);
	else
		m_pContourEngine->MakeRankMap(m_dMinDgrmVal, m_dMaxDgrmVal);
	m_bDsgnDataSet = TRUE;
}

BOOL CDesignEngine::RatingDgrmData(T_ELEM_K ElemK, T_PSC_DSGN_RESL_D RsltD[4])
{
	CDBDoc *pDoc = CDBDoc::GetDocPoint();

	T_ISBRDG_D BrdgData;
	BrdgData.Initialize();
	BOOL bCheckIMax = FALSE, bCheckIMin = FALSE, bCheckJMax = FALSE, bCheckJMin = FALSE;

	double dValI, dValJ;
	BOOL bCheckI, bCheckJ;
	BOOL bCalcSuccess = TRUE;
	if (m_nRatingRstType == 0) //Steel
	{
		switch (m_nSteelRatingRstType)
		{
		case 0: // Rating Factor
			if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetRatingResult4Contour(0, m_SelRatingCaseK, ElemK, bCheckI, bCheckJ, dValI, dValJ))
			{
				bCalcSuccess = FALSE;
			}
			break;
		case 1: // 기본내하력
			if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetRatingResult4Contour(1, m_SelRatingCaseK, ElemK, bCheckI, bCheckJ, dValI, dValJ))
			{
				bCalcSuccess = FALSE;
			}
			break;
		default:
			ASSERT(0);
		}
	}
	else if (m_nRatingRstType == 1) // PSC
	{
		switch (m_nSteelRatingRstType)
		{
		case 0: // Rating Factor
			if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetPSCRatingResult4Contour(0, m_SelRatingCaseK, ElemK, bCheckI, bCheckJ, dValI, dValJ))
			{
				bCalcSuccess = FALSE;
			}
			break;
		case 1: // 기본내하력
			if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetPSCRatingResult4Contour(1, m_SelRatingCaseK, ElemK, bCheckI, bCheckJ, dValI, dValJ))
			{
				bCalcSuccess = FALSE;
			}
			break;
		default:
			ASSERT(0);
		}
	}
	else if (m_nRatingRstType == 2) //RC
	{
		switch (m_nSteelRatingRstType)
		{
		case 0: // Rating Factor
			if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetRCRatingResult4Contour(0, m_SelRatingCaseK, ElemK, bCheckI, bCheckJ, dValI, dValJ))
			{
				bCalcSuccess = FALSE;
			}
			break;
		case 1: // 기본내하력
			if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetRCRatingResult4Contour(1, m_SelRatingCaseK, ElemK, bCheckI, bCheckJ, dValI, dValJ))
			{
				bCalcSuccess = FALSE;
			}
			break;
		case 2: // 공용내하력
			if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetRCRatingResult4Contour(2, m_SelRatingCaseK, ElemK, bCheckI, bCheckJ, dValI, dValJ))
			{
				bCalcSuccess = FALSE;
			}
			break;
		default:
			ASSERT(0);
		}
	}


	if (!bCalcSuccess)
	{
		bCheckIMax = FALSE;
		bCheckJMax = FALSE;
		bCheckIMin = FALSE;
		bCheckJMin = FALSE;

		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = 0.0;
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = 0.0;

		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = 0.0;
		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = 0.0;

		BrdgData.bBrdgDataI = FALSE;
		BrdgData.bBrdgDataJ = FALSE;

		m_mapbBrdgData.SetAt(ElemK, BrdgData);
		FinishMakingPscDsgnData(RsltD);

		return TRUE;
	}

	if (!bCheckI)
	{
		dValI = 0.0;
	}
	if (!bCheckJ)
	{
		dValJ = 0.0;
	}

	bCheckIMax = FALSE;
	bCheckJMax = FALSE;
	bCheckIMin = TRUE;
	bCheckJMin = TRUE;

	RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = dValI;
	RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = dValJ;

	RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = dValI;
	RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = dValJ;

	m_mapbBrdgData.SetAt(ElemK, BrdgData);
	FinishMakingPscDsgnData(RsltD);

	// RsltD[4]중에서 [0]과 [2]만 씀.. void CDesignEngine::MakeRatingList()에서 if(Key1[j] == PSC_DSGN_NULL_KEY)continue; 를 보면 알 수 있음

	return TRUE;
}

BOOL CDesignEngine::RatingAASHTODgrmData(T_ELEM_K ElemK, T_PSC_DSGN_RESL_D RsltD[4])
{
	CDBDoc *pDoc = CDBDoc::GetDocPoint();

	T_ISBRDG_D BrdgData;
	BrdgData.Initialize();
	BOOL bCheckIMax = FALSE, bCheckJMax = FALSE, bCheckIMin = FALSE, bCheckJMin = FALSE;
	double dValIMax = 0.0, dValJMax = 0.0, dValIMin = 0.0, dValJMin = 0.0;

	if (m_nSign == 0)
	{
		pDoc->m_pPostCtrl->GetAnalysisResult()->GetRatingAASHTOResult4Contour(m_SelRatingCaseK, ElemK,
			m_bDC_Max, m_bDW_MAX, m_bTemp_Max, m_nConcurr,
			m_nSteelRatingRstType, TRUE, bCheckIMax, bCheckJMax, dValIMax, dValJMax);
	}
	else if (m_nSign == 1)
	{
		pDoc->m_pPostCtrl->GetAnalysisResult()->GetRatingAASHTOResult4Contour(m_SelRatingCaseK, ElemK,
			m_bDC_Max, m_bDW_MAX, m_bTemp_Max, m_nConcurr,
			m_nSteelRatingRstType, FALSE, bCheckIMin, bCheckJMin, dValIMin, dValJMin);
	}
	else if (m_nSign == 2)
	{
		pDoc->m_pPostCtrl->GetAnalysisResult()->GetRatingAASHTOResult4Contour(m_SelRatingCaseK, ElemK,
			m_bDC_Max, m_bDW_MAX, m_bTemp_Max, m_nConcurr,
			m_nSteelRatingRstType, TRUE, bCheckIMax, bCheckJMax, dValIMax, dValJMax);

		pDoc->m_pPostCtrl->GetAnalysisResult()->GetRatingAASHTOResult4Contour(m_SelRatingCaseK, ElemK,
			m_bDC_Max, m_bDW_MAX, m_bTemp_Max, m_nConcurr,
			m_nSteelRatingRstType, FALSE, bCheckIMin, bCheckJMin, dValIMin, dValJMin);
	}
	else
	{
		ASSERT(0);
	}

	if (!bCheckIMax && !bCheckJMax && !bCheckIMin && !bCheckJMin)
	{
		bCheckIMax = FALSE;
		bCheckJMax = FALSE;
		bCheckIMin = FALSE;
		bCheckJMin = FALSE;

		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = 0.0;
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = 0.0;

		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = 0.0;
		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = 0.0;

		BrdgData.bBrdgDataI = FALSE;
		BrdgData.bBrdgDataJ = FALSE;

		m_mapbBrdgData.SetAt(ElemK, BrdgData);
		FinishMakingPscDsgnData(RsltD);

		return TRUE;
	}

	if (!bCheckIMax) dValIMax = 0.0;
	if (!bCheckJMax) dValJMax = 0.0;
	if (!bCheckIMin) dValIMin = 0.0;
	if (!bCheckJMin) dValJMin = 0.0;

	RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = dValIMax;
	RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = dValJMax;

	RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = dValIMin;
	RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = dValJMin;

	m_mapbBrdgData.SetAt(ElemK, BrdgData);
	FinishMakingPscDsgnData(RsltD);
	return TRUE;
}

BOOL CDesignEngine::RatingAASHTO19DgrmData(T_ELEM_K ElemK, T_PSC_DSGN_RESL_D RsltD[4])
{
	CDBDoc *pDoc = CDBDoc::GetDocPoint();

	T_ISBRDG_D BrdgData;
	BrdgData.Initialize();
	BOOL bCheckIMax = FALSE, bCheckJMax = FALSE, bCheckIMin = FALSE, bCheckJMin = FALSE;
	double dValIMax = 0.0, dValJMax = 0.0, dValIMin = 0.0, dValJMin = 0.0;

	BOOL bCheckTopTF_I = FALSE;
	BOOL bCheckBotTF_I = FALSE;
	BOOL bCheckTopBF_I = FALSE;
	BOOL bCheckBotBF_I = FALSE;

	BOOL bCheckTopTF_J = FALSE;
	BOOL bCheckBotTF_J = FALSE;
	BOOL bCheckTopBF_J = FALSE;
	BOOL bCheckBotBF_J = FALSE;

	double dValTopTF_I = 0.0;
	double dValBotTF_I = 0.0;
	double dValTopBF_I = 0.0;
	double dValBotBF_I = 0.0;

	double dValTopTF_J = 0.0;
	double dValBotTF_J = 0.0;
	double dValTopBF_J = 0.0;
	double dValBotBF_J = 0.0;

	switch (m_nSteelRatingRstType)
	{
	case ENUM_Stress:
		if (m_nSign == 0)
		{
			pDoc->m_pPostCtrl->GetAnalysisResult()->GetRatingAASHTO19Result4ContourStress(m_SelRatingCaseK, ElemK,
				m_bDC_Max, m_bDW_MAX, m_bTemp_Max, m_nConcurr,
				TRUE, bCheckIMax, bCheckJMax, dValIMax, dValJMax);
		}
		else if (m_nSign == 1)
		{
			pDoc->m_pPostCtrl->GetAnalysisResult()->GetRatingAASHTO19Result4ContourStress(m_SelRatingCaseK, ElemK,
				m_bDC_Max, m_bDW_MAX, m_bTemp_Max, m_nConcurr,
				FALSE, bCheckIMin, bCheckJMin, dValIMin, dValJMin);
		}
		else if (m_nSign == 2)
		{
			pDoc->m_pPostCtrl->GetAnalysisResult()->GetRatingAASHTO19Result4ContourStress(m_SelRatingCaseK, ElemK,
				m_bDC_Max, m_bDW_MAX, m_bTemp_Max, m_nConcurr,
				TRUE, bCheckIMax, bCheckJMax, dValIMax, dValJMax);

			pDoc->m_pPostCtrl->GetAnalysisResult()->GetRatingAASHTO19Result4ContourStress(m_SelRatingCaseK, ElemK,
				m_bDC_Max, m_bDW_MAX, m_bTemp_Max, m_nConcurr,
				FALSE, bCheckIMin, bCheckJMin, dValIMin, dValJMin);
		}
		else
		{
			ASSERT(0);
		}
		break;
	case ENUM_Flexure:
		if (m_nSign == 0)
		{
			pDoc->m_pPostCtrl->GetAnalysisResult()->GetRatingAASHTO19Result4ContourFlexure(m_SelRatingCaseK, ElemK,
				m_bDC_Max, m_bDW_MAX, m_bTemp_Max, m_nConcurr,
				TRUE, bCheckIMax, bCheckJMax, dValIMax, dValJMax);
		}
		else if (m_nSign == 1)
		{
			pDoc->m_pPostCtrl->GetAnalysisResult()->GetRatingAASHTO19Result4ContourFlexure(m_SelRatingCaseK, ElemK,
				m_bDC_Max, m_bDW_MAX, m_bTemp_Max, m_nConcurr,
				FALSE, bCheckIMin, bCheckJMin, dValIMin, dValJMin);
		}
		else if (m_nSign == 2)
		{
			pDoc->m_pPostCtrl->GetAnalysisResult()->GetRatingAASHTO19Result4ContourFlexure(m_SelRatingCaseK, ElemK,
				m_bDC_Max, m_bDW_MAX, m_bTemp_Max, m_nConcurr,
				TRUE, bCheckIMax, bCheckJMax, dValIMax, dValJMax);

			pDoc->m_pPostCtrl->GetAnalysisResult()->GetRatingAASHTO19Result4ContourFlexure(m_SelRatingCaseK, ElemK,
				m_bDC_Max, m_bDW_MAX, m_bTemp_Max, m_nConcurr,
				FALSE, bCheckIMin, bCheckJMin, dValIMin, dValJMin);
		}
		else
		{
			ASSERT(0);
		}
		break;
	case ENUM_Shear:
		if (m_nSign == 0)
		{
			pDoc->m_pPostCtrl->GetAnalysisResult()->GetRatingAASHTO19Result4ContourShear(m_SelRatingCaseK, ElemK,
				m_bDC_Max, m_bDW_MAX, m_bTemp_Max, m_nConcurr,
				TRUE, bCheckIMax, bCheckJMax, dValIMax, dValJMax);
		}
		else if (m_nSign == 1)
		{
			pDoc->m_pPostCtrl->GetAnalysisResult()->GetRatingAASHTO19Result4ContourShear(m_SelRatingCaseK, ElemK,
				m_bDC_Max, m_bDW_MAX, m_bTemp_Max, m_nConcurr,
				FALSE, bCheckIMin, bCheckJMin, dValIMin, dValJMin);
		}
		else if (m_nSign == 2)
		{
			pDoc->m_pPostCtrl->GetAnalysisResult()->GetRatingAASHTO19Result4ContourShear(m_SelRatingCaseK, ElemK,
				m_bDC_Max, m_bDW_MAX, m_bTemp_Max, m_nConcurr,
				TRUE, bCheckIMax, bCheckJMax, dValIMax, dValJMax);

			pDoc->m_pPostCtrl->GetAnalysisResult()->GetRatingAASHTO19Result4ContourShear(m_SelRatingCaseK, ElemK,
				m_bDC_Max, m_bDW_MAX, m_bTemp_Max, m_nConcurr,
				FALSE, bCheckIMin, bCheckJMin, dValIMin, dValJMin);
		}
		else
		{
			ASSERT(0);
		}
		break;
	case ENUM_Fatigue:
		if (m_bChkPosi[ENUM_TOP_TF] == TRUE)
		{
			pDoc->m_pPostCtrl->GetAnalysisResult()->GetRatingAASHTO19Result4ContourFatigue(m_SelRatingCaseK, ElemK,
				m_bDC_Max, m_bDW_MAX, m_bTemp_Max, m_nConcurr,
				ENUM_TOP_TF, bCheckTopTF_I, bCheckTopTF_J, dValTopTF_I, dValTopTF_J);
		}
		if (m_bChkPosi[ENUM_BOT_TF] == TRUE)
		{
			pDoc->m_pPostCtrl->GetAnalysisResult()->GetRatingAASHTO19Result4ContourFatigue(m_SelRatingCaseK, ElemK,
				m_bDC_Max, m_bDW_MAX, m_bTemp_Max, m_nConcurr,
				ENUM_BOT_TF, bCheckBotTF_I, bCheckBotTF_J, dValBotTF_I, dValBotTF_J);
		}
		if (m_bChkPosi[ENUM_TOP_BF] == TRUE)
		{
			pDoc->m_pPostCtrl->GetAnalysisResult()->GetRatingAASHTO19Result4ContourFatigue(m_SelRatingCaseK, ElemK,
				m_bDC_Max, m_bDW_MAX, m_bTemp_Max, m_nConcurr,
				ENUM_TOP_BF, bCheckTopBF_I, bCheckTopBF_J, dValTopBF_I, dValTopBF_J);
		}
		if (m_bChkPosi[ENUM_BOT_BF] == TRUE)
		{
			pDoc->m_pPostCtrl->GetAnalysisResult()->GetRatingAASHTO19Result4ContourFatigue(m_SelRatingCaseK, ElemK,
				m_bDC_Max, m_bDW_MAX, m_bTemp_Max, m_nConcurr,
				ENUM_BOT_BF, bCheckBotBF_I, bCheckBotBF_J, dValBotBF_I, dValBotBF_J);
		}
		break;
	default:
		ASSERT(0);
		break;
	}

	BOOL bCheckFatigue[8] = { bCheckTopTF_I, bCheckTopTF_J, bCheckBotTF_I, bCheckBotTF_J, bCheckTopBF_I, bCheckTopBF_J, bCheckBotBF_I, bCheckBotBF_J };

	BOOL bCheckFatiPosi = FALSE;

	switch (m_nSteelRatingRstType)
	{
	case ENUM_Flexure:
	case ENUM_Shear:
	case ENUM_Stress:
		if (!bCheckIMax && !bCheckJMax && !bCheckIMin && !bCheckJMin)
		{
			bCheckIMax = FALSE;
			bCheckJMax = FALSE;
			bCheckIMin = FALSE;
			bCheckJMin = FALSE;

			RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = 0.0;
			RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = 0.0;

			RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = 0.0;
			RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = 0.0;

			BrdgData.bBrdgDataI = FALSE;
			BrdgData.bBrdgDataJ = FALSE;
		}
		else
		{
			if (!bCheckIMax) dValIMax = 0.0;
			if (!bCheckJMax) dValJMax = 0.0;
			if (!bCheckIMin) dValIMin = 0.0;
			if (!bCheckJMin) dValJMin = 0.0;

			RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = dValIMax;
			RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = dValJMax;

			RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = dValIMin;
			RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = dValJMin;
		}
		m_mapbBrdgData.SetAt(ElemK, BrdgData);
		FinishMakingPscDsgnDataAASHTO19(RsltD, FALSE);
		break;
	case ENUM_Fatigue:
		for (int j = 0; j < 8; j++)
		{
			if (bCheckFatigue[j] == TRUE)
			{
				bCheckFatiPosi = TRUE;
				break;
			}
		}

		if (bCheckFatiPosi == FALSE)
		{
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = 0.0;
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = 0.0;

			RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = 0.0;
			RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = 0.0;

			RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = 0.0;
			RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = 0.0;

			RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = 0.0;
			RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = 0.0;

			BrdgData.bBrdgDataI = FALSE;
			BrdgData.bBrdgDataJ = FALSE;
		}
		else
		{
			if (!bCheckTopTF_I) dValTopTF_I = 0.0;
			if (!bCheckTopTF_J) dValTopTF_J = 0.0;
			if (!bCheckBotTF_I) dValBotTF_I = 0.0;
			if (!bCheckBotTF_J) dValBotTF_J = 0.0;
			if (!bCheckTopBF_I) dValTopBF_I = 0.0;
			if (!bCheckTopBF_J) dValTopBF_J = 0.0;
			if (!bCheckBotBF_I) dValBotBF_I = 0.0;
			if (!bCheckBotBF_J) dValBotBF_J = 0.0;

			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = dValTopTF_I;
			RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = dValTopTF_J;

			RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = dValBotTF_I;
			RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = dValBotTF_J;

			RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = dValTopBF_I;
			RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = dValTopBF_J;

			RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = dValBotBF_I;
			RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = dValBotBF_J;
		}
		m_mapbBrdgData.SetAt(ElemK, BrdgData);
		FinishMakingPscDsgnDataAASHTO19(RsltD, TRUE);
		break;
	default:
		ASSERT(0);
		break;
	}

	return TRUE;
}

int CDesignEngine::GetSteelRatingDrawType()
{
	I_GPSModel* gm = (I_GPSModel *)m_pGPSModel;
	if (!gm)
	{
		ASSERT(0);
		return -1;
	}

	if (gm->m_GPSMode != GPS_COMMAND_STEEL_RATING && gm->m_GPSMode != GPS_COMMAND_PSC_RATING && gm->m_GPSMode != GPS_COMMAND_RC_RATING)
	{
		ASSERT(0);
		return -1;
	}

	if (m_nRatingRstType == 0 || m_nRatingRstType == 1 || m_nRatingRstType == 2)
	{
		if (m_nSteelRatingRstType == 0 || m_nSteelRatingRstType == 1)
		{
			return 0;
		}
		else if (m_nSteelRatingRstType == 2)
		{
			return 1;
		}
	}
	else
	{
		ASSERT(0);
	}


	ASSERT(0);
	return -1;
}

void CDesignEngine::GetCurrentSteelRatingStr(CString &csVal)
{
	csVal.Empty();
	switch (m_nSteelRatingRstType)
	{
	case 0:	csVal = _T("Rating Factor");  break;
	case 1: csVal = _T("기본내하력");  break;
	case 2:	csVal = _T("공용내하력");  break;
	default:
		ASSERT(0);
	}
}

void CDesignEngine::GetCurrentSteelRatingAASHTOStr(CString &csVal)
{
	csVal.Empty();
	switch (m_nSteelRatingRstType)
	{
	case 0:	csVal = _T("Steel Stress");  break;
	case 1: csVal = _T("Flexure");       break;
	case 2:	csVal = _T("Shear");         break;
	case 3:	csVal = _T("Fatigue");       break;
	default:
		ASSERT(0);
	}
}


void CDesignEngine::GetCurrentSODStr(CString &csVal)
{
	csVal.Empty();
	switch (m_nSODResultType)
	{
	case 0:	csVal = _T("STRN.-Top Flange");  break;
	case 1: csVal = _T("STRN.-Bottom Flange");  break;
	case 2:	csVal = _T("STRN.-Web");  break;
	case 3:	csVal = _T("STAB.-Global Deck");  break;
	case 4:	csVal = _T("STAB.-Top Flange");  break;
	case 5: csVal = _T("STAB.-Bottom Flange");  break;
	case 6:	csVal = _T("STAB.-Web");  break;
	case 7:	csVal = _T("Fatigue");  break;
	default:
		ASSERT(0);
	}
}

//----------------------------------------------------------------------------------------
// INIT : 2006.06.20. by kyungha
// FUNC : Bridge Load Rating Result Diagram 정보를 가져옴
//----------------------------------------------------------------------------------------
BOOL CDesignEngine::BridgeLoadRateDgrmData(T_ELEM_K ElemK, T_PSC_DSGN_RESL_D RsltD[4])
{
	CDBDoc *pDoc = CDBDoc::GetDocPoint();
	// "999"로 값이 넘어오는 경우는 해석 결과가 없는 것이므로 FALSE로 설정하고 그외는 TRUE
	T_ISBRDG_D BrdgData;
	BrdgData.Initialize();
	BOOL bCheckIMax = FALSE, bCheckIMin = FALSE, bCheckJMax = FALSE, bCheckJMin = FALSE;

	if (fabs(m_nBrdgLoadRateLcIndex) > 1e-3)
	{
		CArray<T_BLRC_K, T_BLRC_K> arBlrcKey;
		pDoc->m_pAttrCtrl->GetBlrcKeyList(arBlrcKey);
		m_BlrcK = arBlrcKey[m_nBrdgLoadRateLcIndex - 1];
	}
	if (m_nBrdgLoadRateComp == 0)
	{
		m_nBrdgLoadRateComp = (m_nPSCPart == 0) ? BRDG_LOAD_RATE_CONC_STRS : BRDG_LOAD_RATE_CONC_STRS_SLAB; // m_nPSCPart 0 : Girder 1 : Slab
	}

	switch (m_nBrdgLoadRateComp)
	{
	case BRDG_LOAD_RATE_CONC_STRS:
		if (fabs(m_nBrdgLoadRateLcIndex) < 1e-3)
		{
			BOOL bPermit = FALSE;
			T_RTST_CASE	RtstCaseDMax;
			T_RTST_CASE	RtstCaseDMin;
			T_RTST_PERMIT_CASE RtstPermitCaseD;
			if (m_nDgnCode == AASHTO_LRFD19_PSC_RATING)
			{
				if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetStressRatingDataTable(ElemK, 1, RtstCaseDMax))
				{
					if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetStressRatingDataTable(ElemK, 3, RtstCaseDMax))
					{
						//이 부분은 Permit 이 들어가야 하는데 Permit은 Tension만 해당하기 때문에 이 부분을 비움
					}
				}

				if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetStressRatingDataTable(ElemK, 2, RtstCaseDMin))
				{
					if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetStressRatingDataTable(ElemK, 4, RtstCaseDMin))
					{
						bPermit = TRUE;
						if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetStressRatingDataPermitTable(ElemK, 5, RtstPermitCaseD)) return FALSE;
					}
				}

			}
			else
			{
				if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetStressRatingDataTable(ElemK, 1, RtstCaseDMax)) return FALSE;
				if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetStressRatingDataTable(ElemK, 2, RtstCaseDMin)) return FALSE;
			}

			if (bPermit == TRUE)
			{
				bCheckIMax = FALSE;
				bCheckJMax = FALSE;
				bCheckIMin = RtstPermitCaseD.RtstPermitBase[0].bChk;
				bCheckJMin = RtstPermitCaseD.RtstPermitBase[1].bChk;
				if (m_bPSCSignNeg)
				{
					if (RtstPermitCaseD.RtstPermitBase[0].dStressRatioMin == DGN_RAT_NOVAL)
					{
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = 0;		BrdgData.bBrdgDataI = FALSE;
					}
					else
					{
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = RtstPermitCaseD.RtstPermitBase[0].dStressRatioMin; // Min I 
					}

					if (RtstPermitCaseD.RtstPermitBase[1].dStressRatioMin == DGN_RAT_NOVAL)
					{
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = 0;		BrdgData.bBrdgDataJ = FALSE;
					}
					else
					{
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = RtstPermitCaseD.RtstPermitBase[1].dStressRatioMin; // Min J 		
					}
				}
			}
			else
			{
				bCheckIMax = RtstCaseDMax.RtstBase[0].bChk;
				bCheckJMax = RtstCaseDMax.RtstBase[1].bChk;
				bCheckIMin = RtstCaseDMin.RtstBase[0].bChk;
				bCheckJMin = RtstCaseDMin.RtstBase[1].bChk;

				//T_RTST_BASE RtstBase[2]	//  0=I-Position, 1=J-Position, 
				if (m_bPSCSignPos)
				{
					if (RtstCaseDMax.RtstBase[0].dRFmin == DGN_RAT_NOVAL)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = 0;		BrdgData.bBrdgDataI = FALSE;
					}
					else
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = RtstCaseDMax.RtstBase[0].dRFmin; // Max I

					if (RtstCaseDMax.RtstBase[1].dRFmin == DGN_RAT_NOVAL)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = 0;		BrdgData.bBrdgDataJ = FALSE;
					}
					else
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = RtstCaseDMax.RtstBase[1].dRFmin; // Max J 
				}
				if (m_bPSCSignNeg)
				{
					if (RtstCaseDMin.RtstBase[0].dRFmin == DGN_RAT_NOVAL)
					{
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = 0;		BrdgData.bBrdgDataI = FALSE;
					}
					else
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = RtstCaseDMin.RtstBase[0].dRFmin; // Min I 
					if (RtstCaseDMin.RtstBase[1].dRFmin == DGN_RAT_NOVAL)
					{
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = 0;		BrdgData.bBrdgDataJ = FALSE;
					}
					else
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = RtstCaseDMin.RtstBase[1].dRFmin; // Min J 		
				}
			}
		}
		else if (fabs(m_nBrdgLoadRateLcIndex) > 1e-3)
		{
			int nPart = 0;
			T_RTST_CASE	RtstCompD;
			T_RTST_CASE	RtstTensD;
			T_RTST_PERMIT_CASE	RtstPermD;
			BOOL bPermit = FALSE;
			if (m_nDgnCode == AASHTO_LRFD19_PSC_RATING)
			{
				if (!pDoc->m_pPostCtrl->GetAnalysisResult()->
					GetStressRatingSortData(ElemK, nPart, m_BlrcK, m_bDC_Max, m_bDW_MAX, m_bTemp_Max, RtstCompD, RtstTensD))
				{
					bPermit = TRUE;
					if (!pDoc->m_pPostCtrl->GetAnalysisResult()->
						GetStressRatingPermitSortData(ElemK, m_BlrcK, m_bDC_Max, m_bDW_MAX, m_bTemp_Max, RtstPermD)) return FALSE;
				}
			}
			else
			{
				if (!pDoc->m_pPostCtrl->GetAnalysisResult()->
					GetStressRatingSortData(ElemK, nPart, m_BlrcK, m_bDC_Max, m_bDW_MAX, m_bTemp_Max, RtstCompD, RtstTensD))	return FALSE;
			}

			if (bPermit == TRUE)
			{
				bCheckIMax = FALSE;
				bCheckJMax = FALSE;
				bCheckIMin = RtstPermD.RtstPermitBase[0].bChk;
				bCheckJMin = RtstPermD.RtstPermitBase[1].bChk;
				if (m_bPSCSignNeg)
				{
					if (RtstPermD.RtstPermitBase[0].dStressRatioMin == DGN_RAT_NOVAL)
					{
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = 0;		BrdgData.bBrdgDataI = FALSE;
					}
					else
					{
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = RtstPermD.RtstPermitBase[0].dStressRatioMin; // Min I 
					}

					if (RtstPermD.RtstPermitBase[1].dStressRatioMin == DGN_RAT_NOVAL)
					{
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = 0;		BrdgData.bBrdgDataJ = FALSE;
					}
					else
					{
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = RtstPermD.RtstPermitBase[1].dStressRatioMin; // Min J 
					}
				}
			}
			else
			{
				bCheckIMax = RtstCompD.RtstBase[0].bChk;
				bCheckJMax = RtstCompD.RtstBase[1].bChk;
				bCheckIMin = RtstTensD.RtstBase[0].bChk;
				bCheckJMin = RtstTensD.RtstBase[1].bChk;

				//T_RTST_BASE RtstBase[2]	//  0=I-Position, 1=J-Position, 
				if (m_bPSCSignPos)
				{
					if (RtstCompD.RtstBase[0].dRFmin == DGN_RAT_NOVAL)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = 0;		BrdgData.bBrdgDataI = FALSE;
					}
					else
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = RtstCompD.RtstBase[0].dRFmin; // Max I 
					if (RtstCompD.RtstBase[1].dRFmin == DGN_RAT_NOVAL)
					{
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = 0;		BrdgData.bBrdgDataJ = FALSE;
					}
					else
						RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = RtstCompD.RtstBase[1].dRFmin; // Max J  
				}
				if (m_bPSCSignNeg)
				{
					if (RtstTensD.RtstBase[0].dRFmin == DGN_RAT_NOVAL)
					{
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = 0;		BrdgData.bBrdgDataI = FALSE;
					}
					else
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = RtstTensD.RtstBase[0].dRFmin; // Min I 
					if (RtstTensD.RtstBase[1].dRFmin == DGN_RAT_NOVAL)
					{
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = 0;		BrdgData.bBrdgDataJ = FALSE;
					}
					else
						RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = RtstTensD.RtstBase[1].dRFmin; // Min J 
				}
			}
		}
		break;

	case BRDG_LOAD_RATE_CONC_STRS_SLAB:
		if (fabs(m_nBrdgLoadRateLcIndex) < 1e-3)
		{
			T_RTST_CASE	RtstCaseDMax;
			T_RTST_CASE	RtstCaseDMin;
			if (m_nDgnCode == AASHTO_LRFD19_PSC_RATING)
			{
				if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetSlabStressRatingDataTable(ElemK, 1, RtstCaseDMax))
				{
					if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetSlabStressRatingDataTable(ElemK, 3, RtstCaseDMax)) return FALSE;
				}

				if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetSlabStressRatingDataTable(ElemK, 2, RtstCaseDMin))
				{
					if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetSlabStressRatingDataTable(ElemK, 4, RtstCaseDMin)) return FALSE;
				}

			}
			else
			{
				if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetSlabStressRatingDataTable(ElemK, 1, RtstCaseDMax)) return FALSE;
				if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetSlabStressRatingDataTable(ElemK, 2, RtstCaseDMin)) return FALSE;
			}

			bCheckIMax = RtstCaseDMax.RtstBase[0].bChk;
			bCheckJMax = RtstCaseDMax.RtstBase[1].bChk;
			bCheckIMin = RtstCaseDMin.RtstBase[0].bChk;
			bCheckJMin = RtstCaseDMin.RtstBase[1].bChk;

			//T_RTST_BASE RtstBase[2]	//  0=I-Position, 1=J-Position, 
			if (m_bPSCSignPos)
			{
				if (RtstCaseDMax.RtstBase[0].dRFmin == DGN_RAT_NOVAL)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = 0;		BrdgData.bBrdgDataI = FALSE;
				}
				else
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = RtstCaseDMax.RtstBase[0].dRFmin; // Max I

				if (RtstCaseDMax.RtstBase[1].dRFmin == DGN_RAT_NOVAL)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = 0;		BrdgData.bBrdgDataJ = FALSE;
				}
				else
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = RtstCaseDMax.RtstBase[1].dRFmin; // Max J 
			}
			if (m_bPSCSignNeg)
			{
				if (RtstCaseDMin.RtstBase[0].dRFmin == DGN_RAT_NOVAL)
				{
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = 0;		BrdgData.bBrdgDataI = FALSE;
				}
				else
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = RtstCaseDMin.RtstBase[0].dRFmin; // Min I 
				if (RtstCaseDMin.RtstBase[1].dRFmin == DGN_RAT_NOVAL)
				{
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = 0;		BrdgData.bBrdgDataJ = FALSE;
				}
				else
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = RtstCaseDMin.RtstBase[1].dRFmin; // Min J 		
			}
		}
		else if (fabs(m_nBrdgLoadRateLcIndex) > 1e-3)
		{
			int nPart = 1;  // 0: Girder, 1: Slab
			T_RTST_CASE	RtstCompD;
			T_RTST_CASE	RtstTensD;
			if (!pDoc->m_pPostCtrl->GetAnalysisResult()->
				GetStressRatingSortData(ElemK, nPart, m_BlrcK, m_bDC_Max, m_bDW_MAX, m_bTemp_Max, RtstCompD, RtstTensD)) return FALSE;

			bCheckIMax = RtstCompD.RtstBase[0].bChk;
			bCheckJMax = RtstCompD.RtstBase[1].bChk;
			bCheckIMin = RtstTensD.RtstBase[0].bChk;
			bCheckJMin = RtstTensD.RtstBase[1].bChk;

			//T_RTST_BASE RtstBase[2]	//  0=I-Position, 1=J-Position, 
			if (m_bPSCSignPos)
			{
				if (RtstCompD.RtstBase[0].dRFmin == DGN_RAT_NOVAL)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = 0;		BrdgData.bBrdgDataI = FALSE;
				}
				else
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = RtstCompD.RtstBase[0].dRFmin; // Max I 
				if (RtstCompD.RtstBase[1].dRFmin == DGN_RAT_NOVAL)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = 0;		BrdgData.bBrdgDataJ = FALSE;
				}
				else
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = RtstCompD.RtstBase[1].dRFmin; // Max J  
			}
			if (m_bPSCSignNeg)
			{
				if (RtstTensD.RtstBase[0].dRFmin == DGN_RAT_NOVAL)
				{
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = 0;		BrdgData.bBrdgDataI = FALSE;
				}
				else
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = RtstTensD.RtstBase[0].dRFmin; // Min I 
				if (RtstTensD.RtstBase[1].dRFmin == DGN_RAT_NOVAL)
				{
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = 0;		BrdgData.bBrdgDataJ = FALSE;
				}
				else
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = RtstTensD.RtstBase[1].dRFmin; // Min J 
			}
		}
		break;


	case BRDG_LOAD_RATE_FLEXURE:
		if (fabs(m_nBrdgLoadRateLcIndex) < 1e-3)
		{
			T_RTBC_CASE RtbcCaseDMax;
			T_RTBC_CASE RtbcCaseDMin;

			if (m_nDgnCode == AASHTO_LRFD19_PSC_RATING)
			{
				if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetFlexuralStrengthRatingDataTable(ElemK, 1, RtbcCaseDMax))
				{
					if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetFlexuralStrengthRatingDataTable(ElemK, 3, RtbcCaseDMax))
					{
						if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetFlexuralStrengthRatingDataTable(ElemK, 5, RtbcCaseDMax)) return FALSE;
					}
				}
				if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetFlexuralStrengthRatingDataTable(ElemK, 2, RtbcCaseDMin))
				{
					if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetFlexuralStrengthRatingDataTable(ElemK, 4, RtbcCaseDMin))
					{
						if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetFlexuralStrengthRatingDataTable(ElemK, 6, RtbcCaseDMin)) return FALSE;
					}
				}
			}
			else
			{
				if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetFlexuralStrengthRatingDataTable(ElemK, 1, RtbcCaseDMax)) return FALSE;
				if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetFlexuralStrengthRatingDataTable(ElemK, 2, RtbcCaseDMin)) return FALSE;
			}

			bCheckIMax = RtbcCaseDMax.RtbcBase[0].bChk;
			bCheckJMax = RtbcCaseDMax.RtbcBase[1].bChk;
			bCheckIMin = RtbcCaseDMin.RtbcBase[0].bChk;
			bCheckJMin = RtbcCaseDMin.RtbcBase[1].bChk;

			//T_RTBC_BASE RtbcBase[2]	//  0=I-Position, 1=J-Position, 
			if (m_bPSCSignPos)
			{
				if (RtbcCaseDMax.RtbcBase[0].dRF == DGN_RAT_NOVAL)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = 0;		BrdgData.bBrdgDataI = FALSE;
				}
				else
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = RtbcCaseDMax.RtbcBase[0].dRF; // Max I 
				if (RtbcCaseDMax.RtbcBase[1].dRF == DGN_RAT_NOVAL)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = 0;		BrdgData.bBrdgDataJ = FALSE;
				}
				else
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = RtbcCaseDMax.RtbcBase[1].dRF; // Max J 
			}
			if (m_bPSCSignNeg)
			{
				if (RtbcCaseDMin.RtbcBase[0].dRF == DGN_RAT_NOVAL)
				{
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = 0; 		BrdgData.bBrdgDataI = FALSE;
				}
				else
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = RtbcCaseDMin.RtbcBase[0].dRF; // Min I 
				if (RtbcCaseDMin.RtbcBase[1].dRF == DGN_RAT_NOVAL)
				{
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = 0;		BrdgData.bBrdgDataJ = FALSE;
				}
				else
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = RtbcCaseDMin.RtbcBase[1].dRF; // Min J
			}
		}
		else if (fabs(m_nBrdgLoadRateLcIndex) > 1e-3)
		{
			T_RTBC_CASE RtbcPosiD;
			T_RTBC_CASE RtbcNagaD;
			if (!pDoc->m_pPostCtrl->GetAnalysisResult()->
				GetFlexuralStrengthRatingSortData(ElemK, m_BlrcK, m_bDC_Max, m_bDW_MAX, m_bTemp_Max, RtbcPosiD, RtbcNagaD)) return FALSE;

			bCheckIMax = RtbcPosiD.RtbcBase[0].bChk;
			bCheckJMax = RtbcPosiD.RtbcBase[1].bChk;
			bCheckIMin = RtbcNagaD.RtbcBase[0].bChk;
			bCheckJMin = RtbcNagaD.RtbcBase[1].bChk;

			//T_RTBC_BASE RtbcBase[2]	//  0=I-Position, 1=J-Position, 
			if (m_bPSCSignPos)
			{
				if (RtbcPosiD.RtbcBase[0].dRF == DGN_RAT_NOVAL)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = 0; 		BrdgData.bBrdgDataI = FALSE;
				}
				else
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = RtbcPosiD.RtbcBase[0].dRF; // Max I 
				if (RtbcPosiD.RtbcBase[1].dRF == DGN_RAT_NOVAL)
				{
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = 0;		BrdgData.bBrdgDataJ = FALSE;
				}
				else
					RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = RtbcPosiD.RtbcBase[1].dRF; // Max J 
			}
			if (m_bPSCSignNeg)
			{
				if (RtbcNagaD.RtbcBase[0].dRF == DGN_RAT_NOVAL)
				{
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = 0; 		BrdgData.bBrdgDataI = FALSE;
				}
				else
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = RtbcNagaD.RtbcBase[0].dRF; // Min I 
				if (RtbcNagaD.RtbcBase[1].dRF == DGN_RAT_NOVAL)
				{
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = 0;		BrdgData.bBrdgDataJ = FALSE;
				}
				else
					RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = RtbcNagaD.RtbcBase[1].dRF; // Min J 
			}
		}
		break;

	case BRDG_LOAD_RATE_SHEAR:
		if (fabs(m_nBrdgLoadRateLcIndex) < 1e-3)
		{
			T_RTSC_CASE RtscCaseD;

			if (m_nDgnCode == AASHTO_LRFD19_PSC_RATING)
			{
				if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetShearStrengthRatingDataTable(ElemK, 1, RtscCaseD))
				{
					if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetShearStrengthRatingDataTable(ElemK, 3, RtscCaseD))
					{
						if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetShearStrengthRatingDataTable(ElemK, 5, RtscCaseD)) return FALSE;
					}
				}
			}
			else
			{
				if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetShearStrengthRatingDataTable(ElemK, 1, RtscCaseD))	return FALSE;
			}

			bCheckIMax = RtscCaseD.RtscBase[0].bChk;
			bCheckJMax = RtscCaseD.RtscBase[1].bChk;

			//T_RTSC_BASE RtscBase[2]	//  0=I-Position, 1=J-Position, 
			if (RtscCaseD.RtscBase[0].dRF == DGN_RAT_NOVAL)
			{
				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = 0; 		BrdgData.bBrdgDataI = FALSE;
			}
			else
				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = RtscCaseD.RtscBase[0].dRF; // Max I 
			if (RtscCaseD.RtscBase[1].dRF == DGN_RAT_NOVAL)
			{
				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = 0;		BrdgData.bBrdgDataJ = FALSE;
			}
			else
				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = RtscCaseD.RtscBase[1].dRF; // Max J 
		}
		else if (fabs(m_nBrdgLoadRateLcIndex) > 1e-3)
		{
			T_RTSC_CASE RtscCaseD;
			if (!pDoc->m_pPostCtrl->GetAnalysisResult()->
				GetShearStrengthRatingSortData(ElemK, m_BlrcK, m_bDC_Max, m_bDW_MAX, m_bTemp_Max, RtscCaseD)) return FALSE;

			bCheckIMax = RtscCaseD.RtscBase[0].bChk;
			bCheckJMax = RtscCaseD.RtscBase[1].bChk;

			//T_RTSC_BASE RtscBase[2]	//  0=I-Position, 1=J-Position, 
			if (RtscCaseD.RtscBase[0].dRF == DGN_RAT_NOVAL)
			{
				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = 0; 		BrdgData.bBrdgDataI = FALSE;
			}
			else
				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = RtscCaseD.RtscBase[0].dRF; // Max I 
			if (RtscCaseD.RtscBase[1].dRF == DGN_RAT_NOVAL)
			{
				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = 0;		BrdgData.bBrdgDataJ = FALSE;
			}
			else
				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = RtscCaseD.RtscBase[1].dRF; // Max J 
		}
		break;
	case BRDG_LOAD_RATE_TENDON:
		T_RTTS_D RttsD;
		if (fabs(m_nBrdgLoadRateLcIndex) < 1e-3)
		{
			if (!pDoc->m_pPostCtrl->GetAnalysisResult()->GetTendonStressRatingDataTable(ElemK, RttsD))	return FALSE;

			bCheckIMax = RttsD.RttsBase[0].bChk;
			bCheckJMax = RttsD.RttsBase[1].bChk;

			//T_RTTS_BASE RttsBase[2] //  0=I-Position, 1=J-Position, 
			if (RttsD.RttsBase[0].dRF == DGN_RAT_NOVAL)
			{
				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = 0; 		BrdgData.bBrdgDataI = FALSE;
			}
			else
				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = RttsD.RttsBase[0].dRF; // Max I 
			if (RttsD.RttsBase[1].dRF == DGN_RAT_NOVAL)
			{
				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = 0;		BrdgData.bBrdgDataJ = FALSE;
			}
			else
				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = RttsD.RttsBase[1].dRF; // Max J 
		}
		else if (fabs(m_nBrdgLoadRateLcIndex) > 1e-3)
		{
			if (!pDoc->m_pPostCtrl->GetAnalysisResult()->
				GetTendonStressRatingSortData(ElemK, m_BlrcK, m_bDC_Max, m_bDW_MAX, m_bTemp_Max, RttsD)) return FALSE;

			bCheckIMax = RttsD.RttsBase[0].bChk;
			bCheckJMax = RttsD.RttsBase[1].bChk;

			//T_RTTS_BASE RttsBase[2] //  0=I-Position, 1=J-Position,
			if (RttsD.RttsBase[0].dRF == DGN_RAT_NOVAL)
			{
				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = 0; 		BrdgData.bBrdgDataI = FALSE;
			}
			else
				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = RttsD.RttsBase[0].dRF; // Max I
			if (RttsD.RttsBase[1].dRF == DGN_RAT_NOVAL)
			{
				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = 0;		BrdgData.bBrdgDataJ = FALSE;
			}
			else
				RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = RttsD.RttsBase[1].dRF; // Max J 
		}
		T_TENDON_D tendonD;
		if (MakeTendonNameList(RttsD, ElemK, tendonD)) m_mapTendonData.SetAt(ElemK, tendonD);
		break;
	}

	if (bCheckIMax == FALSE && bCheckJMax == TRUE)
	{
		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0] = RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1];
		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0] = RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1];
	}
	else if (bCheckIMax == TRUE && bCheckJMax == FALSE)
	{
		RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[3][1] = RsltD[PSC_DSGN_STRG_MAX_KEY].dValue[0][0];
		RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[3][1] = RsltD[PSC_DSGN_CRIT_MAX_KEY].dValue[0][0];
	}
	if (bCheckIMin == FALSE && bCheckJMin == TRUE)
	{
		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0] = RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1];
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0] = RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1];
	}
	else if (bCheckIMin == TRUE && bCheckJMin == FALSE)
	{
		RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[3][1] = RsltD[PSC_DSGN_STRG_MIN_KEY].dValue[0][0];
		RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[3][1] = RsltD[PSC_DSGN_CRIT_MIN_KEY].dValue[0][0];
	}

	m_mapbBrdgData.SetAt(ElemK, BrdgData);
	FinishMakingPscDsgnData(RsltD);
	return TRUE;
}

BOOL  CDesignEngine::MakeTendonNameList(T_RTTS_D RttsD, T_ELEM_K ElemK, T_TENDON_D &tendonD)
{
	CDBDoc *pDoc = CDBDoc::GetDocPoint();
	T_TDNA_D TdnaD1, TdnaD2;
	tendonD.Initialize();

	// I단 텐던 
	UINT TdnaK1 = RttsD.RttsBase[0].TdnaK;
	if (pDoc->m_pAttrCtrl->GetTdna(TdnaK1, TdnaD1))
		tendonD.TendonNameI = TdnaD1.TendonName;

	// J단 텐던 
	UINT TdnaK2 = RttsD.RttsBase[1].TdnaK;
	if (pDoc->m_pAttrCtrl->GetTdna(TdnaK2, TdnaD2))
		tendonD.TendonNameJ = TdnaD2.TendonName;

	if (TdnaD1.TendonName || TdnaD2.TendonName)
		tendonD.ElemK = ElemK;

	return TRUE;
}

void  CDesignEngine::GetCurrentBrdgCompStr(CString &csComp)
{
	csComp.Empty();
	switch (m_nBrdgLoadRateComp)
	{
	case BRDG_LOAD_RATE_CONC_STRS:	      csComp = _LSX(Con`c Stress(Girder));  break;
	case BRDG_LOAD_RATE_TENDON: 		      csComp = _LSX(Tendon);  break;
	case BRDG_LOAD_RATE_FLEXURE:		      csComp = _LSX(Flexure);  break;
	case BRDG_LOAD_RATE_SHEAR:			      csComp = _LSX(Shear);  break;
	case BRDG_LOAD_RATE_CONC_STRS_SLAB:   csComp = _LSX(Con`c Stress(Slab));  break;
	}
}

void  CDesignEngine::GetLoadString(CString &sLoadName)
{
	if (m_BrdgLoadRateLCName)
		sLoadName = m_BrdgLoadRateLCName;
	return;
}

//----------------------------------------------------------------------------------------
// INIT : 2006.06.30. by KYUNG_HA
// FUNC : Tendon Name 정보를 가져와서 출력
//----------------------------------------------------------------------------------------
void  CDesignEngine::DrawTendonData(CDC *pDC)
{
	BOOL		fl_bak, is_inverse;
	int			i, elem_num, slope;
	CString		TendonNameI, TendonNameJ;

	T_ELEM_K	ekey;
	T_ELEM_D	edata;
	T_TENDON_D tendonD;

	C3DPoint	node3D_i, node3D_j, DrawPoint, node3D[4];
	CPoint		text_p, node_2d_i, node_2d_j;
	CFont		  ft, *old_ft;

	CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray <CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					edge_list;
	POSITION pos;

	COLORREF NGColor;
	NGColor = RGB(255, 0, 0);

	I_GPSModel*gm = (I_GPSModel *)m_pGPSModel;
	CDBDoc		*pDoc = gm->GetDBDoc();
	if (!m_bDsgnDataSet)return;

	if (gm->m_DOPT.TX.m_bNumberOpaque)
		pDC->SetBkMode(OPAQUE);
	else
		pDC->SetBkMode(TRANSPARENT);

	pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
	pDC->SetBkColor(gm->m_DOPT.TX.m_NumberBackCol);
	pDC->SetTextAlign(TA_CENTER | TA_BOTTOM);

	BOOL bGrpFltMode = gm->m_pGPSCtrl->IsGroupFilterMode();
	if (!bGrpFltMode)elem_num = gm->m_EKeyListActive.GetSize();
	else            elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize();

	for (i = 0; i < elem_num; i++)
	{
		if (!bGrpFltMode)ekey = gm->m_EKeyListActive[i];
		else            ekey = gm->m_pDispFilter->m_aGrpEKey[i];

		if (!gm->m_pGPSCtrl->IsActiveElem(ekey)) continue; // Lable Hidden 처리를 위해 추가 
		pDoc->m_pAttrCtrl->GetElem(ekey, edata);

		if (!m_mapTendonData.Lookup(ekey, tendonD)) continue; // 텐던 결과가 있는 요소만 필터링

		fl_bak = gm->m_DOPT.DR.m_bFrameLine;
		gm->m_DOPT.DR.m_bFrameLine = TRUE;
		gm->GetShapeElement(ekey, polygon_list, &edge_list);
		gm->m_DOPT.DR.m_bFrameLine = fl_bak;

		if (edata.eltyp != WALL_EL)
		{
			pos = polygon_list[0]->GetHeadPosition();
			node3D_i = polygon_list[0]->GetNext(pos);
			node3D_j = polygon_list[0]->GetNext(pos);
		}
		else	continue;

		for (int j = 0; j < polygon_list.GetSize(); j++)
		{
			polygon_list[j]->RemoveAll();
			delete polygon_list[j];
			edge_list[j]->RemoveAll();
			delete edge_list[j];
		}
		polygon_list.RemoveAll();
		edge_list.RemoveAll();

		if (gm->m_bVirtualMode)
		{
			node_2d_i = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_i);
			node_2d_j = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_j);
		}
		else
		{
			node_2d_i = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_i);
			node_2d_j = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_j);
		}
		if (node_2d_i.x < 0 || node_2d_i.y < 0) continue;
		if (node_2d_j.x < 0 || node_2d_j.y < 0) continue;
		slope = (int)(atan2(node_2d_i.y - node_2d_j.y, node_2d_j.x - node_2d_i.x)*1800.0 / 3.14159);
		slope = (slope + 3600) % 3600;
		if ((900 < slope) && (slope <= 2700)) {
			is_inverse = TRUE;
			slope = (slope + 1800) % 3600;
		}
		else {
			is_inverse = FALSE;
		}

		gm->SetNumberFontOrientation(slope);
		ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
		old_ft = (CFont *)pDC->SelectObject(&ft);

		if (ekey == tendonD.ElemK)
		{
			TendonNameI = tendonD.TendonNameI;
			TendonNameJ = tendonD.TendonNameJ;

			if (TendonNameI)
			{
				if (!pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorI))
					pDC->SetTextColor(NGColor);
				if (is_inverse)pDC->SetTextAlign(TA_RIGHT | TA_BOTTOM);
				else				  pDC->SetTextAlign(TA_LEFT | TA_BOTTOM);

				text_p.x = (int)node_2d_i.x;
				text_p.y = (int)node_2d_i.y;
				//text_str.Format(fmt_str, TendonNameI);
				pDC->TextOut(text_p.x, text_p.y, TendonNameI);
			}
			if (TendonNameJ)
			{
				if (!pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorJ))
					pDC->SetTextColor(NGColor);
				if (is_inverse) pDC->SetTextAlign(TA_LEFT | TA_BOTTOM);
				else						pDC->SetTextAlign(TA_RIGHT | TA_BOTTOM);

				text_p.x = (int)node_2d_j.x;
				text_p.y = (int)node_2d_j.y;
				//text_str.Format(fmt_str, TendonNameJ);
				pDC->TextOut(text_p.x, text_p.y, TendonNameJ);
			}
		}
		pDC->SelectObject(old_ft);
		ft.DeleteObject();
	}
}

#if defined(__OLD_OUTPUT_VALUE)
void CDesignEngine::OutputSlabDesignNumbers(CDC *pDC)
{
	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;

	int			  i, j, elem_num, node_in_elem, v_num;
	T_ELEM_K	ekey;
	T_ELEM_D	edata;
	T_GPS_SLAB_DESIGN_RESULT	pforc;
	C3DPoint	node[4], DrawPt;
	CPoint		text_p;
	TCHAR		  fmt_str[10], text_str[512];
	CFont		  ft, *old_ft;

	BOOL		fl_bak;
	POSITION	pos;
	CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray <CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					edge_list;

	if (!m_bDsgnDataSet)
		return;

	if (gm->m_DOPT.TX.m_bNumberOpaque)
		pDC->SetBkMode(OPAQUE);
	else
		pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
	pDC->SetBkColor(gm->m_DOPT.TX.m_NumberBackCol);
	pDC->SetTextAlign(TA_CENTER | TA_BOTTOM);

	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T("%s%de"), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T("%s%df"), _T("%."), gm->m_NumberDecimalPoint);

	fl_bak = gm->m_DOPT.DR.m_bFrameLine;
	gm->m_DOPT.DR.m_bFrameLine = TRUE;

	BOOL bUseReBar = FALSE;
	switch (gm->m_GPSMode)
	{
	case GPS_COMMAND_SHELL_DGN:
	{
		if (m_nRebarRatio == 5 && m_nXDirYDir != 2) { bUseReBar = TRUE; }
	}
	break;
	case GPS_COMMAND_SHELL_CHK:
	{
		if (m_nRebarRatio == 7 && m_nXDirYDir != 2) { bUseReBar = TRUE; }
	}
	break;
	case GPS_COMMAND_SLAB_DGN:
	case GPS_COMMAND_SLAB_CHK:
	case GPS_COMMAND_WALL_DGN:
	case GPS_COMMAND_WALL_CHK:
	{
		if (m_nRebarRatio == 0 && m_nXDirYDir != 2) { bUseReBar = TRUE; }
	}
	break;
	default:
		break;
	}

	gm->SetNumberFontOrientation(0);
	ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
	old_ft = (CFont *)pDC->SelectObject(&ft);

	BOOL bGrpFltMode = gm->m_pGPSCtrl->IsGroupFilterMode();
	if (!bGrpFltMode)elem_num = gm->m_EKeyListActive.GetSize();
	else            elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize();

	for (i = 0; i < elem_num; i++)
	{
		if (!bGrpFltMode)ekey = gm->m_EKeyListActive[i];
		else            ekey = gm->m_pDispFilter->m_aGrpEKey[i];

		if (!gm->m_pGPSCtrl->IsActiveElem(ekey))
			continue;

		m_pDoc->m_pAttrCtrl->GetElem(ekey, edata);
		if (!m_pDoc->m_pAttrCtrl->IsPlate(edata.eltyp)) continue;

		node_in_elem = m_pDoc->m_pAttrCtrl->GetNumNode(edata.eltyp, edata.elnod);
		gm->GetShapeElement(ekey, polygon_list, &edge_list);

		v_num = polygon_list[0]->GetCount();
		pos = polygon_list[0]->GetHeadPosition();
		for (j = 0; j < v_num; j++)
			node[j] = polygon_list[0]->GetNext(pos);

		if (!m_mapSDRData.Lookup(ekey, pforc))
		{
			for (j = 0; j < polygon_list.GetSize(); j++)
			{
				polygon_list[j]->RemoveAll();
				delete polygon_list[j];
				edge_list[j]->RemoveAll();
				delete edge_list[j];
			}
			polygon_list.RemoveAll();
			edge_list.RemoveAll();

			continue; //KYE-HONG-20020515
		}

		for (j = 0; j < v_num - 1; j++)
		{
			node[v_num - 1].x += node[j].x;
			node[v_num - 1].y += node[j].y;
			node[v_num - 1].z += node[j].z;
		}

		DrawPt.x = (node[v_num - 1].x / ((double)v_num));
		DrawPt.y = (node[v_num - 1].y / ((double)v_num));
		DrawPt.z = (node[v_num - 1].z / ((double)v_num));

		double dMaxPForc = GetMaxSDRForc(pforc, node_in_elem);
		double dMinPForc = GetMinSDRForc(pforc, node_in_elem);
		double dAbsMaxPForc = (fabs(dMaxPForc) > fabs(dMinPForc)) ? dMaxPForc : dMinPForc;

		/////////////////////////////////////////////////////////////////////////////////////////////
		if (!bUseReBar && gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
		{
			double dLimit = (m_dMaxValue - m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;
			switch (gm->m_DOPT.TX.m_nOutputMinMaxType)
			{
			case 0: // Min & Max
				if ((m_dMaxValue - dMaxPForc) <= dLimit)
					DrawMinMaxOutputValue(pDC, DrawPt, fmt_str, 0, dMaxPForc);
				else if ((dMinPForc - m_dMinValue) <= dLimit)
					DrawMinMaxOutputValue(pDC, DrawPt, fmt_str, 1, dMinPForc);
				break;
			case 1: // Abs Max
				if (fabs(m_dMaxValue) >= fabs(m_dMinValue))
				{
					if (fabs(m_dMaxValue) - fabs(dAbsMaxPForc) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPt, fmt_str, 2, dAbsMaxPForc);
				}
				else
				{
					if (fabs(m_dMinValue) - fabs(dAbsMaxPForc) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPt, fmt_str, 2, dAbsMaxPForc);
				}
				break;
			case 2: // Max
				if ((m_dMaxValue - dMaxPForc) <= dLimit)
					DrawMinMaxOutputValue(pDC, DrawPt, fmt_str, 0, dMaxPForc);
				break;
			case 3: // Min
				if ((dMinPForc - m_dMinValue) <= dLimit)
					DrawMinMaxOutputValue(pDC, DrawPt, fmt_str, 1, dMinPForc);
				break;
			}
		}
		else // output all values;
		{
			if (gm->m_bVirtualMode)
				text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(DrawPt);
			else
				text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(DrawPt);

			if (text_p.x >= 0 && text_p.y >= 0)
			{
				if (bUseReBar)// Rebar
				{
					CString sRebar;
					sRebar = GetRebarStrbyAsValue(dAbsMaxPForc);
					pDC->TextOut(text_p.x, text_p.y + 10, sRebar);
				}
				else
				{
					_stprintf(text_str, fmt_str, dAbsMaxPForc);
					pDC->TextOut(text_p.x, text_p.y + 10, text_str);
				}
			}
		}

		for (j = 0; j < polygon_list.GetSize(); j++)
		{
			polygon_list[j]->RemoveAll();
			delete polygon_list[j];
			edge_list[j]->RemoveAll();
			delete edge_list[j];
		}
		polygon_list.RemoveAll();
		edge_list.RemoveAll();
	}

	pDC->SelectObject(old_ft);
	ft.DeleteObject();
	gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}
#else
void CDesignEngine::OutputSlabDesignNumbers(CDC* pDC)
{
	I_GPSModel* gm = (I_GPSModel*)m_pGPSModel;

	int			  i, j, elem_num, node_in_elem, v_num;
	T_ELEM_K	ekey;
	T_ELEM_D	edata;
	T_GPS_SLAB_DESIGN_RESULT	pforc;
	C3DPoint	node[4], DrawPt;
	CPoint		text_p;
	TCHAR		  fmt_str[10], text_str[512];

	BOOL		fl_bak;
	POSITION	pos;
	CArray <CList <C3DPoint, C3DPoint>*, CList <C3DPoint, C3DPoint>*>		polygon_list;
	CArray <CArray <BOOL, BOOL>*, CArray <BOOL, BOOL>*>					edge_list;

	if (!m_bDsgnDataSet)
		return;


	GPostTextOut TextOutModel;
	TextOutModel.SetDC(pDC);
	TextOutModel.StartSlabVal();
	TextOutModel.SettingSlab(gm);

	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T("%s%de"), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T("%s%df"), _T("%."), gm->m_NumberDecimalPoint);

	fl_bak = gm->m_DOPT.DR.m_bFrameLine;
	gm->m_DOPT.DR.m_bFrameLine = TRUE;

	BOOL bUseReBar = FALSE;
	switch (gm->m_GPSMode)
	{
	case GPS_COMMAND_SHELL_DGN:
	{
		if (m_nRebarRatio == 5 && m_nXDirYDir != 2) { bUseReBar = TRUE; }
	}
	break;
	case GPS_COMMAND_SHELL_CHK:
	{
		if (m_nRebarRatio == 7 && m_nXDirYDir != 2) { bUseReBar = TRUE; }
	}
	break;
	case GPS_COMMAND_SLAB_DGN:
	case GPS_COMMAND_SLAB_CHK:
	case GPS_COMMAND_WALL_DGN:
	case GPS_COMMAND_WALL_CHK:
	{
		if (m_nRebarRatio == 0 && m_nXDirYDir != 2) { bUseReBar = TRUE; }
	}
	break;
	default:
		break;
	}

	TextOutModel.Font4Slab(gm, 0);

	BOOL bGrpFltMode = gm->m_pGPSCtrl->IsGroupFilterMode();
	if (!bGrpFltMode)elem_num = gm->m_EKeyListActive.GetSize();
	else            elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize();

	for (i = 0; i < elem_num; i++)
	{
		if (!bGrpFltMode)ekey = gm->m_EKeyListActive[i];
		else            ekey = gm->m_pDispFilter->m_aGrpEKey[i];

		if (!gm->m_pGPSCtrl->IsActiveElem(ekey))
			continue;

		m_pDoc->m_pAttrCtrl->GetElem(ekey, edata);
		if (!m_pDoc->m_pAttrCtrl->IsPlate(edata.eltyp)) continue;

		node_in_elem = m_pDoc->m_pAttrCtrl->GetNumNode(edata.eltyp, edata.elnod);
		gm->GetShapeElement(ekey, polygon_list, &edge_list);

		v_num = polygon_list[0]->GetCount();
		pos = polygon_list[0]->GetHeadPosition();
		for (j = 0; j < v_num; j++)
			node[j] = polygon_list[0]->GetNext(pos);

		if (!m_mapSDRData.Lookup(ekey, pforc))
		{
			for (j = 0; j < polygon_list.GetSize(); j++)
			{
				polygon_list[j]->RemoveAll();
				delete polygon_list[j];
				edge_list[j]->RemoveAll();
				delete edge_list[j];
			}
			polygon_list.RemoveAll();
			edge_list.RemoveAll();

			continue; //KYE-HONG-20020515
		}

		for (j = 0; j < v_num - 1; j++)
		{
			node[v_num - 1].x += node[j].x;
			node[v_num - 1].y += node[j].y;
			node[v_num - 1].z += node[j].z;
		}

		DrawPt.x = (node[v_num - 1].x / ((double)v_num));
		DrawPt.y = (node[v_num - 1].y / ((double)v_num));
		DrawPt.z = (node[v_num - 1].z / ((double)v_num));

		double dMaxPForc = GetMaxSDRForc(pforc, node_in_elem);
		double dMinPForc = GetMinSDRForc(pforc, node_in_elem);
		double dAbsMaxPForc = (fabs(dMaxPForc) > fabs(dMinPForc)) ? dMaxPForc : dMinPForc;

		/////////////////////////////////////////////////////////////////////////////////////////////
		if (!bUseReBar && gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
		{
			double dLimit = (m_dMaxValue - m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;
			switch (gm->m_DOPT.TX.m_nOutputMinMaxType)
			{
			case 0: // Min & Max
				if ((m_dMaxValue - dMaxPForc) <= dLimit)
					DrawMinMaxOutputValue(pDC, DrawPt, fmt_str, 0, dMaxPForc);
				else if ((dMinPForc - m_dMinValue) <= dLimit)
					DrawMinMaxOutputValue(pDC, DrawPt, fmt_str, 1, dMinPForc);
				break;
			case 1: // Abs Max
				if (fabs(m_dMaxValue) >= fabs(m_dMinValue))
				{
					if (fabs(m_dMaxValue) - fabs(dAbsMaxPForc) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPt, fmt_str, 2, dAbsMaxPForc);
				}
				else
				{
					if (fabs(m_dMinValue) - fabs(dAbsMaxPForc) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPt, fmt_str, 2, dAbsMaxPForc);
				}
				break;
			case 2: // Max
				if ((m_dMaxValue - dMaxPForc) <= dLimit)
					DrawMinMaxOutputValue(pDC, DrawPt, fmt_str, 0, dMaxPForc);
				break;
			case 3: // Min
				if ((dMinPForc - m_dMinValue) <= dLimit)
					DrawMinMaxOutputValue(pDC, DrawPt, fmt_str, 1, dMinPForc);
				break;
			}
		}
		else // output all values;
		{
			if (gm->m_bVirtualMode)
				text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(DrawPt);
			else
				text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(DrawPt);

			if (text_p.x >= 0 && text_p.y >= 0)
			{
				if (bUseReBar)// Rebar
				{
					CString sRebar;
					sRebar = GetRebarStrbyAsValue(dAbsMaxPForc);
					TextOutModel.TextOutSlab(text_p.x, text_p.y + 10, NULL, sRebar);
				}
				else
				{
					_stprintf(text_str, fmt_str, dAbsMaxPForc);
					TextOutModel.TextOutSlab(text_p.x, text_p.y + 10, text_str, _T('A'));
				}
			}
		}

		for (j = 0; j < polygon_list.GetSize(); j++)
		{
			polygon_list[j]->RemoveAll();
			delete polygon_list[j];
			edge_list[j]->RemoveAll();
			delete edge_list[j];
		}
		polygon_list.RemoveAll();
		edge_list.RemoveAll();
	}

	TextOutModel.DeleteFont();
	TextOutModel.EndSlabVal();
	gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}
#endif

#if defined(__OLD_OUTPUT_VALUE)
void CDesignEngine::OutputSlabOnewayDesignNumbers(CDC* pDC)
{
	if (!m_bOnCuttingLine || m_OnewayResPosition.GetCount() == 0) return;
	I_GPSModel* gm = (I_GPSModel*)m_pGPSModel;

	T_UNIT_INDEX UnitIndex;
	m_pDoc->m_pUnitCtrl->GetUnitIndexCurrent(UnitIndex);

	CPoint	 pnt2D;
	CBrush	 brush, * old_brush;
	CPen		 pen, * old_pen;
	CRect rect, client_rect;
	CString sRatioValue;
	int nWidth;
	if (!gm->m_bVirtualMode)
	{
		gm->m_pMyView->GetClientRect(&client_rect);
		nWidth = client_rect.Width() / 60.0;
	}
	else
		nWidth = (int)((double)pDC->GetDeviceCaps(LOGPIXELSX)) * 0.15;

	pen.CreatePen(PS_SOLID, gm->m_nLineWidth, gm->m_DOPT.TX.m_NumberTextColorC);
	brush.CreateSolidBrush(gm->m_DOPT.TX.m_NumberTextColorC);

	old_pen = (CPen*)pDC->SelectObject(&pen);
	old_brush = (CBrush*)pDC->SelectObject(&brush);

	POSITION pos = m_OnewayResPosition.GetStartPosition();
	CString sCheckLineName = _T("");
	T_RSL1_D result; result.Initialize();
	T_NODE_D pPnt;   pPnt.Initialize();
	UINT nChkLineKey;
	C3DPoint point3D;
	while (pos)
	{
		m_OnewayResPosition.GetNextAssoc(pos, nChkLineKey, pPnt);
		m_OnewaySlabResData.Lookup(nChkLineKey, result);

		point3D.x = pPnt.x;
		point3D.y = pPnt.y;
		point3D.z = pPnt.z;

		DrawPoint(pDC, point3D, (double)nWidth / 2.5);

		if (gm->m_bVirtualMode)
			pnt2D = gm->m_pGPSCtrl->GetWorldToWindowP2D(point3D);
		else
			pnt2D = gm->m_pGPSCtrl->GetWorldToMemDCP2D(point3D);

		pDC->MoveTo(pnt2D);
		pDC->LineTo(pnt2D.x + nWidth * 1.5, pnt2D.y + nWidth * 1.5);
		pDC->LineTo(pnt2D.x + nWidth * 2.5, pnt2D.y + nWidth * 1.5);

		pnt2D.x = pnt2D.x + nWidth * 2.75;
		pnt2D.y = pnt2D.y + nWidth * 1.5;
		CString sValue;
		if (gm->m_GPSMode == GPS_COMMAND_SHELL_DGN || gm->m_GPSMode == GPS_COMMAND_SHELL_CHK || gm->m_GPSMode == GPS_COMMAND_SHELL_SHEAR_CHK)
		{
			ASSERT(0); // CuttingLine 지원 안함
			sValue = _T("");
		}
		else
		{
			switch (m_nRebarRatio)
			{
			case 0:// Rebar
				sValue.Format(_LS(IDS_WG_GPS___Rebar__s), result.Rebar.strInfo);
				OutputOneWayCheckValue(pDC, pnt2D, sCheckLineName, sValue);
				break;
			case 1:// As 
				if (gm->m_GPSMode == GPS_COMMAND_SLAB_DGN)
				{
					result.dAsReq *= CDBLib::GetAs2Factor(UnitIndex.nBase_Length);
					sValue.Format(_T(" %s:%.4g"), _LS(IDS_WG_GPS__Asreq), result.dAsReq);
				}
				else if (gm->m_GPSMode == GPS_COMMAND_SLAB_CHK)
				{
					result.dAsUse *= CDBLib::GetAs2Factor(UnitIndex.nBase_Length);
					sValue.Format(_LS(IDS_WG_GPS___As___4g), result.dAsUse);
				}
				else
					ASSERT(0);
				OutputOneWayCheckValue(pDC, pnt2D, sCheckLineName, sValue);
				break;
			case 2:// As Ratio
				if (gm->m_GPSMode == GPS_COMMAND_SLAB_DGN)
				{
					sValue.Format(_T(" %s:%.4g"), _LS(IDS_WG_GPS__Rho_req), result.dRhoReq);
					OutputOneWayCheckValue(pDC, pnt2D, sCheckLineName, sValue, TRUE, result.dRhoReq);
				}
				else if (gm->m_GPSMode == GPS_COMMAND_SLAB_CHK)
				{
					sValue.Format(_T(" %s:%.4g"), _LS(IDS_WG_GPS__Rho), result.dRhoUse);
					OutputOneWayCheckValue(pDC, pnt2D, sCheckLineName, sValue, TRUE, result.dRhoUse);
				}
				break;
			case 3: // x/d
			{
				const double dXD = (m_nXDType == 0) ? result.dRatXd : result.GetXDRatioToLimit();
				sValue.Format(_T(" %s:%.4g"), _LS(IDS_WG_GPS__Ratio_x_d), dXD);
				OutputOneWayCheckValue(pDC, pnt2D, sCheckLineName, sValue, TRUE, dXD);
			}
			break;
			case 4: // Resistance Ratio 
			{
				sValue.Format(_T(" %s:%.4g"), _LS(IDS_WG_GPS__Resistance_Ratio), result.dRatM);
				OutputOneWayCheckValue(pDC, pnt2D, sCheckLineName, sValue, TRUE, result.dRatM);
			}
			break;
			}
		}
	}

	pDC->SelectObject(old_pen);
	pDC->SelectObject(old_brush);
	pen.DeleteObject();
	brush.DeleteObject();

	//   pDC->SelectObject(old_ft);
	//   ft.DeleteObject();
	//   gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}
#else
void CDesignEngine::OutputSlabOnewayDesignNumbers(CDC *pDC)
{
	if (!m_bOnCuttingLine || m_OnewayResPosition.GetCount() == 0) return;
	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;

	T_UNIT_INDEX UnitIndex;
	m_pDoc->m_pUnitCtrl->GetUnitIndexCurrent(UnitIndex);

	CPoint	 pnt2D;
	CBrush	 brush, *old_brush;
	CPen		 pen, *old_pen;
	CRect rect, client_rect;
	CString sRatioValue;
	int nWidth;
	if (!gm->m_bVirtualMode)
	{
		gm->m_pMyView->GetClientRect(&client_rect);
		nWidth = client_rect.Width() / 60.0;
	}
	else
		nWidth = (int)((double)pDC->GetDeviceCaps(LOGPIXELSX))*0.15;

	pen.CreatePen(PS_SOLID, gm->m_nLineWidth, gm->m_DOPT.TX.m_NumberTextColorC);
	brush.CreateSolidBrush(gm->m_DOPT.TX.m_NumberTextColorC);

	old_pen = (CPen*)pDC->SelectObject(&pen);
	old_brush = (CBrush*)pDC->SelectObject(&brush);

	POSITION pos = m_OnewayResPosition.GetStartPosition();
	CString sCheckLineName = _T("");
	T_RSL1_D result; result.Initialize();
	T_NODE_D pPnt;   pPnt.Initialize();
	UINT nChkLineKey;
	C3DPoint point3D;
	GPostTextOut TextOutModel;
	TextOutModel.SetDC(pDC);
	TextOutModel.StartSlabOneWayVal();
	while (pos)
	{
		m_OnewayResPosition.GetNextAssoc(pos, nChkLineKey, pPnt);
		m_OnewaySlabResData.Lookup(nChkLineKey, result);

		point3D.x = pPnt.x;
		point3D.y = pPnt.y;
		point3D.z = pPnt.z;

		DrawPoint(pDC, point3D, (double)nWidth / 2.5);

		if (gm->m_bVirtualMode)
			pnt2D = gm->m_pGPSCtrl->GetWorldToWindowP2D(point3D);
		else
			pnt2D = gm->m_pGPSCtrl->GetWorldToMemDCP2D(point3D);

		pDC->MoveTo(pnt2D);
		pDC->LineTo(pnt2D.x + nWidth * 1.5, pnt2D.y + nWidth * 1.5);
		pDC->LineTo(pnt2D.x + nWidth * 2.5, pnt2D.y + nWidth * 1.5);

		pnt2D.x = pnt2D.x + nWidth * 2.75;
		pnt2D.y = pnt2D.y + nWidth * 1.5;

		CString sValue;
		if (gm->m_GPSMode == GPS_COMMAND_SHELL_DGN || gm->m_GPSMode == GPS_COMMAND_SHELL_CHK || gm->m_GPSMode == GPS_COMMAND_SHELL_SHEAR_CHK)
		{
			ASSERT(0); // CuttingLine 지원 안함
			sValue = _T("");
		}
		else
		{
			
			switch (m_nRebarRatio)
			{
			case 0:// Rebar
				sValue.Format(_LS(IDS_WG_GPS___Rebar__s), result.Rebar.strInfo);
				TextOutModel.TextOutOneWay(gm, pnt2D, sCheckLineName, sValue);
				break;
			case 1:// As 
				if (gm->m_GPSMode == GPS_COMMAND_SLAB_DGN)
				{
					result.dAsReq *= CDBLib::GetAs2Factor(UnitIndex.nBase_Length);
					sValue.Format(_T(" %s:%.4g"), _LS(IDS_WG_GPS__Asreq), result.dAsReq);
				}
				else if (gm->m_GPSMode == GPS_COMMAND_SLAB_CHK)
				{
					result.dAsUse *= CDBLib::GetAs2Factor(UnitIndex.nBase_Length);
					sValue.Format(_LS(IDS_WG_GPS___As___4g), result.dAsUse);
				}
				else
					ASSERT(0);
				TextOutModel.TextOutOneWay(gm, pnt2D, sCheckLineName, sValue);
				break;
			case 2:// As Ratio
				if (gm->m_GPSMode == GPS_COMMAND_SLAB_DGN)
				{
					sValue.Format(_T(" %s:%.4g"), _LS(IDS_WG_GPS__Rho_req), result.dRhoReq);
					TextOutModel.TextOutOneWay(gm, pnt2D, sCheckLineName, sValue, TRUE, result.dRhoReq);
				}
				else if (gm->m_GPSMode == GPS_COMMAND_SLAB_CHK)
				{
					sValue.Format(_T(" %s:%.4g"), _LS(IDS_WG_GPS__Rho), result.dRhoUse);
					TextOutModel.TextOutOneWay(gm, pnt2D, sCheckLineName, sValue, TRUE, result.dRhoUse);
				}
				break;
			case 3: // x/d
			{
				const double dXD = (m_nXDType == 0) ? result.dRatXd : result.GetXDRatioToLimit();
				sValue.Format(_T(" %s:%.4g"), _LS(IDS_WG_GPS__Ratio_x_d), dXD);
				TextOutModel.TextOutOneWay(gm, pnt2D, sCheckLineName, sValue, TRUE, dXD);
			}
			break;
			case 4: // Resistance Ratio 
			{
				sValue.Format(_T(" %s:%.4g"), _LS(IDS_WG_GPS__Resistance_Ratio), result.dRatM);
				TextOutModel.TextOutOneWay(gm, pnt2D, sCheckLineName, sValue, TRUE, result.dRatM);
			}
			break;
			}
		}
	}
	TextOutModel.EndSlabOneWayVal();
	pDC->SelectObject(old_pen);
	pDC->SelectObject(old_brush);
	pen.DeleteObject();
	brush.DeleteObject();

	//   pDC->SelectObject(old_ft);
	//   ft.DeleteObject();
	//   gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}
#endif

void CDesignEngine::DrawSlabDesignContour(CDC *pDC)
{
	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;
	T_MIRE_K mkey;

	int			i, elem_num;
	BOOL		fl_bak = gm->m_DOPT.DR.m_bFrameLine;
	T_ELEM_D	elem_d;
	CPen		elem_pen, *old_pen;
	CArray <int, int>				type_list;
	CArray <GRE_Atom, GRE_Atom&>		atom_list;
	BOOL bEscapePressed = FALSE;

	if (!gm->m_bContour && !m_bOnCuttingLine) {
		gm->GPSDrawOriginal(pDC);
		return;
	}

	BOOL bCrack = FALSE;
	if (m_nMode == 2 && m_nDeflection == 1 && m_bCrackPoint) bCrack = TRUE;

	type_list.Add(gm->m_MinOTID + OBJECT_TYPE_ORIGINAL);

	elem_pen.CreatePen(PS_SOLID, gm->m_DOPT.DR.nElemHddn, m_pContourEngine->m_ElemColor);
	old_pen = (CPen *)pDC->SelectObject(&elem_pen);

	gm->m_pGPSCtrl->GetZSortedList(type_list, gm->m_EKeyListVisible_Mirror, atom_list);
	elem_num = atom_list.GetSize();
	for (i = 0; i < elem_num; i++)
	{
		if (gm->m_pGPSCtrl->WatchEscKeyPress())
		{
			gm->m_DOPT.DR.m_bFrameLine = fl_bak;
			pDC->SelectObject(old_pen);
			elem_pen.DeleteObject();
			return;
		}

		if (gm->m_pGPSCtrl->IsZoomAllState() ||
			gm->m_pGPSCtrl->IsObjectInClientWindow(atom_list[i].m_OType, atom_list[i].m_OKey))
		{
			mkey.keymap = atom_list[i].m_OKey;
			m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d);

			if (gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey) &&
				(m_pDoc->m_pAttrCtrl->IsPlate(elem_d.eltyp) || m_pDoc->m_pAttrCtrl->IsPlstrs(elem_d.eltyp)) &&
				!bEscapePressed)
			{
				gm->m_DOPT.DR.m_bFrameLine = fl_bak;
				DoSlabDesignResultContour(pDC, atom_list[i].m_OKey);
				if (bCrack)DrawCrackPoint(pDC, atom_list[i].m_OKey);
			}
			else
			{
				//KYE-HONG-20020903 Hidden처리되게 해달라고 함 
				//if (bVectorMode)  gm->m_bFrameLine = TRUE;		// Vector를 그릴 경우 Hidden을 끈다.
				//else              gm->m_bFrameLine = fl_bak;
				gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
			}
		}
	}

	gm->m_DOPT.DR.m_bFrameLine = fl_bak;

	pDC->SelectObject(old_pen);
	elem_pen.DeleteObject();

	if (m_bOnCuttingLine)
	{
		gm->m_pGPSCtrl->XGL_Begin_CuttingPLDiagram();
		DrawCuttingLineDiagrams(pDC);
		gm->m_pGPSCtrl->XGL_End_CuttingPLDiagram();
		/*
		T_UNIT_INDEX UnitIndex;
		m_pDoc->m_pUnitCtrl->GetUnitIndexCurrent(UnitIndex);

		CPoint	 pnt2D;
		CBrush	 brush,*old_brush;
		CPen		 pen,*old_pen;
		CRect rect,client_rect;
		CString sRatioValue;
		int nWidth;
		if(!gm->m_bVirtualMode)
		{
		gm->m_pMyView->GetClientRect(&client_rect);
		nWidth = client_rect.Width()/60.0;
		}
		else
		nWidth = (int) ((double) pDC->GetDeviceCaps(LOGPIXELSX))*0.15;

		gm->m_pGPSCtrl->XGL_Begin_CuttingPLDiagram();
		DrawCuttingLineDiagrams(pDC);
		gm->m_pGPSCtrl->XGL_End_CuttingPLDiagram();

		pen.CreatePen(PS_SOLID,gm->m_nLineWidth,gm->m_DOPT.TX.m_NumberTextColorC);
		brush.CreateSolidBrush(gm->m_DOPT.TX.m_NumberTextColorC);

		old_pen = (CPen*)pDC->SelectObject(&pen);
		old_brush = (CBrush*)pDC->SelectObject(&brush);

		POSITION pos = m_OnewayResPosition.GetStartPosition();
		CString sCheckLineName=_T("");
		T_RSL1_D result; result.Initialize();
		T_NODE_D pPnt;   pPnt.Initialize();
		UINT nChkLineKey;
		C3DPoint point3D;
		while(pos)
		{
		m_OnewayResPosition.GetNextAssoc(pos,nChkLineKey,pPnt);
		m_OnewaySlabResData.Lookup(nChkLineKey,result);

		point3D.x = pPnt.x;
		point3D.y = pPnt.y;
		point3D.z = pPnt.z;

		DrawPoint(pDC,point3D,nWidth/2.5);

		if (gm->m_bVirtualMode)
		pnt2D = gm->m_pGPSCtrl->GetWorldToWindowP2D(point3D);
		else
		pnt2D = gm->m_pGPSCtrl->GetWorldToMemDCP2D(point3D);

		pDC->MoveTo(pnt2D);
		pDC->LineTo(pnt2D.x+nWidth*1.5,pnt2D.y+nWidth*1.5);
		pDC->LineTo(pnt2D.x+nWidth*2.5,pnt2D.y+nWidth*1.5);

		pnt2D.x = pnt2D.x+nWidth*2.75;
		pnt2D.y = pnt2D.y+nWidth*1.5;
		CString sValue;
		switch(m_nRebarRatio)
		{
		case 0:// Rebar
		sValue.Format(_LS(IDS_WG_GPS___Rebar__s),result.strRebar);
		OutputOneWayCheckValue(pDC,pnt2D,sCheckLineName,sValue);
		break;
		case 1:// As
		result.dAsReq *= CDBLib::GetAs2Factor(UnitIndex.nBase_Length);
		sValue.Format(_LS(IDS_WG_GPS___Req_As___4g),result.dAsReq);
		OutputOneWayCheckValue(pDC,pnt2D,sCheckLineName,sValue);
		break;
		case 2:// Ratio
		sValue.Format(_LS(IDS_WG_GPS___Ratio___4g),result.dRatM);
		OutputOneWayCheckValue(pDC,pnt2D,sCheckLineName,sValue,TRUE,result.dRatM);
		break;
		}
		}

		pDC->SelectObject(old_pen);
		pDC->SelectObject(old_brush);
		pen.DeleteObject();
		brush.DeleteObject();
		*/
	}
}

void CDesignEngine::DoSlabDesignResultContour(CDC *pDC, T_ELEM_K ekey)
{
	I_GPSModel		*gm = (I_GPSModel *)m_pGPSModel;

	int				i, j, poly_num, vtx_num, node_in_elem;
	double		pforc_val[4];
	BOOL			ef[4];
	T_ELEM_D	elem_d;
	T_GPS_SLAB_DESIGN_RESULT	pforc;

	CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray <CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>			        		edge_list;
	CArray <CArray <T_NODE_K, T_NODE_K> *, CArray <T_NODE_K, T_NODE_K> *>	VertexNode;

	if (m_pContourEngine == NULL) return;

	if (!m_mapSDRData.Lookup(ekey, pforc))
	{
		gm->GPSDrawInactiveElement(pDC, ekey);
		return;
	}

	// 1. 요소의 형상정보를 얻는다.
	m_pDoc->m_pAttrCtrl->GetElem(ekey, elem_d);
	node_in_elem = m_pDoc->m_pAttrCtrl->GetNumNode(elem_d.eltyp, elem_d.elnod);
	gm->GetShapeElement(ekey, polygon_list, &edge_list, NULL, &VertexNode);

	gm->GPS_XGL_Begin_Elem(ekey, elem_d);

	poly_num = polygon_list.GetSize();
	for (i = 0; i < poly_num; i++)
	{
		vtx_num = polygon_list[i]->GetCount();
		if (vtx_num == 2)
			continue;

		if (poly_num > 1 && !gm->m_DOPT.DR.m_bFrameLine &&  gm->m_DOPT.DR.m_bPlaneThick && !gm->IsVisibleFace(polygon_list[i], vtx_num))
			continue;

		// Fill+Outline의 경우 Contour를 수행하기 전의 Polygon의 Outline을 그림.// Line Only 일경우는 먼저그린다.
		if ((gm->m_DOPT.DR.m_RenderFlag == 3 || gm->m_DOPT.DR.m_RenderFlag == 2) && m_pContourEngine->m_nContourFill == 1)
		{
			gm->DrawPolygon3DFill(pDC, *(polygon_list[i]), *(edge_list[i]), gm->m_DOPT.CL.m_ClientBackColor);
			gm->GPSDrawPolygonEdge(pDC, polygon_list[i], edge_list[i]);
		}

		if (gm->m_bContour)
		{
			for (j = 0; j < vtx_num; j++)
			{
				int nNodeOrder = GetNodeOrder(VertexNode[i]->GetAt(j), elem_d, node_in_elem);
				if (nNodeOrder >= vtx_num) { ASSERT(0); break; }
				pforc_val[j] = pforc.dValue[nNodeOrder];
				ef[j] = edge_list[i]->GetAt(j);
			}
			DoSubPolyContour(pDC, pforc_val, polygon_list[i], ef, FALSE);
		}

		// Fill+Outline의 경우 Contour를 수행하기 전의 Polygon의 Outline을 그림. Fill Type
		if ((gm->m_DOPT.DR.m_RenderFlag == 3 || gm->m_DOPT.DR.m_RenderFlag == 2) && m_pContourEngine->m_nContourFill == 0)
			gm->GPSDrawPolygonEdge(pDC, polygon_list[i], edge_list[i]);

	}
	gm->GPS_XGL_End_Elem();
	FreeMemoryPolyList(&polygon_list, &edge_list, &VertexNode);
}

BOOL CDesignEngine::MakeSlabMaxAsMapULS(const T_KEY_LIST& aElemK, OUT CArray<CString, CString&>& raRebarString, OUT CMap<int, int, double, double&>& rmMaxAsuse)
{
	rmMaxAsuse.RemoveAll();
	rmMaxAsuse.InitHashTable(HASHSIZEELEM);

	raRebarString.RemoveAll();

	CDesignResult* pDgnRslt = m_pDoc->m_pPostCtrl->GetDesignResult();
	if (pDgnRslt == nullptr) { return FALSE; }

	CMap<CString, LPCTSTR, int, int> mRebarString;
	mRebarString.InitHashTable(HASHSIZEELEM);

	CString strRebar = "";
	double dRebar = 0.0;
	double dSpace = 0.0;

	INT_PTR nElem = aElemK.GetSize();

	// make rebar string 
	for (INT_PTR i = 0; i < nElem; ++i)
	{
		const T_ELEM_K ElemK = aElemK[i];
		const BOOL bBasicRebar = IsExistBasicBar(ElemK);

		T_RSL2_D Rsl2D;
		if (!pDgnRslt->Get_2waySlabResult(ElemK, m_nXDirYDir, Rsl2D)) { continue; }

		for (INT_PTR j = 0; j < Rsl2D.iNodeNum; ++j)
		{
			if (!CalcRebarValue(Rsl2D, j, strRebar, dRebar, dSpace, bBasicRebar)) { continue; }

			if (strRebar.GetLength() == 0 || fabs(dSpace) < 1.e-7) { continue; }

			int nTemp = 0;
			if (!mRebarString.Lookup(strRebar, nTemp))
			{
				mRebarString.SetAt(strRebar, nTemp);
				raRebarString.Add(strRebar);
			}
		}
	}

	// rebar 별로 max값을 저장
	double dTempRebar = 0.0;
	INT_PTR nSize = raRebarString.GetSize();

	for (INT_PTR i = 0; i < nElem; ++i)
	{
		const T_ELEM_K ElemK = aElemK[i];
		const BOOL bBasicRebar = IsExistBasicBar(ElemK);

		T_RSL2_D Rsl2D;
		if (!pDgnRslt->Get_2waySlabResult(ElemK, m_nXDirYDir, Rsl2D))
		{
			continue;
		}

		for (INT_PTR j = 0; j < Rsl2D.iNodeNum; ++j)
		{
			if (!CalcRebarValue(Rsl2D, j, strRebar, dRebar, dSpace, bBasicRebar)) { continue; }
			for (INT_PTR k = 0; k < nSize; ++k)
			{
				if (strRebar.CompareNoCase(raRebarString[k]) == 0)
				{
					if (!rmMaxAsuse.Lookup(k, dTempRebar))
					{
						rmMaxAsuse.SetAt(k, dRebar);
					}
					else
					{
						if (dTempRebar < dRebar)
						{
							rmMaxAsuse.SetAt(k, dRebar);
						}
					}
					break;
				}
			}
		}
	}

	return TRUE;
}

BOOL CDesignEngine::MakeSlabMaxAsMapELS(const T_KEY_LIST& aElemK, OUT CArray<CString, CString&>& raRebarString, OUT CMap<int, int, double, double&>& rmMaxAsuse)
{
	rmMaxAsuse.RemoveAll();
	rmMaxAsuse.InitHashTable(HASHSIZEELEM);

	raRebarString.RemoveAll();

	CDesignResult* pDgnRslt = m_pDoc->m_pPostCtrl->GetDesignResult();
	if (pDgnRslt == nullptr) { return FALSE; }

	CMap<CString, LPCTSTR, int, int> mRebarString;
	mRebarString.InitHashTable(HASHSIZEELEM);

	CString strRebar = _T("");
	double dRebar = 0.0;
	double dSpace = 0.0;

	INT_PTR nElem = aElemK.GetSize();

	// make rebar string 
	for (INT_PTR i = 0; i < nElem; ++i)
	{
		const T_ELEM_K ElemK = aElemK[i];
		const BOOL bBasicRebar = IsExistBasicBar(ElemK);

		T_RSLE_D RsleD;
		if (!pDgnRslt->Get_SlabNDResult(ElemK, m_nXDirYDir, RsleD)) { continue; }

		for (INT_PTR j = 0; j < RsleD.nNodeNum; ++j)
		{
			if (!CalcRebarValue(RsleD, j, strRebar, dRebar, dSpace, bBasicRebar)) { continue; }

			if (strRebar.GetLength() == 0 || fabs(dSpace) < 1.e-7) { continue; }

			int nTemp = 0;
			if (!mRebarString.Lookup(strRebar, nTemp))
			{
				mRebarString.SetAt(strRebar, nTemp);
				raRebarString.Add(strRebar);
			}
		}
	}

	// rebar 별로 max값을 저장
	double dTempRebar = 0.0;
	INT_PTR nSize = raRebarString.GetSize();

	for (INT_PTR i = 0; i < nElem; ++i)
	{
		const T_ELEM_K ElemK = aElemK[i];
		const BOOL bBasicRebar = IsExistBasicBar(ElemK);

		T_RSLE_D RsleD;
		if (!pDgnRslt->Get_SlabNDResult(ElemK, m_nXDirYDir, RsleD))
		{
			continue;
		}

		for (INT_PTR j = 0; j < RsleD.nNodeNum; ++j)
		{
			if (!CalcRebarValue(RsleD, j, strRebar, dRebar, dSpace, bBasicRebar)) { continue; }
			for (INT_PTR k = 0; k < nSize; ++k)
			{
				if (strRebar.CompareNoCase(raRebarString[k]) == 0)
				{
					if (!rmMaxAsuse.Lookup(k, dTempRebar))
					{
						rmMaxAsuse.SetAt(k, dRebar);
					}
					else
					{
						if (dTempRebar < dRebar)
						{
							rmMaxAsuse.SetAt(k, dRebar);
						}
					}
					break;
				}
			}
		}
	}

	return TRUE;
}

BOOL CDesignEngine::MakeSlabSDRMapULS(const T_KEY_LIST& aElemK, T_KEY unLcaseK, OUT double& rdMax, OUT double& rdMin,
	OUT int& rMaxElemK, OUT int& rMinElemK, OUT T_GPS_SLAB_DESIGN_RESULT_MAP& rmSDR)
{
	rdMax = -DBL_MAX;
	rdMin = DBL_MAX;
	rMaxElemK = 0;
	rMinElemK = 0;
	rmSDR.RemoveAll();

	BOOL bHasContent = FALSE;

	BOOL bCodeCH = CDBLib::IsCodeForMeshedDesignCH();
	CDesignResult* pDgnRslt = m_pDoc->m_pPostCtrl->GetDesignResult();

	T_SLAB_FORCE_COMPACT SlabForce;
	T_GPS_SLAB_DESIGN_RESULT SdrtD;
	T_RSL2_D Rsl2D;
	double dVal = 0.0;

	INT_PTR nElem = aElemK.GetSize();
	for (INT_PTR i = 0; i < nElem; ++i)
	{
		SlabForce.initialize();
		SdrtD.Initialize();
		Rsl2D.Initialize();

		const T_ELEM_K ElemK = aElemK[i];

		if (m_nRebarRatio == 5 && unLcaseK != 0 && bCodeCH == FALSE) // wood armer moment
		{
			if (!pDgnRslt->Get_SlabForce(ElemK, m_nXDirYDir, SlabForce)) continue;
			T_ELEM_D ElemD;
			if (!m_pDoc->m_pAttrCtrl->GetElem(ElemK, ElemD)) continue;
			for (int jj = 0; jj < 4; jj++)
			{
				if (ElemD.elnod != 0)  Rsl2D.iNodeNum++;
			}
		}
		else
		{
			if (!pDgnRslt->Get_2waySlabResult(ElemK, m_nXDirYDir, Rsl2D)) continue;
		}

		for (INT_PTR j = 0; j < Rsl2D.iNodeNum; ++j)
		{
			if (m_nRebarRatio == 5 && unLcaseK != 0 && bCodeCH == FALSE)
			{
				switch (m_nPosi)
				{
				case 0:
				{
					dVal = SlabForce.dForce[j + 4];
					break;
				}
				case 1:
				{
					dVal = SlabForce.dForce[j];
					break;
				}
				case 2:
				{
					double dVal1 = fabs(SlabForce.dForce[j]);
					double dVal2 = fabs(SlabForce.dForce[j + 4]);
					dVal = (dVal1 - dVal2 > 0.0) ? SlabForce.dForce[j] : SlabForce.dForce[j + 4];
					break;
				}
				default: ASSERT(0);
					break;
				}
			}
			else
			{
				dVal = CalcSDRValue(Rsl2D, j, m_nPosi, m_nRebarRatio);
			}

			SdrtD.nNodeNum = Rsl2D.iNodeNum;
			SdrtD.dValue[j] = dVal;

			if (rdMin > dVal)
			{
				rdMin = dVal;
				rMinElemK = ElemK;
			}
			if (rdMax < dVal)
			{
				rdMax = dVal;
				rMaxElemK = ElemK;
			}
		}

		rmSDR.SetAt(ElemK, SdrtD);

		bHasContent = TRUE;
	}
	return bHasContent;
}

BOOL CDesignEngine::MakeSlabSDRMapELS(const T_KEY_LIST& aElemK, T_KEY unLcaseK, OUT double& rdMax, OUT double& rdMin,
	OUT int& rMaxElemK, OUT int& rMinElemK, OUT T_GPS_SLAB_DESIGN_RESULT_MAP& rmSDR)
{
	rdMax = -DBL_MAX;
	rdMin = DBL_MAX;
	rMaxElemK = 0;
	rMinElemK = 0;
	rmSDR.RemoveAll();

	BOOL bHasContent = FALSE;

	CDesignResult* pDgnRslt = m_pDoc->m_pPostCtrl->GetDesignResult();

	T_SLAB_FORCE_COMPACT SlabForce;
	T_GPS_SLAB_DESIGN_RESULT SdrtD;
	T_RSLE_D RsleD;
	double dVal = 0.0;

	INT_PTR nElem = aElemK.GetSize();
	for (INT_PTR i = 0; i < nElem; ++i)
	{
		SlabForce.initialize();
		SdrtD.Initialize();
		RsleD.Initialize();

		const T_ELEM_K ElemK = aElemK[i];

		if (m_nRebarRatio == 5 && unLcaseK != 0) // wood armer moment
		{
			if (!pDgnRslt->Get_SlabForce(ElemK, m_nXDirYDir, SlabForce)) continue;
			T_ELEM_D ElemD;
			if (!m_pDoc->m_pAttrCtrl->GetElem(ElemK, ElemD)) continue;
			for (int jj = 0; jj < 4; jj++)
			{
				if (ElemD.elnod != 0)  RsleD.nNodeNum++;
			}
		}
		else
		{
			if (!pDgnRslt->Get_SlabNDResult(ElemK, m_nXDirYDir, RsleD)) continue;
		}

		for (INT_PTR j = 0; j < RsleD.nNodeNum; ++j)
		{
			if (m_nRebarRatio == 5 && unLcaseK != 0)
			{
				switch (m_nPosi)
				{
				case 0:
				{
					dVal = SlabForce.dForce[j + 4];
					break;
				}
				case 1:
				{
					dVal = SlabForce.dForce[j];
					break;
				}
				case 2:
				{
					double dVal1 = fabs(SlabForce.dForce[j]);
					double dVal2 = fabs(SlabForce.dForce[j + 4]);
					dVal = (dVal1 - dVal2 > 0.0) ? SlabForce.dForce[j] : SlabForce.dForce[j + 4];
					break;
				}
				default: ASSERT(0);
					break;
				}
			}
			else
			{
				dVal = CalcSDRValue(RsleD, j, m_nPosi, m_nRebarRatio);
			}

			SdrtD.nNodeNum = RsleD.nNodeNum;
			SdrtD.dValue[j] = dVal;

			if (rdMin > dVal)
			{
				rdMin = dVal;
				rMinElemK = ElemK;
			}
			if (rdMax < dVal)
			{
				rdMax = dVal;
				rMaxElemK = ElemK;
			}
		}

		rmSDR.SetAt(ElemK, SdrtD);

		bHasContent = TRUE;
	}
	return bHasContent;
}

BOOL CDesignEngine::IsExistBasicBar(T_ELEM_K ElemK)
{
	T_MSRB_D MsrbD;
	if (!m_pDoc->m_pAttrCtrl->GetMsrb(MsrbD))
	{
		m_pDoc->m_pMatlDB->InitializeMsrb(MsrbD);
	}

	T_DOEL_D DoelD;
	if (!m_pDoc->m_pAttrCtrl->GetDoel(ElemK, DoelD)) { ASSERT(0); return FALSE; }
	if (DoelD.nDomainType != 1) { ASSERT(0); return FALSE; }

	T_SBDO_D SbdoD;
	if (!m_pDoc->m_pAttrCtrl->GetSbdo(DoelD.KeyDomain, SbdoD)) { ASSERT(0); return FALSE; }

	return (SbdoD.bBasicRebar || MsrbD.bBasicRebar) ? TRUE : FALSE;
}

BOOL CDesignEngine::MakeSlabSDRMapShrAdh(const T_KEY_LIST& aElemK, T_KEY unLcaseK, OUT double& rdMax, OUT double& rdMin,
	OUT int& rMaxElemK, OUT int& rMinElemK, OUT T_GPS_SLAB_DESIGN_RESULT_MAP& rmSDR)
{
	rdMax = -DBL_MAX;
	rdMin = DBL_MAX;
	rMaxElemK = 0;
	rMinElemK = 0;
	rmSDR.RemoveAll();

	CDesignResult* pDgnRslt = m_pDoc->m_pPostCtrl->GetDesignResult();

	T_GPS_SLAB_DESIGN_RESULT SdrtD;
	BOOL bHasContent = FALSE;

	const INT_PTR nElem = aElemK.GetSize();
	for (INT_PTR i = 0; i < nElem; ++i)
	{
		const T_ELEM_K ElemK = aElemK[i];
		T_RSSA_D RssaD;
		if (!pDgnRslt->Get_SlabShrAdhJPResult(ElemK, m_nXDirYDir, RssaD)) { continue; }

		SdrtD.Initialize();
		for (INT_PTR j = 0; j < RssaD.nNodeNum; ++j)
		{
			const double dVal = CalcSDRValue(RssaD, j, m_nRebarRatio);

			SdrtD.nNodeNum = RssaD.nNodeNum;
			SdrtD.dValue[j] = dVal;

			if (rdMin > dVal)
			{
				rdMin = dVal;
				rMinElemK = ElemK;
			}
			if (rdMax < dVal)
			{
				rdMax = dVal;
				rMaxElemK = ElemK;
			}
		}

		rmSDR.SetAt(ElemK, SdrtD);

		bHasContent = TRUE;
	}
	return bHasContent;
}

BOOL CDesignEngine::MakeSlabDesignDataList()
{
	I_GPSModel *gm = (I_GPSModel *)m_pGPSModel;
	if (!gm->m_bLoadDataSet)return FALSE;

	BOOL   has_content = FALSE;
	double max_val = -DBL_MAX;
	double min_val = DBL_MAX;
	double len = 0.0;

	m_mapSDRData.RemoveAll();
	m_aRebarStringList.RemoveAll();
	m_aRebarAsList.RemoveAll();

	int nStrSize = -1;
	if (m_bSlabDgnResult)
	{
		GetActivePlateList();

		if (m_nRebarRatio == 0)
		{
			T_MSRB_D MsrbD;
			if (!m_pDoc->m_pAttrCtrl->GetMsrb(MsrbD))
			{
				m_pDoc->m_pMatlDB->InitializeMsrb(MsrbD);
			}

			CMap<int, int, double, double&> mapMaxValue; mapMaxValue.InitHashTable(HASHSIZEELEM);
			CArray<CString, CString&> aRebarString;

			if (m_pDoc->IsNTC2018() && m_nULSnELS)
			{
				MakeSlabMaxAsMapELS(m_PlateKeyList, aRebarString, mapMaxValue);
			}
			else
			{
				MakeSlabMaxAsMapULS(m_PlateKeyList, aRebarString, mapMaxValue);
			}

			CArray<int, int> aIndex;
			int nTemp = 0;
			int nIndex = 0;

			INT_PTR nSize = aRebarString.GetSize();
			for (INT_PTR i = 0; i < nSize; ++i)
			{
				double dTempRebar = 0.0;
				mapMaxValue.Lookup(i, dTempRebar);
				m_aRebarAsList.Add(dTempRebar);
				aIndex.Add(i);
			}

			CQSort::QSortDblWithIndex(aIndex.GetData(), m_aRebarAsList.GetData(), m_aRebarAsList.GetSize());
			for (INT_PTR i = 0; i < aIndex.GetSize(); ++i)
			{
				m_aRebarStringList.Add(aRebarString[aIndex[i]]);
			}

			CString strRebar = _T("None");
			double dRebar = 0.0;
			m_aRebarStringList.InsertAt(0, strRebar);
			m_aRebarAsList.InsertAt(0, dRebar);

			if (m_aRebarStringList.GetSize() > 24 || m_aRebarStringList.GetSize() <= 0) { ASSERT(0); return FALSE; }
		}

		if (m_pDoc->IsNTC2018() && m_nULSnELS)
		{
			has_content = MakeSlabSDRMapELS(m_PlateKeyList, gm->m_LoadCaseKey, max_val, min_val, gm->m_nLgdMaxValKey, gm->m_nLgdMinValKey, m_mapSDRData);
		}
		else
		{
			has_content = MakeSlabSDRMapULS(m_PlateKeyList, gm->m_LoadCaseKey, max_val, min_val, gm->m_nLgdMaxValKey, gm->m_nLgdMinValKey, m_mapSDRData);
		}
	}

	if (nStrSize == 0)
		has_content = FALSE;

	if (m_bOnCuttingLine)
		MakeOneWayMomentCheckData();

	if (!has_content)
	{
		min_val = max_val = 0.0;
		gm->m_nLgdMaxValKey = 0;
		gm->m_nLgdMinValKey = 0;
		m_mapSDRData.RemoveAll();
	}
	m_dMaxValue = max_val;
	m_dMinValue = min_val;

	if (m_nRebarRatio == 0 && has_content) // Rebar string
	{
		if (m_pContourEngine == NULL)
		{
			m_pContourEngine = new CContourEngine;
			m_pContourEngine->MakeRankMap_Rebar(m_aRebarStringList, m_aRebarAsList);
		}
		else
			m_pContourEngine->MakeRankMap_Rebar(m_aRebarStringList, m_aRebarAsList);
	}
	else
	{
		if (m_pContourEngine == NULL)
			m_pContourEngine = new CContourEngine(min_val, max_val);
		else
			m_pContourEngine->MakeRankMap(min_val, max_val);
	}

	m_bDsgnDataSet = TRUE;
	gm->m_pMyView->EndWaitCursor();
	return TRUE;
}

BOOL CDesignEngine::MakeSlabShrAdhDataList()
{
	I_GPSModel *gm = (I_GPSModel *)m_pGPSModel;
	if (!gm->m_bLoadDataSet) { return FALSE; }

	BOOL   has_content = FALSE;
	double max_val = -DBL_MAX;
	double min_val = DBL_MAX;

	m_mapSDRData.RemoveAll();
	if (m_bSlabDgnResult)
	{
		GetActivePlateList();
		has_content = MakeSlabSDRMapShrAdh(m_PlateKeyList, gm->m_LoadCaseKey, max_val, min_val, gm->m_nLgdMaxValKey, gm->m_nLgdMinValKey, m_mapSDRData);
	}

	if (!has_content)
	{
		min_val = max_val = 0.0;
		gm->m_nLgdMaxValKey = 0;
		gm->m_nLgdMinValKey = 0;
		m_mapSDRData.RemoveAll();
	}

	m_dMaxValue = max_val;
	m_dMinValue = min_val;

	CArray<CString, CString&> acsDgnInput;
	CArray<double, double&>   adDgnInput;
	bool bDgnInput = GetDgnInputByValue(m_mapSDRData, acsDgnInput, adDgnInput);

	if (m_pContourEngine == NULL)
	{
		m_pContourEngine = new CContourEngine();
		if (bDgnInput)
		{
			m_pContourEngine->MakeRankMap_Rebar(acsDgnInput, adDgnInput);
		}
		else
		{
			m_pContourEngine->MakeRankMap(min_val, max_val);
		}
	}
	else
	{
		if (bDgnInput)
		{
			m_pContourEngine->MakeRankMap_Rebar(acsDgnInput, adDgnInput);
		}
		else
		{
			m_pContourEngine->MakeRankMap(min_val, max_val);
		}
	}

	m_bDsgnDataSet = TRUE;
	gm->m_pMyView->EndWaitCursor();
	return TRUE;
}

bool CDesignEngine::GetDgnInputByValue(const T_GPS_SLAB_DESIGN_RESULT_MAP& mSDRData, CArray<CString, CString&>& racsDgnInput, CArray<double, double&>& radDgnInput)
{
	racsDgnInput.RemoveAll();
	radDgnInput.RemoveAll();
	if (mSDRData.IsEmpty()) { ASSERT(0); return false; }

	auto L_IsDgnInputItem = [](int nItem) -> bool
	{
		switch (nItem)
		{
		case 2: // [ iGen ] Meshed Slab Shear Check : wft
		case 3: // [ iGen ] Meshed Slab Shear Check : pw
			return true;
		}
		return false;
	};
	if (!L_IsDgnInputItem(m_nRebarRatio)) return false;

	auto L_IsExist = [](const double& dValue, const std::vector<double>& vdValue) -> bool
	{
		if (vdValue.empty()) return false;
		if (fabs(dValue) < 1.0e-7) return true;

		for (const double& dVal : vdValue)
		{
			if (fabs(dVal - dValue) < 1.0e-7)
			{
				return true;
			}
		}
		return false;
	};

	std::vector<double> vdDgnInput;
	POSITION pos = mSDRData.GetStartPosition();
	while (pos)
	{
		UINT ElemK = 0;
		T_GPS_SLAB_DESIGN_RESULT DgnRes;
		mSDRData.GetNextAssoc(pos, ElemK, DgnRes);

		double dInput = DgnRes.dValue[0];
		if (!L_IsExist(dInput, vdDgnInput))
		{
			vdDgnInput.push_back(dInput);
		}
	}
	if (vdDgnInput.empty()) { ASSERT(0); return false; }

	for (double dInput : vdDgnInput)
	{
		radDgnInput.Add(dInput);
	}
	CQSort::QSortDbl(radDgnInput.GetData(), radDgnInput.GetSize());

	INT_PTR nDgnInput = radDgnInput.GetCount();
	for (INT_PTR i = 0; i < nDgnInput; ++i)
	{
		CString csDgnInput;
		csDgnInput.Format(_T("%g"), radDgnInput[i]);
		racsDgnInput.Add(csDgnInput);
	}

	CString csDgnInput0 = _T("None");
	double dDgnInput0 = 0.0;
	radDgnInput.InsertAt(0, dDgnInput0);
	racsDgnInput.InsertAt(0, csDgnInput0);
	return !racsDgnInput.IsEmpty();
}

BOOL CDesignEngine::MakeShellDesignDataList()
{
	I_GPSModel *gm = (I_GPSModel *)m_pGPSModel;
	if (!gm->m_bLoadDataSet)return FALSE;

	int			i, j;
	T_ELEM_K	ElemK;

	BOOL   has_content = FALSE;
	double max_val = -DBL_MAX, min_val = DBL_MAX, len;

	m_mapSDRData.RemoveAll();
	m_aRebarStringList.RemoveAll();
	m_aRebarAsList.RemoveAll();

	BOOL bRebar;
	bRebar = FALSE;
	if (gm->m_GPSMode == GPS_COMMAND_SHELL_DGN)
	{
		if (m_nRebarRatio == 5)
		{
			bRebar = TRUE;
		}
	}
	else if (gm->m_GPSMode == GPS_COMMAND_SHELL_CHK)
	{
		if (m_nRebarRatio == 7)
		{
			bRebar = TRUE;
		}
	}


	int nStrSize = -1;
	if (m_bSlabDgnResult)
	{
		GetActivePlateList();

		int elem_num = m_PlateKeyList.GetSize();

		T_SLAB_FORCE_COMPACT SlabForce;
		T_GPS_SLAB_DESIGN_RESULT SdrtD;
		T_RSHF_D RshfD;

		if (bRebar)
		{
			T_MSRB_D MsrbD;
			if (!m_pDoc->m_pAttrCtrl->GetMsrb(MsrbD))
			{
				m_pDoc->m_pMatlDB->InitializeMsrb(MsrbD);
			}

			CString strRebar = _T("");
			double  dRebar = 0;
			double  dSpace = 0;
			CMap<CString, LPCTSTR, int, int> mapRebarString; mapRebarString.InitHashTable(HASHSIZEELEM);
			CMap<int, int, double, double&> mapMaxValue; mapMaxValue.InitHashTable(HASHSIZEELEM);
			CArray<CString, CString&> aTempRebarString;
			CArray<int, int> aIndex;
			int nTemp = 0;
			int nIndex = 0;

			// make rebar string 
			for (i = 0; i < elem_num; i++)
			{
				SdrtD.Initialize();
				RshfD.Initialize();
				ElemK = m_PlateKeyList[i];

				T_DOEL_D DoelD;
				if (!m_pDoc->m_pAttrCtrl->GetDoel(ElemK, DoelD)) { ASSERT(0); continue; }
				if (DoelD.nDomainType != 1) { ASSERT(0); continue; }
				T_SBDO_D SbdoD;
				if (!m_pDoc->m_pAttrCtrl->GetSbdo(DoelD.KeyDomain, SbdoD)) { ASSERT(0); continue; }

				BOOL bBasicRebar = FALSE;
				if (SbdoD.bBasicRebar || MsrbD.bBasicRebar) bBasicRebar = TRUE;

				if (m_nXDirYDir == 0) // Dir 1
				{
					if (!m_pDoc->m_pPostCtrl->GetDesignResult()->Get_ShellResult_BarX(ElemK, RshfD)) continue;
				}
				else if (m_nXDirYDir == 1) // Dir 2
				{
					if (!m_pDoc->m_pPostCtrl->GetDesignResult()->Get_ShellResult_BarY(ElemK, RshfD)) continue;
				}
				else if (m_nXDirYDir == 2) // Conc
				{
					if (!m_pDoc->m_pPostCtrl->GetDesignResult()->Get_ShellResult_Conc(ElemK, RshfD)) continue;
				}
				else ASSERT(0);

				for (j = 0; j < RshfD.nNodeNum; j++)
				{
					if (!CalcRebarValue_Shell(RshfD, j, strRebar, dRebar, dSpace, bBasicRebar)) continue;
					if (strRebar.GetLength() == 0 || fabs(dSpace) < 1.e-7)
						continue;
					if (!mapRebarString.Lookup(strRebar, nTemp))
					{
						mapRebarString.SetAt(strRebar, nTemp);
						aTempRebarString.Add(strRebar);
					}
				}
			}

			// rebar 별로 max값을 저장
			double dTempRebar;
			nStrSize = aTempRebarString.GetSize();
			for (i = 0; i < elem_num; i++)
			{
				SdrtD.Initialize();
				RshfD.Initialize();
				ElemK = m_PlateKeyList[i];

				T_DOEL_D DoelD;
				if (!m_pDoc->m_pAttrCtrl->GetDoel(ElemK, DoelD)) { ASSERT(0); continue; }
				if (DoelD.nDomainType != 1) { ASSERT(0); continue; }
				T_SBDO_D SbdoD;
				if (!m_pDoc->m_pAttrCtrl->GetSbdo(DoelD.KeyDomain, SbdoD)) { ASSERT(0); continue; }

				BOOL bBasicRebar = FALSE;
				if (SbdoD.bBasicRebar || MsrbD.bBasicRebar) bBasicRebar = TRUE;

				if (m_nXDirYDir == 0) // Dir 1
				{
					if (!m_pDoc->m_pPostCtrl->GetDesignResult()->Get_ShellResult_BarX(ElemK, RshfD)) continue;
				}
				else if (m_nXDirYDir == 1) // Dir 2
				{
					if (!m_pDoc->m_pPostCtrl->GetDesignResult()->Get_ShellResult_BarY(ElemK, RshfD)) continue;
				}
				else if (m_nXDirYDir == 2) // Conc
				{
					if (!m_pDoc->m_pPostCtrl->GetDesignResult()->Get_ShellResult_Conc(ElemK, RshfD)) continue;
				}
				else ASSERT(0);

				for (j = 0; j < RshfD.nNodeNum; j++)
				{
					if (!CalcRebarValue_Shell(RshfD, j, strRebar, dRebar, dSpace, bBasicRebar)) continue;
					for (int k = 0; k < nStrSize; k++)
					{
						if (strRebar.CompareNoCase(aTempRebarString[k]) == 0)
						{
							if (!mapMaxValue.Lookup(k, dTempRebar))
								mapMaxValue.SetAt(k, dRebar);
							else
							{
								if (dTempRebar < dRebar)
									mapMaxValue.SetAt(k, dRebar);
							}
							break;
						}
					}
				}
			}

			for (i = 0; i < nStrSize; i++)
			{
				mapMaxValue.Lookup(i, dTempRebar);
				m_aRebarAsList.Add(dTempRebar);
				aIndex.Add(i);
			}

			CQSort::QSortDblWithIndex(aIndex.GetData(), m_aRebarAsList.GetData(), m_aRebarAsList.GetSize());
			for (i = 0; i < aIndex.GetSize(); i++)
				m_aRebarStringList.Add(aTempRebarString[aIndex[i]]);

			strRebar = _T("None");
			dRebar = 0.0;
			m_aRebarStringList.InsertAt(0, strRebar);
			m_aRebarAsList.InsertAt(0, dRebar);

			if (m_aRebarStringList.GetSize() > 24 || m_aRebarStringList.GetSize() <= 0) { ASSERT(0); return FALSE; }
		}

		for (i = 0; i < elem_num; i++)
		{
			SlabForce.initialize();
			SdrtD.Initialize();
			RshfD.Initialize();
			ElemK = m_PlateKeyList[i];
			//      BOOL bCodeCH = CDBLib::IsCodeForMeshedDesignCH();
			//       if(m_nRebarRatio == 5 && gm->m_LoadCaseKey != 0 && bCodeCH == FALSE) // wood armer moment
			//       {
			//         if(!m_pDoc->m_pPostCtrl->GetDesignResult()->Get_SlabForce(ElemK, m_nXDirYDir, SlabForce)) continue;
			//         T_ELEM_D ElemD;
			//         if(!m_pDoc->m_pAttrCtrl->GetElem(ElemK, ElemD)) continue;
			//         for(int jj=0; jj<4; jj++)
			//         {
			//           if(ElemD.elnod!=0)  Rsl2D.iNodeNum++;
			//         }
			//       }   
			//       else
			{
				if (m_nXDirYDir == 0) // Dir 1
				{
					if (!m_pDoc->m_pPostCtrl->GetDesignResult()->Get_ShellResult_BarX(ElemK, RshfD)) continue;
				}
				else if (m_nXDirYDir == 1) // Dir 2
				{
					if (!m_pDoc->m_pPostCtrl->GetDesignResult()->Get_ShellResult_BarY(ElemK, RshfD)) continue;
				}
				else if (m_nXDirYDir == 2) // Conc
				{
					if (!m_pDoc->m_pPostCtrl->GetDesignResult()->Get_ShellResult_Conc(ElemK, RshfD)) continue;
				}
				else ASSERT(0);
			}

			for (j = 0; j < RshfD.nNodeNum; j++)
			{
				//         if(m_nRebarRatio == 5 && gm->m_LoadCaseKey != 0 && bCodeCH == FALSE)
				//         {
				//           if(m_nPosi == 0)          
				//             len = SlabForce.dForce[j+4];
				//           else if(m_nPosi == 1)          
				//             len = SlabForce.dForce[j];
				//           else if(m_nPosi == 2)       
				//           {      
				//             dVal1 = fabs(SlabForce.dForce[j]);
				//             dVal2 = fabs(SlabForce.dForce[j+4]);
				//             len = (dVal1 - dVal2 > 0.0) ?  SlabForce.dForce[j] : SlabForce.dForce[j+4];
				//           }
				//           else
				//             ASSERT(0);
				//         }
				//         else
				{
					if (gm->m_GPSMode == GPS_COMMAND_SHELL_DGN)
					{
						len = CalcShellDesignRValue(RshfD, j, m_nPosi, m_nXDirYDir, m_nRebarRatio);
					}
					else if (gm->m_GPSMode == GPS_COMMAND_SHELL_CHK)
					{
						len = CalcShellCheckRValue(RshfD, j, m_nPosi, m_nXDirYDir, m_nRebarRatio);
					}
					else
					{
						ASSERT(0);
					}
				}

				SdrtD.nNodeNum = RshfD.nNodeNum;
				SdrtD.dValue[j] = len;

				if (min_val > len)
				{
					min_val = len;
					gm->m_nLgdMinValKey = ElemK;
				}
				if (max_val < len)
				{
					max_val = len;
					gm->m_nLgdMaxValKey = ElemK;
				}
			}

			m_mapSDRData.SetAt(ElemK, SdrtD);

			has_content = TRUE;
		}
	}

	if (nStrSize == 0)
		has_content = FALSE;

	if (!has_content)
	{
		min_val = max_val = 0.0;
		gm->m_nLgdMaxValKey = 0;
		gm->m_nLgdMinValKey = 0;
		m_mapSDRData.RemoveAll();
	}

	if (max_val == -DBL_MAX)
	{
		max_val = 0.00000001;
	}
	if (min_val == DBL_MAX)
	{
		min_val = -0.00000001;
	}

	m_dMaxValue = max_val;
	m_dMinValue = min_val;

	if (bRebar && has_content) // Rebar string
	{
		if (m_pContourEngine == NULL)
		{
			m_pContourEngine = new CContourEngine;
			m_pContourEngine->MakeRankMap_Rebar(m_aRebarStringList, m_aRebarAsList);
		}
		else
			m_pContourEngine->MakeRankMap_Rebar(m_aRebarStringList, m_aRebarAsList);
	}
	else
	{
		if (m_pContourEngine == NULL)
		{
			m_pContourEngine = new CContourEngine(min_val, max_val);
		}
		else
		{
			m_pContourEngine->MakeRankMap(min_val, max_val);
		}
	}

	m_bDsgnDataSet = TRUE;
	gm->m_pMyView->EndWaitCursor();
	return TRUE;
}

BOOL CDesignEngine::CalcRebarValue_Shell(T_RSHF_D& RshfD, int nNode, CString& strRebar, double& dRebar, double& dSpace, BOOL bBasicRebar)
{
	I_GPSModel *gm = (I_GPSModel *)m_pGPSModel;

	T_UNIT_INDEX UnitIndex;
	m_pDoc->m_pUnitCtrl->GetUnitIndexCurrent(UnitIndex);
	double dFactAs2 = CDBLib::GetAs2Factor(UnitIndex.nBase_Length);

	double dVal1 = 0.0, dVal2 = 0.0;

	T_RSHF_BAR ShellPos; ShellPos.Initialize();
	switch (m_nPosi)
	{
	case 0: // top
	{
		if (m_nXDirYDir == 0) // Dir1
		{
			ShellPos = RshfD.Top[nNode].RsltBarX;
		}
		else if (m_nXDirYDir == 1) //Dir2
		{
			ShellPos = RshfD.Top[nNode].RsltBarY;
		}
		else // Conc
		{
			ASSERT(0);
			return FALSE;
		}
	}
	break;
	case 1: // bot
	{
		if (m_nXDirYDir == 0) // Dir1
		{
			ShellPos = RshfD.Bot[nNode].RsltBarX;
		}
		else if (m_nXDirYDir == 1) //Dir2
		{
			ShellPos = RshfD.Bot[nNode].RsltBarY;
		}
		else // Conc
		{
			ASSERT(0);
			return FALSE;
		}
	}
	break;
	case 2: // both
	{
		if (m_nXDirYDir == 0) // Dir1
		{
			dVal1 = fabs(RshfD.Top[nNode].RsltBarX.dAsuse)*dFactAs2;
			dVal2 = fabs(RshfD.Bot[nNode].RsltBarX.dAsuse)*dFactAs2;

			if (dVal1 > dVal2)
			{
				ShellPos = RshfD.Top[nNode].RsltBarX;
			}
			else
			{
				ShellPos = RshfD.Bot[nNode].RsltBarX;
			}
		}
		else if (m_nXDirYDir == 1) //Dir2
		{
			dVal1 = fabs(RshfD.Top[nNode].RsltBarY.dAsuse)*dFactAs2;
			dVal2 = fabs(RshfD.Bot[nNode].RsltBarY.dAsuse)*dFactAs2;

			if (dVal1 > dVal2)
			{
				ShellPos = RshfD.Top[nNode].RsltBarY;
			}
			else
			{
				ShellPos = RshfD.Bot[nNode].RsltBarY;
			}
		}
		else
		{
			ASSERT(0);
		}
	}
	break;
	default:
		ASSERT(0);
		return FALSE;
		break;
	}

	dRebar = fabs(ShellPos.dAsuse)*dFactAs2;

	if (bBasicRebar)
	{
		if (ShellPos.strAddBarSize.IsEmpty())
		{
			strRebar = ShellPos.strBarInfo;
			dSpace = ShellPos.dSpace;
		}
		else
		{
			strRebar = ShellPos.strBarInfo + _T(",") + ShellPos.strAddBarInfo;
			dSpace = ShellPos.dAddSpace;
		}
	}
	else
	{
		strRebar = ShellPos.strAddBarInfo;
		dSpace = ShellPos.dAddSpace;
	}

	strRebar.Replace(_T(" "), _T("")); // 공백제거

	return TRUE;
}

BOOL CDesignEngine::MakeShellShearChkDataList()
{
	I_GPSModel *gm = (I_GPSModel *)m_pGPSModel;
	if (!gm->m_bLoadDataSet)return FALSE;

	int			i, j;
	T_ELEM_K	ElemK;

	BOOL   has_content = FALSE;
	double max_val = -DBL_MAX, min_val = DBL_MAX, len;

	m_mapSDRData.RemoveAll();
	m_aRebarStringList.RemoveAll();
	m_aRebarAsList.RemoveAll();

	int nStrSize = -1;
	if (m_bSlabDgnResult)
	{
		GetActivePlateList();

		int elem_num = m_PlateKeyList.GetSize();

		T_SLAB_FORCE_COMPACT SlabForce;
		T_GPS_SLAB_DESIGN_RESULT SdrtD;
		T_RSHS_D RshsD;

		for (i = 0; i < elem_num; i++)
		{
			SlabForce.initialize();
			SdrtD.Initialize();
			RshsD.Initialize();
			ElemK = m_PlateKeyList[i];
			//      BOOL bCodeCH = CDBLib::IsCodeForMeshedDesignCH();
			//       if(m_nRebarRatio == 5 && gm->m_LoadCaseKey != 0 && bCodeCH == FALSE) // wood armer moment
			//       {
			//         if(!m_pDoc->m_pPostCtrl->GetDesignResult()->Get_SlabForce(ElemK, m_nXDirYDir, SlabForce)) continue;
			//         T_ELEM_D ElemD;
			//         if(!m_pDoc->m_pAttrCtrl->GetElem(ElemK, ElemD)) continue;
			//         for(int jj=0; jj<4; jj++)
			//         {
			//           if(ElemD.elnod!=0)  Rsl2D.iNodeNum++;
			//         }
			//       }   
			//       else
			{
				if (!m_pDoc->m_pPostCtrl->GetDesignResult()->Get_ShellResult(ElemK, RshsD)) continue;
			}

			for (j = 0; j < RshsD.nNodeNum; j++)
			{
				//         if(m_nRebarRatio == 5 && gm->m_LoadCaseKey != 0 && bCodeCH == FALSE)
				//         {
				//           if(m_nPosi == 0)          
				//             len = SlabForce.dForce[j+4];
				//           else if(m_nPosi == 1)          
				//             len = SlabForce.dForce[j];
				//           else if(m_nPosi == 2)       
				//           {      
				//             dVal1 = fabs(SlabForce.dForce[j]);
				//             dVal2 = fabs(SlabForce.dForce[j+4]);
				//             len = (dVal1 - dVal2 > 0.0) ?  SlabForce.dForce[j] : SlabForce.dForce[j+4];
				//           }
				//           else
				//             ASSERT(0);
				//         }
				//         else
				{
					len = CalcShellShearChkRValue(RshsD, j, m_nRebarRatio);
				}

				SdrtD.nNodeNum = RshsD.nNodeNum;
				SdrtD.dValue[j] = len;

				if (min_val > len)
				{
					min_val = len;
					gm->m_nLgdMinValKey = ElemK;
				}
				if (max_val < len)
				{
					max_val = len;
					gm->m_nLgdMaxValKey = ElemK;
				}
			}

			m_mapSDRData.SetAt(ElemK, SdrtD);

			has_content = TRUE;
		}
	}

	if (nStrSize == 0)
		has_content = FALSE;

	if (!has_content)
	{
		min_val = max_val = 0.0;
		gm->m_nLgdMaxValKey = 0;
		gm->m_nLgdMinValKey = 0;
		m_mapSDRData.RemoveAll();
	}

	if (max_val == -DBL_MAX)
	{
		max_val = 0.00000001;
	}
	if (min_val == DBL_MAX)
	{
		min_val = -0.00000001;
	}

	m_dMaxValue = max_val;
	m_dMinValue = min_val;

	//   if(m_nRebarRatio == 0 && has_content) // Rebar string
	//   {
	//     if (m_pContourEngine == NULL)
	//     {
	//       m_pContourEngine = new CContourEngine;
	//       m_pContourEngine->MakeRankMap_Rebar(m_aRebarStringList, m_aRebarAsList); 
	//     }
	//     else
	//       m_pContourEngine->MakeRankMap_Rebar(m_aRebarStringList, m_aRebarAsList);            
	//   }
	//   else
	{
		if (m_pContourEngine == NULL)
			m_pContourEngine = new CContourEngine(min_val, max_val);
		else
			m_pContourEngine->MakeRankMap(min_val, max_val);
	}

	m_bDsgnDataSet = TRUE;
	gm->m_pMyView->EndWaitCursor();
	return TRUE;
}

double CDesignEngine::CalcShellDesignRValue(T_RSHF_D& RshfD, int nNode, int nPos, int nDir, int nRebar)
{
	DECLARE_GPSMD();
	ASSERT(gm->m_GPSMode == GPS_COMMAND_SHELL_DGN);

	T_UNIT_INDEX UnitIndex;
	m_pDoc->m_pUnitCtrl->GetUnitIndexCurrent(UnitIndex);
	double dFactAs2 = CDBLib::GetAs2Factor(UnitIndex.nBase_Length);

	double dVal1 = 0.0, dVal2 = 0.0;
	double len = 0.0;
	switch (nPos)
	{
	case 0: // top
	{
		if (nRebar == 0) // Membr. Axial Force
		{
			if (nDir == 0) len = RshfD.Top[nNode].dSigEdx;  // Dir 1
			else if (nDir == 1) len = RshfD.Top[nNode].dSigEdy;  // Dir 2
			else if (nDir == 2) len = RshfD.Top[nNode].dSigEdx;  // Conc
			else ASSERT(0);

		}
		else if (nRebar == 1) // Membr. Shear Force
		{
			if (nDir == 0) len = RshfD.Top[nNode].dTauEdxy;  // Dir 1
			else if (nDir == 1) len = RshfD.Top[nNode].dTauEdxy;  // Dir 2
			else if (nDir == 2) len = RshfD.Top[nNode].dTauEdxy;  // Conc
			else ASSERT(0);

		}
		else if (nRebar == 2) // Rebar Stress / Principal Stress
		{
			if (nDir == 0) len = RshfD.Top[nNode].RsltBarX.dftd;  // Dir 1
			else if (nDir == 1) len = RshfD.Top[nNode].RsltBarY.dftd;  // Dir 2
			else if (nDir == 2) len = RshfD.Top[nNode].dSigcd;   // Conc
			else ASSERT(0);

		}
		else if (nRebar == 3) // As_req / Ratio
		{
			if (nDir == 0) len = RshfD.Top[nNode].RsltBarX.dAsreq*dFactAs2;  // Dir 1
			else if (nDir == 1) len = RshfD.Top[nNode].RsltBarY.dAsreq*dFactAs2;  // Dir 2
			else if (nDir == 2) len = RshfD.Top[nNode].dRatSigcd;  // Conc
			else ASSERT(0);

		}
		else if (nRebar == 4) // Rho_req
		{
			if (nDir == 0) len = RshfD.Top[nNode].RsltBarX.dRhoreq;  // Dir 1
			else if (nDir == 1) len = RshfD.Top[nNode].RsltBarY.dRhoreq;  // Dir 2
			else ASSERT(0);

		}
		else if (nRebar == 5) // Rebar Arrangement ratio
		{
			if (nDir == 0) len = RshfD.Top[nNode].RsltBarX.dAsuse*dFactAs2;  // Dir 1
			else if (nDir == 1) len = RshfD.Top[nNode].RsltBarY.dAsuse*dFactAs2;  // Dir 2
			else ASSERT(0);
		}
		else if (nRebar == 6) // ratio
		{
			if (nDir == 0) len = RshfD.Top[nNode].RsltBarX.dRatFtd;  // Dir 1
			else if (nDir == 1) len = RshfD.Top[nNode].RsltBarY.dRatFtd;  // Dir 2
			else ASSERT(0);
		}
		else
			ASSERT(0);
	}
	break;
	case 1: // bot
	{
		if (nRebar == 0) // Membr. Axial Force
		{
			if (nDir == 0) len = RshfD.Bot[nNode].dSigEdx;  // Dir 1
			else if (nDir == 1) len = RshfD.Bot[nNode].dSigEdy;  // Dir 2
			else if (nDir == 2) len = RshfD.Bot[nNode].dSigEdx;  // Conc
			else ASSERT(0);

		}
		else if (nRebar == 1) // Membr. Shear Force
		{
			if (nDir == 0) len = RshfD.Bot[nNode].dTauEdxy;  // Dir 1
			else if (nDir == 1) len = RshfD.Bot[nNode].dTauEdxy;  // Dir 2
			else if (nDir == 2) len = RshfD.Bot[nNode].dTauEdxy;  // Conc
			else ASSERT(0);

		}
		else if (nRebar == 2) // Rebar Stress / Principal Stress
		{
			if (nDir == 0) len = RshfD.Bot[nNode].RsltBarX.dftd;  // Dir 1
			else if (nDir == 1) len = RshfD.Bot[nNode].RsltBarY.dftd;  // Dir 2
			else if (nDir == 2) len = RshfD.Bot[nNode].dSigcd;   // Conc
			else ASSERT(0);

		}
		else if (nRebar == 3) // As_req / Ratio
		{
			if (nDir == 0) len = RshfD.Bot[nNode].RsltBarX.dAsreq*dFactAs2;   // Dir 1
			else if (nDir == 1) len = RshfD.Bot[nNode].RsltBarY.dAsreq*dFactAs2;   // Dir 2
			else if (nDir == 2) len = RshfD.Bot[nNode].dRatSigcd;  // Conc
			else ASSERT(0);

		}
		else if (nRebar == 4) // Rho_req
		{
			if (nDir == 0) len = RshfD.Bot[nNode].RsltBarX.dRhoreq;  // Dir 1
			else if (nDir == 1) len = RshfD.Bot[nNode].RsltBarY.dRhoreq;  // Dir 2
			else ASSERT(0);

		}
		else if (nRebar == 5) // Rebar Arrangement ratio
		{
			if (nDir == 0) len = RshfD.Bot[nNode].RsltBarX.dAsuse*dFactAs2;  // Dir 1
			else if (nDir == 1) len = RshfD.Bot[nNode].RsltBarY.dAsuse*dFactAs2;  // Dir 2
			else ASSERT(0);
		}
		else if (nRebar == 6) // ratio
		{
			if (nDir == 0) len = RshfD.Bot[nNode].RsltBarX.dRatFtd;  // Dir 1
			else if (nDir == 1) len = RshfD.Bot[nNode].RsltBarY.dRatFtd;  // Dir 2
			else ASSERT(0);
		}
		else
			ASSERT(0);
	}
	break;
	case 2: // both
	{
		if (nRebar == 0) // Membr. Axial Force
		{
			if (nDir == 0) { dVal1 = fabs(RshfD.Top[nNode].dSigEdx);  dVal2 = fabs(RshfD.Bot[nNode].dSigEdx); }
			else if (nDir == 1) { dVal1 = fabs(RshfD.Top[nNode].dSigEdy);  dVal2 = fabs(RshfD.Bot[nNode].dSigEdy); }
			else if (nDir == 2) { dVal1 = fabs(RshfD.Top[nNode].dSigEdx);  dVal2 = fabs(RshfD.Bot[nNode].dSigEdx); }
			else ASSERT(0);

			if (dVal1 > dVal2)
			{
				if (nDir == 0) len = RshfD.Top[nNode].dSigEdx;
				else if (nDir == 1) len = RshfD.Top[nNode].dSigEdy;
				else if (nDir == 2) len = RshfD.Top[nNode].dSigEdx;
				else ASSERT(0);
			}
			else
			{
				if (nDir == 0) len = RshfD.Bot[nNode].dSigEdx;
				else if (nDir == 1) len = RshfD.Bot[nNode].dSigEdy;
				else if (nDir == 2) len = RshfD.Bot[nNode].dSigEdx;
				else ASSERT(0);
			}

		}
		else if (nRebar == 1)  // Membr. Shear Force
		{
			if (nDir == 0) { dVal1 = fabs(RshfD.Top[nNode].dTauEdxy);  dVal2 = fabs(RshfD.Bot[nNode].dTauEdxy); }
			else if (nDir == 1) { dVal1 = fabs(RshfD.Top[nNode].dTauEdxy);  dVal2 = fabs(RshfD.Bot[nNode].dTauEdxy); }
			else if (nDir == 2) { dVal1 = fabs(RshfD.Top[nNode].dTauEdxy);  dVal2 = fabs(RshfD.Bot[nNode].dTauEdxy); }
			else ASSERT(0);

			if (dVal1 > dVal2)
			{
				if (nDir == 0) len = RshfD.Top[nNode].dTauEdxy;  // Dir 1
				else if (nDir == 1) len = RshfD.Top[nNode].dTauEdxy;  // Dir 2
				else if (nDir == 2) len = RshfD.Top[nNode].dTauEdxy;  // Conc
				else ASSERT(0);
			}
			else
			{
				if (nDir == 0) len = RshfD.Bot[nNode].dTauEdxy;  // Dir 1
				else if (nDir == 1) len = RshfD.Bot[nNode].dTauEdxy;  // Dir 2
				else if (nDir == 2) len = RshfD.Bot[nNode].dTauEdxy;  // Conc
				else ASSERT(0);
			}

		}
		else if (nRebar == 2)  // Rebar Stress / Principal Stress
		{
			if (nDir == 0) { dVal1 = fabs(RshfD.Top[nNode].RsltBarX.dftd);  dVal2 = fabs(RshfD.Bot[nNode].RsltBarX.dftd); }
			else if (nDir == 1) { dVal1 = fabs(RshfD.Top[nNode].RsltBarY.dftd);  dVal2 = fabs(RshfD.Bot[nNode].RsltBarY.dftd); }
			else if (nDir == 2) { dVal1 = fabs(RshfD.Top[nNode].dSigcd);  dVal2 = fabs(RshfD.Bot[nNode].dSigcd); }
			else ASSERT(0);

			if (dVal1 > dVal2)
			{
				if (nDir == 0) len = RshfD.Top[nNode].RsltBarX.dftd;  // Dir 1
				else if (nDir == 1) len = RshfD.Top[nNode].RsltBarY.dftd;  // Dir 2
				else if (nDir == 2) len = RshfD.Top[nNode].dSigcd;   // Conc
				else ASSERT(0);

			}
			else
			{
				if (nDir == 0) len = RshfD.Bot[nNode].RsltBarX.dftd;  // Dir 1
				else if (nDir == 1) len = RshfD.Bot[nNode].RsltBarY.dftd;  // Dir 2
				else if (nDir == 2) len = RshfD.Bot[nNode].dSigcd;   // Conc
				else ASSERT(0);

			}
		}
		else if (nRebar == 3) // As_req / Ratio
		{
			if (nDir == 0) { dVal1 = fabs(RshfD.Top[nNode].RsltBarX.dAsreq)*dFactAs2;  dVal2 = fabs(RshfD.Bot[nNode].RsltBarX.dAsreq)*dFactAs2; }
			else if (nDir == 1) { dVal1 = fabs(RshfD.Top[nNode].RsltBarY.dAsreq)*dFactAs2;  dVal2 = fabs(RshfD.Bot[nNode].RsltBarY.dAsreq)*dFactAs2; }
			else if (nDir == 2) { dVal1 = fabs(RshfD.Top[nNode].dRatSigcd); dVal2 = fabs(RshfD.Bot[nNode].dRatSigcd); }
			else ASSERT(0);

			if (dVal1 > dVal2)
			{
				if (nDir == 0) len = RshfD.Top[nNode].RsltBarX.dAsreq*dFactAs2;   // Dir 1
				else if (nDir == 1) len = RshfD.Top[nNode].RsltBarY.dAsreq*dFactAs2;   // Dir 2
				else if (nDir == 2) len = RshfD.Top[nNode].dRatSigcd;  // Conc
				else ASSERT(0);
			}
			else
			{
				if (nDir == 0) len = RshfD.Bot[nNode].RsltBarX.dAsreq*dFactAs2;   // Dir 1
				else if (nDir == 1) len = RshfD.Bot[nNode].RsltBarY.dAsreq*dFactAs2;   // Dir 2
				else if (nDir == 2) len = RshfD.Bot[nNode].dRatSigcd;  // Conc
				else ASSERT(0);
			}

		}
		else if (nRebar == 4) // Rho_req
		{
			if (nDir == 0) { dVal1 = fabs(RshfD.Top[nNode].RsltBarX.dRhoreq);  dVal2 = fabs(RshfD.Bot[nNode].RsltBarX.dRhoreq); }
			else if (nDir == 1) { dVal1 = fabs(RshfD.Top[nNode].RsltBarY.dRhoreq);  dVal2 = fabs(RshfD.Bot[nNode].RsltBarY.dRhoreq); }
			else ASSERT(0);

			if (dVal1 > dVal2)
			{
				if (nDir == 0) len = RshfD.Top[nNode].RsltBarX.dRhoreq;  // Dir 1
				else if (nDir == 1) len = RshfD.Top[nNode].RsltBarY.dRhoreq;  // Dir 2
				else ASSERT(0);
			}
			else
			{
				if (nDir == 0) len = RshfD.Bot[nNode].RsltBarX.dRhoreq;  // Dir 1
				else if (nDir == 1) len = RshfD.Bot[nNode].RsltBarY.dRhoreq;  // Dir 2
				else ASSERT(0);
			}

		}
		else if (nRebar == 5)  // Rebar Arrangement ratio
		{
			if (nDir == 0) { dVal1 = fabs(RshfD.Top[nNode].RsltBarX.dAsuse)*dFactAs2;  dVal2 = fabs(RshfD.Bot[nNode].RsltBarX.dAsuse)*dFactAs2; }
			else if (nDir == 1) { dVal1 = fabs(RshfD.Top[nNode].RsltBarY.dAsuse)*dFactAs2;  dVal2 = fabs(RshfD.Bot[nNode].RsltBarY.dAsuse)*dFactAs2; }
			else ASSERT(0);

			if (dVal1 > dVal2)
			{
				if (nDir == 0) len = RshfD.Top[nNode].RsltBarX.dAsuse*dFactAs2;  // Dir 1
				else if (nDir == 1) len = RshfD.Top[nNode].RsltBarY.dAsuse*dFactAs2;  // Dir 2
				else ASSERT(0);
			}
			else
			{
				if (nDir == 0) len = RshfD.Bot[nNode].RsltBarX.dAsuse*dFactAs2;  // Dir 1
				else if (nDir == 1) len = RshfD.Bot[nNode].RsltBarY.dAsuse*dFactAs2;  // Dir 2
				else ASSERT(0);
			}
		}
		else if (nRebar == 6)  // ratio
		{
			if (nDir == 0) { dVal1 = fabs(RshfD.Top[nNode].RsltBarX.dRatFtd);  dVal2 = fabs(RshfD.Bot[nNode].RsltBarX.dRatFtd); }
			else if (nDir == 1) { dVal1 = fabs(RshfD.Top[nNode].RsltBarY.dRatFtd);  dVal2 = fabs(RshfD.Bot[nNode].RsltBarY.dRatFtd); }
			else ASSERT(0);

			if (dVal1 > dVal2)
			{
				if (nDir == 0) len = RshfD.Top[nNode].RsltBarX.dRatFtd;  // Dir 1
				else if (nDir == 1) len = RshfD.Top[nNode].RsltBarY.dRatFtd;  // Dir 2
				else ASSERT(0);
			}
			else
			{
				if (nDir == 0) len = RshfD.Bot[nNode].RsltBarX.dRatFtd;  // Dir 1
				else if (nDir == 1) len = RshfD.Bot[nNode].RsltBarY.dRatFtd;  // Dir 2
				else ASSERT(0);
			}
		}
		else
			ASSERT(0);
	}
	break;
	default:
		ASSERT(0);
		break;
	}
	return len;
}

double CDesignEngine::CalcShellCheckRValue(T_RSHF_D& RshfD, int nNode, int nPos, int nDir, int nRebar)
{
	DECLARE_GPSMD();
	ASSERT(gm->m_GPSMode == GPS_COMMAND_SHELL_CHK);

	T_UNIT_INDEX UnitIndex;
	m_pDoc->m_pUnitCtrl->GetUnitIndexCurrent(UnitIndex);
	double dFactAs2 = CDBLib::GetAs2Factor(UnitIndex.nBase_Length);

	double dVal1 = 0.0, dVal2 = 0.0;
	double len = 0.0;
	switch (nPos)
	{
	case 0: // top
	{
		if (nRebar == 0) // Membr. Axial Force
		{
			if (nDir == 0) len = RshfD.Top[nNode].dSigEdx;  // Dir 1
			else if (nDir == 1) len = RshfD.Top[nNode].dSigEdy;  // Dir 2
			else if (nDir == 2) len = RshfD.Top[nNode].dSigEdx;  // Conc
			else ASSERT(0);

		}
		else if (nRebar == 1) // Membr. Shear Force
		{
			if (nDir == 0) len = RshfD.Top[nNode].dTauEdxy;  // Dir 1
			else if (nDir == 1) len = RshfD.Top[nNode].dTauEdxy;  // Dir 2
			else if (nDir == 2) len = RshfD.Top[nNode].dTauEdxy;  // Conc
			else ASSERT(0);

		}
		else if (nRebar == 2) // Rebar Stress / Principal Stress
		{
			if (nDir == 0) len = RshfD.Top[nNode].RsltBarX.dftd;  // Dir 1
			else if (nDir == 1) len = RshfD.Top[nNode].RsltBarY.dftd;  // Dir 2
			else if (nDir == 2) len = RshfD.Top[nNode].dSigcd;   // Conc
			else ASSERT(0);

		}
		else if (nRebar == 3) // As_req / Ratio
		{
			if (nDir == 0) len = RshfD.Top[nNode].RsltBarX.dAsreq*dFactAs2;  // Dir 1
			else if (nDir == 1) len = RshfD.Top[nNode].RsltBarY.dAsreq*dFactAs2;  // Dir 2
			else if (nDir == 2) len = RshfD.Top[nNode].dRatSigcd;  // Conc
			else ASSERT(0);
		}
		else if (nRebar == 4) // Rho_req
		{
			if (nDir == 0) len = RshfD.Top[nNode].RsltBarX.dRhoreq;  // Dir 1
			else if (nDir == 1) len = RshfD.Top[nNode].RsltBarY.dRhoreq;  // Dir 2
			else ASSERT(0);
		}
		else if (nRebar == 5) // As_use / Ratio
		{
			if (nDir == 0) len = RshfD.Top[nNode].RsltBarX.dAsuse*dFactAs2;  // Dir 1
			else if (nDir == 1) len = RshfD.Top[nNode].RsltBarY.dAsuse*dFactAs2;  // Dir 2
			else ASSERT(0);
		}
		else if (nRebar == 6) // Rho_use
		{
			if (nDir == 0) len = RshfD.Top[nNode].RsltBarX.dRhouse;  // Dir 1
			else if (nDir == 1) len = RshfD.Top[nNode].RsltBarY.dRhouse;  // Dir 2
			else ASSERT(0);
		}
		else if (nRebar == 7) // Rebar Arrangement ratio
		{
			if (nDir == 0) len = RshfD.Top[nNode].RsltBarX.dAsuse*dFactAs2;  // Dir 1
			else if (nDir == 1) len = RshfD.Top[nNode].RsltBarY.dAsuse*dFactAs2;  // Dir 2
			else ASSERT(0);
		}
		else if (nRebar == 8) // ratio
		{
			if (nDir == 0) len = RshfD.Top[nNode].RsltBarX.dRatFtd;  // Dir 1
			else if (nDir == 1) len = RshfD.Top[nNode].RsltBarY.dRatFtd;  // Dir 2
			else ASSERT(0);
		}
		else
			ASSERT(0);
	}
	break;
	case 1: // bot
	{
		if (nRebar == 0) // Membr. Axial Force
		{
			if (nDir == 0) len = RshfD.Bot[nNode].dSigEdx;  // Dir 1
			else if (nDir == 1) len = RshfD.Bot[nNode].dSigEdy;  // Dir 2
			else if (nDir == 2) len = RshfD.Bot[nNode].dSigEdx;  // Conc
			else ASSERT(0);
		}
		else if (nRebar == 1) // Membr. Shear Force
		{
			if (nDir == 0) len = RshfD.Bot[nNode].dTauEdxy;  // Dir 1
			else if (nDir == 1) len = RshfD.Bot[nNode].dTauEdxy;  // Dir 2
			else if (nDir == 2) len = RshfD.Bot[nNode].dTauEdxy;  // Conc
			else ASSERT(0);
		}
		else if (nRebar == 2) // Rebar Stress / Principal Stress
		{
			if (nDir == 0) len = RshfD.Bot[nNode].RsltBarX.dftd;  // Dir 1
			else if (nDir == 1) len = RshfD.Bot[nNode].RsltBarY.dftd;  // Dir 2
			else if (nDir == 2) len = RshfD.Bot[nNode].dSigcd;   // Conc
			else ASSERT(0);
		}
		else if (nRebar == 3) // As_req / Ratio
		{
			if (nDir == 0) len = RshfD.Bot[nNode].RsltBarX.dAsreq*dFactAs2;   // Dir 1
			else if (nDir == 1) len = RshfD.Bot[nNode].RsltBarY.dAsreq*dFactAs2;   // Dir 2
			else if (nDir == 2) len = RshfD.Bot[nNode].dRatSigcd;  // Conc
			else ASSERT(0);
		}
		else if (nRebar == 4) // Rho_req
		{
			if (nDir == 0) len = RshfD.Bot[nNode].RsltBarX.dRhoreq;  // Dir 1
			else if (nDir == 1) len = RshfD.Bot[nNode].RsltBarY.dRhoreq;  // Dir 2
			else ASSERT(0);
		}
		else if (nRebar == 5) // As_use / Ratio
		{
			if (nDir == 0) len = RshfD.Bot[nNode].RsltBarX.dAsuse*dFactAs2;   // Dir 1
			else if (nDir == 1) len = RshfD.Bot[nNode].RsltBarY.dAsuse*dFactAs2;   // Dir 2
			else ASSERT(0);
		}
		else if (nRebar == 6) // Rho_use
		{
			if (nDir == 0) len = RshfD.Bot[nNode].RsltBarX.dRhouse;  // Dir 1
			else if (nDir == 1) len = RshfD.Bot[nNode].RsltBarY.dRhouse;  // Dir 2
			else ASSERT(0);
		}
		else if (nRebar == 7) // Rebar Arrangement ratio
		{
			if (nDir == 0) len = RshfD.Bot[nNode].RsltBarX.dAsuse*dFactAs2;  // Dir 1
			else if (nDir == 1) len = RshfD.Bot[nNode].RsltBarY.dAsuse*dFactAs2;  // Dir 2
			else ASSERT(0);
		}
		else if (nRebar == 8) // ratio
		{
			if (nDir == 0) len = RshfD.Bot[nNode].RsltBarX.dRatFtd;  // Dir 1
			else if (nDir == 1) len = RshfD.Bot[nNode].RsltBarY.dRatFtd;  // Dir 2
			else ASSERT(0);
		}
		else
			ASSERT(0);
	}
	break;
	case 2: // both
	{
		if (nRebar == 0) // Membr. Axial Force
		{
			if (nDir == 0) { dVal1 = fabs(RshfD.Top[nNode].dSigEdx);  dVal2 = fabs(RshfD.Bot[nNode].dSigEdx); }
			else if (nDir == 1) { dVal1 = fabs(RshfD.Top[nNode].dSigEdy);  dVal2 = fabs(RshfD.Bot[nNode].dSigEdy); }
			else if (nDir == 2) { dVal1 = fabs(RshfD.Top[nNode].dSigEdx);  dVal2 = fabs(RshfD.Bot[nNode].dSigEdx); }
			else ASSERT(0);

			if (dVal1 > dVal2)
			{
				if (nDir == 0) len = RshfD.Top[nNode].dSigEdx;
				else if (nDir == 1) len = RshfD.Top[nNode].dSigEdy;
				else if (nDir == 2) len = RshfD.Top[nNode].dSigEdx;
				else ASSERT(0);
			}
			else
			{
				if (nDir == 0) len = RshfD.Bot[nNode].dSigEdx;
				else if (nDir == 1) len = RshfD.Bot[nNode].dSigEdy;
				else if (nDir == 2) len = RshfD.Bot[nNode].dSigEdx;
				else ASSERT(0);
			}

		}
		else if (nRebar == 1)  // Membr. Shear Force
		{
			if (nDir == 0) { dVal1 = fabs(RshfD.Top[nNode].dTauEdxy);  dVal2 = fabs(RshfD.Bot[nNode].dTauEdxy); }
			else if (nDir == 1) { dVal1 = fabs(RshfD.Top[nNode].dTauEdxy);  dVal2 = fabs(RshfD.Bot[nNode].dTauEdxy); }
			else if (nDir == 2) { dVal1 = fabs(RshfD.Top[nNode].dTauEdxy);  dVal2 = fabs(RshfD.Bot[nNode].dTauEdxy); }
			else ASSERT(0);

			if (dVal1 > dVal2)
			{
				if (nDir == 0) len = RshfD.Top[nNode].dTauEdxy;  // Dir 1
				else if (nDir == 1) len = RshfD.Top[nNode].dTauEdxy;  // Dir 2
				else if (nDir == 2) len = RshfD.Top[nNode].dTauEdxy;  // Conc
				else ASSERT(0);
			}
			else
			{
				if (nDir == 0) len = RshfD.Bot[nNode].dTauEdxy;  // Dir 1
				else if (nDir == 1) len = RshfD.Bot[nNode].dTauEdxy;  // Dir 2
				else if (nDir == 2) len = RshfD.Bot[nNode].dTauEdxy;  // Conc
				else ASSERT(0);
			}

		}
		else if (nRebar == 2)  // Rebar Stress / Principal Stress
		{
			if (nDir == 0) { dVal1 = fabs(RshfD.Top[nNode].RsltBarX.dftd);  dVal2 = fabs(RshfD.Bot[nNode].RsltBarX.dftd); }
			else if (nDir == 1) { dVal1 = fabs(RshfD.Top[nNode].RsltBarY.dftd);  dVal2 = fabs(RshfD.Bot[nNode].RsltBarY.dftd); }
			else if (nDir == 2) { dVal1 = fabs(RshfD.Top[nNode].dSigcd);  dVal2 = fabs(RshfD.Bot[nNode].dSigcd); }
			else ASSERT(0);

			if (dVal1 > dVal2)
			{
				if (nDir == 0) len = RshfD.Top[nNode].RsltBarX.dftd;  // Dir 1
				else if (nDir == 1) len = RshfD.Top[nNode].RsltBarY.dftd;  // Dir 2
				else if (nDir == 2) len = RshfD.Top[nNode].dSigcd;   // Conc
				else ASSERT(0);

			}
			else
			{
				if (nDir == 0) len = RshfD.Bot[nNode].RsltBarX.dftd;  // Dir 1
				else if (nDir == 1) len = RshfD.Bot[nNode].RsltBarY.dftd;  // Dir 2
				else if (nDir == 2) len = RshfD.Bot[nNode].dSigcd;   // Conc
				else ASSERT(0);

			}
		}
		else if (nRebar == 3) // As_req / Ratio
		{
			if (nDir == 0) { dVal1 = fabs(RshfD.Top[nNode].RsltBarX.dAsreq)*dFactAs2;  dVal2 = fabs(RshfD.Bot[nNode].RsltBarX.dAsreq)*dFactAs2; }
			else if (nDir == 1) { dVal1 = fabs(RshfD.Top[nNode].RsltBarY.dAsreq)*dFactAs2;  dVal2 = fabs(RshfD.Bot[nNode].RsltBarY.dAsreq)*dFactAs2; }
			else if (nDir == 2) { dVal1 = fabs(RshfD.Top[nNode].dRatSigcd); dVal2 = fabs(RshfD.Bot[nNode].dRatSigcd); }
			else ASSERT(0);

			if (dVal1 > dVal2)
			{
				if (nDir == 0) len = RshfD.Top[nNode].RsltBarX.dAsreq*dFactAs2;   // Dir 1
				else if (nDir == 1) len = RshfD.Top[nNode].RsltBarY.dAsreq*dFactAs2;   // Dir 2
				else if (nDir == 2) len = RshfD.Top[nNode].dRatSigcd;  // Conc
				else ASSERT(0);
			}
			else
			{
				if (nDir == 0) len = RshfD.Bot[nNode].RsltBarX.dAsreq*dFactAs2;   // Dir 1
				else if (nDir == 1) len = RshfD.Bot[nNode].RsltBarY.dAsreq*dFactAs2;   // Dir 2
				else if (nDir == 2) len = RshfD.Bot[nNode].dRatSigcd;  // Conc
				else ASSERT(0);
			}

		}
		else if (nRebar == 4) // Rho_req
		{
			if (nDir == 0) { dVal1 = fabs(RshfD.Top[nNode].RsltBarX.dRhoreq);  dVal2 = fabs(RshfD.Bot[nNode].RsltBarX.dRhoreq); }
			else if (nDir == 1) { dVal1 = fabs(RshfD.Top[nNode].RsltBarY.dRhoreq);  dVal2 = fabs(RshfD.Bot[nNode].RsltBarY.dRhoreq); }
			else ASSERT(0);

			if (dVal1 > dVal2)
			{
				if (nDir == 0) len = RshfD.Top[nNode].RsltBarX.dRhoreq;  // Dir 1
				else if (nDir == 1) len = RshfD.Top[nNode].RsltBarY.dRhoreq;  // Dir 2
				else ASSERT(0);
			}
			else
			{
				if (nDir == 0) len = RshfD.Bot[nNode].RsltBarX.dRhoreq;  // Dir 1
				else if (nDir == 1) len = RshfD.Bot[nNode].RsltBarY.dRhoreq;  // Dir 2
				else ASSERT(0);
			}
		}
		else if (nRebar == 5) // As_use / Ratio
		{
			if (nDir == 0) { dVal1 = fabs(RshfD.Top[nNode].RsltBarX.dAsuse)*dFactAs2;  dVal2 = fabs(RshfD.Bot[nNode].RsltBarX.dAsuse)*dFactAs2; }
			else if (nDir == 1) { dVal1 = fabs(RshfD.Top[nNode].RsltBarY.dAsuse)*dFactAs2;  dVal2 = fabs(RshfD.Bot[nNode].RsltBarY.dAsuse)*dFactAs2; }
			else if (nDir == 2) { dVal1 = fabs(RshfD.Top[nNode].dRatSigcd); dVal2 = fabs(RshfD.Bot[nNode].dRatSigcd); }
			else ASSERT(0);

			if (dVal1 > dVal2)
			{
				if (nDir == 0) len = RshfD.Top[nNode].RsltBarX.dAsuse*dFactAs2;   // Dir 1
				else if (nDir == 1) len = RshfD.Top[nNode].RsltBarY.dAsuse*dFactAs2;   // Dir 2
				else if (nDir == 2) len = RshfD.Top[nNode].dRatSigcd;  // Conc
				else ASSERT(0);
			}
			else
			{
				if (nDir == 0) len = RshfD.Bot[nNode].RsltBarX.dAsuse*dFactAs2;   // Dir 1
				else if (nDir == 1) len = RshfD.Bot[nNode].RsltBarY.dAsuse*dFactAs2;   // Dir 2
				else if (nDir == 2) len = RshfD.Bot[nNode].dRatSigcd;  // Conc
				else ASSERT(0);
			}
		}
		else if (nRebar == 6) // Rho_use
		{
			if (nDir == 0) { dVal1 = fabs(RshfD.Top[nNode].RsltBarX.dRhouse);  dVal2 = fabs(RshfD.Bot[nNode].RsltBarX.dRhouse); }
			else if (nDir == 1) { dVal1 = fabs(RshfD.Top[nNode].RsltBarY.dRhouse);  dVal2 = fabs(RshfD.Bot[nNode].RsltBarY.dRhouse); }
			else ASSERT(0);

			if (dVal1 > dVal2)
			{
				if (nDir == 0) len = RshfD.Top[nNode].RsltBarX.dRhouse;  // Dir 1
				else if (nDir == 1) len = RshfD.Top[nNode].RsltBarY.dRhouse;  // Dir 2
				else ASSERT(0);
			}
			else
			{
				if (nDir == 0) len = RshfD.Bot[nNode].RsltBarX.dRhouse;  // Dir 1
				else if (nDir == 1) len = RshfD.Bot[nNode].RsltBarY.dRhouse;  // Dir 2
				else ASSERT(0);
			}
		}
		else if (nRebar == 7)  // Rebar Arrangement ratio
		{
			if (nDir == 0) { dVal1 = fabs(RshfD.Top[nNode].RsltBarX.dAsuse)*dFactAs2;  dVal2 = fabs(RshfD.Bot[nNode].RsltBarX.dAsuse)*dFactAs2; }
			else if (nDir == 1) { dVal1 = fabs(RshfD.Top[nNode].RsltBarY.dAsuse)*dFactAs2;  dVal2 = fabs(RshfD.Bot[nNode].RsltBarY.dAsuse)*dFactAs2; }
			else ASSERT(0);

			if (dVal1 > dVal2)
			{
				if (nDir == 0) len = RshfD.Top[nNode].RsltBarX.dAsuse*dFactAs2;  // Dir 1
				else if (nDir == 1) len = RshfD.Top[nNode].RsltBarY.dAsuse*dFactAs2;  // Dir 2
				else ASSERT(0);
			}
			else
			{
				if (nDir == 0) len = RshfD.Bot[nNode].RsltBarX.dAsuse*dFactAs2;  // Dir 1
				else if (nDir == 1) len = RshfD.Bot[nNode].RsltBarY.dAsuse*dFactAs2;  // Dir 2
				else ASSERT(0);
			}
		}
		else if (nRebar == 8)  // ratio
		{
			if (nDir == 0) { dVal1 = fabs(RshfD.Top[nNode].RsltBarX.dRatFtd);  dVal2 = fabs(RshfD.Bot[nNode].RsltBarX.dRatFtd); }
			else if (nDir == 1) { dVal1 = fabs(RshfD.Top[nNode].RsltBarY.dRatFtd);  dVal2 = fabs(RshfD.Bot[nNode].RsltBarY.dRatFtd); }
			else ASSERT(0);

			if (dVal1 > dVal2)
			{
				if (nDir == 0) len = RshfD.Top[nNode].RsltBarX.dRatFtd;  // Dir 1
				else if (nDir == 1) len = RshfD.Top[nNode].RsltBarY.dRatFtd;  // Dir 2
				else ASSERT(0);
			}
			else
			{
				if (nDir == 0) len = RshfD.Bot[nNode].RsltBarX.dRatFtd;  // Dir 1
				else if (nDir == 1) len = RshfD.Bot[nNode].RsltBarY.dRatFtd;  // Dir 2
				else ASSERT(0);
			}
		}
		else
			ASSERT(0);
	}
	break;
	default:
		ASSERT(0);
		break;
	}
	return len;
}

double CDesignEngine::CalcShellShearChkRValue(T_RSHS_D& RshSD, int nNode, int nRebar)
{
	DECLARE_GPSMD();
	if (gm->m_GPSMode != GPS_COMMAND_SHELL_SHEAR_CHK) return 0.0;

	T_UNIT_INDEX UnitIndex;
	m_pDoc->m_pUnitCtrl->GetUnitIndexCurrent(UnitIndex);

	double len = 0.0;;

	if (nRebar == 0)
		len = RshSD.Shr[nNode].dVEdo;
	else if (nRebar == 1)
		len = RshSD.Shr[nNode].dVRdc;
	else if (nRebar == 2)
		len = RshSD.Shr[nNode].dRatio;
	else
		ASSERT(0);

	return len;
}

BOOL CDesignEngine::GetSlabDesignRangeDataList(double& dMaxRange, double& dMinRange, CArray<UINT, UINT>& aElemKeyList)
{
	aElemKeyList.RemoveAll();

	I_GPSModel *gm = (I_GPSModel *)m_pGPSModel;
	gm->m_pMyView->BeginWaitCursor();

	if (m_bSlabDgnResult)
	{
		int			i, j;
		T_ELEM_K	ElemK;
		T_GPS_SLAB_DESIGN_RESULT SdrtD;

		int elem_num = m_PlateKeyList.GetSize();
		for (i = 0; i < elem_num; i++)
		{
			ElemK = m_PlateKeyList[i];
			if (!m_mapSDRData.Lookup(ElemK, SdrtD)) continue;

			double	  len_max = -DBL_MAX, len_min = DBL_MAX, len;
			for (j = 0; j < SdrtD.nNodeNum; j++)
			{
				len = SdrtD.dValue[j];

				if (len > len_max) len_max = len;
				if (len < len_min) len_min = len;
			}

			if ((len_min <= dMinRange && len_max >= dMaxRange) ||
				(len_min >= dMinRange && len_min <= dMaxRange) ||
				(len_max >= dMinRange && len_max <= dMaxRange))
				aElemKeyList.Add(ElemK);
		}
	}

	gm->m_pMyView->EndWaitCursor();
	return TRUE;
}

BOOL CDesignEngine::GetShellDesignRangeDataList(double& dMaxRange, double& dMinRange, CArray<UINT, UINT>& aElemKeyList)
{
	aElemKeyList.RemoveAll();

	I_GPSModel *gm = (I_GPSModel *)m_pGPSModel;
	gm->m_pMyView->BeginWaitCursor();

	if (m_bSlabDgnResult)
	{
		int			i, j;
		T_ELEM_K	ElemK;
		T_GPS_SLAB_DESIGN_RESULT SdrtD;

		int elem_num = m_PlateKeyList.GetSize();
		for (i = 0; i < elem_num; i++)
		{
			ElemK = m_PlateKeyList[i];
			if (!m_mapSDRData.Lookup(ElemK, SdrtD)) continue;

			double	  len_max = -DBL_MAX, len_min = DBL_MAX, len;
			for (j = 0; j < SdrtD.nNodeNum; j++)
			{
				len = SdrtD.dValue[j];

				if (len > len_max) len_max = len;
				if (len < len_min) len_min = len;
			}

			if ((len_min <= dMinRange && len_max >= dMaxRange) ||
				(len_min >= dMinRange && len_min <= dMaxRange) ||
				(len_max >= dMinRange && len_max <= dMaxRange))
				aElemKeyList.Add(ElemK);
		}
	}

	gm->m_pMyView->EndWaitCursor();
	return TRUE;
}

BOOL CDesignEngine::MakeWallDesignDataList()
{
	I_GPSModel *gm = (I_GPSModel *)m_pGPSModel;
	if (!gm->m_bLoadDataSet)return FALSE;
	m_bOnCuttingLine = FALSE;
	if (::IsWindow(gm->m_pCutLineDetDlg->GetSafeHwnd()))
		gm->m_pCutLineDetDlg->DestroyWindow();

	int			i, j, k;
	T_ELEM_K	ElemK;

	BOOL   has_content = FALSE;
	double max_val = -DBL_MAX, min_val = DBL_MAX, len;

	GetActivePlateList(TRUE);

	m_mapSDRData.RemoveAll();
	m_aRebarStringList.RemoveAll();
	m_aRebarAsList.RemoveAll();

	int elem_num = m_PlateKeyList.GetSize();

	T_GPS_SLAB_DESIGN_RESULT SdrtD;
	T_RMEW_D RmewD;
	int nStrSize = -1;
	if (m_nRebarRatio == 0 && m_nXDirYDir != 2)
	{
		CString strRebar = _T("");
		double  dRebar = 0;
		double  dSpace = 0;
		CMap<CString, LPCTSTR, int, int> mapRebarString; mapRebarString.InitHashTable(HASHSIZEELEM);
		CMap<int, int, double, double&> mapMaxValue; mapMaxValue.InitHashTable(HASHSIZEELEM);
		CArray<CString, CString&> aTempRebarString;
		CArray<int, int> aIndex;
		int nTemp = 0;
		int nIndex = 0;

		// make rebar string 
		for (i = 0; i < elem_num; i++)
		{
			SdrtD.Initialize();
			RmewD.Initialize();
			ElemK = m_PlateKeyList[i];
			if (!m_pDoc->m_pPostCtrl->GetDesignResult()->Get_MeshWallResult(ElemK, RmewD, m_nXDirYDir)) continue;
			for (j = 0; j < RmewD.iNodeNum; j++)
			{
				if (!CalcRebarValue_Wall(RmewD, j, strRebar, dRebar, dSpace)) continue;
				if (strRebar.GetLength() == 0 || fabs(dSpace) < 1.e-7)
					continue;
				if (!mapRebarString.Lookup(strRebar, nTemp))
				{
					mapRebarString.SetAt(strRebar, nTemp);
					aTempRebarString.Add(strRebar);
				}
			}
		}

		// rebar 별로 max값을 저장
		double dTempRebar;
		nStrSize = aTempRebarString.GetSize();
		for (i = 0; i < elem_num; i++)
		{
			SdrtD.Initialize();
			RmewD.Initialize();
			ElemK = m_PlateKeyList[i];
			if (!m_pDoc->m_pPostCtrl->GetDesignResult()->Get_MeshWallResult(ElemK, RmewD, m_nXDirYDir)) continue;
			for (j = 0; j < RmewD.iNodeNum; j++)
			{
				if (!CalcRebarValue_Wall(RmewD, j, strRebar, dRebar, dSpace)) continue;
				for (k = 0; k < nStrSize; k++)
				{
					if (strRebar.CompareNoCase(aTempRebarString[k]) == 0)
					{
						if (!mapMaxValue.Lookup(k, dTempRebar))
							mapMaxValue.SetAt(k, dRebar);
						else
						{
							if (dTempRebar < dRebar)
								mapMaxValue.SetAt(k, dRebar);
						}
						break;
					}
				}
			}
		}

		for (i = 0; i < nStrSize; i++)
		{
			mapMaxValue.Lookup(i, dTempRebar);
			m_aRebarAsList.Add(dTempRebar);
			aIndex.Add(i);
		}

		CQSort::QSortDblWithIndex(aIndex.GetData(), m_aRebarAsList.GetData(), m_aRebarAsList.GetSize());
		for (i = 0; i < aIndex.GetSize(); i++)
			m_aRebarStringList.Add(aTempRebarString[aIndex[i]]);

		strRebar = _T("None");
		dRebar = 0.0;
		m_aRebarStringList.InsertAt(0, strRebar);
		m_aRebarAsList.InsertAt(0, dRebar);

		if (m_aRebarStringList.GetSize() > 24 || m_aRebarStringList.GetSize() <= 0) { ASSERT(0); return FALSE; }
	}

	for (i = 0; i < elem_num; i++)
	{
		SdrtD.Initialize();
		RmewD.Initialize();
		ElemK = m_PlateKeyList[i];
		if (!m_pDoc->m_pPostCtrl->GetDesignResult()->Get_MeshWallResult(ElemK, RmewD, m_nXDirYDir)) continue;

		for (j = 0; j < RmewD.iNodeNum; j++)
		{
			len = CalcWDRValue(RmewD, j, m_nXDirYDir, m_nRebarRatio);
			SdrtD.nNodeNum = RmewD.iNodeNum;
			SdrtD.dValue[j] = len;

			if (min_val > len)
			{
				min_val = len;
				gm->m_nLgdMinValKey = ElemK;
			}
			if (max_val < len)
			{
				max_val = len;
				gm->m_nLgdMaxValKey = ElemK;
			}
		}

		m_mapSDRData.SetAt(ElemK, SdrtD);

		has_content = TRUE;
	}

	if (nStrSize == 0)
		has_content = FALSE;

	if (!has_content)
	{
		min_val = max_val = 0.0;
		gm->m_nLgdMaxValKey = 0;
		gm->m_nLgdMinValKey = 0;
		m_mapSDRData.RemoveAll();
	}
	m_dMaxValue = max_val;
	m_dMinValue = min_val;

	if (m_nRebarRatio == 0 && m_nXDirYDir != 2 && has_content) // Rebar string
	{
		if (m_pContourEngine == NULL)
		{
			m_pContourEngine = new CContourEngine;
			m_pContourEngine->MakeRankMap_Rebar(m_aRebarStringList, m_aRebarAsList);
		}
		else
			m_pContourEngine->MakeRankMap_Rebar(m_aRebarStringList, m_aRebarAsList);
	}
	else
	{
		if (m_pContourEngine == NULL)
			m_pContourEngine = new CContourEngine(min_val, max_val);
		else
			m_pContourEngine->MakeRankMap(min_val, max_val);
	}

	m_bDsgnDataSet = TRUE;
	gm->m_pMyView->EndWaitCursor();
	return TRUE;
}

BOOL CDesignEngine::CalcRebarValue(const T_RSL2_D& Rsl2D, int nNode, CString& strRebar, double& dRebar, double& dSpace, BOOL bBasicRebar)
{
	DECLARE_GPSMD();

	T_UNIT_INDEX UnitIndex;
	m_pDoc->m_pUnitCtrl->GetUnitIndexCurrent(UnitIndex);

	const T_SLAB_POS& Top = Rsl2D.Top[nNode];
	const T_SLAB_POS& Bot = Rsl2D.Bot[nNode];

	auto L_GetRebarValue = [bBasicRebar](const T_SLAB_POS& CurPos, OUT CString& rstrRebar, OUT double& rdSpace)
	{
		if (bBasicRebar && CurPos.AddRebar.strInfo != _T(""))
		{
			rstrRebar = CurPos.Rebar.strInfo + _T(",") + CurPos.AddRebar.strInfo;
			rdSpace = CurPos.AddRebar.dSpace;
		}
		else if (!bBasicRebar && CurPos.AddRebar.strInfo != _T(""))
		{
			rstrRebar = CurPos.AddRebar.strInfo;
			rdSpace = CurPos.AddRebar.dSpace;
		}
		else
		{
			rstrRebar = CurPos.Rebar.strInfo;
			rdSpace = CurPos.Rebar.dSpace;
		}
	};

	switch (m_nPosi)
	{
	case 0: // top
	{
		L_GetRebarValue(Top, strRebar, dSpace);
		dRebar = Top.dAsUse*CDBLib::GetAs2Factor(UnitIndex.nBase_Length);
		break;
	}
	case 1: // bot
	{
		L_GetRebarValue(Bot, strRebar, dSpace);
		dRebar = Bot.dAsUse*CDBLib::GetAs2Factor(UnitIndex.nBase_Length);
		break;
	}
	case 2: // both
	{
		double dTop = fabs(Top.dAsUse)*CDBLib::GetAs2Factor(UnitIndex.nBase_Length);
		double dBot = fabs(Bot.dAsUse)*CDBLib::GetAs2Factor(UnitIndex.nBase_Length);

		T_SLAB_POS SlabPos; SlabPos.Initialize();
		if (dTop > dBot)
		{
			SlabPos = Top;
			dRebar = dTop;
		}
		else
		{
			SlabPos = Bot;
			dRebar = dBot;
		}
		L_GetRebarValue(SlabPos, strRebar, dSpace);
		break;
	}
	default:
	{
		ASSERT(0);
		return FALSE;
		break;
	}
	}
	strRebar.Replace(_T(" "), _T(""));
	return TRUE;
}

BOOL CDesignEngine::CalcRebarValue(const T_RSLE_D& RsleD, int nNode, CString& strRebar, double& dRebar, double& dSpace, BOOL bBasicRebar)
{
	DECLARE_GPSMD();

	T_UNIT_INDEX UnitIndex;
	m_pDoc->m_pUnitCtrl->GetUnitIndexCurrent(UnitIndex);

	const T_RSLE_POS& Top = RsleD.Top[nNode];
	const T_RSLE_POS& Bot = RsleD.Bot[nNode];

	auto L_GetRebarValue = [bBasicRebar](const T_RSLE_POS& CurPos, OUT CString& rstrRebar, OUT double& rdSpace)
	{
		if (bBasicRebar && CurPos.AddRebar.strInfo != _T(""))
		{
			rstrRebar = CurPos.Rebar.strInfo + _T(",") + CurPos.AddRebar.strInfo;
			rdSpace = CurPos.AddRebar.dSpace;
		}
		else
		{
			rstrRebar = CurPos.Rebar.strInfo;
			rdSpace = CurPos.Rebar.dSpace;
		}
	};

	const double dAs2Fact = CDBLib::GetAs2Factor(UnitIndex.nBase_Length);
	switch (m_nPosi)
	{
	case 0: // top
	{
		L_GetRebarValue(Top, strRebar, dSpace);
		dRebar = Top.dAsUse*dAs2Fact;
		break;
	}
	case 1: // bot
	{
		L_GetRebarValue(Bot, strRebar, dSpace);
		dRebar = Bot.dAsUse*dAs2Fact;
		break;
	}
	case 2: // both
	{
		double dTop = fabs(Top.dAsUse)*dAs2Fact;
		double dBot = fabs(Bot.dAsUse)*dAs2Fact;

		T_RSLE_POS SlabPos; SlabPos.Initialize();
		if (dTop > dBot)
		{
			SlabPos = Top;
			dRebar = dTop;
		}
		else
		{
			SlabPos = Bot;
			dRebar = dBot;
		}
		L_GetRebarValue(SlabPos, strRebar, dSpace);
		break;
	}
	default:
	{
		ASSERT(0);
		return FALSE;
		break;
	}
	}
	strRebar.Replace(_T(" "), _T(""));
	return TRUE;
}

BOOL CDesignEngine::CalcRebarValue_Wall(T_RMEW_D& RmewD, int nNode, CString& strRebar, double& dRebar, double& dSpace)
{
	DECLARE_GPSMD();

	T_UNIT_INDEX UnitIndex;
	m_pDoc->m_pUnitCtrl->GetUnitIndexCurrent(UnitIndex);

	switch (m_nXDirYDir)
	{
	case 0: // X Dir
	{
		strRebar = RmewD.Res[nNode].strRebar[0];
		dRebar = RmewD.Res[nNode].dAsUse[0] * CDBLib::GetAs2Factor(UnitIndex.nBase_Length);
		dSpace = RmewD.Res[nNode].dSpace[0];
	}
	break;
	case 1: // Y Dir
	{
		strRebar = RmewD.Res[nNode].strRebar[1];
		dRebar = RmewD.Res[nNode].dAsUse[1] * CDBLib::GetAs2Factor(UnitIndex.nBase_Length);
		dSpace = RmewD.Res[nNode].dSpace[1];
	}
	break;
	default:
		ASSERT(0);
		return FALSE;
		break;
	}
	return TRUE;
}

double CDesignEngine::CalcSDRValue(const T_RSL2_D& Rsl2D, int nNode, int nPos, int nRebar)
{
	DECLARE_GPSMD();
	int nCheck;
	if (gm->m_GPSMode == GPS_COMMAND_SLAB_DGN)
		nCheck = 0;
	else
		nCheck = 1;

	T_UNIT_INDEX UnitIndex;
	m_pDoc->m_pUnitCtrl->GetUnitIndexCurrent(UnitIndex);

	auto L_GetXD = [](const T_SLAB_POS& CurPos, int nXDType) -> double
	{
		if (nXDType == 0) return CurPos.dRatXd;
		return CurPos.GetXDRatioToLimit();
	};

	double len = 0.0;
	switch (nPos)
	{
	case 0: // top
	{
		const T_SLAB_POS& Top = Rsl2D.Top[nNode];
		if (nRebar == 0) // Rebar
		{
			len = Top.dAsUse*CDBLib::GetAs2Factor(UnitIndex.nBase_Length);
		}
		else if (nRebar == 1) // As
		{
			if (nCheck == 0) len = Top.dAsReq*CDBLib::GetAs2Factor(UnitIndex.nBase_Length);
			else            len = Top.dAsUse*CDBLib::GetAs2Factor(UnitIndex.nBase_Length);
		}
		else if (nRebar == 2) // As Ratio
		{
			if (nCheck == 0) len = Top.dRhoReq;
			else            len = Top.dRhoUse;
		}
		else if (nRebar == 3) // x/d
		{
			len = L_GetXD(Top, m_nXDType);
		}
		else if (nRebar == 4) // Resistance Ratio
		{
			len = Top.dRatM;
		}
		else if (nRebar == 5) // Wood Armer
		{
			len = Top.dMu;
		}
		else
			ASSERT(0);
	}
	break;
	case 1: // bot
	{
		const T_SLAB_POS& Bot = Rsl2D.Bot[nNode];
		if (nRebar == 0) // Rebar
		{
			len = Bot.dAsUse*CDBLib::GetAs2Factor(UnitIndex.nBase_Length);
		}
		else if (nRebar == 1) // As
		{
			if (nCheck == 0) len = Bot.dAsReq*CDBLib::GetAs2Factor(UnitIndex.nBase_Length);
			else            len = Bot.dAsUse*CDBLib::GetAs2Factor(UnitIndex.nBase_Length);
		}
		else if (nRebar == 2)
		{
			if (nCheck == 0) len = Bot.dRhoReq;
			else            len = Bot.dRhoUse;
		}
		else if (nRebar == 3) // x/d
		{
			len = L_GetXD(Bot, m_nXDType);
		}
		else if (nRebar == 4)
		{
			len = Bot.dRatM;
		}
		else if (nRebar == 5) // Wood Armer
		{
			len = Bot.dMu;
		}
		else
			ASSERT(0);
	}
	break;
	case 2: // both
	{
		const T_SLAB_POS& Top = Rsl2D.Top[nNode];
		const T_SLAB_POS& Bot = Rsl2D.Bot[nNode];

		auto L_GetAbsMaxVal = [](double dTop, double dBot)
		{
			return (fabs(dTop) > fabs(dBot)) ? dTop : dBot;
		};

		if (nRebar == 0) // Rebar
		{
			const double dAsUse = L_GetAbsMaxVal(Top.dAsUse, Bot.dAsUse);
			len = dAsUse * CDBLib::GetAs2Factor(UnitIndex.nBase_Length);
		}
		else if (nRebar == 1) // As
		{
			if (nCheck == 0)
			{
				const double dAsReq = L_GetAbsMaxVal(Top.dAsReq, Bot.dAsReq);
				len = dAsReq * CDBLib::GetAs2Factor(UnitIndex.nBase_Length);
			}
			else
			{
				const double dAsUse = L_GetAbsMaxVal(Top.dAsUse, Bot.dAsUse);
				len = dAsUse * CDBLib::GetAs2Factor(UnitIndex.nBase_Length);
			}
		}
		else if (nRebar == 2)
		{
			if (nCheck == 0)
			{
				len = L_GetAbsMaxVal(Top.dRhoReq, Bot.dRhoReq);
			}
			else
			{
				len = L_GetAbsMaxVal(Top.dRhoUse, Bot.dRhoUse);
			}
		}
		else if (nRebar == 3) // x/d
		{
			const double dTop = L_GetXD(Top, m_nXDType);
			const double dBot = L_GetXD(Bot, m_nXDType);

			len = L_GetAbsMaxVal(dTop, dBot);
		}
		else if (nRebar == 4)
		{
			len = L_GetAbsMaxVal(Top.dRatM, Bot.dRatM);
		}
		else if (nRebar == 5)
		{
			len = L_GetAbsMaxVal(Top.dMu, Bot.dMu);
		}
		else
			ASSERT(0);
	}
	break;
	default:
		ASSERT(0);
		break;
	}
	return len;
}

double CDesignEngine::CalcSDRValue(const T_RSLE_D& RsleD, int nNode, int nPos, int nRebar)
{
	DECLARE_GPSMD();

	// ND 결과는 Flexural Checking일 때만 수행.
	if (gm->m_GPSMode != GPS_COMMAND_SLAB_CHK) { return 0.0; }

	T_UNIT_INDEX UnitIndex;
	m_pDoc->m_pUnitCtrl->GetUnitIndexCurrent(UnitIndex);

	const double dAs2Fact = CDBLib::GetAs2Factor(UnitIndex.nBase_Length);

	auto L_GetValue = [dAs2Fact](const T_RSLE_POS& pos, int nItem) -> double
	{
		double dVal = 0.0;
		switch (nItem)
		{
		case 0: { dVal = pos.dAsUse*dAs2Fact; } break; // Rebar
		case 1: { dVal = pos.dAsUse*dAs2Fact; } break; // As
		case 2: { dVal = pos.dRhoUse;         } break; // As Ratio
		case 3: ASSERT(0); break; // x/d
		case 4: { dVal = pos.dRatio;          } break; // Resistance Ratio
		case 5: { dVal = pos.dMEd;            } break; // Wood Armer
		default: ASSERT(0); break;
		}
		return dVal;
	};

	auto L_GetMaxValue = [dAs2Fact](const T_RSLE_POS& Top, const T_RSLE_POS& Bot, int nItem) -> double
	{
		auto L_GetAbsMaxVal = [](double dTop, double dBot)
		{
			return (fabs(dTop) > fabs(dBot)) ? dTop : dBot;
		};

		double dVal = 0.0;
		switch (nItem)
		{
		case 0: { dVal = L_GetAbsMaxVal(Top.dAsUse, Bot.dAsUse)*dAs2Fact; } break; // Rebar
		case 1: { dVal = L_GetAbsMaxVal(Top.dAsUse, Bot.dAsUse)*dAs2Fact; } break; // As
		case 2: { dVal = L_GetAbsMaxVal(Top.dRhoUse, Bot.dRhoUse);        } break; // As Ratio
		case 3: ASSERT(0); break; // x/d
		case 4: { dVal = L_GetAbsMaxVal(Top.dRatio, Bot.dRatio);          } break; // Resistance Ratio
		case 5: { dVal = L_GetAbsMaxVal(Top.dMEd, Bot.dMEd);              } break; // Wood Armer
		default: ASSERT(0); break;
		}
		return dVal;
	};

	double len = 0.0;
	switch (nPos)
	{
	case 0: len = L_GetValue(RsleD.Top[nNode], nRebar); // top.
		break;
	case 1: len = L_GetValue(RsleD.Bot[nNode], nRebar); // bot.
		break;
	case 2: len = L_GetMaxValue(RsleD.Top[nNode], RsleD.Bot[nNode], nRebar); // both.    
		break;
	default: ASSERT(0);
		break;
	}
	return len;
}

double CDesignEngine::CalcSDRValue(const T_RSSA_D& RssaD, int nNode, int nItem)
{
	DECLARE_GPSMD();

	// valid for shear/adhesive check + AIJ-WSD99
	if (!CDBLib::IsCodeForMeshedDesignAIJ_JP()) { ASSERT(0); return 0.0; }
	if (gm->m_GPSMode != GPS_COMMAND_SHEAR_CHK) { ASSERT(0); return 0.0; }

	const T_RSSA_POS& CurPos = RssaD.Pos[nNode];
	switch (nItem)
	{
	case 0: return CurPos.dQ;
	case 1: return CurPos.dRatio;
	case 2: return CurPos.dwft;
	case 3: return CurPos.dpw;
	case 4: return CurPos.dAlpha;
	default: ASSERT(0); return 0.0;
	}
}

double CDesignEngine::CalcWDRValue(T_RMEW_D& RmewD, int nNode, int nDir, int nRebar)
{
	DECLARE_GPSMD();
	int nCheck;
	if (gm->m_GPSMode == GPS_COMMAND_WALL_DGN)
		nCheck = 0;
	else
		nCheck = 1;

	T_UNIT_INDEX UnitIndex;
	m_pDoc->m_pUnitCtrl->GetUnitIndexCurrent(UnitIndex);

	double len;
	switch (nDir)
	{
	case 0: // X Dir
	{
		if (nRebar == 0) // Rebar
		{
			len = RmewD.Res[nNode].dAsUse[0] * CDBLib::GetAs2Factor(UnitIndex.nBase_Length);
		}
		else if (nRebar == 1) // As
		{
			if (nCheck == 0) len = RmewD.Res[nNode].dAsReq[0] * CDBLib::GetAs2Factor(UnitIndex.nBase_Length);
			else          len = RmewD.Res[nNode].dAsUse[0] * CDBLib::GetAs2Factor(UnitIndex.nBase_Length);
		}
		else if (nRebar == 2) // As Ratio
		{
			if (nCheck == 0) len = RmewD.Res[nNode].dRhoReq[0];
			else          len = RmewD.Res[nNode].dRhoUse[0];
		}
		else if (nRebar == 3) // Resistance Ratio
		{
			len = RmewD.Res[nNode].dRat[0];
		}
		else
			ASSERT(0);
	}
	break;
	case 1: // Y Dir
	{
		if (nRebar == 0) // Rebar
		{
			len = RmewD.Res[nNode].dAsUse[1] * CDBLib::GetAs2Factor(UnitIndex.nBase_Length);
		}
		else if (nRebar == 1) // As      
		{
			if (nCheck == 0) len = RmewD.Res[nNode].dAsReq[1] * CDBLib::GetAs2Factor(UnitIndex.nBase_Length);
			else          len = RmewD.Res[nNode].dAsUse[1] * CDBLib::GetAs2Factor(UnitIndex.nBase_Length);
		}
		else if (nRebar == 2)
		{
			if (nCheck == 0) len = RmewD.Res[nNode].dRhoReq[1];
			else          len = RmewD.Res[nNode].dRhoUse[1];
		}
		else if (nRebar == 3)
		{
			len = RmewD.Res[nNode].dRat[1];
		}
		else
			ASSERT(0);
	}
	break;
	case 2: // sig_cd
	{
		if (nRebar == 0)
		{
			len = RmewD.Res[nNode].dSig_cd;
		}
		else if (nRebar == 1)
		{
			len = RmewD.Res[nNode].dRat[2];
		}
		else
			ASSERT(0);
	}
	break;
	default:
		ASSERT(0);
		break;
	}
	return len;
}

double CDesignEngine::GetMaxSDRForc(T_GPS_SLAB_DESIGN_RESULT &pforc, int node_num)
{
	double len, dMax = -DBL_MAX;
	for (int i = 0; i < node_num; i++)
	{
		len = pforc.dValue[i];
		if (len > dMax)
			dMax = len;
	}
	return dMax;
}

double CDesignEngine::GetMinSDRForc(T_GPS_SLAB_DESIGN_RESULT &pforc, int node_num)
{
	double len, dMin = DBL_MAX;
	for (int i = 0; i < node_num; i++)
	{
		len = pforc.dValue[i];
		if (len < dMin)
			dMin = len;
	}
	return dMin;
}

CString CDesignEngine::GetRebarStrbyAsValue(double dAsValue)
{
	for (int i = 0; i < m_aRebarAsList.GetSize() - 1; i++)
	{
		if (m_aRebarAsList[i] < dAsValue && m_aRebarAsList[i + 1] >= dAsValue)
			return m_aRebarStringList[i + 1];
	}

	return _T("");
}

void CDesignEngine::DrawPunchingCheckRatio(CDC *pDC)
{
	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;
	CDBDoc		  *pDoc = gm->GetDBDoc();
	int			    i, point_num = m_aPunchingPoint.GetSize();

	T_NODE_D NodeD;
	C3DPoint pnt3DPoint;
	CPoint	 pnt2D;
	CBrush	 brush, *old_brush;
	CPen		 pen, *old_pen;
	COLORREF ratio_color;
	CRect rect, client_rect;
	double  dPunchingRatio;
	CString sRatioValue;

	gm->GPSDrawOriginal(pDC);

	if (m_bPunchShear)
	{
		int nWidth;
		if (!gm->m_bVirtualMode)
		{
			gm->m_pMyView->GetClientRect(&client_rect);
			nWidth = client_rect.Width() / 60.0;
		}
		else
			nWidth = (int)((double)pDC->GetDeviceCaps(LOGPIXELSX))*0.15;

		for (i = 0; i < point_num; i++)
		{
			dPunchingRatio = m_aPunchingRatio[i];
			if (!gm->IsActiveNode(m_aPunchingPoint[i]))continue;
			if (!m_pDoc->m_pAttrCtrl->GetNode(m_aPunchingPoint[i], NodeD)) { ASSERT(0); continue; }
			pnt3DPoint.x = NodeD.x;
			pnt3DPoint.y = NodeD.y;
			pnt3DPoint.z = NodeD.z;
			ratio_color = m_pContourEngine->GetValueColor(dPunchingRatio);
			pen.CreatePen(PS_SOLID, gm->m_nLineWidth, ratio_color);
			brush.CreateSolidBrush(ratio_color);

			old_pen = (CPen*)pDC->SelectObject(&pen);
			old_brush = (CBrush*)pDC->SelectObject(&brush);

			DrawPoint(pDC, pnt3DPoint, (double)nWidth);

			if (gm->m_bVirtualMode)
				pnt2D = gm->m_pGPSCtrl->GetWorldToWindowP2D(pnt3DPoint);
			else
				pnt2D = gm->m_pGPSCtrl->GetWorldToMemDCP2D(pnt3DPoint);

			if (gm->m_DOPT.TX.m_bOutputNumber)
			{
				pDC->MoveTo(pnt2D);
				pDC->LineTo(pnt2D.x + nWidth * 1.5, pnt2D.y - nWidth * 1.5);
				pDC->LineTo(pnt2D.x + nWidth * 2.5, pnt2D.y - nWidth * 1.5);

				pnt2D.x = pnt2D.x + nWidth * 2.75;
				pnt2D.y = pnt2D.y - nWidth * 1.5;
				OutputPunchingCheckValue(pDC, pnt2D, dPunchingRatio, FALSE, m_nPunchFlag == 0);
			}

			pDC->SelectObject(old_pen);
			pDC->SelectObject(old_brush);
			pen.DeleteObject();
			brush.DeleteObject();
		}

		if (m_nForceStress == 1)
			DrawPunchingCheckRatioStressDiagram(pDC);
		else
			DrawPunchingCheckRatioForceDiagram(pDC);
	}

	if (m_bOnCuttingLine)
	{
		gm->m_pGPSCtrl->XGL_Begin_CuttingPLDiagram();
		DrawCuttingLineDiagrams(pDC);
		gm->m_pGPSCtrl->XGL_End_CuttingPLDiagram();

		/*
		pen.CreatePen(PS_SOLID,gm->m_nLineWidth,gm->m_DOPT.TX.m_NumberTextColorC);
		brush.CreateSolidBrush(gm->m_DOPT.TX.m_NumberTextColorC);

		old_pen = (CPen*)pDC->SelectObject(&pen);
		old_brush = (CBrush*)pDC->SelectObject(&brush);

		POSITION pos = m_OnewayResPosition.GetStartPosition();
		CString sCheckLineName=_T("");
		T_RSS1_D result; result.Initialize();
		T_NODE_D pPnt; pPnt.Initialize();

		char fmt_str[10],text_str[512];
		if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T("%s%dE"), _T("%."), gm->m_NumberDecimalPoint);
		else
		_stprintf(fmt_str, _T("%s%df"), _T("%."), gm->m_NumberDecimalPoint);

		UINT nChkLineKey;
		C3DPoint point3D;
		while(pos)
		{
		m_OnewayResPosition.GetNextAssoc(pos,nChkLineKey,pPnt);
		m_OnewaySlabShearResData.Lookup(nChkLineKey,result);

		point3D.x = pPnt.x;
		point3D.y = pPnt.y;
		point3D.z = pPnt.z;

		DrawPoint(pDC,point3D,nWidth/2.5);

		if (gm->m_bVirtualMode)
		pnt2D = gm->m_pGPSCtrl->GetWorldToWindowP2D(point3D);
		else
		pnt2D = gm->m_pGPSCtrl->GetWorldToMemDCP2D(point3D);

		pDC->MoveTo(pnt2D);
		pDC->LineTo(pnt2D.x+nWidth*1.5,pnt2D.y+nWidth*1.5);
		pDC->LineTo(pnt2D.x+nWidth*2.5,pnt2D.y+nWidth*1.5);

		pnt2D.x = pnt2D.x+nWidth*2.75;
		pnt2D.y = pnt2D.y+nWidth*1.5;
		CString sValue,sRVal,sTVal;
		_stprintf(text_str,fmt_str,result.dRatV);   sRVal.Format(_T("%s"),text_str);
		_stprintf(text_str,fmt_str,result.dThkReq); sTVal.Format(_T("%s"),text_str);

		sValue.Format(_T(" R:%s Thk:%s"),sRVal,sTVal);
		OutputOneWayCheckValue(pDC,pnt2D,sCheckLineName,sValue,TRUE,result.dRatV);
		}

		pDC->SelectObject(old_pen);
		pDC->SelectObject(old_brush);
		pen.DeleteObject();
		brush.DeleteObject();
		*/
	}
}

void CDesignEngine::DrawPunchingCheckRatioForceDiagram(CDC *pDC)
{
	if (m_arPnChkCutlMnMx.GetSize() < 1)
		return;
	T_ELEM_D elem_d;
	I_GPSModel  *gm = (I_GPSModel *)m_pGPSModel;
	int i;
	int nNumDatas;
	T_CUTLINE_D cutlinedata;
	double  local_vector[3][3];
	double	DiagVector[3], LineVector[3];
	double  dCutLinePoint1[3];
	double  dCutLinePoint2[3];

	double total_max = -DBL_MAX;
	double total_min = DBL_MAX;
	double AbsMax;
	double dCutLineAdjustFactor;

	for (int nCL = 0; nCL < m_arPnChkCutlMnMx.GetSize(); nCL++)
	{
		if (total_max < m_arPnChkCutlMnMx[nCL].Max) total_max = m_arPnChkCutlMnMx[nCL].Max;
		if (total_min > m_arPnChkCutlMnMx[nCL].Min) total_min = m_arPnChkCutlMnMx[nCL].Min;
	}
	AbsMax = __max(fabs(total_max), fabs(total_min));
	InitCutLineAdjustFactor(AbsMax, dCutLineAdjustFactor);

	for (int nCL = 0; nCL < m_arPnChkCutl.GetSize(); nCL++)
	{
		int ntype, etype;
		gm->RE_GetNode_ElemTypeByCDBDocSelection(ntype, etype);
		nNumDatas = m_arPnChkCutl[nCL]->GetSize();
		for (i = 0; i < nNumDatas; i++)
		{
			cutlinedata = m_arPnChkCutl[nCL]->GetAt(i);

			if (!gm->m_pGPSCtrl->IsActiveElem(cutlinedata.KeyElem) && !cutlinedata.bShowAlways) continue;

			// 도메인경계에 있을경우 통과
			//if(IsMutipleDo_tmain(cutlinedata.KeyElem))
			//{
			//  mapRemovePile.SetAt(cutlinedata.iPileNo);
			//  break; 
			// }

			dCutLinePoint1[0] = cutlinedata.Point1.x;
			dCutLinePoint1[1] = cutlinedata.Point1.y;
			dCutLinePoint1[2] = cutlinedata.Point1.z;

			dCutLinePoint2[0] = cutlinedata.Point2.x;
			dCutLinePoint2[1] = cutlinedata.Point2.y;
			dCutLinePoint2[2] = cutlinedata.Point2.z;

			LineVector[0] = dCutLinePoint2[0] - dCutLinePoint1[0];
			LineVector[1] = dCutLinePoint2[1] - dCutLinePoint1[1];
			LineVector[2] = dCutLinePoint2[2] - dCutLinePoint1[2];

			m_pDoc->m_pAttrCtrl->GetElem(cutlinedata.KeyElem, elem_d);
			if (!(gm->m_pGPSCtrl->IsZoomAllState() ||
				gm->m_pGPSCtrl->IsObjectInClientWindow(etype, cutlinedata.KeyElem)))
				continue;

			if (!cutlinedata.bShowAlways) m_pDoc->calcPlaneLocalVector(cutlinedata.KeyElem, local_vector);

			if (gm->m_nPShrCutLineDir == 0) // vertical
			{
				DiagVector[0] = local_vector[2][0];
				DiagVector[1] = local_vector[2][1];
				DiagVector[2] = local_vector[2][2];
			}
			else
			{
				CMathFunc::mathCross(LineVector, local_vector[2], DiagVector);
				CMathFunc::mathNormalize(DiagVector, DiagVector);
			}


			C3DPoint	ps, pss, pe, pee, pm;
			double dVal1, dVal2;

			ps = cutlinedata.Point1;
			pe = cutlinedata.Point2;
			dVal1 = cutlinedata.dPoint1Val;
			dVal2 = cutlinedata.dPoint2Val;
			if (gm->m_AnimEngine.m_bAnimateContour)
			{
				dVal1 *= gm->m_AnimEngine.GetAnimationFactor(TRUE);
				dVal2 *= gm->m_AnimEngine.GetAnimationFactor(TRUE);
			}

			CUtilFuncs::GetVectorDirectionPoint(DiagVector, dVal1, gm->m_bCutLineScaleFactor*dCutLineAdjustFactor, ps, pss);
			CUtilFuncs::GetVectorDirectionPoint(DiagVector, dVal2, gm->m_bCutLineScaleFactor*dCutLineAdjustFactor, pe, pee);

			///////////////////////////////////////////////////////////////////////////		
			CPen pen, *old_pen;
			pen.CreatePen(PS_SOLID, gm->m_nLineWidth*1.0, gm->m_PShrCutLineColor);

			old_pen = (CPen *)pDC->SelectObject(&pen);

			if (gm->m_bVirtualMode)
			{
				gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, ps, pss);
				gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, pe, pee);
			}
			else
			{
				gm->m_pGPSCtrl->DrawLine3D(pDC, ps, pss);
				gm->m_pGPSCtrl->DrawLine3D(pDC, pe, pee);
			}

			pDC->SelectObject(old_pen);
			pen.DeleteObject();

			pen.CreatePen(PS_SOLID, gm->m_nLineWidth*2.0, gm->m_PShrCutLineColor);

			old_pen = (CPen *)pDC->SelectObject(&pen);

			if (gm->m_bVirtualMode)
			{
				gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, pss, pee);
				gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, ps, pe);
			}
			else
			{
				gm->m_pGPSCtrl->DrawLine3D(pDC, pss, pee);
				gm->m_pGPSCtrl->DrawLine3D(pDC, ps, pe);
			}

			pDC->SelectObject(old_pen);
			pen.DeleteObject();
			///////////////////////////////////////////////////////////////////////////
		}
	}
}

void CDesignEngine::DrawPunchingCheckRatioStressDiagram(CDC *pDC)
{
	T_ELEM_D elem_d;
	I_GPSModel  *gm = (I_GPSModel *)m_pGPSModel;
	int i;
	int nNumDatas;
	T_CUTLINE_D cutlinedata;
	double  local_vector[3][3];
	double	DiagVector[3], LineVector[3];
	double  dCutLinePoint1[3];
	double  dCutLinePoint2[3];

	double total_max = -DBL_MAX;
	double total_min = DBL_MAX;
	double AbsMax;
	double dCutLineAdjustFactor;

	for (int nCL = 0; nCL < m_arPnChkCutlMnMx.GetSize(); nCL++)
	{
		if (total_max < m_arPnChkCutlMnMx[nCL].Max) total_max = m_arPnChkCutlMnMx[nCL].Max;
		if (total_min > m_arPnChkCutlMnMx[nCL].Min) total_min = m_arPnChkCutlMnMx[nCL].Min;
	}
	AbsMax = __max(fabs(total_max), fabs(total_min));
	InitCutLineAdjustFactor(AbsMax, dCutLineAdjustFactor);

	for (int nCL = 0; nCL < m_arPnChkCutl.GetSize(); nCL++)
	{
		int ntype, etype;
		gm->RE_GetNode_ElemTypeByCDBDocSelection(ntype, etype);
		nNumDatas = m_arPnChkCutl[nCL]->GetSize();
		for (i = 0; i < nNumDatas; i++)
		{
			cutlinedata = m_arPnChkCutl[nCL]->GetAt(i);

			if (!gm->m_pGPSCtrl->IsActiveElem(cutlinedata.KeyElem) && !cutlinedata.bShowAlways) continue;

			dCutLinePoint1[0] = cutlinedata.Point1.x;
			dCutLinePoint1[1] = cutlinedata.Point1.y;
			dCutLinePoint1[2] = cutlinedata.Point1.z;

			dCutLinePoint2[0] = cutlinedata.Point2.x;
			dCutLinePoint2[1] = cutlinedata.Point2.y;
			dCutLinePoint2[2] = cutlinedata.Point2.z;

			LineVector[0] = dCutLinePoint2[0] - dCutLinePoint1[0];
			LineVector[1] = dCutLinePoint2[1] - dCutLinePoint1[1];
			LineVector[2] = dCutLinePoint2[2] - dCutLinePoint1[2];

			m_pDoc->m_pAttrCtrl->GetElem(cutlinedata.KeyElem, elem_d);
			if (!(gm->m_pGPSCtrl->IsZoomAllState() ||
				gm->m_pGPSCtrl->IsObjectInClientWindow(etype, cutlinedata.KeyElem)))
				continue;

			m_pDoc->calcPlaneLocalVector(cutlinedata.KeyElem, local_vector);

			if (gm->m_nPShrCutLineDir == 0) // vertical
			{
				DiagVector[0] = local_vector[2][0];
				DiagVector[1] = local_vector[2][1];
				DiagVector[2] = local_vector[2][2];
			}
			else
			{
				CMathFunc::mathCross(LineVector, local_vector[2], DiagVector);
				CMathFunc::mathNormalize(DiagVector, DiagVector);
			}


			C3DPoint	ps, pss, pe, pee, pm;
			double dVal1, dVal2;

			ps = cutlinedata.Point1;
			pe = cutlinedata.Point2;
			dVal1 = cutlinedata.dPoint1Val;
			dVal2 = cutlinedata.dPoint2Val;
			if (gm->m_AnimEngine.m_bAnimateContour)
			{
				dVal1 *= gm->m_AnimEngine.GetAnimationFactor(TRUE);
				dVal2 *= gm->m_AnimEngine.GetAnimationFactor(TRUE);
			}

			CUtilFuncs::GetVectorDirectionPoint(DiagVector, dVal1, gm->m_bCutLineScaleFactor*dCutLineAdjustFactor, ps, pss);
			CUtilFuncs::GetVectorDirectionPoint(DiagVector, dVal2, gm->m_bCutLineScaleFactor*dCutLineAdjustFactor, pe, pee);

			///////////////////////////////////////////////////////////////////////////		
			CPen pen, *old_pen;
			pen.CreatePen(PS_SOLID, gm->m_nLineWidth*1.0, gm->m_PShrCutLineColor);

			old_pen = (CPen *)pDC->SelectObject(&pen);

			if (gm->m_bVirtualMode)
			{
				gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, ps, pss);
				gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, pe, pee);
			}
			else
			{
				gm->m_pGPSCtrl->DrawLine3D(pDC, ps, pss);
				gm->m_pGPSCtrl->DrawLine3D(pDC, pe, pee);
			}

			pDC->SelectObject(old_pen);
			pen.DeleteObject();

			pen.CreatePen(PS_SOLID, gm->m_nLineWidth*2.0, gm->m_PShrCutLineColor);

			old_pen = (CPen *)pDC->SelectObject(&pen);

			if (gm->m_bVirtualMode)
			{
				gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, pss, pee);
				gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, ps, pe);
			}
			else
			{
				gm->m_pGPSCtrl->DrawLine3D(pDC, pss, pee);
				gm->m_pGPSCtrl->DrawLine3D(pDC, ps, pe);
			}

			pDC->SelectObject(old_pen);
			pen.DeleteObject();
			///////////////////////////////////////////////////////////////////////////

			if (gm->m_bPShrCutLineOutputValue && gm->m_bPShrCutLineOutputMinMax)
			{
				if (fabs(dVal1 - m_arPnChkCutlMnMx[nCL].Max) < 1e-8)
					OutputCutLineNumber(pDC, &pss, dVal1);
				else if (fabs(dVal1 - m_arPnChkCutlMnMx[nCL].Min) < 1e-8)
					OutputCutLineNumber(pDC, &pss, dVal1);
				if (fabs(dVal2 - m_arPnChkCutlMnMx[nCL].Max) < 1e-8)
					OutputCutLineNumber(pDC, &pee, dVal2);
				else if (fabs(dVal2 - m_arPnChkCutlMnMx[nCL].Min) < 1e-8)
					OutputCutLineNumber(pDC, &pee, dVal2);
			}
			else if (gm->m_bPShrCutLineOutputValue && !gm->m_bPShrCutLineOutputMinMax)
			{
				OutputCutLineNumber(pDC, &pss, dVal1);
				OutputCutLineNumber(pDC, &pee, dVal2);
			}
		}
	}
}

#if defined(__OLD_OUTPUT_VALUE)
void CDesignEngine::OutputPunchingCheckValue(CDC* pDC, CPoint point, double dValue, BOOL bVertical, BOOL bCheckValAsRatio)
{
	DECLARE_GPSMD();
	DECLARE_DPTTX();

	TCHAR							text_str[512];
	CFont							ft, * old_ft;

	if (point.x < 0 || point.y < 0) return;
	if (bVertical)
		gm->m_NumberFont.lfEscapement = gm->m_NumberFont.lfOrientation = 900;
	else
		gm->m_NumberFont.lfEscapement = gm->m_NumberFont.lfOrientation = 0;
	ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
	old_ft = (CFont*)pDC->SelectObject(&ft);

	TEXTMETRIC tm;
	pDC->GetTextMetrics(&tm);
	int fh = tm.tmHeight;

	if (gm->m_DOPT.TX.m_bNumberOpaque)
		pDC->SetBkMode(OPAQUE);
	else
		pDC->SetBkMode(TRANSPARENT);

	if (dValue <= 1.0 || bCheckValAsRatio == FALSE)
	{
		pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
		pDC->SetBkColor(gm->m_DOPT.TX.m_NumberBackCol);
		if (gm->m_DOPT.TX.m_bNumberOpaque)
			pDC->SetBkMode(OPAQUE);
		else
			pDC->SetBkMode(TRANSPARENT);
	}
	else
	{
		pDC->SetTextColor(RGB(255, 0, 0));
		pDC->SetBkColor(RGB(255, 255, 0));
		pDC->SetBkMode(OPAQUE);
	}

	if (bVertical)
		pDC->SetTextAlign(TA_LEFT | TA_TOP);
	else
		pDC->SetTextAlign(TA_LEFT | TA_BOTTOM);

	TCHAR fmt_str[10];
	if (pTX->m_bNumberExponent)
		_stprintf(fmt_str, _T("%s%dE"), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T("%s%df"), _T("%."), gm->m_NumberDecimalPoint);
	_stprintf(text_str, fmt_str, dValue);
	pDC->TextOut(point.x, point.y + fh / 2.0, text_str);

	if (m_bOnCuttingLine)
	{
		T_UNIT_INDEX UnitIndex;
		m_pDoc->m_pUnitCtrl->GetUnitIndexCurrent(UnitIndex);

		CPoint	 pnt2D;
		CBrush	 brush, * old_brush;
		CPen		 pen, * old_pen;
		CRect rect, client_rect;
		CString sRatioValue;
		int nWidth;
		if (!gm->m_bVirtualMode)
		{
			gm->m_pMyView->GetClientRect(&client_rect);
			nWidth = client_rect.Width() / 60.0;
		}
		else
			nWidth = (int)((double)pDC->GetDeviceCaps(LOGPIXELSX)) * 0.15;

		pen.CreatePen(PS_SOLID, gm->m_nLineWidth, gm->m_DOPT.TX.m_NumberTextColorC);
		brush.CreateSolidBrush(gm->m_DOPT.TX.m_NumberTextColorC);

		old_pen = (CPen*)pDC->SelectObject(&pen);
		old_brush = (CBrush*)pDC->SelectObject(&brush);

		POSITION pos = m_OnewayResPosition.GetStartPosition();
		CString sCheckLineName = _T("");
		T_RSS1_D result; result.Initialize();
		T_NODE_D pPnt; pPnt.Initialize();

		TCHAR fmt_str[10], text_str[512];
		if (gm->m_DOPT.TX.m_bNumberExponent)
			_stprintf(fmt_str, _T("%s%dE"), _T("%."), gm->m_NumberDecimalPoint);
		else
			_stprintf(fmt_str, _T("%s%df"), _T("%."), gm->m_NumberDecimalPoint);

		UINT nChkLineKey;
		C3DPoint point3D;
		while (pos)
		{
			m_OnewayResPosition.GetNextAssoc(pos, nChkLineKey, pPnt);
			m_OnewaySlabShearResData.Lookup(nChkLineKey, result);

			point3D.x = pPnt.x;
			point3D.y = pPnt.y;
			point3D.z = pPnt.z;

			DrawPoint(pDC, point3D, (double)nWidth / 2.5);

			if (gm->m_bVirtualMode)
				pnt2D = gm->m_pGPSCtrl->GetWorldToWindowP2D(point3D);
			else
				pnt2D = gm->m_pGPSCtrl->GetWorldToMemDCP2D(point3D);

			pDC->MoveTo(pnt2D);
			pDC->LineTo(pnt2D.x + nWidth * 1.5, pnt2D.y + nWidth * 1.5);
			pDC->LineTo(pnt2D.x + nWidth * 2.5, pnt2D.y + nWidth * 1.5);

			pnt2D.x = pnt2D.x + nWidth * 2.75;
			pnt2D.y = pnt2D.y + nWidth * 1.5;
			CString sValue, sRVal, sTVal;
			_stprintf(text_str, fmt_str, result.dRatV);   sRVal.Format(_T("%s"), text_str);
			_stprintf(text_str, fmt_str, result.dThkReq); sTVal.Format(_T("%s"), text_str);

			sValue.Format(_T(" R:%s Thk:%s"), sRVal, sTVal);
			OutputOneWayCheckValue(pDC, pnt2D, sCheckLineName, sValue, TRUE, result.dRatV);
		}

		pDC->SelectObject(old_pen);
		pDC->SelectObject(old_brush);
		pen.DeleteObject();
		brush.DeleteObject();
	}

	pDC->SelectObject(old_ft);
	ft.DeleteObject();

	gm->m_NumberFont.lfEscapement = gm->m_NumberFont.lfOrientation = 0;
}

#else
void CDesignEngine::OutputPunchingCheckValue(CDC *pDC, CPoint point, double dValue, BOOL bVertical, BOOL bCheckValAsRatio)
{
	DECLARE_GPSMD();
	DECLARE_DPTTX();

	TCHAR							text_str[512];
	
	
	if (point.x < 0 || point.y < 0) return;

	TCHAR fmt_str[10];
	if (pTX->m_bNumberExponent)
		_stprintf(fmt_str, _T("%s%dE"), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T("%s%df"), _T("%."), gm->m_NumberDecimalPoint);
	_stprintf(text_str, fmt_str, dValue);
	GPostTextOut TextOutModel;
	TextOutModel.SetDC(pDC);
	TextOutModel.StartPunchingVal();
	TextOutModel.TextOutPunching(gm, point.x, point.y, text_str, dValue, bVertical, bCheckValAsRatio);
	
	if (m_bOnCuttingLine)
	{
		T_UNIT_INDEX UnitIndex;
		m_pDoc->m_pUnitCtrl->GetUnitIndexCurrent(UnitIndex);

		CPoint	 pnt2D;
		CBrush	 brush, *old_brush;
		CPen		 pen, *old_pen;
		CRect rect, client_rect;
		CString sRatioValue;
		int nWidth;
		if (!gm->m_bVirtualMode)
		{
			gm->m_pMyView->GetClientRect(&client_rect);
			nWidth = client_rect.Width() / 60.0;
		}
		else
			nWidth = (int)((double)pDC->GetDeviceCaps(LOGPIXELSX))*0.15;

		pen.CreatePen(PS_SOLID, gm->m_nLineWidth, gm->m_DOPT.TX.m_NumberTextColorC);
		brush.CreateSolidBrush(gm->m_DOPT.TX.m_NumberTextColorC);

		old_pen = (CPen*)pDC->SelectObject(&pen);
		old_brush = (CBrush*)pDC->SelectObject(&brush);

		POSITION pos = m_OnewayResPosition.GetStartPosition();
		CString sCheckLineName = _T("");
		T_RSS1_D result; result.Initialize();
		T_NODE_D pPnt; pPnt.Initialize();

		TCHAR fmt_str[10], text_str[512];
		if (gm->m_DOPT.TX.m_bNumberExponent)
			_stprintf(fmt_str, _T("%s%dE"), _T("%."), gm->m_NumberDecimalPoint);
		else
			_stprintf(fmt_str, _T("%s%df"), _T("%."), gm->m_NumberDecimalPoint);

		UINT nChkLineKey;
		C3DPoint point3D;
		while (pos)
		{
			m_OnewayResPosition.GetNextAssoc(pos, nChkLineKey, pPnt);
			m_OnewaySlabShearResData.Lookup(nChkLineKey, result);

			point3D.x = pPnt.x;
			point3D.y = pPnt.y;
			point3D.z = pPnt.z;

			DrawPoint(pDC, point3D, (double)nWidth / 2.5);

			if (gm->m_bVirtualMode)
				pnt2D = gm->m_pGPSCtrl->GetWorldToWindowP2D(point3D);
			else
				pnt2D = gm->m_pGPSCtrl->GetWorldToMemDCP2D(point3D);

			pDC->MoveTo(pnt2D);
			pDC->LineTo(pnt2D.x + nWidth * 1.5, pnt2D.y + nWidth * 1.5);
			pDC->LineTo(pnt2D.x + nWidth * 2.5, pnt2D.y + nWidth * 1.5);

			pnt2D.x = pnt2D.x + nWidth * 2.75;
			pnt2D.y = pnt2D.y + nWidth * 1.5;
			CString sValue, sRVal, sTVal;
			_stprintf(text_str, fmt_str, result.dRatV);   sRVal.Format(_T("%s"), text_str);
			_stprintf(text_str, fmt_str, result.dThkReq); sTVal.Format(_T("%s"), text_str);

			sValue.Format(_T(" R:%s Thk:%s"), sRVal, sTVal);
			TextOutModel.TextOutOneWay(gm, pnt2D, sCheckLineName, sValue, TRUE, result.dRatV);
		}

		pDC->SelectObject(old_pen);
		pDC->SelectObject(old_brush);
		pen.DeleteObject();
		brush.DeleteObject();
	}

	TextOutModel.DeleteFont();
	TextOutModel.EndPunchingVal();

	gm->m_NumberFont.lfEscapement = gm->m_NumberFont.lfOrientation = 0;
}
#endif

void CDesignEngine::OutputOneWayCheckValue(CDC *pDC, CPoint point, CString& Name, CString& sValue, BOOL bRatioCheck/*=FALSE*/, double dRatio/*=0*/)
{
	I_GPSModel				*gm = (I_GPSModel *)m_pGPSModel;

	TCHAR							text_str[512];
	CFont							ft, *old_ft;

	if (point.x < 0 || point.y < 0) return;

	gm->m_NumberFont.lfEscapement = gm->m_NumberFont.lfOrientation = 0;
	ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
	old_ft = (CFont *)pDC->SelectObject(&ft);

	TEXTMETRIC tm;
	pDC->GetTextMetrics(&tm);
	int fh = tm.tmHeight;

	pDC->SetTextAlign(TA_LEFT | TA_BOTTOM);

	if (gm->m_DOPT.TX.m_bNumberOpaque)
		pDC->SetBkMode(OPAQUE);
	else
		pDC->SetBkMode(TRANSPARENT);

	pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
	pDC->SetBkColor(gm->m_DOPT.TX.m_NumberBackCol);
	if (gm->m_DOPT.TX.m_bNumberOpaque)
		pDC->SetBkMode(OPAQUE);
	else
		pDC->SetBkMode(TRANSPARENT);

	_stprintf(text_str, _T("%s"), (LPCTSTR)Name);
	pDC->TextOut(point.x, point.y - fh * 0.05, text_str);

	if (bRatioCheck && (dRatio > 1.0))
	{
		pDC->SetTextColor(RGB(255, 0, 0));
		pDC->SetBkColor(RGB(255, 255, 0));
		pDC->SetBkMode(OPAQUE);
	}
	else
	{
		pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
		pDC->SetBkColor(gm->m_DOPT.TX.m_NumberBackCol);
		if (gm->m_DOPT.TX.m_bNumberOpaque)
			pDC->SetBkMode(OPAQUE);
		else
			pDC->SetBkMode(TRANSPARENT);
	}

	pDC->TextOut(point.x, point.y + fh, sValue);


	pDC->SelectObject(old_ft);
	ft.DeleteObject();

	gm->m_NumberFont.lfEscapement = gm->m_NumberFont.lfOrientation = 0;
}

#if defined(__OLD_OUTPUT_VALUE)
void CDesignEngine::OutputSeisPerform(CDC *pDC, BOOL bSeisPerformDataSet)
{
	DECLARE_DBDOC();
	DECLARE_GPSMD();
	DECLARE_DPTDR();
	DECLARE_DPTRD();
	DECLARE_DPTTX();

	int	  i, nElemN;
	T_ELEM_D  ElemD;
	GPS_INTG_ARRY  TypeList;
	GPS_ATOM_ARRYR AtomList;

	BOOL bEscapePressed = FALSE;
	if (!bSeisPerformDataSet || !gm->m_bContour) { gm->GPSDrawOriginal(pDC); return; }

	pTX->m_NumberDecimalPoint = gm->m_NumberDecimalPoint;
	pTX->m_NumberFont = gm->m_NumberFont;

	CFont	ft, *old_ft;
	ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
	old_ft = (CFont *)pDC->SelectObject(&ft);

	if (m_bDeformedShapeContour) TypeList.Add(gm->m_MinOTID + OBJECT_TYPE_DEFORMED);
	else		                    TypeList.Add(gm->m_MinOTID + OBJECT_TYPE_ORIGINAL);
	gm->m_pGPSCtrl->GetZSortedList(TypeList, gm->m_EKeyListVisible_Mirror, AtomList);
	nElemN = AtomList.GetSize();

	CMap<UINT, UINT, UINT, UINT> mUsedWallK; mUsedWallK.RemoveAll();
	mUsedWallK.InitHashTable(11);
	CArray<T_ELEM_K, T_ELEM_K> ElemKeyList; ElemKeyList.RemoveAll();
	UINT nTemp = 0;

	T_ELEM_K ElemK = NULL;
	for (i = 0; i < nElemN; i++)
	{
		ElemK = AtomList[i].m_OKey;
		if (gm->m_pGPSCtrl->WatchEscKeyPress())break;
		if (gm->m_pGPSCtrl->IsZoomAllState() ||
			gm->m_pGPSCtrl->IsObjectInClientWindow(AtomList[i].m_OType, ElemK))
		{
			if (!m_mSeisPerform.Exist(ElemK)) continue;

			if (gm->m_pGPSCtrl->IsActiveElem(ElemK))
			{
				if (!pDoc->m_pAttrCtrl->GetElem(ElemK, ElemD))continue;
				OutputSeisPerformSub(pDC, ElemK);
			}
		}
	}
	pDC->SelectObject(old_ft);
	ft.DeleteObject();
}
#else
void CDesignEngine::OutputSeisPerform(CDC* pDC, BOOL bSeisPerformDataSet)
{
	DECLARE_DBDOC();
	DECLARE_GPSMD();
	DECLARE_DPTDR();
	DECLARE_DPTRD();
	DECLARE_DPTTX();

	int	  i, nElemN;
	T_ELEM_D  ElemD;
	GPS_INTG_ARRY  TypeList;
	GPS_ATOM_ARRYR AtomList;

	BOOL bEscapePressed = FALSE;
	if (!bSeisPerformDataSet || !gm->m_bContour) { gm->GPSDrawOriginal(pDC); return; }

	pTX->m_NumberDecimalPoint = gm->m_NumberDecimalPoint;
	pTX->m_NumberFont = gm->m_NumberFont;

	GPostTextOut TextOutModel;
	TextOutModel.SetDC(pDC);
	TextOutModel.StartSeisPerformVal();
	TextOutModel.Font4SeisPerform(gm, 0);
	
	if (m_bDeformedShapeContour) TypeList.Add(gm->m_MinOTID + OBJECT_TYPE_DEFORMED);
	else		                    TypeList.Add(gm->m_MinOTID + OBJECT_TYPE_ORIGINAL);
	gm->m_pGPSCtrl->GetZSortedList(TypeList, gm->m_EKeyListVisible_Mirror, AtomList);
	nElemN = AtomList.GetSize();

	CMap<UINT, UINT, UINT, UINT> mUsedWallK; mUsedWallK.RemoveAll();
	mUsedWallK.InitHashTable(11);
	CArray<T_ELEM_K, T_ELEM_K> ElemKeyList; ElemKeyList.RemoveAll();
	UINT nTemp = 0;

	T_ELEM_K ElemK = NULL;
	for (i = 0; i < nElemN; i++)
	{
		ElemK = AtomList[i].m_OKey;
		if (gm->m_pGPSCtrl->WatchEscKeyPress())break;
		if (gm->m_pGPSCtrl->IsZoomAllState() ||
			gm->m_pGPSCtrl->IsObjectInClientWindow(AtomList[i].m_OType, ElemK))
		{
			if (!m_mSeisPerform.Exist(ElemK)) continue;

			if (gm->m_pGPSCtrl->IsActiveElem(ElemK))
			{
				if (!pDoc->m_pAttrCtrl->GetElem(ElemK, ElemD))continue;
				OutputSeisPerformSub(pDC, ElemK);
			}
		}
	}
	TextOutModel.DeleteFont();
	TextOutModel.EndSeisPerformVal();
}
#endif

#if defined(__OLD_OUTPUT_VALUE)
void CDesignEngine::OutputSeisPerformSub(CDC* pDC, UINT ElemK)
{
	DECLARE_DBDOC();
	DECLARE_GPSMD();
	DECLARE_DPTDR();
	DECLARE_DPTTX();

	T_PRFM_RESULT  PrfmResult;
	CArray<GPS_3DPT_LISTP, GPS_3DPT_LISTP>	PolyList, PolyList_J;

	BOOL m_bDSCont = m_bDeformedShapeContour;
	if (!m_mSeisPerform.Lookup(ElemK, PrfmResult))return;

	BOOL bBackWireFrame = pDR->m_bFrameLine;
	pDR->m_bFrameLine = TRUE;

	if (gm->m_DOPT.TX.m_bNumberOpaque) pDC->SetBkMode(OPAQUE);
	else                               pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
	pDC->SetBkColor(gm->m_DOPT.TX.m_NumberBackCol);
	pDC->SetTextAlign(TA_CENTER | TA_BOTTOM);

	CPoint Node2D[2];

	T_ELEM_D ElemD;
	if (!pDoc->m_pAttrCtrl->GetElem(ElemK, ElemD)) return;
	if (pDoc->m_pAttrCtrl->IsWall(ElemD.eltyp))
	{
		CArray<T_ELEM_K, T_ELEM_K> ElemKeyList;
		m_pDoc->m_pAttrCtrl->GetKeyListBy_WallID_ByStor(ElemKeyList, ElemK);

		C3DPoint BottmPt, TopPt;
		GetCenterPosition4Wall_ByWallID_ByStor(ElemKeyList, TopPt, BottmPt);

		Node2D[0] = gm->Get3DPtTo2DPt(&BottmPt);
		Node2D[1] = gm->Get3DPtTo2DPt(&TopPt);
	}
	else
	{
		T_MEMB_K MembK = 0;
		if (gm->GetDrawPOHingeByMember() && m_pDoc->m_pAttrCtrl->GetMembAssigned(ElemK, MembK))
		{
			// [PMS 5388] 내진성능평가 - 멤버별 힌지 결과출력
			T_MEMB_D MembD;
			m_pDoc->m_pAttrCtrl->GetMemb(MembK, MembD);

			T_ELEM_K ElemK_I = MembD.aElemList[0];
			T_ELEM_K ElemK_J = MembD.aElemList[MembD.aElemList.GetSize() - 1];

			// 조적허리벽 고려 시 출력위치 변경
			if (gm->m_pDeformEngine->GetColumnByInfillStrut() == TRUE)
			{
				T_PARTIALCOLUMN_DATA data;
				if (gm->m_pDeformEngine->m_columnDividerByIS.GetData(MembK, data))
				{
					enum { D_DOF_FX = 0, D_DOF_FY, D_DOF_FZ, D_DOF_RX, D_DOF_RY, D_DOF_RZ };
					switch (m_SeisPerformComponent_2nd)
					{
					case DUTL_FACTOR_DY:
					case DUTL_FACTOR_RZ:
						ElemK_I = data.inPlane.ElemK_I;
						ElemK_J = data.inPlane.ElemK_J;
						break;
					case DUTL_FACTOR_DZ:
					case DUTL_FACTOR_RY:
						ElemK_I = data.outOfPlane.ElemK_I;
						ElemK_J = data.outOfPlane.ElemK_J;
						break;
					case DUTL_FACTOR_DX:
					case DUTL_FACTOR_RX:
						break; // 기존 위치 그대로
					}
				}
			}

			if (m_bDSCont)
			{
				gm->m_pDeformEngine->GetDeformedShapeElement(ElemK_I, &PolyList, NULL, NULL);
				gm->m_pDeformEngine->GetDeformedShapeElement(ElemK_J, &PolyList_J, NULL, NULL);
			}
			else
			{
				gm->GetShapeElement(ElemK_I, PolyList, NULL, NULL, NULL);
				gm->GetShapeElement(ElemK_J, PolyList_J, NULL, NULL, NULL);
			}

			// Tail 값을 J요소의 J단으로 교체
			PolyList[0]->RemoveTail();
			PolyList[0]->AddTail(PolyList_J[0]->GetTail());
		}
		else
		{
			if (m_bDSCont) gm->m_pDeformEngine->GetDeformedShapeElement(ElemK, &PolyList, NULL, NULL);
			else	        gm->GetShapeElement(ElemK, PolyList, NULL, NULL, NULL);
		}

		C3DPoint  Node3D[2];
		POSITION nPos = PolyList[0]->GetHeadPosition();
		Node3D[0] = PolyList[0]->GetNext(nPos);
		Node3D[1] = PolyList[0]->GetNext(nPos);
		Node2D[0] = gm->Get3DPtTo2DPt(&Node3D[0]);
		Node2D[1] = gm->Get3DPtTo2DPt(&Node3D[1]);

		FreeMemoryPolyList(&PolyList, NULL, NULL);
	}
	pDR->m_bFrameLine = bBackWireFrame;

	CSeisEvalDataTool Tool;
	CPoint Pt_1, Pt_2;
	if (m_nDisplayMode == 0)
	{
		Pt_1.x = Node2D[0].x + (Node2D[1].x - Node2D[0].x) * 0.1;
		Pt_1.y = Node2D[0].y + (Node2D[1].y - Node2D[0].y) * 0.1;

		Pt_2.x = Node2D[0].x + (Node2D[1].x - Node2D[0].x) * 0.9;
		Pt_2.y = Node2D[0].y + (Node2D[1].y - Node2D[0].y) * 0.9;

		if (PrfmResult.enLevel_1 >= EN_LEVEL_IO && PrfmResult.enLevel_1 <= EN_LEVEL_CL)
			pDC->TextOut(Pt_1.x, Pt_1.y, Tool.GetPerformLevel((EN_LEVEL)PrfmResult.enLevel_1));
		if (PrfmResult.enLevel_2 >= EN_LEVEL_IO && PrfmResult.enLevel_2 <= EN_LEVEL_CL)
			pDC->TextOut(Pt_2.x, Pt_2.y, Tool.GetPerformLevel((EN_LEVEL)PrfmResult.enLevel_2));
	}
	else
	{
		Pt_1.x = Node2D[0].x + (Node2D[1].x - Node2D[0].x) * 0.5;
		Pt_1.y = Node2D[0].y + (Node2D[1].y - Node2D[0].y) * 0.5;

		if (PrfmResult.enLevel >= EN_LEVEL_IO && PrfmResult.enLevel <= EN_LEVEL_CL)
			pDC->TextOut(Pt_1.x, Pt_1.y, Tool.GetPerformLevel((EN_LEVEL)PrfmResult.enLevel));
	}
}
#else
void CDesignEngine::OutputSeisPerformSub(CDC *pDC, UINT ElemK)
{
	DECLARE_DBDOC();
	DECLARE_GPSMD();
	DECLARE_DPTDR();
	DECLARE_DPTTX();

	T_PRFM_RESULT  PrfmResult;
	CArray<GPS_3DPT_LISTP, GPS_3DPT_LISTP>	PolyList, PolyList_J;

	BOOL m_bDSCont = m_bDeformedShapeContour;
	if (!m_mSeisPerform.Lookup(ElemK, PrfmResult))return;

	BOOL bBackWireFrame = pDR->m_bFrameLine;
	pDR->m_bFrameLine = TRUE;
	GPostTextOut TextOutModel;
	TextOutModel.SetDC(pDC);
	TextOutModel.SettingSeisPerform(gm);

	CPoint Node2D[2];

	T_ELEM_D ElemD;
	if (!pDoc->m_pAttrCtrl->GetElem(ElemK, ElemD)) return;
	if (pDoc->m_pAttrCtrl->IsWall(ElemD.eltyp))
	{
		CArray<T_ELEM_K, T_ELEM_K> ElemKeyList;
		m_pDoc->m_pAttrCtrl->GetKeyListBy_WallID_ByStor(ElemKeyList, ElemK);

		C3DPoint BottmPt, TopPt;
		GetCenterPosition4Wall_ByWallID_ByStor(ElemKeyList, TopPt, BottmPt);

		Node2D[0] = gm->Get3DPtTo2DPt(&BottmPt);
		Node2D[1] = gm->Get3DPtTo2DPt(&TopPt);
	}
	else
	{
		T_MEMB_K MembK = 0;
		if (gm->GetDrawPOHingeByMember() && m_pDoc->m_pAttrCtrl->GetMembAssigned(ElemK, MembK))
		{
			// [PMS 5388] 내진성능평가 - 멤버별 힌지 결과출력
			T_MEMB_D MembD;
			m_pDoc->m_pAttrCtrl->GetMemb(MembK, MembD);

			T_ELEM_K ElemK_I = MembD.aElemList[0];
			T_ELEM_K ElemK_J = MembD.aElemList[MembD.aElemList.GetSize() - 1];

			// 조적허리벽 고려 시 출력위치 변경
			if (gm->m_pDeformEngine->GetColumnByInfillStrut() == TRUE)
			{
				T_PARTIALCOLUMN_DATA data;
				if (gm->m_pDeformEngine->m_columnDividerByIS.GetData(MembK, data))
				{
					enum { D_DOF_FX = 0, D_DOF_FY, D_DOF_FZ, D_DOF_RX, D_DOF_RY, D_DOF_RZ };
					switch (m_SeisPerformComponent_2nd)
					{
					case DUTL_FACTOR_DY:
					case DUTL_FACTOR_RZ:
						ElemK_I = data.inPlane.ElemK_I;
						ElemK_J = data.inPlane.ElemK_J;
						break;
					case DUTL_FACTOR_DZ:
					case DUTL_FACTOR_RY:
						ElemK_I = data.outOfPlane.ElemK_I;
						ElemK_J = data.outOfPlane.ElemK_J;
						break;
					case DUTL_FACTOR_DX:
					case DUTL_FACTOR_RX:
						break; // 기존 위치 그대로
					}
				}
			}

			if (m_bDSCont)
			{
				gm->m_pDeformEngine->GetDeformedShapeElement(ElemK_I, &PolyList, NULL, NULL);
				gm->m_pDeformEngine->GetDeformedShapeElement(ElemK_J, &PolyList_J, NULL, NULL);
			}
			else
			{
				gm->GetShapeElement(ElemK_I, PolyList, NULL, NULL, NULL);
				gm->GetShapeElement(ElemK_J, PolyList_J, NULL, NULL, NULL);
			}

			// Tail 값을 J요소의 J단으로 교체
			PolyList[0]->RemoveTail();
			PolyList[0]->AddTail(PolyList_J[0]->GetTail());
		}
		else
		{
			if (m_bDSCont) gm->m_pDeformEngine->GetDeformedShapeElement(ElemK, &PolyList, NULL, NULL);
			else	        gm->GetShapeElement(ElemK, PolyList, NULL, NULL, NULL);
		}

		C3DPoint  Node3D[2];
		POSITION nPos = PolyList[0]->GetHeadPosition();
		Node3D[0] = PolyList[0]->GetNext(nPos);
		Node3D[1] = PolyList[0]->GetNext(nPos);
		Node2D[0] = gm->Get3DPtTo2DPt(&Node3D[0]);
		Node2D[1] = gm->Get3DPtTo2DPt(&Node3D[1]);

		FreeMemoryPolyList(&PolyList, NULL, NULL);
	}
	pDR->m_bFrameLine = bBackWireFrame;

	CSeisEvalDataTool Tool;
	CPoint Pt_1, Pt_2;
	if (m_nDisplayMode == 0)
	{
		Pt_1.x = Node2D[0].x + (Node2D[1].x - Node2D[0].x)*0.1;
		Pt_1.y = Node2D[0].y + (Node2D[1].y - Node2D[0].y)*0.1;

		Pt_2.x = Node2D[0].x + (Node2D[1].x - Node2D[0].x)*0.9;
		Pt_2.y = Node2D[0].y + (Node2D[1].y - Node2D[0].y)*0.9;

		if (PrfmResult.enLevel_1 >= EN_LEVEL_IO && PrfmResult.enLevel_1 <= EN_LEVEL_CL)
			TextOutModel.TextOutSeisPerform(Pt_1.x, Pt_1.y, Tool.GetPerformLevel((EN_LEVEL)PrfmResult.enLevel_1));
		if (PrfmResult.enLevel_2 >= EN_LEVEL_IO && PrfmResult.enLevel_2 <= EN_LEVEL_CL)
			TextOutModel.TextOutSeisPerform(Pt_2.x, Pt_2.y, Tool.GetPerformLevel((EN_LEVEL)PrfmResult.enLevel_2));
	}
	else
	{
		Pt_1.x = Node2D[0].x + (Node2D[1].x - Node2D[0].x)*0.5;
		Pt_1.y = Node2D[0].y + (Node2D[1].y - Node2D[0].y)*0.5;

		if (PrfmResult.enLevel >= EN_LEVEL_IO && PrfmResult.enLevel <= EN_LEVEL_CL)
			TextOutModel.TextOutSeisPerform(Pt_1.x, Pt_1.y, Tool.GetPerformLevel((EN_LEVEL)PrfmResult.enLevel));
	}
}
#endif

BOOL CDesignEngine::MakePunchingCheckData()
{
	m_bDsgnDataSet = FALSE;
	ResetPnChkCutlData();
	GetActivePlateList();

	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;

	if (!gm->m_bLoadDataSet)return FALSE;
	gm->m_pMyView->BeginWaitCursor();

	// Puching Shear Check
	if (m_bPunchShear)
		SubMakePunchingCheckData();

	// One Way Shear Check Procedure
	if (m_bOnCuttingLine)
	{
		BOOL bSuc = MakeOneWayShearCheckData();
		if (!m_bPunchShear)
			m_bDsgnDataSet = bSuc;
	}

	gm->m_pMyView->EndWaitCursor();

	return TRUE;
}

BOOL CDesignEngine::SubMakePunchingCheckData()
{
	int   i, j;
	int   elem_num, nIndex;
	//double    dLevel;
	double		dMaxRatio = 0.0;
	double		dMinRatio = DBL_MAX;
	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;

	CArray<T_CUTLINE_D, T_CUTLINE_D&> *paCutLineData;
	//elem_num=m_PlateKeyList.GetSize();
	CArray<UINT, UINT> aNodeK; aNodeK.RemoveAll();
	elem_num = m_pDoc->m_pPostCtrl->GetDesignResult()->Get_PunchKeyList(m_nForceStress, aNodeK);

	m_aPunchingPoint.RemoveAll();
	m_aPunchingRatio.RemoveAll();

	BOOL has_content = FALSE;
	T_RSF2_D Rs_F2D;
	T_RSS2_D Rs_S2D;
	T_CUTLINE_D CutlD;
	T_CUTLINE_MINMAX_D CutlMnMxD;
	for (i = 0; i < elem_num; i++)
	{
		nIndex = 0;
		CutlMnMxD.Max = -DBL_MAX;
		CutlMnMxD.Min = DBL_MAX;

		// [PMS 5024-11] Critical section이 있는 경우 설계에서 받은 레이블로 그리지 않음. 
		CArray<T_ELEM_K, T_ELEM_K> aElemK;
		m_pDoc->m_pAttrCtrl->GetElemKeyListConnectedToNode(aNodeK[i], aElemK);
		T_ELEM_K ColmK = 0;
		T_ELEM_D ElemD;
		T_NODE_D TempNode1, TempNode2;
		for (j = 0; j < aElemK.GetSize(); j++)
		{
			if (m_pDoc->m_pAttrCtrl->GetMemberType(aElemK[j]) != D_MBTP_COLUMN) continue;
			m_pDoc->m_pAttrCtrl->GetElem(aElemK[j], ElemD);

			// 기둥이면 더 높은 곳에 있는 절점과 NodeK가 같아야 한다.
			m_pDoc->m_pAttrCtrl->GetNode(ElemD.elnod[0], TempNode1);
			m_pDoc->m_pAttrCtrl->GetNode(ElemD.elnod[1], TempNode2);

			if (TempNode1.z > TempNode2.z && aNodeK[i] == ElemD.elnod[0])
			{
				ColmK = aElemK[j];
				break;
			}
			else if (TempNode1.z < TempNode2.z && aNodeK[i] == ElemD.elnod[1])
			{
				ColmK = aElemK[j];
				break;
			}
		}

		if (!m_pDoc->m_pAttrCtrl2->ExistColc(ColmK))
		{
			if (m_nForceStress == 0)
			{
				Rs_F2D.Initialize();
				m_pDoc->m_pPostCtrl->GetDesignResult()->Get_SlabPunchShearForResult(aNodeK[i], Rs_F2D);
				double dCurVal = Rs_F2D.dRatV;
				if (m_nPunchFlag == 1)
					dCurVal = Rs_F2D.dVu;
				else 	if (m_nPunchFlag == 2)
					dCurVal = Rs_F2D.dAsw_s;
				if (dMaxRatio < dCurVal)
				{
					dMaxRatio = dCurVal;
					gm->m_nLgdMaxValKey = aNodeK[i];
				}
				if (dMinRatio > dCurVal)
				{
					dMinRatio = dCurVal;
					gm->m_nLgdMinValKey = aNodeK[i];
				}

				paCutLineData = new CArray<T_CUTLINE_D, T_CUTLINE_D&>;

				for (j = 0; j < Rs_F2D.arPnChkCutl.GetSize(); j++)
				{
					CutlD.dPoint1Val = Rs_F2D.arPnChkCutl[j].dPoint1Val;
					CutlD.dPoint2Val = Rs_F2D.arPnChkCutl[j].dPoint2Val;
					CutlD.Point1.x = Rs_F2D.arPnChkCutl[j].Point1[0];
					CutlD.Point1.y = Rs_F2D.arPnChkCutl[j].Point1[1];
					CutlD.Point1.z = Rs_F2D.arPnChkCutl[j].Point1[2];
					CutlD.Point2.x = Rs_F2D.arPnChkCutl[j].Point2[0];
					CutlD.Point2.y = Rs_F2D.arPnChkCutl[j].Point2[1];
					CutlD.Point2.z = Rs_F2D.arPnChkCutl[j].Point2[2];
					CutlD.KeyElem = Rs_F2D.arPnChkCutl[j].KeyElem;
					paCutLineData->Add(CutlD);

					if (CutlD.dPoint1Val > CutlMnMxD.Max)CutlMnMxD.Max = CutlD.dPoint1Val;
					if (CutlD.dPoint1Val < CutlMnMxD.Min)CutlMnMxD.Min = CutlD.dPoint1Val;
					if (CutlD.dPoint2Val > CutlMnMxD.Max)CutlMnMxD.Max = CutlD.dPoint2Val;
					if (CutlD.dPoint2Val < CutlMnMxD.Min)CutlMnMxD.Min = CutlD.dPoint2Val;
				}
				m_arPnChkCutl.Add(paCutLineData);
				m_arPnChkCutlMnMx.Add(CutlMnMxD);

				m_aPunchingPoint.Add(aNodeK[i]);
				m_aPunchingRatio.Add(dCurVal);
			}
			else
			{
				Rs_S2D.Initialize();
				m_pDoc->m_pPostCtrl->GetDesignResult()->Get_SlabPunchShearStrResult(aNodeK[i], Rs_S2D);
				if (dMaxRatio < Rs_S2D.dRatV)
				{
					dMaxRatio = Rs_S2D.dRatV;
					gm->m_nLgdMaxValKey = aNodeK[i];
				}
				if (dMinRatio > Rs_S2D.dRatV)
				{
					dMinRatio = Rs_S2D.dRatV;
					gm->m_nLgdMinValKey = aNodeK[i];
				}

				paCutLineData = new CArray<T_CUTLINE_D, T_CUTLINE_D&>;

				for (j = 0; j < Rs_S2D.arPnChkCutl.GetSize(); j++)
				{
					CutlD.dPoint1Val = Rs_S2D.arPnChkCutl[j].dPoint1Val;
					CutlD.dPoint2Val = Rs_S2D.arPnChkCutl[j].dPoint2Val;
					CutlD.Point1.x = Rs_S2D.arPnChkCutl[j].Point1[0];
					CutlD.Point1.y = Rs_S2D.arPnChkCutl[j].Point1[1];
					CutlD.Point1.z = Rs_S2D.arPnChkCutl[j].Point1[2];
					CutlD.Point2.x = Rs_S2D.arPnChkCutl[j].Point2[0];
					CutlD.Point2.y = Rs_S2D.arPnChkCutl[j].Point2[1];
					CutlD.Point2.z = Rs_S2D.arPnChkCutl[j].Point2[2];
					CutlD.KeyElem = Rs_S2D.arPnChkCutl[j].KeyElem;
					paCutLineData->Add(CutlD);

					if (CutlD.dPoint1Val > CutlMnMxD.Max)CutlMnMxD.Max = CutlD.dPoint1Val;
					if (CutlD.dPoint1Val < CutlMnMxD.Min)CutlMnMxD.Min = CutlD.dPoint1Val;
					if (CutlD.dPoint2Val > CutlMnMxD.Max)CutlMnMxD.Max = CutlD.dPoint2Val;
					if (CutlD.dPoint2Val < CutlMnMxD.Min)CutlMnMxD.Min = CutlD.dPoint2Val;
				}
				m_arPnChkCutl.Add(paCutLineData);
				m_arPnChkCutlMnMx.Add(CutlMnMxD);

				m_aPunchingPoint.Add(aNodeK[i]);
				m_aPunchingRatio.Add(Rs_S2D.dRatV);
			}
		}
		else
		{
			double dRange[4]; // [0]:+y, [1]:-y, [2]:+z, [3]:-z
			m_pDoc->m_pAttrCtrl2->GetColcCriticalSectionRange(ColmK, dRange);
			T_NODE_D NodeD;
			m_pDoc->m_pAttrCtrl->GetNode(aNodeK[i], NodeD);

			paCutLineData = new CArray<T_CUTLINE_D, T_CUTLINE_D&>;
			CutlD.dPoint1Val = 0.;
			CutlD.dPoint2Val = 0.;
			CutlD.KeyElem = 0;
			CutlD.bShowAlways = TRUE;

			C3DPoint VX, VY, VZ;
			double LocalVector[3][3];
			if (m_pDoc->calcElemLocalVector(ColmK, LocalVector))
			{
				VX.x = LocalVector[0][0]; VX.y = LocalVector[0][1]; VX.z = LocalVector[0][2];
				VY.x = LocalVector[1][0]; VY.y = LocalVector[1][1]; VY.z = LocalVector[1][2];
				VZ.x = LocalVector[2][0]; VZ.y = LocalVector[2][1]; VZ.z = LocalVector[2][2];
			}
			else
			{
				VX.Set(0, 0, 0); VY.Set(0, 0, 0); VZ.Set(0, 0, 0);
			}

			double dRangeR = dRange[0];  // +y, Right
			double dRangeL = dRange[1];  // -y, Left
			double dRangeT = dRange[2];  // +z, Top
			double dRangeB = dRange[3];  // -z, Bottom
			C3DPoint ptOffsetR(0.0, 0.0, 0.0);  ptOffsetR.x = dRangeR * (VY.x);  ptOffsetR.y = dRangeR * (VY.y);  ptOffsetR.z = dRangeR * (VY.z);
			C3DPoint ptOffsetL(0.0, 0.0, 0.0);  ptOffsetL.x = dRangeL * (-VY.x);  ptOffsetL.y = dRangeL * (-VY.y);  ptOffsetL.z = dRangeL * (-VY.z);
			C3DPoint ptOffsetT(0.0, 0.0, 0.0);  ptOffsetT.x = dRangeT * (VZ.x);  ptOffsetT.y = dRangeT * (VZ.y);  ptOffsetT.z = dRangeT * (VZ.z);
			C3DPoint ptOffsetB(0.0, 0.0, 0.0);  ptOffsetB.x = dRangeB * (-VZ.x);  ptOffsetB.y = dRangeB * (-VZ.y);  ptOffsetB.z = dRangeB * (-VZ.z);

			C3DPoint ptRT;  ptRT.Set(NodeD.x, NodeD.y, NodeD.z);    // right-top
			C3DPoint ptRB;  ptRB.Set(NodeD.x, NodeD.y, NodeD.z);    // right-bottom
			C3DPoint ptLB;  ptLB.Set(NodeD.x, NodeD.y, NodeD.z);    // left-bottom
			C3DPoint ptLT;  ptLT.Set(NodeD.x, NodeD.y, NodeD.z);    // left-top

			// offset 적용 
			ptRT.Offset(ptOffsetR.x, ptOffsetR.y, ptOffsetR.z);
			ptRT.Offset(ptOffsetT.x, ptOffsetT.y, ptOffsetT.z);

			ptRB.Offset(ptOffsetR.x, ptOffsetR.y, ptOffsetR.z);
			ptRB.Offset(ptOffsetB.x, ptOffsetB.y, ptOffsetB.z);

			ptLB.Offset(ptOffsetL.x, ptOffsetL.y, ptOffsetL.z);
			ptLB.Offset(ptOffsetB.x, ptOffsetB.y, ptOffsetB.z);

			ptLT.Offset(ptOffsetL.x, ptOffsetL.y, ptOffsetL.z);
			ptLT.Offset(ptOffsetT.x, ptOffsetT.y, ptOffsetT.z);

			////////////////////////////////////////////////////////////////
			// L
			CutlD.Point1 = ptLT;
			CutlD.Point2 = ptLB;
			paCutLineData->Add(CutlD);

			// R
			CutlD.Point1 = ptRT;
			CutlD.Point2 = ptRB;
			paCutLineData->Add(CutlD);

			// B
			CutlD.Point1 = ptLB;
			CutlD.Point2 = ptRB;
			paCutLineData->Add(CutlD);

			// T
			CutlD.Point1 = ptLT;
			CutlD.Point2 = ptRT;
			paCutLineData->Add(CutlD);

			if (m_nForceStress == 0)
			{
				Rs_F2D.Initialize();
				m_pDoc->m_pPostCtrl->GetDesignResult()->Get_SlabPunchShearForResult(aNodeK[i], Rs_F2D);
				if (dMaxRatio < Rs_F2D.dRatV)
				{
					dMaxRatio = Rs_F2D.dRatV;
					gm->m_nLgdMaxValKey = aNodeK[i];
				}
				if (dMinRatio > Rs_F2D.dRatV)
				{
					dMinRatio = Rs_F2D.dRatV;
					gm->m_nLgdMinValKey = aNodeK[i];
				}
				for (j = 0; j < Rs_F2D.arPnChkCutl.GetSize(); j++)
				{
					if (Rs_F2D.arPnChkCutl[j].dPoint1Val > CutlMnMxD.Max)CutlMnMxD.Max = Rs_F2D.arPnChkCutl[j].dPoint1Val;
					if (Rs_F2D.arPnChkCutl[j].dPoint1Val < CutlMnMxD.Min)CutlMnMxD.Min = Rs_F2D.arPnChkCutl[j].dPoint1Val;
					if (Rs_F2D.arPnChkCutl[j].dPoint2Val > CutlMnMxD.Max)CutlMnMxD.Max = Rs_F2D.arPnChkCutl[j].dPoint2Val;
					if (Rs_F2D.arPnChkCutl[j].dPoint2Val < CutlMnMxD.Min)CutlMnMxD.Min = Rs_F2D.arPnChkCutl[j].dPoint2Val;
				}
			}
			else
			{
				Rs_S2D.Initialize();
				m_pDoc->m_pPostCtrl->GetDesignResult()->Get_SlabPunchShearStrResult(aNodeK[i], Rs_S2D);
				if (dMaxRatio < Rs_S2D.dRatV)
				{
					dMaxRatio = Rs_S2D.dRatV;
					gm->m_nLgdMaxValKey = aNodeK[i];
				}
				if (dMinRatio > Rs_S2D.dRatV)
				{
					dMinRatio = Rs_S2D.dRatV;
					gm->m_nLgdMinValKey = aNodeK[i];
				}
				for (j = 0; j < Rs_S2D.arPnChkCutl.GetSize(); j++)
				{
					if (Rs_S2D.arPnChkCutl[j].dPoint1Val > CutlMnMxD.Max)CutlMnMxD.Max = Rs_S2D.arPnChkCutl[j].dPoint1Val;
					if (Rs_S2D.arPnChkCutl[j].dPoint1Val < CutlMnMxD.Min)CutlMnMxD.Min = Rs_S2D.arPnChkCutl[j].dPoint1Val;
					if (Rs_S2D.arPnChkCutl[j].dPoint2Val > CutlMnMxD.Max)CutlMnMxD.Max = Rs_S2D.arPnChkCutl[j].dPoint2Val;
					if (Rs_S2D.arPnChkCutl[j].dPoint2Val < CutlMnMxD.Min)CutlMnMxD.Min = Rs_S2D.arPnChkCutl[j].dPoint2Val;
				}
			}
			m_arPnChkCutl.Add(paCutLineData);
			m_arPnChkCutlMnMx.Add(CutlMnMxD);
			m_aPunchingPoint.Add(aNodeK[i]);
			m_aPunchingRatio.Add(Rs_F2D.dRatV);
		}


		has_content = TRUE;
	}

	if (!has_content)
	{
		dMaxRatio = 0.0;
		dMinRatio = 0.0;
		gm->m_nLgdMaxValKey = 0;
		gm->m_nLgdMinValKey = 0;
		m_aPunchingPoint.RemoveAll();
		m_aPunchingRatio.RemoveAll();
	}

	m_dMaxValue = dMaxRatio;
	m_dMinValue = dMinRatio;

	if (m_pContourEngine == NULL)
		m_pContourEngine = new CContourEngine(m_dMinValue, m_dMaxValue);
	else
		m_pContourEngine->MakeRankMap(m_dMinValue, m_dMaxValue);

	m_bDsgnDataSet = TRUE;

	return TRUE;
}

// Plate Key List 중 현재 Active인 것들의 List를 구한다.
void CDesignEngine::GetActivePlateList(BOOL bWall/*=FALSE*/)
{
	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;

	int			i, elem_num;

	T_ELEM_K	elem_key;

	m_PlateKeyList.RemoveAll();
	elem_num = gm->m_EKeyListActive.GetSize();

	for (i = 0; i < elem_num; i++)
	{
		elem_key = gm->m_EKeyListActive[i];
		if (bWall)
		{
			if (!m_pDoc->m_pPostCtrl->IsSlabWallDesignElement(elem_key, 3, FALSE)) continue;
		}
		else
		{
			if (gm->m_GPSMode == GPS_COMMAND_SLABSERV_CHK)
			{
				if (m_nMode == 2 && m_nDeflection == 1) // crack
				{
					if (!m_pDoc->m_pPostCtrl->IsSlabWallDesignElement(elem_key, 1, TRUE)) continue;
				}
				else
				{
					if (!m_pDoc->m_pPostCtrl->IsSlabWallDesignElement(elem_key, 4, TRUE)) continue;
				}
			}
			else if (gm->m_GPSMode == GPS_COMMAND_SHELL_DGN || gm->m_GPSMode == GPS_COMMAND_SHELL_CHK || gm->m_GPSMode == GPS_COMMAND_SHELL_SHEAR_CHK)
			{
				if (!m_pDoc->m_pPostCtrl->IsSlabWallDesignElement(elem_key, 5, FALSE)) continue;
			}
			else
			{
				if (!m_pDoc->m_pPostCtrl->IsSlabWallDesignElement(elem_key, 4, FALSE)) continue;
			}
		}
		m_PlateKeyList.Add(elem_key);
	}
}

void CDesignEngine::ResetPnChkCutlData()
{
	m_arPnChkCutlLine.RemoveAll();
	m_arPnChkCutlMnMx.RemoveAll();
	for (int i = 0; i < m_arPnChkCutl.GetSize(); i++)
	{
		delete m_arPnChkCutl[i];
		m_arPnChkCutl[i] = NULL;
	}
	m_arPnChkCutl.RemoveAll();
}

BOOL CDesignEngine::MakeOneWayMomentCheckData()
{
	I_GPSModel		*gm = (I_GPSModel *)m_pGPSModel;
	int				i;

	T_CUTL_D    cutline;

	/*
	T_ELEM_D		elem_d;
	T_NODE_D		node_d1,node_d2;

	C3DPoint Point3d1,Point3d2,Point3d3;
	double dPoint1[3],dPoint2[3],dPoint3[3];
	double dCutLinePoint1[3],dCutLinePoint2[3];
	double dCutLineVector[2],dCutLinePerpVector[2];
	double dElemCenter[2],dElemCenterVector[2];
	double dCosValue;
	double dDistance;
	double dCutValue;
	double dPlateCutVal1,dPlateCutVal2;
	double d1,d2;
	CArray <C3DPoint,C3DPoint&> aCutPoints;
	CArray <double,double> aCutValues;
	CList <C3DPoint, C3DPoint> CutPointsList;
	*/

	CArray<T_CUTLINE_D, T_CUTLINE_D&> *paCutLineData;
	CArray<T_CUTLINE_D, T_CUTLINE_D&> aCutLineData;
	T_CUTLINE_MINMAX_D CutLineMinMax;
	T_CUTLINE_D				 CutLineData;
	T_NODE_D OneWayCheckResPoint;

	ResetCuttingLineData();
	m_aCutLines.RemoveAll();
	m_OnewaySlabResData.RemoveAll();
	m_OnewayResPosition.RemoveAll();

	T_CUTL_K  KeyCutLine;
	CArray<T_CUTL_K, T_CUTL_K> aCutLineKList;
	// Cutting Line Data추가   
	for (i = 0; i < gm->m_aCutLineKeys.GetSize(); i++)
	{
		KeyCutLine = gm->m_aCutLineKeys[i];
		m_pDoc->m_pAttrCtrl->GetCutl(KeyCutLine, cutline);
		if (cutline.nType == 0) continue;
		m_aCutLines.Add(cutline);
		aCutLineKList.Add(KeyCutLine);
	}

	int nNumCutLines = m_aCutLines.GetSize();
	T_RSL1_D _dgn_1way_data_Top;
	T_RSL1_D _dgn_1way_data_Bot;
	T_RSL1_D _dgn_1way_data;
	for (int nCL = 0; nCL < nNumCutLines; nCL++)
	{
		paCutLineData = new CArray<T_CUTLINE_D, T_CUTLINE_D&>;	paCutLineData->RemoveAll();
		m_aCutLineData.Add(paCutLineData);

		_dgn_1way_data.Initialize();
		_dgn_1way_data_Top.Initialize();
		_dgn_1way_data_Bot.Initialize();
		if (!m_pDoc->m_pPostCtrl->GetDesignResult()->Get_1waySlabResult(aCutLineKList[nCL], _dgn_1way_data_Top, TRUE)) { ASSERT(0); }
		if (!m_pDoc->m_pPostCtrl->GetDesignResult()->Get_1waySlabResult(aCutLineKList[nCL], _dgn_1way_data_Bot, FALSE)) { ASSERT(0); }

		if (_dgn_1way_data_Top.PartList.GetSize() != _dgn_1way_data_Bot.PartList.GetSize())
		{
			ASSERT(0);
			CutLineMinMax.Max = 0;
			CutLineMinMax.Min = 0;
			m_aCutLineMinMax.Add(CutLineMinMax);
			continue;
		}
		for (i = 0; i < _dgn_1way_data_Top.PartList.GetSize(); i++)
		{
			T_RSL1_PART rsl1Part; rsl1Part.Initialize();
			rsl1Part.dDist[0] = _dgn_1way_data_Top.PartList[i].dDist[0];
			rsl1Part.dDist[1] = _dgn_1way_data_Top.PartList[i].dDist[1];
			rsl1Part.dPoint1[0] = _dgn_1way_data_Top.PartList[i].dPoint1[0];
			rsl1Part.dPoint1[1] = _dgn_1way_data_Top.PartList[i].dPoint1[1];
			rsl1Part.dPoint1[2] = _dgn_1way_data_Top.PartList[i].dPoint1[2];
			rsl1Part.dPoint2[0] = _dgn_1way_data_Top.PartList[i].dPoint2[0];
			rsl1Part.dPoint2[1] = _dgn_1way_data_Top.PartList[i].dPoint2[1];
			rsl1Part.dPoint2[2] = _dgn_1way_data_Top.PartList[i].dPoint2[2];
			if (fabs(_dgn_1way_data_Top.PartList[i].dMu[0]) > fabs(_dgn_1way_data_Bot.PartList[i].dMu[0]))
			{
				rsl1Part.dMu[0] = -_dgn_1way_data_Top.PartList[i].dMu[0];
			}
			else
			{
				rsl1Part.dMu[0] = _dgn_1way_data_Bot.PartList[i].dMu[0];
			}
			if (fabs(_dgn_1way_data_Top.PartList[i].dMu[1]) > fabs(_dgn_1way_data_Bot.PartList[i].dMu[1]))
			{
				rsl1Part.dMu[1] = -_dgn_1way_data_Top.PartList[i].dMu[1];
			}
			else
			{
				rsl1Part.dMu[1] = _dgn_1way_data_Bot.PartList[i].dMu[1];
			}
			rsl1Part.iSlabNo = _dgn_1way_data_Top.PartList[i].iSlabNo;
			_dgn_1way_data.PartList.Add(rsl1Part);
		}

		double dZero = 10E-7;
		int nTopBot = 0;
		if (gm->m_GPSMode == GPS_COMMAND_SLAB_DGN)
		{
			if (m_nRebarRatio == 4)
			{
				/// 선택기준 보완 : 필요철근비가 동일한 경우에는 강도비로 검토
				if (fabs(_dgn_1way_data_Top.dRhoReq - _dgn_1way_data_Bot.dRhoReq) < dZero)
				{
					nTopBot = (_dgn_1way_data_Top.dRatM > _dgn_1way_data_Bot.dRatM) ? 0 : 1;
				}
				else
				{
					nTopBot = (fabs(_dgn_1way_data_Top.dRhoReq) > fabs(_dgn_1way_data_Bot.dRhoReq)) ? 0 : 1;
				}
			}
			else
			{
				/// 선택기준 보완 : 필요철근량이 동일한 경우에는 강도비로 검토
				if (fabs(_dgn_1way_data_Top.dAsReq - _dgn_1way_data_Bot.dAsReq) < dZero)
				{
					nTopBot = (_dgn_1way_data_Top.dRatM > _dgn_1way_data_Bot.dRatM) ? 0 : 1;
				}
				else
				{
					nTopBot = (fabs(_dgn_1way_data_Top.dAsReq) > fabs(_dgn_1way_data_Bot.dAsReq)) ? 0 : 1;
				}
			}
		}
		else if (gm->m_GPSMode == GPS_COMMAND_SLAB_CHK)
		{
			if (m_nRebarRatio == 4)
			{
				/// 선택기준 보완 : 사용철근비가 동일한 경우에는 강도비로 검토.
				if (fabs(_dgn_1way_data_Top.dRhoUse - _dgn_1way_data_Bot.dRhoUse) < dZero)
				{
					nTopBot = (_dgn_1way_data_Top.dRatM > _dgn_1way_data_Bot.dRatM) ? 0 : 1;
				}
				else
				{
					nTopBot = (fabs(_dgn_1way_data_Top.dRhoUse) > fabs(_dgn_1way_data_Bot.dRhoUse)) ? 0 : 1;
				}
			}
			else
			{
				/// 선택기준 보완 : 사용철근량이 동일한 경우에는 강도비로 검토
				if (fabs(_dgn_1way_data_Top.dAsUse - _dgn_1way_data_Bot.dAsUse) < dZero)
				{
					nTopBot = (_dgn_1way_data_Top.dRatM > _dgn_1way_data_Bot.dRatM) ? 0 : 1;
				}
				else
				{
					nTopBot = (fabs(_dgn_1way_data_Top.dAsUse) > fabs(_dgn_1way_data_Bot.dAsUse)) ? 0 : 1;
				}
			}
		}
		else
			ASSERT(0);

		auto L_GetCurRslt = [](const T_RSL1_D& CurPosRslt, OUT T_RSL1_D& rOutRslt)
		{
			rOutRslt.dMu = CurPosRslt.dMu;
			rOutRslt.dpMn = CurPosRslt.dpMn;
			rOutRslt.dRatM = CurPosRslt.dRatM;
			rOutRslt.dRatXd = CurPosRslt.dRatXd;
			rOutRslt.dLimXd = CurPosRslt.dLimXd;
			rOutRslt.dAsReq = CurPosRslt.dAsReq;
			rOutRslt.dRhoReq = CurPosRslt.dRhoReq;
			rOutRslt.dRhoUse = CurPosRslt.dRhoUse;
			rOutRslt.dAsUse = CurPosRslt.dAsUse;

			rOutRslt.Rebar = CurPosRslt.Rebar;
		};

		if (nTopBot == 0)
		{
			L_GetCurRslt(_dgn_1way_data_Top, _dgn_1way_data);
		}
		else
		{
			L_GetCurRslt(_dgn_1way_data_Bot, _dgn_1way_data);
		}

		if (_dgn_1way_data.PartList.GetSize() < 1)
		{
			CutLineMinMax.Max = 0;
			CutLineMinMax.Min = 0;
			m_aCutLineMinMax.Add(CutLineMinMax);
			continue;
		}

		double CutLineMax = -DBL_MAX;
		double CutLineMin = DBL_MAX;

		cutline = m_aCutLines[nCL];

		OneWayCheckResPoint.x = (cutline.Point1[0] + cutline.Point2[0]) / 2.0;
		OneWayCheckResPoint.y = (cutline.Point1[1] + cutline.Point2[1]) / 2.0;
		OneWayCheckResPoint.z = (cutline.Point1[2] + cutline.Point2[2]) / 2.0;
		m_OnewayResPosition.SetAt(aCutLineKList[nCL], OneWayCheckResPoint);

		aCutLineData.RemoveAll();
		for (i = 0; i < _dgn_1way_data.PartList.GetSize(); i++)
		{
			CutLineData.dDist1 = _dgn_1way_data.PartList[i].dDist[0];
			CutLineData.dDist2 = _dgn_1way_data.PartList[i].dDist[1];
			CutLineData.Point1.x = _dgn_1way_data.PartList[i].dPoint1[0];
			CutLineData.Point1.y = _dgn_1way_data.PartList[i].dPoint1[1];
			CutLineData.Point1.z = _dgn_1way_data.PartList[i].dPoint1[2];
			CutLineData.Point2.x = _dgn_1way_data.PartList[i].dPoint2[0];
			CutLineData.Point2.y = _dgn_1way_data.PartList[i].dPoint2[1];
			CutLineData.Point2.z = _dgn_1way_data.PartList[i].dPoint2[2];
			CutLineData.dPoint1Val = _dgn_1way_data.PartList[i].dMu[0];
			CutLineData.dPoint2Val = _dgn_1way_data.PartList[i].dMu[1];
			CutLineData.KeyElem = _dgn_1way_data.PartList[i].iSlabNo;
			aCutLineData.Add(CutLineData);
		}
		m_aCutLineData[nCL]->Copy(aCutLineData);

		_dgn_1way_data.strCutLineNa = cutline.CutLineName;
		m_OnewaySlabResData.SetAt(aCutLineKList[nCL], _dgn_1way_data);

		// Setting the Final Min/Max of this Cutting Line
		double dVal1, dVal2;
		for (int x = 0; x < m_aCutLineData[nCL]->GetSize(); x++)
		{
			dVal1 = m_aCutLineData[nCL]->GetAt(x).dPoint1Val;
			dVal2 = m_aCutLineData[nCL]->GetAt(x).dPoint2Val;

			if (CutLineMax < dVal1) CutLineMax = dVal1;
			if (CutLineMax < dVal2) CutLineMax = dVal2;
			if (CutLineMin > dVal1) CutLineMin = dVal1;
			if (CutLineMin > dVal2) CutLineMin = dVal2;
		}
		CutLineMinMax.Max = CutLineMax;
		CutLineMinMax.Min = CutLineMin;
		m_aCutLineMinMax.Add(CutLineMinMax);
	}

	if (m_aCutLineMinMax.GetSize() <= 0) return FALSE;
	return TRUE;
}

BOOL CDesignEngine::MakeOneWayShearCheckData()
{
	I_GPSModel		*gm = (I_GPSModel *)m_pGPSModel;
	int				i;

	T_CUTL_D    cutline;

	/*
	T_ELEM_D		elem_d;
	T_NODE_D		node_d1,node_d2;

	C3DPoint Point3d1,Point3d2,Point3d3;
	double dPoint1[3],dPoint2[3],dPoint3[3];
	double dCutLinePoint1[3],dCutLinePoint2[3];
	double dCutLineVector[2],dCutLinePerpVector[2];
	double dElemCenter[2],dElemCenterVector[2];
	double dCosValue;
	double dDistance;
	double dCutValue;
	double dPlateCutVal1,dPlateCutVal2;
	double d1,d2;
	CArray <C3DPoint,C3DPoint&> aCutPoints;
	CArray <double,double> aCutValues;
	CList <C3DPoint, C3DPoint> CutPointsList;
	*/

	CArray<T_CUTLINE_D, T_CUTLINE_D&> *paCutLineData;
	CArray<T_CUTLINE_D, T_CUTLINE_D&> aCutLineData;
	T_CUTLINE_MINMAX_D CutLineMinMax;
	T_CUTLINE_D				 CutLineData;
	T_NODE_D OneWayCheckResPoint;

	ResetCuttingLineData();
	m_aCutLines.RemoveAll();
	m_OnewaySlabShearResData.RemoveAll();
	m_OnewayResPosition.RemoveAll();

	T_CUTL_K  KeyCutLine;
	CArray<T_CUTL_K, T_CUTL_K> aCutLineKList;
	// Cutting Line Data추가   
	for (i = 0; i < gm->m_aCutLineKeys.GetSize(); i++)
	{
		KeyCutLine = gm->m_aCutLineKeys[i];
		m_pDoc->m_pAttrCtrl->GetCutl(KeyCutLine, cutline);
		if (cutline.nType == 0) continue;
		m_aCutLines.Add(cutline);
		aCutLineKList.Add(KeyCutLine);
	}

	int nNumCutLines = m_aCutLines.GetSize();
	T_RSS1_D _dgn_1way_data;
	for (int nCL = 0; nCL < nNumCutLines; nCL++)
	{
		paCutLineData = new CArray<T_CUTLINE_D, T_CUTLINE_D&>;	paCutLineData->RemoveAll();
		m_aCutLineData.Add(paCutLineData);

		_dgn_1way_data.Initialize();
		if (!m_pDoc->m_pPostCtrl->GetDesignResult()->Get_1waySlabShearResult(aCutLineKList[nCL], _dgn_1way_data)) { ASSERT(0); }
		if (_dgn_1way_data.PartList.GetSize() < 1)
		{
			CutLineMinMax.Max = 0;
			CutLineMinMax.Min = 0;
			m_aCutLineMinMax.Add(CutLineMinMax);
			continue;
		}

		double CutLineMax = -DBL_MAX;
		double CutLineMin = DBL_MAX;

		cutline = m_aCutLines[nCL];

		OneWayCheckResPoint.x = (cutline.Point1[0] + cutline.Point2[0]) / 2.0;
		OneWayCheckResPoint.y = (cutline.Point1[1] + cutline.Point2[1]) / 2.0;
		OneWayCheckResPoint.z = (cutline.Point1[2] + cutline.Point2[2]) / 2.0;
		m_OnewayResPosition.SetAt(aCutLineKList[nCL], OneWayCheckResPoint);

		aCutLineData.RemoveAll();
		for (i = 0; i < _dgn_1way_data.PartList.GetSize(); i++)
		{
			CutLineData.dDist1 = _dgn_1way_data.PartList[i].dDist[0];
			CutLineData.dDist2 = _dgn_1way_data.PartList[i].dDist[1];
			CutLineData.Point1.x = _dgn_1way_data.PartList[i].dPoint1[0];
			CutLineData.Point1.y = _dgn_1way_data.PartList[i].dPoint1[1];
			CutLineData.Point1.z = _dgn_1way_data.PartList[i].dPoint1[2];
			CutLineData.Point2.x = _dgn_1way_data.PartList[i].dPoint2[0];
			CutLineData.Point2.y = _dgn_1way_data.PartList[i].dPoint2[1];
			CutLineData.Point2.z = _dgn_1way_data.PartList[i].dPoint2[2];
			CutLineData.dPoint1Val = _dgn_1way_data.PartList[i].dVu[0];
			CutLineData.dPoint2Val = _dgn_1way_data.PartList[i].dVu[1];
			CutLineData.KeyElem = _dgn_1way_data.PartList[i].iSlabNo;
			aCutLineData.Add(CutLineData);
		}
		m_aCutLineData[nCL]->Copy(aCutLineData);

		_dgn_1way_data.strCutLineNa = cutline.CutLineName;
		m_OnewaySlabShearResData.SetAt(aCutLineKList[nCL], _dgn_1way_data);

		// Setting the Final Min/Max of this Cutting Line
		double dVal1, dVal2;
		for (int x = 0; x < m_aCutLineData[nCL]->GetSize(); x++)
		{
			dVal1 = m_aCutLineData[nCL]->GetAt(x).dPoint1Val;
			dVal2 = m_aCutLineData[nCL]->GetAt(x).dPoint2Val;

			if (CutLineMax < dVal1) CutLineMax = dVal1;
			if (CutLineMax < dVal2) CutLineMax = dVal2;
			if (CutLineMin > dVal1) CutLineMin = dVal1;
			if (CutLineMin > dVal2) CutLineMin = dVal2;
		}
		CutLineMinMax.Max = CutLineMax;
		CutLineMinMax.Min = CutLineMin;
		m_aCutLineMinMax.Add(CutLineMinMax);
	}

	if (m_aCutLineMinMax.GetSize() <= 0) return FALSE;
	return TRUE;
}

BOOL CDesignEngine::MakeSlabServCheckData()
{
	I_GPSModel *gm = (I_GPSModel *)m_pGPSModel;
	if (!gm->m_bLoadDataSet)return FALSE;

	if (m_nMode == 2 && m_nDeflection == 1)
	{
		if (!m_pDoc->m_pPostCtrl->IsAnalysisResultEnable(D_RESULT_FLAG_ANALYSIS_CRACK))
		{
			m_pDoc->DisplayHistoryMessage(_LS(IDS_GPS_Error_Cracked_Section_Analysis_is_not_performed));
			return FALSE;
		}
	}

	m_bOnCuttingLine = FALSE;
	if (::IsWindow(gm->m_pCutLineDetDlg->GetSafeHwnd()))
		gm->m_pCutLineDetDlg->DestroyWindow();

	int			i, j;
	T_ELEM_K	ElemK;

	BOOL   has_content = FALSE;
	double max_val = -DBL_MAX, min_val = DBL_MAX, len;

	m_mapSDRData.RemoveAll();

	GetActivePlateList();

	////////////////////////////////////////////////////////////////////////
	// MQC10930 Crack에 대해서 Long Term Deflection이고 KCI 및 ACI인 경우에만 해석결과 대신 설계결과를 뷰에 출력
	BOOL bUseAnalResult = TRUE;
	BOOL bLongtermDef = CDBLib::IsCodeMeshSlabLongTermDeflFromDesign();
	if (m_bLongTermDefl && bLongtermDef) bUseAnalResult = FALSE;
	////////////////////////////////////////////////////////////////////////

	if (m_nMode == 2 && m_nDeflection == 1) // crack result
		MakeSlabCrackData();

	// PMS:xxxx-Seungjun-20100913 요소별 slab length 저장.
	m_aSlabLeng.RemoveAll();
	m_aSlabLeng.InitHashTable(HASHSIZEELEM);

	T_GPS_SLAB_DESIGN_RESULT SdrtD;
	T_RSSE_D RsseD;
	T_ELEM_D ElemD;
	T_DOEL_D DoelD;
	T_SERV_D ServD;
	T_NODE_K NodeK;
	int node_in_elem;
	double dFact, dAllowDsp, dSlabLength;
	int elem_num = m_PlateKeyList.GetSize();
	BOOL bCode4CH = CDBLib::IsCodeForMeshedDesignCH();
	for (i = 0; i < elem_num; i++)
	{
		BOOL bHasValue = FALSE;

		SdrtD.Initialize();
		RsseD.Initialize();
		ElemK = m_PlateKeyList[i];
		if (m_nMode == 2 && m_nDeflection == 1 && bUseAnalResult) // crack
		{
			if (!m_pDoc->m_pPostCtrl->IsSlabWallDesignElement(ElemK, 1, TRUE)) { ASSERT(0); continue; }

			ElemD.Initialize();
			if (!m_pDoc->m_pAttrCtrl->GetElem(ElemK, ElemD)) { ASSERT(0); continue; }
			DoelD.Initialize();
			if (!m_pDoc->m_pAttrCtrl->GetDoel(ElemK, DoelD)) { ASSERT(0); continue; }
			if (DoelD.nDomainType != 1) continue;

			if (m_nRebarRatio == 1)
			{
				ServD.Initialize();
				if (!m_pDoc->m_pAttrCtrl->GetServ(ElemK, ServD)) ServD.dDefLim = 250.;
				dSlabLength = Get_SlabLeng(ElemK, DoelD.KeyDomain);
				dAllowDsp = ServD.dDefLim > 0. ? dSlabLength / ServD.dDefLim : 0.;
			}

			if (m_nDeflection)
			{
				if (m_nTimeCreep == 0)
				{
					double dRhoComp = 0.0;
					int nDirX = 0, nDirY = 1;
					T_RSL2_D Rsl2D;
					if (m_pDoc->m_pPostCtrl->GetDesignResult()->Get_2waySlabResult(ElemK, nDirX, Rsl2D))
					{
						dRhoComp = Rsl2D.Top->dRhoCom;
					}
					if (m_pDoc->m_pPostCtrl->GetDesignResult()->Get_2waySlabResult(ElemK, nDirY, Rsl2D))
					{
						dRhoComp = min(dRhoComp, Rsl2D.Top->dRhoCom);
					}

					dFact = m_dTimeCreepCoef / (1.0 + 50.0*dRhoComp);
					if (dFact > 2.0) { ASSERT(0); dFact = 2.0; }
					else if (dFact < 1.0) { ASSERT(0); dFact = 1.0; }
				}
				else
				{
					dFact = 1.0 + m_dTimeCreepCoef;
				}
			}

			node_in_elem = m_pDoc->m_pAttrCtrl->GetNumNode(ElemD.eltyp, ElemD.elnod);
			SdrtD.nNodeNum = node_in_elem;
			for (j = 0; j < node_in_elem; j++)
			{
				NodeK = ElemD.elnod[j];
				if (!m_pDoc->m_pPostCtrl->IsAvailNode(NodeK))continue;

				if (!m_mapCrackData.Lookup(NodeK, len)) { ASSERT(0); continue; }

				// Creep 팩터를 먼저 곱하고 Ratio를 계산한다.    
				if (m_bLongTermDefl)
				{
					len *= dFact;
				}

				if (m_nRebarRatio == 1) // Ratio
				{
					if (dAllowDsp != 0) len /= dAllowDsp;
					else               len = 0.0;

					len = fabs(len); // Ratio는 절대값으로 보여준다.
				}

				SdrtD.dValue[j] = len;

				if (min_val > len)
				{
					min_val = len;
					gm->m_nLgdMinValKey = NodeK;
				}
				if (max_val < len)
				{
					max_val = len;
					gm->m_nLgdMaxValKey = NodeK;
				}
				bHasValue = TRUE;
			}
		}
		else
		{
			if (!m_pDoc->m_pPostCtrl->IsSlabWallDesignElement(ElemK, 4, TRUE)) { ASSERT(0); continue; }
			if (!m_pDoc->m_pPostCtrl->GetDesignResult()->Get_SlabServResult(ElemK, m_nXDirYDir, RsseD)) continue;

			for (j = 0; j < RsseD.iNodeNum; j++)
			{
				len = CalcServValue(RsseD, j, m_nPosi);
				if (!bHasValue && (m_nMode == 1 && bCode4CH == FALSE) && (fabs(len) < 1.e-7))
					bHasValue = FALSE;
				else if (m_nMode == 3 && bCode4CH && (fabs(len) < 1.e-7))
					bHasValue = FALSE;
				else
					bHasValue = TRUE;

				if (m_nRebarRatio == 1) len = fabs(len); // Ratio는 절대값으로 보여준다.

				SdrtD.nNodeNum = RsseD.iNodeNum;
				SdrtD.dValue[j] = len;

				if (min_val > len)
				{
					min_val = len;
					gm->m_nLgdMinValKey = ElemK;
				}
				if (max_val < len)
				{
					max_val = len;
					gm->m_nLgdMaxValKey = ElemK;
				}
			}
		}

		if (!bHasValue) continue;
		has_content = TRUE;
		m_mapSDRData.SetAt(ElemK, SdrtD);
	}
	m_aSlabLeng.RemoveAll();

	if (!has_content)
	{
		min_val = max_val = 0.0;
		gm->m_nLgdMaxValKey = 0;
		gm->m_nLgdMinValKey = 0;
		m_mapSDRData.RemoveAll();
	}

	m_dMaxValue = max_val;
	m_dMinValue = min_val;

	if (m_pContourEngine == NULL)
		m_pContourEngine = new CContourEngine(min_val, max_val);
	else
		m_pContourEngine->MakeRankMap(min_val, max_val);

	m_bDsgnDataSet = TRUE;
	gm->m_pMyView->EndWaitCursor();
	return TRUE;
}

BOOL CDesignEngine::GetSlabServCheckRangeDataList(double& dMaxRange, double& dMinRange, CArray<UINT, UINT>& aElemKeyList)
{
	aElemKeyList.RemoveAll();

	I_GPSModel *gm = (I_GPSModel *)m_pGPSModel;
	gm->m_pMyView->BeginWaitCursor();

	int			i, j;
	T_ELEM_K	ElemK;

	T_GPS_SLAB_DESIGN_RESULT SdrtD;
	int elem_num = m_PlateKeyList.GetSize();
	for (i = 0; i < elem_num; i++)
	{
		ElemK = m_PlateKeyList[i];
		if (!m_mapSDRData.Lookup(ElemK, SdrtD)) continue;

		double	  len_max = -DBL_MAX, len_min = DBL_MAX, len;
		for (j = 0; j < SdrtD.nNodeNum; j++)
		{
			len = SdrtD.dValue[j];

			if (len > len_max) len_max = len;
			if (len < len_min) len_min = len;
		}

		if ((len_min <= dMinRange && len_max >= dMaxRange) ||
			(len_min >= dMinRange && len_min <= dMaxRange) ||
			(len_max >= dMinRange && len_max <= dMaxRange))
			aElemKeyList.Add(ElemK);
	}

	gm->m_pMyView->EndWaitCursor();

	return TRUE;
}

BOOL CDesignEngine::GetShellShearCheckRangeDataList(double& dMaxRange, double& dMinRange, CArray<UINT, UINT>& aElemKeyList)
{
	aElemKeyList.RemoveAll();

	I_GPSModel *gm = (I_GPSModel *)m_pGPSModel;
	gm->m_pMyView->BeginWaitCursor();

	int			i, j;
	T_ELEM_K	ElemK;

	T_GPS_SLAB_DESIGN_RESULT SdrtD;
	int elem_num = m_PlateKeyList.GetSize();
	for (i = 0; i < elem_num; i++)
	{
		ElemK = m_PlateKeyList[i];
		if (!m_mapSDRData.Lookup(ElemK, SdrtD)) continue;

		double	  len_max = -DBL_MAX, len_min = DBL_MAX, len;
		for (j = 0; j < SdrtD.nNodeNum; j++)
		{
			len = SdrtD.dValue[j];

			if (len > len_max) len_max = len;
			if (len < len_min) len_min = len;
		}

		if ((len_min <= dMinRange && len_max >= dMaxRange) ||
			(len_min >= dMinRange && len_min <= dMaxRange) ||
			(len_max >= dMinRange && len_max <= dMaxRange))
			aElemKeyList.Add(ElemK);
	}

	gm->m_pMyView->EndWaitCursor();

	return TRUE;
}

double CDesignEngine::CalcServValue(T_RSSE_D& RsseD, int nNode, int nPos)
{
	const bool bAIJ_WSD99 = CDBLib::GetConCodeName() == CONCODE_AIJ_WSD99 ? true : false;

	double len = 0.0;
	switch (nPos)
	{
	case 0: // top
	{
		const T_SSER_POS& SerTop = RsseD.Top[nNode];
		switch (m_nMode)
		{
		case 0: len = CalcServValueStress(SerTop, m_nStress, m_nRebarRatio); break;
		case 1: len = bAIJ_WSD99 ? CalcServValueStress(SerTop, 0, m_nRebarRatio) : CalcServValueCrack(SerTop, m_nCrack, m_nRebarRatio); break;
		case 2: len = CalcServValueDeflectUncracked(SerTop, m_bLongTermDefl, m_nDeflection, m_nRebarRatio); break;
		case 3: len = SerTop.dAniCrack; break;
		default: { ASSERT(0); len = 0.0; } break;
		}
	}
	break;
	case 1: // bot
	{
		const T_SSER_POS& SerBot = RsseD.Bot[nNode];
		switch (m_nMode)
		{
		case 0: len = CalcServValueStress(SerBot, m_nStress, m_nRebarRatio); break;
		case 1: len = bAIJ_WSD99 ? CalcServValueStress(SerBot, 0, m_nRebarRatio) : CalcServValueCrack(SerBot, m_nCrack, m_nRebarRatio);   break;
		case 2: len = CalcServValueDeflectUncracked(SerBot, m_bLongTermDefl, m_nDeflection, m_nRebarRatio); break;
		case 3: len = SerBot.dAniCrack; break;
		default: { ASSERT(0); len = 0.0; } break;
		}
	}
	break;
	case 2: // both
	{
		const T_SSER_POS& SerTop = RsseD.Top[nNode];
		const T_SSER_POS& SerBot = RsseD.Bot[nNode];

		switch (m_nMode)
		{
		case 0: { len = CalcServValueStress(SerTop, SerBot, m_nStress, m_nRebarRatio); } break;
		case 1: { len = bAIJ_WSD99 ? CalcServValueStress(SerTop, SerBot, 0, m_nRebarRatio) : CalcServValueCrack(SerTop, SerBot, m_nCrack, m_nRebarRatio); } break;
		case 2: { len = CalcServValueDeflectUncracked(SerTop, SerBot, m_bLongTermDefl, m_nDeflection, m_nRebarRatio); } break;
		case 3: { len = max(SerTop.dAniCrack, SerBot.dAniCrack); }break;
		default: { ASSERT(0); len = 0.0; } break;
		}
	}
	break;
	default:
		ASSERT(0);
		break;
	}
	return len;
}

BOOL CDesignEngine::ConvertStripData(T_RBST_D &rRbstD, /*const*/ T_STRIP_RES_D &StripRes, UINT nChkPos)
{
	rRbstD.Initialize();

	rRbstD.nLayerType = nChkPos; // 0=Top-Main, 1=Bot.-Main

	T_STRIP_RES_D1 &PosI = StripRes.PosI;
	T_STRIP_RES_D1 &PosM = StripRes.PosM;
	T_STRIP_RES_D1 &PosJ = StripRes.PosJ;

	BOOL bBottom = (nChkPos == 1) ? TRUE : FALSE;
	if (bBottom)
	{
		rRbstD.dCover = max(PosI.Bot.Com.dB, max(PosM.Bot.Com.dB, PosJ.Bot.Com.dB));
		rRbstD.strRebarName_I = PosI.Bot.Pos.Rebar.strSize;
		rRbstD.strRebarName_C = PosM.Bot.Pos.Rebar.strSize;
		rRbstD.strRebarName_J = PosJ.Bot.Pos.Rebar.strSize;
		rRbstD.dRebarSpace_I = PosI.Bot.Pos.Rebar.dSpace;
		rRbstD.dRebarSpace_C = PosM.Bot.Pos.Rebar.dSpace;
		rRbstD.dRebarSpace_J = PosJ.Bot.Pos.Rebar.dSpace;
	}
	else
	{
		rRbstD.dCover = max(PosI.Top.Com.dT, max(PosM.Top.Com.dT, PosJ.Top.Com.dT));
		rRbstD.strRebarName_I = PosI.Top.Pos.Rebar.strSize;
		rRbstD.strRebarName_C = PosM.Top.Pos.Rebar.strSize;
		rRbstD.strRebarName_J = PosJ.Top.Pos.Rebar.strSize;
		rRbstD.dRebarSpace_I = PosI.Top.Pos.Rebar.dSpace;
		rRbstD.dRebarSpace_C = PosM.Top.Pos.Rebar.dSpace;
		rRbstD.dRebarSpace_J = PosJ.Top.Pos.Rebar.dSpace;
	}

	if (rRbstD.dCover <= 0.0) return FALSE;
	if (rRbstD.strRebarName_I.IsEmpty() || rRbstD.dRebarSpace_I <= 0.0) return FALSE;
	if (rRbstD.strRebarName_C.IsEmpty() || rRbstD.dRebarSpace_C <= 0.0) return FALSE;
	if (rRbstD.strRebarName_J.IsEmpty() || rRbstD.dRebarSpace_J <= 0.0) return FALSE;

	return TRUE;
}

BOOL CDesignEngine::UpdateRebarStrip()
{
	m_pDoc->m_pPostCtrl->GetDesignResult()->GetDesignedMstrKList(m_PlateKeyList);
	T_MSTR_K_LIST aDgnStripK;
	aDgnStripK.Copy(m_PlateKeyList);

	int nStripNo = aDgnStripK.GetSize();
	if (nStripNo < 1) return TRUE;

	CDesignResult *pDgnResult = m_pDoc->m_pPostCtrl->GetDesignResult(); ASSERT(pDgnResult);

	const UINT nStripChkPosNo = 2; // Top, Bottom
	CArray<T_RBST_K, T_RBST_K > aRbstK[nStripChkPosNo];
	CArray<T_RBST_D, T_RBST_D&> aRbstD[nStripChkPosNo];

	CArray<T_MSTR_K, T_MSTR_K> aStripK; aStripK.RemoveAll();
	for (int i = 0; i < nStripNo; ++i)
	{
		T_MSTR_K StripK = aDgnStripK[i];

		T_STRIP_RES_D StripResD;
		if (!pDgnResult->Get_StripResult(StripK, StripResD)) continue;

		CArray<T_RBST_D, T_RBST_D&> aAddRbstD; aAddRbstD.RemoveAll();
		for (int k = 0; k < nStripChkPosNo; ++k)
		{
			T_RBST_D RbstD;
			if (!ConvertStripData(RbstD, StripResD, k)) break;

			aAddRbstD.Add(RbstD);
		}
		if (aAddRbstD.GetSize() != nStripChkPosNo) { ASSERT(0); continue; }

		for (int k = 0; k < nStripChkPosNo; ++k)
		{
			aRbstK[k].Add(0); // Dummy Key.
			aRbstD[k].Add(aAddRbstD[k]);
		}
		aStripK.Add(StripK);
	}

	if (aStripK.GetSize() < 1)
	{
		m_pDoc->DisplayHistoryMessage(_LS(IDS_GPS_Error_Update_Rebar));
		return FALSE;
	}

	return m_pDoc->m_pDataCtrl->AddRbstByElemK(aStripK, aRbstK, aRbstD);
}

BOOL CDesignEngine::UpdateRebarShell()
{
	T_MSRB_D MsrbD;
	if (!m_pDoc->m_pAttrCtrl->GetMsrb(MsrbD))
	{
		m_pDoc->m_pMatlDB->InitializeMsrb(MsrbD);
	}

	auto L_Update = [] (const T_RSHF_BAR& Cur, OUT T_RSHF_BAR& rMax)
	{
		if ( dgn::MT(Cur.dAsreq, rMax.dAsreq) )
		{
			rMax = Cur;
			return true;
		}
		if ( dgn::MT(Cur.dAsuse, rMax.dAsuse) )
		{
			rMax = Cur;
			return true;
		}
		if ( dgn::MT(Cur.dRatFtd, rMax.dRatFtd) )
		{
			rMax = Cur;
			return true;
		}
		return false;
	};

	T_ELEM_K_LIST aElemK;
	CArray<T_RBSL_K, T_RBSL_K>  aRbslK[4];
	CArray<T_RBSL_D, T_RBSL_D&> aRbslD[4];
	T_RSHF_D RshfDX, RshfDY, RshfDC;

	int nElem = m_PlateKeyList.GetSize();
	for (int i = 0; i < nElem; ++i)
	{
		T_RSHF_POS MaxRshfPosTop;
		T_RSHF_POS MaxRshfPosBot;

		RshfDX.Initialize();
		RshfDY.Initialize();
		RshfDC.Initialize();

		T_ELEM_K ElemK = m_PlateKeyList[i];
		if (!m_pDoc->m_pPostCtrl->GetDesignResult()->Get_ShellResult_ByElem(ElemK, RshfDX, RshfDY, RshfDC)) { continue; }

		T_DOEL_D DoelD;
		if (!m_pDoc->m_pAttrCtrl->GetDoel(ElemK, DoelD)) { ASSERT(0); continue; }
		if (DoelD.nDomainType != 1) { ASSERT(0); continue; }

		T_SBDO_D SbdoD;
		if (!m_pDoc->m_pAttrCtrl->GetSbdo(DoelD.KeyDomain, SbdoD)) { ASSERT(0); continue; }

		for (int j = 0; j < RshfDX.nNodeNum; ++j)
		{
			L_Update(RshfDX.Top[j].RsltBarX, MaxRshfPosTop.RsltBarX);
			L_Update(RshfDX.Bot[j].RsltBarX, MaxRshfPosBot.RsltBarX);
			L_Update(RshfDY.Top[j].RsltBarY, MaxRshfPosTop.RsltBarY);
			L_Update(RshfDY.Bot[j].RsltBarY, MaxRshfPosBot.RsltBarY);
		}

		CArray<T_RBSL_D, T_RBSL_D&> aAddRbslD; aAddRbslD.RemoveAll();
		for (int k = 0; k < 4; ++k)
		{
			T_RBSL_D RbslD; RbslD.Initialize();			
			
			RbslD.nLayerType = k;
			RbslD.bThickOptimal = MsrbD.bThickOptimal;
			RbslD.dTopThik = MsrbD.dTopThik;
			RbslD.dBotThik = MsrbD.dBotThik;
			RbslD.nIteration = MsrbD.nIteration;
			RbslD.dConvTolerance = MsrbD.dConvTolerance;

			T_RSHF_BAR RshfBar;
			switch (k)
			{
			case EN_TOP_DIR1: { RbslD.dCover = RshfDX.dT; RshfBar = MaxRshfPosTop.RsltBarX; } break;
			case EN_BOT_DIR1: { RbslD.dCover = RshfDX.dB; RshfBar = MaxRshfPosBot.RsltBarX; } break;
			case EN_TOP_DIR2: { RbslD.dCover = RshfDY.dT; RshfBar = MaxRshfPosTop.RsltBarY; } break;
			case EN_BOT_DIR2: { RbslD.dCover = RshfDY.dB; RshfBar = MaxRshfPosBot.RsltBarY; } break;
			default: ASSERT(FALSE); break;
			}

			CString strAdd1 = _T(""), strAdd2 = _T("");
			if (SbdoD.bBasicRebar || MsrbD.bBasicRebar)
			{
				RbslD.strBasicRebarName = RshfBar.strBarSize;
				RbslD.dBasicRebarSpace = RshfBar.dSpace;
				RbslD.dAdd1RebarSpace = RshfBar.dAddSpace;
				DivideRebarString(RshfBar.strAddBarSize, strAdd1, strAdd2); // Basic Rebar만 들어가는 경우가 있다.				
			}
			else
			{
				// Basic이 없으면 Add1은 꼭 있어야 한다.          
				RbslD.dAdd1RebarSpace = RshfBar.dAddSpace;
				if (!DivideRebarString(RshfBar.strAddBarSize, strAdd1, strAdd2)) { break; }
			}

			RbslD.strAdd1RebarName = strAdd1;
			RbslD.strAdd2RebarName = strAdd2;

			if (RbslD.strBasicRebarName.GetLength() <= 0 && RbslD.strAdd1RebarName.GetLength() <= 0) break;
			if (RbslD.dBasicRebarSpace <= 0.0 && RbslD.dAdd1RebarSpace <= 0) break;
			if (RbslD.dCover <= 0.0) break;

			aAddRbslD.Add(RbslD);
		}

		// 검증을 위해
		if (aAddRbslD.GetSize() != 4) { ASSERT(0); continue; }

		// Key는 Dummy로 넣어준다.
		for (int k = 0; k < 4; ++k)
		{
			aRbslK[k].Add(0);
			aRbslD[k].Add(aAddRbslD[k]);
		}
		aElemK.Add(ElemK);
	}

	if (aElemK.GetSize() <= 0)
	{
		m_pDoc->DisplayHistoryMessage(_LS(IDS_GPS_Error_Update_Rebar));
		return FALSE;
	}

	return m_pDoc->m_pDataCtrl->AddRbslByElemK(aElemK, aRbslK, aRbslD);
}

BOOL CDesignEngine::UpdateRebarShellBySbdo()
{
	/// SUBDOMAIN별 불리한 조건을 저장합니다.
	CMap<T_SBDO_K, T_SBDO_K, T_RSHF_POS, T_RSHF_POS&> mapTopX;
	CMap<T_SBDO_K, T_SBDO_K, T_RSHF_POS, T_RSHF_POS&> mapBotX;
	CMap<T_SBDO_K, T_SBDO_K, T_RSHF_POS, T_RSHF_POS&> mapTopY;
	CMap<T_SBDO_K, T_SBDO_K, T_RSHF_POS, T_RSHF_POS&> mapBotY;

	CMap<T_SBDO_K, T_SBDO_K, double, double> mapTopAsX;
	CMap<T_SBDO_K, T_SBDO_K, double, double> mapBotAsX;
	CMap<T_SBDO_K, T_SBDO_K, double, double> mapTopAsY;
	CMap<T_SBDO_K, T_SBDO_K, double, double> mapBotAsY;

	T_MSRB_D MsrbD;
	if (!m_pDoc->m_pAttrCtrl->GetMsrb(MsrbD))
	{
		m_pDoc->m_pMatlDB->InitializeMsrb(MsrbD);
	}

	T_ELEM_K_LIST aElemK;
	CArray<T_RBSL_K, T_RBSL_K>  aRbslK[4];
	CArray<T_RBSL_D, T_RBSL_D&> aRbslD[4];
	T_RSHF_D RshfDX, RshfDY, RshfDC;

	double dMaxTopX = 0.0, dMaxBotX = 0.0, dMaxTopY = 0.0, dMaxBotY = 0.0;
	double dCurTopX = 0.0, dCurBotX = 0.0, dCurTopY = 0.0, dCurBotY = 0.0;
	int nElem = m_PlateKeyList.GetSize();
	for (int i = 0; i < nElem; ++i)
	{
		RshfDX.Initialize();
		RshfDY.Initialize();
		RshfDC.Initialize();

		T_ELEM_K ElemK = m_PlateKeyList[i];
		if (!m_pDoc->m_pPostCtrl->GetDesignResult()->Get_ShellResult_ByElem(ElemK, RshfDX, RshfDY, RshfDC)) { continue; }

		T_DOEL_D DoelD;
		if (!m_pDoc->m_pAttrCtrl->GetDoel(ElemK, DoelD)) { ASSERT(0); continue; }
		if (DoelD.nDomainType != 1) { ASSERT(0); continue; }

		T_SBDO_K SbdoK = DoelD.KeyDomain;
		T_SBDO_D SbdoD;
		if (!m_pDoc->m_pAttrCtrl->GetSbdo(SbdoK, SbdoD)) { ASSERT(0); continue; }

		for (int j = 0; j < RshfDX.nNodeNum; ++j)
		{
			dCurTopX = RshfDX.Top[j].RsltBarX.dAsreq;
			if (!mapTopAsX.Lookup(SbdoK, dMaxTopX)) { dMaxTopX = -DBL_MAX; }
			if (dMaxTopX < dCurTopX)
			{
				dMaxTopX = dCurTopX;
				mapTopAsX.SetAt(SbdoK, dCurTopX);
				mapTopX.SetAt(SbdoK, RshfDX.Top[j]);
			}

			dCurBotX = RshfDX.Bot[j].RsltBarX.dAsreq;
			if (!mapBotAsX.Lookup(SbdoK, dMaxBotX)) { dMaxBotX = -DBL_MAX; }
			if (dMaxBotX < dCurBotX)
			{
				dMaxBotX = dCurBotX;
				mapBotAsX.SetAt(SbdoK, dCurBotX);
				mapBotX.SetAt(SbdoK, RshfDX.Bot[j]);
			}

			dCurTopY = RshfDY.Top[j].RsltBarY.dAsreq;
			if (!mapTopAsY.Lookup(SbdoK, dMaxTopY)) { dMaxTopY = -DBL_MAX; }
			if (dMaxTopY < dCurTopY)
			{
				dMaxTopY = dCurTopY;
				mapTopAsY.SetAt(SbdoK, dCurTopY);
				mapTopY.SetAt(SbdoK, RshfDY.Top[j]);
			}

			dCurBotY = RshfDY.Bot[j].RsltBarY.dAsreq;
			if (!mapBotAsY.Lookup(SbdoK, dMaxBotY)) { dMaxBotY = -DBL_MAX; }
			if (dMaxBotY < dCurBotY)
			{
				dMaxBotY = dCurBotY;
				mapBotAsY.SetAt(SbdoK, dCurBotY);
				mapBotY.SetAt(SbdoK, RshfDY.Bot[j]);
			}
		}
	}

	for (int i = 0; i < nElem; ++i)
	{
		T_ELEM_K ElemK = m_PlateKeyList[i];
		T_DOEL_D DoelD;
		if (!m_pDoc->m_pAttrCtrl->GetDoel(ElemK, DoelD)) { ASSERT(0); continue; }
		if (DoelD.nDomainType != 1) { ASSERT(0); continue; }

		T_SBDO_K SbodK = DoelD.KeyDomain;
		T_SBDO_D SbdoD;
		if (!m_pDoc->m_pAttrCtrl->GetSbdo(SbodK, SbdoD)) { ASSERT(0); continue; }

		CArray<T_RBSL_D, T_RBSL_D&> aAddRbslD; aAddRbslD.RemoveAll();
		for (int k = 0; k < 4; ++k)
		{
			T_RBSL_D RbslD; RbslD.Initialize();
			T_RSHF_POS RshfPos;
			switch (k)
			{
			case EN_TOP_DIR1: { mapTopX.Lookup(SbodK, RshfPos); RbslD.dCover = RshfDX.dT; } break;
			case EN_BOT_DIR1: { mapBotX.Lookup(SbodK, RshfPos); RbslD.dCover = RshfDX.dB; } break;
			case EN_TOP_DIR2: { mapTopY.Lookup(SbodK, RshfPos); RbslD.dCover = RshfDY.dT; } break;
			case EN_BOT_DIR2: { mapBotY.Lookup(SbodK, RshfPos); RbslD.dCover = RshfDY.dB; } break;
			default: ASSERT(FALSE); break;
			}

			RbslD.nLayerType = k;
			RbslD.bThickOptimal = MsrbD.bThickOptimal;
			RbslD.dTopThik = MsrbD.dTopThik;
			RbslD.dBotThik = MsrbD.dBotThik;
			RbslD.nIteration = MsrbD.nIteration;
			RbslD.dConvTolerance = MsrbD.dConvTolerance;

			T_RSHF_BAR RshfBar;
			switch (k)
			{
			case EN_TOP_DIR1: RshfBar = RshfPos.RsltBarX; break;
			case EN_BOT_DIR1: RshfBar = RshfPos.RsltBarX; break;
			case EN_TOP_DIR2: RshfBar = RshfPos.RsltBarY; break;
			case EN_BOT_DIR2: RshfBar = RshfPos.RsltBarY; break;
			default: ASSERT(FALSE); break;
			}

			CString strAdd1 = _T(""), strAdd2 = _T("");
			if (SbdoD.bBasicRebar || MsrbD.bBasicRebar)
			{
				RbslD.strBasicRebarName = RshfBar.strBarSize;
				RbslD.dBasicRebarSpace = RshfBar.dSpace;
				RbslD.dAdd1RebarSpace = RshfBar.dAddSpace;
				DivideRebarString(RshfBar.strAddBarSize, strAdd1, strAdd2); // Basic Rebar만 들어가는 경우가 있다.				
			}
			else
			{
				// Basic이 없으면 Add1은 꼭 있어야 한다.          
				RbslD.dAdd1RebarSpace = RshfBar.dSpace;
				if (!DivideRebarString(RshfBar.strBarSize, strAdd1, strAdd2)) { break; }
			}

			RbslD.strAdd1RebarName = strAdd1;
			RbslD.strAdd2RebarName = strAdd2;

			if (RbslD.strBasicRebarName.GetLength() <= 0 && RbslD.strAdd1RebarName.GetLength() <= 0) break;
			if (RbslD.dBasicRebarSpace <= 0 && RbslD.dAdd1RebarSpace <= 0) break;
			if (RbslD.dCover <= 0) break;

			aAddRbslD.Add(RbslD);
		}

		// 검증을 위해
		if (aAddRbslD.GetSize() != 4) { ASSERT(0); continue; }

		// Key는 Dummy로 넣어준다.
		for (int k = 0; k < 4; ++k)
		{
			aRbslK[k].Add(0);
			aRbslD[k].Add(aAddRbslD[k]);
		}
		aElemK.Add(ElemK);
	}

	if (aElemK.GetSize() <= 0)
	{
		m_pDoc->DisplayHistoryMessage(_LS(IDS_GPS_Error_Update_Rebar));
		return FALSE;
	}

	return m_pDoc->m_pDataCtrl->AddRbslByElemK(aElemK, aRbslK, aRbslD);
}

BOOL CDesignEngine::UpdateRebarSlab()
{
	/// 기존 소스 알고리즘을 정리해서 함수로 분리.
	T_MSRB_D MsrbD;
	if (!m_pDoc->m_pAttrCtrl->GetMsrb(MsrbD))
	{
		m_pDoc->m_pMatlDB->InitializeMsrb(MsrbD);
	}

	T_ELEM_K_LIST aElemK;
	CArray<T_RBMS_K, T_RBMS_K>  aRbmsK[4];
	CArray<T_RBMS_D, T_RBMS_D&> aRbmsD[4];
	T_RSL2_D Rsl2D_X, Rsl2D_Y;
	int nMaxTopX = 0, nMaxTopY = 0, nMaxBotX = 0, nMaxBotY = 0;

	int nElem = m_PlateKeyList.GetSize();
	for (int i = 0; i < nElem; ++i)
	{
		double dMaxTopX = -DBL_MAX, dCurTopX = 0.0;
		double dMaxTopY = -DBL_MAX, dCurTopY = 0.0;
		double dMaxBotX = -DBL_MAX, dCurBotX = 0.0;
		double dMaxBotY = -DBL_MAX, dCurBotY = 0.0;

		Rsl2D_X.Initialize();
		Rsl2D_Y.Initialize();

		T_ELEM_K ElemK = m_PlateKeyList[i];
		if (!m_pDoc->m_pPostCtrl->GetDesignResult()->Get_2waySlabResult(ElemK, 0, Rsl2D_X)) { continue; }
		if (!m_pDoc->m_pPostCtrl->GetDesignResult()->Get_2waySlabResult(ElemK, 1, Rsl2D_Y)) { continue; }

		T_DOEL_D DoelD;
		if (!m_pDoc->m_pAttrCtrl->GetDoel(ElemK, DoelD)) { ASSERT(0); continue; }
		if (DoelD.nDomainType != 1) { ASSERT(0); continue; }
		T_SBDO_D SbdoD;
		if (!m_pDoc->m_pAttrCtrl->GetSbdo(DoelD.KeyDomain, SbdoD)) { ASSERT(0); continue; }

		for (int j = 0; j < Rsl2D_X.iNodeNum; ++j)
		{
			dCurTopX = CalcSDRValue(Rsl2D_X, j, 0, 1);
			if (dMaxTopX < dCurTopX) { dMaxTopX = dCurTopX; nMaxTopX = j; }

			dCurTopY = CalcSDRValue(Rsl2D_Y, j, 0, 1);
			if (dMaxTopY < dCurTopY) { dMaxTopY = dCurTopY; nMaxTopY = j; }

			dCurBotX = CalcSDRValue(Rsl2D_X, j, 1, 1);
			if (dMaxBotX < dCurBotX) { dMaxBotX = dCurBotX; nMaxBotX = j; }

			dCurBotY = CalcSDRValue(Rsl2D_Y, j, 1, 1);
			if (dMaxBotY < dCurBotY) { dMaxBotY = dCurBotY; nMaxBotY = j; }
		}

		CArray<T_RBMS_D, T_RBMS_D&> aAddRbmsD; aAddRbmsD.RemoveAll();
		for (int k = 0; k < 4; ++k)
		{
			CString strAdd1 = _T(""), strAdd2 = _T("");
			T_RBMS_D RbmsD; RbmsD.Initialize();

			T_SLAB_POS SlabPos;
			if (k == 0) { SlabPos = Rsl2D_X.Top[nMaxTopX]; RbmsD.dCover = Rsl2D_X.dT; }
			else if (k == 1) { SlabPos = Rsl2D_X.Bot[nMaxBotX]; RbmsD.dCover = Rsl2D_X.dB; }
			else if (k == 2) { SlabPos = Rsl2D_Y.Top[nMaxTopY]; RbmsD.dCover = Rsl2D_Y.dT; }
			else if (k == 3) { SlabPos = Rsl2D_Y.Bot[nMaxBotY]; RbmsD.dCover = Rsl2D_Y.dB; }

			RbmsD.nLayerType = k;
			if (SbdoD.bBasicRebar || MsrbD.bBasicRebar)
			{
				RbmsD.strBasicRebarName = SlabPos.Rebar.strSize;
				RbmsD.dBasicRebarSpace = SlabPos.Rebar.dSpace;
				RbmsD.dAdd1RebarSpace = SlabPos.AddRebar.dSpace;
				DivideRebarString(SlabPos.AddRebar.strSize, strAdd1, strAdd2); // Basic Rebar만 들어가는 경우가 있다.
			}
			else
			{
				// Basic이 없으면 Add1은 꼭 있어야 한다.          
				RbmsD.dAdd1RebarSpace = SlabPos.Rebar.dSpace;
				if (!DivideRebarString(SlabPos.Rebar.strSize, strAdd1, strAdd2)) break;
			}
			RbmsD.strAdd1RebarName = strAdd1;
			RbmsD.strAdd2RebarName = strAdd2;

			if (RbmsD.strBasicRebarName.GetLength() <= 0 && RbmsD.strAdd1RebarName.GetLength() <= 0) break;
			if (RbmsD.dBasicRebarSpace <= 0 && RbmsD.dAdd1RebarSpace <= 0) break;
			if (RbmsD.dCover <= 0) break;

			//MakeRbmsData(ElemK, RbmsD, aElemK, aRbmsData[k]);                 

			aAddRbmsD.Add(RbmsD);
		}

		// 검증을 위해
		if (aAddRbmsD.GetSize() != 4) { ASSERT(0); continue; }

		// Key는 Dummy로 넣어준다.
		for (int k = 0; k < 4; k++)
		{
			aRbmsK[k].Add(0);
			aRbmsD[k].Add(aAddRbmsD[k]);
		}
		aElemK.Add(ElemK);
	}

	if (aElemK.GetSize() <= 0)
	{
		m_pDoc->DisplayHistoryMessage(_LS(IDS_GPS_Error_Update_Rebar));
		return FALSE;
	}

	return m_pDoc->m_pDataCtrl->AddRbmsByElemK(aElemK, aRbmsK, aRbmsD);
}

BOOL CDesignEngine::UpdateRebarSlabBySbdo()
{
	/// SUBDOMAIN별 불리한 조건을 저장합니다.
	CMap<T_SBDO_K, T_SBDO_K, T_SLAB_POS, T_SLAB_POS&> mapTopX;
	CMap<T_SBDO_K, T_SBDO_K, T_SLAB_POS, T_SLAB_POS&> mapBotX;
	CMap<T_SBDO_K, T_SBDO_K, T_SLAB_POS, T_SLAB_POS&> mapTopY;
	CMap<T_SBDO_K, T_SBDO_K, T_SLAB_POS, T_SLAB_POS&> mapBotY;

	CMap<T_SBDO_K, T_SBDO_K, double, double> mapTopAsX;
	CMap<T_SBDO_K, T_SBDO_K, double, double> mapBotAsX;
	CMap<T_SBDO_K, T_SBDO_K, double, double> mapTopAsY;
	CMap<T_SBDO_K, T_SBDO_K, double, double> mapBotAsY;

	/// 기존 소스 알고리즘을 정리해서 함수로 분리.
	T_MSRB_D MsrbD;
	if (!m_pDoc->m_pAttrCtrl->GetMsrb(MsrbD))
	{
		m_pDoc->m_pMatlDB->InitializeMsrb(MsrbD);
	}

	T_ELEM_K_LIST aElemK;
	CArray<T_RBMS_K, T_RBMS_K>  aRbmsK[4];
	CArray<T_RBMS_D, T_RBMS_D&> aRbmsD[4];
	T_RSL2_D Rsl2D_X, Rsl2D_Y;

	double dMaxTopX = 0.0, dMaxBotX = 0.0, dMaxTopY = 0.0, dMaxBotY = 0.0;
	double dCurTopX = 0.0, dCurBotX = 0.0, dCurTopY = 0.0, dCurBotY = 0.0;
	int nElem = m_PlateKeyList.GetSize();
	for (int i = 0; i < nElem; ++i)
	{
		Rsl2D_X.Initialize();
		Rsl2D_Y.Initialize();

		T_ELEM_K ElemK = m_PlateKeyList[i];
		if (!m_pDoc->m_pPostCtrl->GetDesignResult()->Get_2waySlabResult(ElemK, 0, Rsl2D_X)) { continue; }
		if (!m_pDoc->m_pPostCtrl->GetDesignResult()->Get_2waySlabResult(ElemK, 1, Rsl2D_Y)) { continue; }

		T_DOEL_D DoelD;
		if (!m_pDoc->m_pAttrCtrl->GetDoel(ElemK, DoelD)) { ASSERT(0); continue; }
		if (DoelD.nDomainType != 1) { ASSERT(0); continue; }

		T_SBDO_K SbdoK = DoelD.KeyDomain;
		T_SBDO_D SbdoD;
		if (!m_pDoc->m_pAttrCtrl->GetSbdo(SbdoK, SbdoD)) { ASSERT(0); continue; }

		for (int j = 0; j < Rsl2D_X.iNodeNum; ++j)
		{
			dCurTopX = CalcSDRValue(Rsl2D_X, j, 0, 1);
			if (!mapTopAsX.Lookup(SbdoK, dMaxTopX)) { dMaxTopX = -DBL_MAX; }
			if (dMaxTopX < dCurTopX)
			{
				dMaxTopX = dCurTopX;
				mapTopAsX.SetAt(SbdoK, dCurTopX);
				mapTopX.SetAt(SbdoK, Rsl2D_X.Top[j]);
			}

			dCurTopY = CalcSDRValue(Rsl2D_Y, j, 0, 1);
			if (!mapTopAsY.Lookup(SbdoK, dMaxTopY)) { dMaxTopY = -DBL_MAX; }
			if (dMaxTopY < dCurTopY)
			{
				dMaxTopY = dCurTopY;
				mapTopAsY.SetAt(SbdoK, dCurTopY);
				mapTopY.SetAt(SbdoK, Rsl2D_Y.Top[j]);
			}

			dCurBotX = CalcSDRValue(Rsl2D_X, j, 1, 1);
			if (!mapBotAsX.Lookup(SbdoK, dMaxBotX)) { dMaxBotX = -DBL_MAX; }
			if (dMaxBotX < dCurBotX)
			{
				dMaxBotX = dCurBotX;
				mapBotAsX.SetAt(SbdoK, dCurBotX);
				mapBotX.SetAt(SbdoK, Rsl2D_X.Bot[j]);
			}

			dCurBotY = CalcSDRValue(Rsl2D_Y, j, 1, 1);
			if (!mapBotAsY.Lookup(SbdoK, dMaxBotY)) { dMaxBotY = -DBL_MAX; }
			if (dMaxBotY < dCurBotY)
			{
				dMaxBotY = dCurBotY;
				mapBotAsY.SetAt(SbdoK, dCurBotY);
				mapBotY.SetAt(SbdoK, Rsl2D_Y.Bot[j]);
			}
		}
	}

	for (int i = 0; i < nElem; ++i)
	{
		T_ELEM_K ElemK = m_PlateKeyList[i];
		T_DOEL_D DoelD;
		if (!m_pDoc->m_pAttrCtrl->GetDoel(ElemK, DoelD)) { ASSERT(0); continue; }
		if (DoelD.nDomainType != 1) { ASSERT(0); continue; }

		T_SBDO_K SbodK = DoelD.KeyDomain;
		T_SBDO_D SbdoD;
		if (!m_pDoc->m_pAttrCtrl->GetSbdo(SbodK, SbdoD)) { ASSERT(0); continue; }

		CArray<T_RBMS_D, T_RBMS_D&> aAddRbmsD; aAddRbmsD.RemoveAll();
		for (int k = 0; k < 4; ++k)
		{
			CString strAdd1 = _T(""), strAdd2 = _T("");
			T_RBMS_D RbmsD; RbmsD.Initialize();

			T_SLAB_POS SlabPos;
			switch (k)
			{
			case EN_TOP_DIR1: { mapTopX.Lookup(SbodK, SlabPos); RbmsD.dCover = Rsl2D_X.dT; } break;
			case EN_BOT_DIR1: { mapBotX.Lookup(SbodK, SlabPos); RbmsD.dCover = Rsl2D_X.dB; } break;
			case EN_TOP_DIR2: { mapTopY.Lookup(SbodK, SlabPos); RbmsD.dCover = Rsl2D_Y.dT; } break;
			case EN_BOT_DIR2: { mapBotY.Lookup(SbodK, SlabPos); RbmsD.dCover = Rsl2D_Y.dB; } break;
			default: ASSERT(FALSE); break;
			}

			RbmsD.nLayerType = k;
			if (SbdoD.bBasicRebar || MsrbD.bBasicRebar)
			{
				RbmsD.strBasicRebarName = SlabPos.Rebar.strInfo;
				RbmsD.dBasicRebarSpace = SlabPos.Rebar.dSpace;
				RbmsD.dAdd1RebarSpace = SlabPos.AddRebar.dSpace;
				DivideRebarString(SlabPos.AddRebar.strSize, strAdd1, strAdd2); // Basic Rebar만 들어가는 경우가 있다.
			}
			else
			{
				// Basic이 없으면 Add1은 꼭 있어야 한다.          
				RbmsD.dAdd1RebarSpace = SlabPos.Rebar.dSpace;
				if (!DivideRebarString(SlabPos.Rebar.strSize, strAdd1, strAdd2)) break;
			}
			RbmsD.strAdd1RebarName = strAdd1;
			RbmsD.strAdd2RebarName = strAdd2;

			if (RbmsD.strBasicRebarName.GetLength() <= 0 && RbmsD.strAdd1RebarName.GetLength() <= 0) break;
			if (RbmsD.dBasicRebarSpace <= 0 && RbmsD.dAdd1RebarSpace <= 0) break;
			if (RbmsD.dCover <= 0) break;

			aAddRbmsD.Add(RbmsD);
		}

		// 검증을 위해
		if (aAddRbmsD.GetSize() != 4) { ASSERT(0); continue; }

		// Key는 Dummy로 넣어준다.
		for (int k = 0; k < 4; k++)
		{
			aRbmsK[k].Add(0);
			aRbmsD[k].Add(aAddRbmsD[k]);
		}
		aElemK.Add(ElemK);
	}

	if (aElemK.GetSize() <= 0)
	{
		m_pDoc->DisplayHistoryMessage(_LS(IDS_GPS_Error_Update_Rebar));
		return FALSE;
	}

	return m_pDoc->m_pDataCtrl->AddRbmsByElemK(aElemK, aRbmsK, aRbmsD);
}

BOOL CDesignEngine::UpdateRebarWall()
{
	/// 기존 소스 알고리즘을 정리해서 함수로 분리.
	T_ELEM_K_LIST aElemK;
	CArray<T_RBMW_D, T_RBMW_D&> aData;
	T_RMEW_D RmewD;
	int nMaxX = 0, nMaxY = 0;

	int nElem = m_PlateKeyList.GetSize();
	for (int i = 0; i < nElem; ++i)
	{
		double dMaxX = -DBL_MAX, dCurX = 0.0;
		double dMaxY = -DBL_MAX, dCurY = 0.0;

		RmewD.Initialize();
		T_ELEM_K ElemK = m_PlateKeyList[i];
		if (!m_pDoc->m_pPostCtrl->GetDesignResult()->Get_MeshWallResult(ElemK, RmewD, m_nXDirYDir)) { continue; }

		for (int j = 0; j < RmewD.iNodeNum; ++j)
		{
			dCurX = CalcWDRValue(RmewD, j, 0, 1);
			if (dMaxX < dCurX) { dMaxX = dCurX; nMaxX = j; }

			dCurY = CalcWDRValue(RmewD, j, 1, 1);
			if (dMaxY < dCurY) { dMaxY = dCurY; nMaxY = j; }
		}

		T_RBMW_D RbmwD; RbmwD.Initialize();
		RbmwD.strHorRebarName = RmewD.Res[nMaxX].strBarSize[0];
		RbmwD.dHorRebarSpace = RmewD.Res[nMaxX].dSpace[0];
		RbmwD.strVerRebarName = RmewD.Res[nMaxY].strBarSize[1];
		RbmwD.dVerRebarSpace = RmewD.Res[nMaxY].dSpace[1];
		RbmwD.dCover = RmewD.dDw;

		if (RbmwD.strHorRebarName.GetLength() <= 0 || RbmwD.strVerRebarName.GetLength() <= 0) { continue; }
		if (RbmwD.dHorRebarSpace <= 0 || RbmwD.dVerRebarSpace <= 0) { continue; }
		if (RbmwD.dCover <= 0) { continue; }

		MakeRbmwData(ElemK, RbmwD, aElemK, aData);
	}

	if (aData.GetSize() <= 0)
	{
		m_pDoc->DisplayHistoryMessage(_LS(IDS_GPS_Error_Update_Rebar));
		return FALSE;
	}

	return m_pDoc->m_pDataCtrl->AddRbmwByElemK(aElemK, aData);
}

BOOL CDesignEngine::UpdateRebarWallBySbdo()
{
	/// SUBDOMAIN별 불리한 조건을 저장합니다.
	CMap<T_SBDO_K, T_SBDO_K, T_WALL_POS, T_WALL_POS&> mapBarX;
	CMap<T_SBDO_K, T_SBDO_K, T_WALL_POS, T_WALL_POS&> mapBarY;

	CMap<T_SBDO_K, T_SBDO_K, double, double> mapAsX;
	CMap<T_SBDO_K, T_SBDO_K, double, double> mapAsY;

	/// 기존 소스 알고리즘을 정리해서 함수로 분리.
	T_ELEM_K_LIST aElemK;
	CArray<T_RBMW_D, T_RBMW_D&> aData;
	T_RMEW_D RmewD;

	double dMaxX = 0.0, dMaxY = 0.0;
	double dCurX = 0.0, dCurY = 0.0;
	int nElem = m_PlateKeyList.GetSize();
	for (int i = 0; i < nElem; ++i)
	{
		RmewD.Initialize();

		T_ELEM_K ElemK = m_PlateKeyList[i];
		if (!m_pDoc->m_pPostCtrl->GetDesignResult()->Get_MeshWallResult(ElemK, RmewD, m_nXDirYDir)) { continue; }

		T_DOEL_D DoelD;
		if (!m_pDoc->m_pAttrCtrl->GetDoel(ElemK, DoelD)) { ASSERT(0); continue; }
		if (DoelD.nDomainType != 1) { ASSERT(0); continue; }

		T_SBDO_K SbdoK = DoelD.KeyDomain;
		T_SBDO_D SbdoD;
		if (!m_pDoc->m_pAttrCtrl->GetSbdo(SbdoK, SbdoD)) { ASSERT(0); continue; }

		for (int j = 0; j < RmewD.iNodeNum; ++j)
		{
			dCurX = CalcWDRValue(RmewD, j, 0, 1);
			if (!mapAsX.Lookup(SbdoK, dMaxX)) { dMaxX = -DBL_MAX; }
			if (dMaxX < dCurX)
			{
				dMaxX = dCurX;
				mapAsX.SetAt(SbdoK, dCurX);
				mapBarX.SetAt(SbdoK, RmewD.Res[j]);
			}

			dCurY = CalcWDRValue(RmewD, j, 1, 1);
			if (!mapAsY.Lookup(SbdoK, dMaxY)) { dMaxY = -DBL_MAX; }
			if (dMaxY < dCurY)
			{
				dMaxY = dCurY;
				mapAsY.SetAt(SbdoK, dCurY);
				mapBarY.SetAt(SbdoK, RmewD.Res[j]);
			}
		}
	}

	for (int i = 0; i < nElem; ++i)
	{
		T_ELEM_K ElemK = m_PlateKeyList[i];
		T_DOEL_D DoelD;
		if (!m_pDoc->m_pAttrCtrl->GetDoel(ElemK, DoelD)) { ASSERT(0); continue; }
		if (DoelD.nDomainType != 1) { ASSERT(0); continue; }

		T_SBDO_K SbodK = DoelD.KeyDomain;
		T_SBDO_D SbdoD;
		if (!m_pDoc->m_pAttrCtrl->GetSbdo(SbodK, SbdoD)) { ASSERT(0); continue; }

		T_RBMW_D RbmwD; RbmwD.Initialize();
		RbmwD.dCover = RmewD.dDw;

		T_WALL_POS WallPosX;
		if (mapBarX.Lookup(SbodK, WallPosX))
		{
			RbmwD.strHorRebarName = WallPosX.strBarSize[0];
			RbmwD.dHorRebarSpace = WallPosX.dSpace[0];
		}
		T_WALL_POS WallPosY;
		if (mapBarY.Lookup(SbodK, WallPosY))
		{
			RbmwD.strVerRebarName = WallPosY.strBarSize[1];
			RbmwD.dVerRebarSpace = WallPosY.dSpace[1];
		}

		if (RbmwD.strHorRebarName.GetLength() <= 0 || RbmwD.strVerRebarName.GetLength() <= 0) { continue; }
		if (RbmwD.dHorRebarSpace <= 0 || RbmwD.dVerRebarSpace <= 0) { continue; }
		if (RbmwD.dCover <= 0) { continue; }

		MakeRbmwData(ElemK, RbmwD, aElemK, aData);
	}

	if (aData.GetSize() <= 0)
	{
		m_pDoc->DisplayHistoryMessage(_LS(IDS_GPS_Error_Update_Rebar));
		return FALSE;
	}

	return m_pDoc->m_pDataCtrl->AddRbmwByElemK(aElemK, aData);
}

double CDesignEngine::CalcServValueStress(const T_SSER_POS& SserPos, int nStress, int nRebarRatio)
{
	if (nStress == 0) // concrete
	{
		switch (nRebarRatio)
		{
		case 0: { return SserPos.dStress[0]; } // value.
		case 1: { return SserPos.dStrRat[0]; } // ratio.
		default: { ASSERT(0); return 0.0; }
		}
	}
	else if (nStress == 1) // reinforcement
	{
		switch (nRebarRatio)
		{
		case 0: { return SserPos.dStress[1]; } // value.
		case 1: { return SserPos.dStrRat[1]; } // ratio.
		default: { ASSERT(0); return 0.0; }
		}
	}
	else
	{
		ASSERT(0);
		return 0.0;
	}
}

double CDesignEngine::CalcServValueCrack(const T_SSER_POS& SserPos, int nCrack, int nRebarRatio)
{
	T_UNIT_INDEX UnitIndex;
	m_pDoc->m_pUnitCtrl->GetUnitIndexCurrent(UnitIndex);

	if (nCrack == 0) // crack width
	{
		switch (nRebarRatio)
		{
		case 0: { return SserPos.dwk; }
		case 1: { return SserPos.dCrkRat[0];  }
		default: { ASSERT(0); return 0.0; }
		}
	}
	else if (nCrack == 1) // min as
	{
		switch (nRebarRatio)
		{
		case 0: { return SserPos.dAsmin*CDBLib::GetAs2Factor(UnitIndex.nBase_Length); }
		case 1: { return SserPos.dCrkRat[1]; }
		default: { ASSERT(0); return 0.0; }
		}
	}
	else if (nCrack == 2) // rebar space
	{
		switch (nRebarRatio)
		{
		case 0: { return SserPos.dASpace; }
		case 1: { return SserPos.dCrkRat[2]; }
		default: { ASSERT(0); return 0.0; }
		}
	}
	else if (nCrack == 3) // rebar dia
	{
		switch (nRebarRatio)
		{
		case 0: { return SserPos.dARebarDia; }
		case 1: { return SserPos.dCrkRat[3]; }
		default: { ASSERT(0); return 0.0; }
		}
	}
	else
	{
		ASSERT(0);
		return 0.0;
	}
}

double CDesignEngine::CalcServValueDeflectUncracked(const T_SSER_POS& SserPos, BOOL bLongTermDefl, int nDeflection, int nRebarRatio)
{
	if (nDeflection == 0) // uncracked
	{
		const double dAllowDsp = SserPos.dAllowDsp;
		if (dAllowDsp == 0 && nRebarRatio == 1) { return 0.0; }

		if (!bLongTermDefl)
		{
			switch (nRebarRatio)
			{
			case 0: { return SserPos.dElasticDsp; }
			case 1: { return SserPos.dElasticDsp / dAllowDsp; }
			default: { ASSERT(0); return 0.0; }
			}
		}
		else
		{
			switch (nRebarRatio)
			{
			case 0: { return SserPos.dCreepedDsp; }
			case 1: { return SserPos.dCreepedDsp / dAllowDsp; }
			default: { ASSERT(0); return 0.0; }
			}
		}
	}
	else
	{
		ASSERT(0);
		return 0.0;
	}
}

double CDesignEngine::CalcServValueStress(const T_SSER_POS& SserTop, const T_SSER_POS& SserBot, int nStress, int nRebarRatio)
{
	if (nStress == 0) // concrete
	{
		switch (nRebarRatio)
		{
		case 0: { return GetAbsMaxValue(SserTop.dStress[0], SserBot.dStress[0]); } // value.
		case 1: { return GetAbsMaxValue(SserTop.dStrRat[0], SserBot.dStrRat[0]); } // ratio.
		default: { ASSERT(0); return 0.0; }
		}
	}
	else if (nStress == 1) // reinforcement
	{
		switch (nRebarRatio)
		{
		case 0: { return GetAbsMaxValue(SserTop.dStress[1], SserBot.dStress[1]); } // value.
		case 1: { return GetAbsMaxValue(SserTop.dStrRat[1], SserBot.dStrRat[1]); } // ratio.
		default: { ASSERT(0); return 0.0; }
		}
	}
	else
	{
		ASSERT(0);
		return 0.0;
	}
}

double CDesignEngine::CalcServValueCrack(const T_SSER_POS& SserTop, const T_SSER_POS& SserBot, int nCrack, int nRebarRatio)
{
	T_UNIT_INDEX UnitIndex;
	m_pDoc->m_pUnitCtrl->GetUnitIndexCurrent(UnitIndex);

	if (nCrack == 0) // crack width
	{
		switch (nRebarRatio)
		{
		case 0: { return GetAbsMaxValue(SserTop.dwk, SserBot.dwk); }
		case 1: { return GetAbsMaxValue(SserTop.dCrkRat[0], SserBot.dCrkRat[0]); }
		default: { ASSERT(0); return 0.0; }
		}
	}
	else if (nCrack == 1) // min as
	{
		switch (nRebarRatio)
		{
		case 0: { return GetAbsMaxValue(SserTop.dAsmin, SserBot.dAsmin) * CDBLib::GetAs2Factor(UnitIndex.nBase_Length); }
		case 1: { return GetAbsMaxValue(SserTop.dCrkRat[1], SserBot.dCrkRat[1]); }
		default: { ASSERT(0); return 0.0; }
		}
	}
	else if (nCrack == 2) // rebar space
	{
		switch (nRebarRatio)
		{
		case 0: { return GetAbsMaxValue(SserTop.dASpace, SserBot.dASpace); }
		case 1: { return GetAbsMaxValue(SserTop.dCrkRat[2], SserBot.dCrkRat[2]); }
		default: { ASSERT(0); return 0.0; }
		}
	}
	else if (nCrack == 3) // rebar dia
	{
		switch (nRebarRatio)
		{
		case 0: { return GetAbsMaxValue(SserTop.dARebarDia, SserBot.dARebarDia); }
		case 1: { return GetAbsMaxValue(SserTop.dCrkRat[3], SserBot.dCrkRat[3]); }
		default: { ASSERT(0); return 0.0; }
		}
	}
	else
	{
		ASSERT(0);
		return 0.0;
	}
}

double CDesignEngine::CalcServValueDeflectUncracked(const T_SSER_POS& SserTop, const T_SSER_POS& SserBot, BOOL bLongTermDefl, int nDeflection, int nRebarRatio)
{
	const double dAllowDsp_Top = SserTop.dAllowDsp;
	const double dAllowDsp_Bot = SserBot.dAllowDsp;

	if (!bLongTermDefl)
	{
		if (nDeflection == 0)
		{
			if (nRebarRatio == 0)
			{
				return GetAbsMaxValue(SserTop.dElasticDsp, SserBot.dElasticDsp);
			}
			else if (nRebarRatio == 1)
			{
				double dDispTop = fabs(SserTop.dElasticDsp);
				double dDispBot = fabs(SserBot.dElasticDsp);
				if (dDispTop > dDispBot)
				{
					if (dAllowDsp_Top != 0.0)
					{
						return fabs(SserTop.dElasticDsp / dAllowDsp_Top);
					}
					else
					{
						if (dAllowDsp_Bot != 0.0) { return fabs(SserBot.dElasticDsp / dAllowDsp_Bot); }
						else return 0.0;
					}
				}
				else
				{
					if (dAllowDsp_Bot != 0.0)
					{
						return fabs(SserBot.dElasticDsp / dAllowDsp_Bot);
					}
					else
					{
						if (dAllowDsp_Top != 0.0) { return fabs(SserTop.dElasticDsp / dAllowDsp_Top); }
						else return 0;
					}
				}
			}
			else
			{
				ASSERT(0);
				return 0.0;
			}
		}
		else
		{
			ASSERT(0);
			return 0.0;
		}
	}
	else
	{
		if (nRebarRatio == 0)
		{
			return GetAbsMaxValue(SserTop.dCreepedDsp, SserBot.dCreepedDsp);
		}
		else if (nRebarRatio == 1)
		{
			BOOL IsCode4CH = CDBLib::IsCodeForMeshedDesignCH();
			const double dDispTop = fabs(SserTop.dCreepedDsp);
			const double dDispBot = fabs(SserBot.dCreepedDsp);
			if (IsCode4CH == FALSE)
			{
				if (dDispTop > dDispBot)
				{
					if (dAllowDsp_Top != 0.0)
					{
						return fabs(SserTop.dCreepedDsp / dAllowDsp_Top);
					}
					else
					{
						if (dAllowDsp_Bot != 0.0)
						{
							return fabs(SserBot.dCreepedDsp / dAllowDsp_Bot);
						}
						else
						{
							return 0.0;
						}
					}
				}
				else
				{
					if (dAllowDsp_Bot != 0)
					{
						return fabs(SserBot.dCreepedDsp / dAllowDsp_Bot);
					}
					else
					{
						if (dAllowDsp_Top != 0.0)
						{
							return fabs(SserTop.dCreepedDsp / dAllowDsp_Top);
						}
						else
						{
							return 0.0;
						}
					}
				}
			}
			else
			{
				if (dDispTop > dDispBot)
				{
					if (SserTop.dElasticDsp != 0.0)
					{
						return fabs(SserTop.dCreepedDsp / SserTop.dElasticDsp);
					}
					else
					{
						if (SserBot.dElasticDsp != 0.0)
						{
							return fabs(SserBot.dCreepedDsp / SserBot.dElasticDsp);
						}
						else
						{
							return 0.0;
						}
					}
				}
				else
				{
					if (SserBot.dElasticDsp != 0.0)
					{
						return fabs(SserBot.dCreepedDsp / SserBot.dElasticDsp);
					}
					else
					{
						if (SserTop.dElasticDsp != 0.0)
						{
							return fabs(SserTop.dCreepedDsp / SserTop.dElasticDsp);
						}
						else
						{
							return 0;
						}
					}
				}
			}
		}
		else
		{
			ASSERT(0);
			return 0.0;
		}
	}
}

double CDesignEngine::GetAbsMaxValue(double dTop, double dBot)
{
	return fabs(dTop) > fabs(dBot) ? dTop : dBot;
}

// 0:None, 1:Slab, 2:Mat, ,3:Wall, 4:Strip, 5:Shell
BOOL CDesignEngine::UpdateRebar(int nSubDomainType, int nUpdateType/*=0*/)
{
	BOOL bUpdate = FALSE;
	switch (nSubDomainType)
	{
	case 1: { bUpdate = nUpdateType == 0 ? UpdateRebarSlab() : UpdateRebarSlabBySbdo(); } break;
	case 3: { bUpdate = nUpdateType == 0 ? UpdateRebarWall() : UpdateRebarWallBySbdo(); } break;
	case 4: { bUpdate = UpdateRebarStrip(); } break;
	case 5: { bUpdate = nUpdateType == 0 ? UpdateRebarShell() : UpdateRebarShellBySbdo(); } break; // 옵션에 따라 UpdateRebarShellBySbdo() 호출합시다!
	default: ASSERT(FALSE); break;
	}
	return bUpdate;
}


void CDesignEngine::MakeRbmwData(T_ELEM_K ElemK, T_RBMW_D& RbmsD, CArray<T_ELEM_K, T_ELEM_K>& aElemK, CArray<T_RBMW_D, T_RBMW_D&>& aData)
{
	int nCount = aElemK.GetSize();
	if (nCount <= 0)
	{
		aElemK.Add(ElemK);
		aData.Add(RbmsD);
		return;
	}

	int i, nComp;
	double dRebarDia, dRebarDia_Data;

	int nStartIndex = 0;
	int nEndIndex = nCount;

	for (i = 0; i < nCount; i++)
	{
		if (RbmsD.IsSameData(aData[i]))
		{
			aElemK.InsertAt(i, ElemK);
			aData.InsertAt(i, RbmsD);
			return;
		}
	}

	// X방향 철근 직경 비교
	BOOL bFind_Start = FALSE;
	dRebarDia = m_pDoc->m_pMatlDB->Get_RebarDia(RbmsD.strHorRebarName);
	for (i = 0; i < nCount; i++)
	{
		dRebarDia_Data = m_pDoc->m_pMatlDB->Get_RebarDia(aData[i].strHorRebarName);
		nComp = CCompFunc::CompRealTol(dRebarDia, dRebarDia_Data, 1.e-7);
		if (nComp == 1)
			continue;
		else if (nComp == -1)
		{
			if (!bFind_Start)
			{
				aElemK.InsertAt(i, ElemK);
				aData.InsertAt(i, RbmsD);
				return;
			}
			nEndIndex = i;
			break;
		}
		else // 같은 경우    
		{
			if (!bFind_Start)
			{
				bFind_Start = TRUE;
				nStartIndex = i;
			}
		}
	}
	if (!bFind_Start)
	{
		aElemK.InsertAt(nEndIndex, ElemK);
		aData.InsertAt(nEndIndex, RbmsD);
		return;
	}

	// X방향 철근 직경이 같은 Data중에서 X 간격을 비교
	bFind_Start = FALSE;
	for (i = nStartIndex; i < nEndIndex; i++)
	{
		nComp = CCompFunc::CompRealTol(RbmsD.dHorRebarSpace, aData[i].dHorRebarSpace, 1.e-7);
		if (nComp == -1)
			continue;
		else if (nComp == 1)
		{
			if (!bFind_Start)
			{
				aElemK.InsertAt(i, ElemK);
				aData.InsertAt(i, RbmsD);
				return;
			}
			nEndIndex = i;
			break;
		}
		else // 같은 경우    
		{
			if (!bFind_Start)
			{
				bFind_Start = TRUE;
				nStartIndex = i;
			}
		}
	}
	if (!bFind_Start)
	{
		aElemK.InsertAt(nEndIndex, ElemK);
		aData.InsertAt(nEndIndex, RbmsD);
		return;
	}

	//////////////////////////////////////////////////////////////////////////

	bFind_Start = FALSE;
	dRebarDia = m_pDoc->m_pMatlDB->Get_RebarDia(RbmsD.strVerRebarName);
	for (i = nStartIndex; i < nEndIndex; i++)
	{
		dRebarDia_Data = m_pDoc->m_pMatlDB->Get_RebarDia(aData[i].strVerRebarName);
		nComp = CCompFunc::CompRealTol(dRebarDia, dRebarDia_Data, 1.e-7);
		if (nComp == 1)
			continue;
		else if (nComp == -1)
		{
			if (!bFind_Start)
			{
				aElemK.InsertAt(i, ElemK);
				aData.InsertAt(i, RbmsD);
				return;
			}
			nEndIndex = i;
			break;
		}
		else // 같은 경우    
		{
			if (!bFind_Start)
			{
				bFind_Start = TRUE;
				nStartIndex = i;
			}
		}
	}
	if (!bFind_Start)
	{
		aElemK.InsertAt(nEndIndex, ElemK);
		aData.InsertAt(nEndIndex, RbmsD);
		return;
	}

	bFind_Start = FALSE;
	for (i = nStartIndex; i < nEndIndex; i++)
	{
		nComp = CCompFunc::CompRealTol(RbmsD.dVerRebarSpace, aData[i].dVerRebarSpace, 1.e-7);
		if (nComp == -1)
			continue;
		else if (nComp == 1)
		{
			if (!bFind_Start)
			{
				aElemK.InsertAt(i, ElemK);
				aData.InsertAt(i, RbmsD);
				return;
			}
			nEndIndex = i;
			break;
		}
		else // 같은 경우    
		{
			if (!bFind_Start)
			{
				bFind_Start = TRUE;
				nStartIndex = i;
			}
		}
	}

	aElemK.InsertAt(nEndIndex, ElemK);
	aData.InsertAt(nEndIndex, RbmsD);
}

BOOL CDesignEngine::IsElemStateChanged(BOOL bIncludePlane/*=FALSE*/)
{
	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;

	CArray<T_ELEM_K, T_ELEM_K> aElemK;
	I_GENModelBase::GetCurMySelfST()->GetSelectedElemKeyList(aElemK, FALSE);
	int elem_num = aElemK.GetSize();
	if (elem_num <= 0)
	{
		elem_num = gm->m_EKeyListActive.GetSize();
		if (elem_num > 0)
			aElemK.Append(gm->m_EKeyListActive);
		else
			return FALSE;
	}

	T_ELEM_D ElemD;
	int nPlanarNum = 0;
	int nSum = 0;
	for (int i = 0; i < elem_num; i++)
	{
		m_pDoc->m_pAttrCtrl->GetElem(aElemK[i], ElemD);
		if (bIncludePlane)
		{
			if (!m_pDoc->m_pAttrCtrl->IsPlstrs(ElemD.eltyp) && !m_pDoc->m_pAttrCtrl->IsPlate(ElemD.eltyp))
				continue;
		}
		else
		{
			if (!m_pDoc->m_pAttrCtrl->IsPlate(ElemD.eltyp))
				continue;
		}
		nPlanarNum++;
		nSum += aElemK[i];
	}

	if ((m_nActiveElemCount != nPlanarNum) || (m_nSumActiveElemNum != nSum))
	{
		m_nActiveElemCount = nPlanarNum;
		m_nSumActiveElemNum = nSum;
		return TRUE;
	}
	return FALSE;
}

BOOL CDesignEngine::IsSlabWallDesignData()
{
	if (m_mapSDRData.GetCount() > 0) return TRUE;
	return FALSE;
}

// PMS:xxxx-Seungjun-20100913 요소별 slab length 계산.
double CDesignEngine::Get_SlabLeng(UINT ElemK, T_SBDO_K SbdoK)
{
	const double cRCS_Upon = 1.0E+28;
	double dLen = 0.0, dMinLen = cRCS_Upon;
	if (m_aSlabLeng.Lookup(ElemK, dLen)) return dLen;

	// PMS:xxx-Seungjun-20100830 요소별 length by sub-domain. sub-domain이 동일 평면이 아닐 경우. 
	CArray<T_DOEL_K, T_DOEL_K> aDoelK;
	std::vector<T_ELEM_K> aElemK;
	int nElem = m_pDoc->m_pAttrCtrl->GetElemListSbdoK(SbdoK, aElemK, aDoelK);
	if (nElem <= 0) return dLen;

	CArray<CArray<UINT, UINT>*, CArray<UINT, UINT>*> aEachPlaneElem;
	int nPlane = m_pDoc->m_pAttrCtrl2->GetPlaneElemListInSbdo(SbdoK, aEachPlaneElem);  // Sub-Domain안에 평면요소 리스트

	T_SBDO_D SbdoD;
	m_pDoc->m_pAttrCtrl->GetSbdo(SbdoK, SbdoD);

	T_UNIT_INDEX CurIndex;
	m_pDoc->m_pUnitCtrl->GetUnitIndexCurrent(CurIndex);
	double dPlaneTol = CDBLib::Get_SlabSamePlaneTol(CurIndex.nBase_Length);

	for (int k = 0; k < nPlane; k++)
	{
		CArray<T_ELEM_K, T_ELEM_K> aPlaneElemK;
		aPlaneElemK.RemoveAll();
		int nPlaneElemK = aEachPlaneElem[k]->GetSize();

		for (int i = 0; i < nPlaneElemK; i++)
		{
			aPlaneElemK.Add(aEachPlaneElem[k]->GetAt(i));
		}
		CArray<T_NODE_K, T_NODE_K> raNodeK;
		int nNode = m_pDoc->m_pAttrCtrl->Find3DCornerNode(aPlaneElemK, raNodeK, dPlaneTol);

		CArray<T_NODE_D, T_NODE_D&> aNodeData;
		dLen = 0.0;
		double dMax[2] = { -1.*cRCS_Upon,-1.*cRCS_Upon };
		double dMin[2] = { cRCS_Upon,cRCS_Upon };
		for (int i = 0; i < nNode; i++)
		{
			T_NODE_D NodeD;
			if (!m_pDoc->m_pAttrCtrl->GetNode(raNodeK[i], NodeD)) continue;
			aNodeData.Add(NodeD);
		}

		dMax[0] = dMin[0] = aNodeData[0].x;
		dMax[1] = dMin[1] = aNodeData[0].y;

		// Sub-Domain의 X방향 angle을 기준으로 Length를 계산하기 위해 첫번째 Node를 기준으로 회전 
		for (int i = 1; i < nNode; i++)
		{
			T_NODE_D RotateNodeD = aNodeData[i];

			CMathFunc::mathRotate(-SbdoD.dAngle[0], aNodeData[0].x, aNodeData[0].y, aNodeData[0].z, 0, 0, 1,
				RotateNodeD.x, RotateNodeD.y, RotateNodeD.z);

			if (dMax[0] < RotateNodeD.x) dMax[0] = RotateNodeD.x;
			if (dMax[1] < RotateNodeD.y) dMax[1] = RotateNodeD.y;

			if (dMin[0] > RotateNodeD.x) dMin[0] = RotateNodeD.x;
			if (dMin[1] > RotateNodeD.y) dMin[1] = RotateNodeD.y;
		}

		double dLx = fabs(dMax[0] - dMin[0]);
		double dLy = fabs(dMax[1] - dMin[1]);
		dLen = min(dLx, dLy);

		dMinLen = min(dMinLen, dLen);

		for (int i = 0; i < nPlaneElemK; i++)
		{
			m_aSlabLeng.SetAt(aPlaneElemK[i], dLen);
		}
	}

	// 메모리 해제 하는 부분
	for (int i = 0; i < 1; i++)
	{
		if (aEachPlaneElem[i] != NULL)
		{
			delete aEachPlaneElem[i];
			aEachPlaneElem[i] = NULL;
		}
	}
	aEachPlaneElem.RemoveAll();

	if (!m_aSlabLeng.Lookup(ElemK, dLen)) dLen = dMinLen;

	return dLen;
}


BOOL CDesignEngine::MakeSlabCrackData()
{
	I_GPSModel *gm = (I_GPSModel *)m_pGPSModel;
	if (m_nMode != 2 || m_nDeflection != 1) // crack result
		return FALSE;

	m_mapCrackData.RemoveAll();
	m_mapCrackElem.RemoveAll();

	int i, j, k;
	double dMaxDisp;
	T_NODE_K NodeK;
	T_DISP_D DispD;
	T_MLCB_D MlcbD;
	if (gm->m_LoadCaseKey == 0) // ALL COMBINATION
	{
		MlcbD.Initialize();
		if (!m_pDoc->m_pAttrCtrl->Get_DefaultMlcb(MlcbD)) { ASSERT(0); return FALSE; }
	}
	int node_num = gm->m_NKeyListActive.GetSize();
	for (i = 0; i < node_num; i++)
	{
		NodeK = gm->m_NKeyListActive[i];
		if (!m_pDoc->m_pPostCtrl->IsAvailNode(NodeK))continue;
		DispD.Initialize();
		if (gm->m_LoadCaseKey == 0)
		{
			dMaxDisp = -DBL_MAX;
			for (j = 0; j < MlcbD.aSlabCracK.GetSize(); j++)
			{
				if (!m_pDoc->m_pPostCtrl->GetDispCrack(MlcbD.aSlabCracK[j], NodeK, DispD)) { ASSERT(0); continue; }
				if (j == 0) dMaxDisp = DispD.dblDisp[2];
				else
				{
					if (fabs(dMaxDisp) < fabs(DispD.dblDisp[2]))
						dMaxDisp = DispD.dblDisp[2];
				}
			}
		}
		else
		{
			if (!m_pDoc->m_pPostCtrl->GetDispCrack(gm->m_LoadCaseKey, NodeK, DispD)) { ASSERT(0); continue; }
			dMaxDisp = DispD.dblDisp[2];
		}
		m_mapCrackData.SetAt(NodeK, dMaxDisp);
	}

	T_GPS_SLAB_CRACK CrackD;
	T_CRLT_D CrltD;
	T_ELEM_K ElemK;
	int elem_num = m_PlateKeyList.GetSize();
	for (i = 0; i < elem_num; i++)
	{
		ElemK = m_PlateKeyList[i];
		if (!m_pDoc->m_pPostCtrl->IsSlabWallDesignElement(ElemK, 1, TRUE)) { ASSERT(0); continue; }

		CrltD.Initialize();
		CrackD.Initialize();
		if (gm->m_LoadCaseKey == 0) // ALL COMBINATION
		{
			for (j = 0; j < MlcbD.aSlabCracK.GetSize(); j++)
			{
				if (!m_pDoc->m_pPostCtrl->GetCrlt(MlcbD.aSlabCracK[j], ElemK, CrltD)) { ASSERT(0); continue; }
				for (k = 0; k < 5; k++)
				{
					if (CrltD.nCrack[k] == 1) CrackD.nCrack[k] = CrltD.nCrack[k];
				}
			}
		}
		else
		{
			if (!m_pDoc->m_pPostCtrl->GetCrlt(gm->m_LoadCaseKey, ElemK, CrltD)) { ASSERT(0); continue; }
			for (k = 0; k < 5; k++) CrackD.nCrack[k] = CrltD.nCrack[k];
		}
		m_mapCrackElem.SetAt(ElemK, CrackD);
	}

	return TRUE;
}

void CDesignEngine::DrawCrackPoint(CDC *pDC, UINT ElemK)
{
	DECLARE_GPSMD();
	DECLARE_DBDOC();
	DECLARE_DPTDR();

	T_GPS_SLAB_CRACK CrackD; CrackD.Initialize();
	if (!m_mapCrackElem.Lookup(ElemK, CrackD)) return;
	T_ELEM_D  ElemD; ElemD.Initialize();
	if (!m_pDoc->m_pAttrCtrl->GetElem(ElemK, ElemD)) { ASSERT(0); return; }
	int nNodeN = m_pDoc->m_pAttrCtrl->GetNumNode(ElemD.eltyp, ElemD.elnod);
	if (nNodeN == 3)
	{
		if (CrackD.nCrack[0] == 0 && CrackD.nCrack[1] == 0 && CrackD.nCrack[2] == 0 && CrackD.nCrack[4] == 0) return;
		if (CrackD.nCrack[3] == 1) CrackD.nCrack[3] = 0;
	}
	else if (nNodeN == 4)
	{
		if (CrackD.nCrack[0] == 0 && CrackD.nCrack[1] == 0 && CrackD.nCrack[2] == 0 && CrackD.nCrack[3] == 0 && CrackD.nCrack[4] == 0) return;
	}
	else { ASSERT(0); return; }

	CArray<GPS_3DPT_LISTP, GPS_3DPT_LISTP>	PolyList;
	CArray<GPS_UINT_ARRYP, GPS_UINT_ARRYP>	VertexNode;

	if (!gm->m_bLoadDataSet)return;

	//---------------------------------------------------------------
	// 요소 절점 위치 저장 
	//---------------------------------------------------------------
	BOOL bBackWireFrame = pDR->m_bFrameLine;
	pDR->m_bFrameLine = TRUE;
	/*if(m_bDeformedShapeContour)
	{
	if(gm->m_pDeformEngine)gm->m_pDeformEngine->GetDeformedShapeElement(ElemK, &PolyList, NULL, &VertexNode);
	else                   gm->GetShapeElement(ElemK, PolyList, NULL, NULL, &VertexNode);
	}
	else */
	{
		gm->GetShapeElement(ElemK, PolyList, NULL, NULL, &VertexNode);
	}
	pDR->m_bFrameLine = bBackWireFrame;

	int i;
	C3DPoint  Pt3D;
	double dElemCoord[8][3];
	POSITION nPos;
	if (m_pDoc->m_pAttrCtrl->IsPlaneType(ElemD.eltyp))
	{
		nPos = PolyList[0]->GetHeadPosition();
		for (i = 0; i < PolyList[0]->GetCount(); i++)
		{
			Pt3D = PolyList[0]->GetNext(nPos);
			dElemCoord[i][0] = Pt3D.x;
			dElemCoord[i][1] = Pt3D.y;
			dElemCoord[i][2] = Pt3D.z;
		}
	}
	else
	{
		FreeMemoryPolyList(&PolyList, NULL, &VertexNode);
		return;
	}
	FreeMemoryPolyList(&PolyList, NULL, &VertexNode);

	//---------------------------------------------------------------
	// 가우스포인트 계산 
	//---------------------------------------------------------------
	int    nGaussPoint;
	double dElemGaussPos[8][3];
	double dDisplacement[8][3];

	for (i = 0; i < 8; i++)
	{
		memset(dElemGaussPos[i], 0, sizeof(dElemGaussPos[i]));
		memset(dDisplacement[i], 0, sizeof(dDisplacement[i]));
	}
	if (!CGPSPostCtrl::GetElemGaussPoint_PlateCenter(nGaussPoint, dElemGaussPos, dElemCoord, dDisplacement, nNodeN, ElemD.eltyp)) { return; }

	//---------------------------------------------------------------
	// 가우스포인트  그리기 
	//---------------------------------------------------------------
	int nSaveDC = pDC->SaveDC();

	CPen Pen, *pOldPen;
	Pen.CreatePen(PS_SOLID, gm->m_nLineWidth*1.9, RGB(0, 0, 0));
	pOldPen = (CPen*)pDC->SelectObject(&Pen);

	double dUnitSize = pDC->GetDeviceCaps(LOGPIXELSX)*0.09;
	C3DPoint CtPt;
	for (i = 0; i < nGaussPoint; i++)
	{
		if (CrackD.nCrack[i])
		{
			CtPt.x = dElemGaussPos[i][0];
			CtPt.y = dElemGaussPos[i][1];
			CtPt.z = dElemGaussPos[i][2];
			DrawCrossLine(pDC, CtPt, dUnitSize, 0);
		}
	}

	pDC->SelectObject(pOldPen);
	Pen.DeleteObject();

	pDC->RestoreDC(nSaveDC);
}

BOOL CDesignEngine::DivideRebarString(CString& strRebarSize, CString& strAdd1, CString& strAdd2)
{
	strRebarSize.TrimLeft();
	strRebarSize.TrimRight();
	if (strRebarSize == _T("")) return FALSE;

	strAdd1 = strAdd2 = _T("");

	int nFind = strRebarSize.Find(_T("+"));
	if (nFind < 0)
	{
		strAdd1 = strRebarSize;
		return TRUE;
	}
	strAdd1 = strRebarSize.Left(nFind);
	strAdd2 = strRebarSize.Mid(nFind + 1);
	return TRUE;
}

BOOL CDesignEngine::MakeStripDesignDataList(BOOL bDgn)
{
	I_GPSModel *gm = (I_GPSModel *)m_pGPSModel;

	if (!gm->m_bLoadDataSet)return FALSE;

	const BOOL Top = TRUE, Bot = FALSE;
	CArray<T_MSTR_K, T_MSTR_K> aMstrK;
	m_pDoc->m_pPostCtrl->GetDesignResult()->GetDesignedMstrKList(aMstrK);
	T_NODE_D NodeI, NodeJ;
	CString  strVal;
	//   CArray<T_FORCSTRIP_D,T_FORCSTRIP_D> aForce, aForceMax, aForceMin, aForceTemp;
	//   BOOL bAllComb = FALSE;
	// 
	//   // All combination인 경우
	//   if(gm->m_LoadCaseKey==0)
	//   {
	//     bAllComb = TRUE;
	//     m_pDoc->m_pAttrCtrl2->GetStripForceAllComb(gm->m_LoadCaseType, aMstrK, aForce, aForceMax, aForceMin);
	//   }
	//   else
	//   {
	//     m_pDoc->m_pAttrCtrl2->GetStripForce(gm->m_LoadCaseType, gm->m_LoadCaseKey, 0, aMstrK, aForce);
	//   }
	CString strI, strC, strJ, str1, str2;

	m_mapStripResData.RemoveAll();
	T_GPS_STRIP_RESULT StripResult;
	for (int i = 0; i < aMstrK.GetSize(); i++)
	{
		T_MSTR_K MstrK = aMstrK[i];
		StripResult.Initialize();

		m_pDoc->m_pAttrCtrl2->GetMstrNodeD(aMstrK[i], NodeI, NodeJ);

		// I, 1/4, C, 3/4, J
		for (int j = 0; j < 5; j++)
		{
			StripResult.ptStrip[j].Set(NodeI.x*(4 - j) / 4 + NodeJ.x*j / 4, NodeI.y*(4 - j) / 4 + NodeJ.y*j / 4, NodeI.z*(4 - j) / 4 + NodeJ.z*j / 4);    // point
		}
		StripResult.ptStripConv[0].Set(NodeI.x * 19 / 20 + NodeJ.x * 1 / 20, NodeI.y * 19 / 20 + NodeJ.y * 1 / 20, NodeI.z * 19 / 20 + NodeJ.z * 1 / 20);
		StripResult.ptStripConv[1].Set(NodeI.x * 7 / 10 + NodeJ.x * 3 / 10, NodeI.y * 7 / 10 + NodeJ.y * 3 / 10, NodeI.z * 7 / 10 + NodeJ.z * 3 / 10);
		StripResult.ptStripConv[2].Set(NodeI.x * 1 / 2 + NodeJ.x * 1 / 2, NodeI.y * 1 / 2 + NodeJ.y * 1 / 2, NodeI.z * 1 / 2 + NodeJ.z * 1 / 2);
		StripResult.ptStripConv[3].Set(NodeI.x * 3 / 10 + NodeJ.x * 7 / 10, NodeI.y * 3 / 10 + NodeJ.y * 7 / 10, NodeI.z * 3 / 10 + NodeJ.z * 7 / 10);
		StripResult.ptStripConv[4].Set(NodeI.x * 1 / 20 + NodeJ.x * 19 / 20, NodeI.y * 1 / 20 + NodeJ.y * 19 / 20, NodeI.z * 1 / 20 + NodeJ.z * 19 / 20);
		StripResult.ptStripConv[5].Set(NodeI.x * 8 / 10 + NodeJ.x * 2 / 10, NodeI.y * 8 / 10 + NodeJ.y * 2 / 10, NodeI.z * 8 / 10 + NodeJ.z * 2 / 10);
		StripResult.ptStripConv[6].Set(NodeI.x * 2 / 10 + NodeJ.x * 8 / 10, NodeI.y * 2 / 10 + NodeJ.y * 8 / 10, NodeI.z * 2 / 10 + NodeJ.z * 8 / 10);

		// 각 모드별 결과를 넣어주자.
		// 0:Rebar
		StripResult.aText0[0] = m_pDoc->m_pPostCtrl->GetDesignResult()->GetStripResultBar(MstrK, STRIP_POS_I, Top);
		StripResult.aText0[1] = m_pDoc->m_pPostCtrl->GetDesignResult()->GetStripResultBar(MstrK, STRIP_POS_M, Top);
		StripResult.aText0[2] = m_pDoc->m_pPostCtrl->GetDesignResult()->GetStripResultBar(MstrK, STRIP_POS_J, Top);
		StripResult.aText0[3] = m_pDoc->m_pPostCtrl->GetDesignResult()->GetStripResultBar(MstrK, STRIP_POS_I, Bot);
		StripResult.aText0[4] = m_pDoc->m_pPostCtrl->GetDesignResult()->GetStripResultBar(MstrK, STRIP_POS_M, Bot);
		StripResult.aText0[5] = m_pDoc->m_pPostCtrl->GetDesignResult()->GetStripResultBar(MstrK, STRIP_POS_J, Bot);

		// 스트립 구간에서 불리한 상부근 결과
		str1 = m_pDoc->m_pPostCtrl->GetDesignResult()->GetSlabResultOfColumnStrip(MstrK, Top);
		str2 = m_pDoc->m_pPostCtrl->GetDesignResult()->GetSlabResultOfColumnStrip_AddRebar(MstrK, Top);
		if (!str1.IsEmpty())
		{
			StripResult.strSlabRebar[0] = str1 + _T("(T)");
			if (!str2.IsEmpty())
				StripResult.strSlabRebar[1] = str2 + _T("(T)");
		}
		else
		{
			if (!str2.IsEmpty())
				StripResult.strSlabRebar[0] = str2 + _T("(T)");
		}

		// 1:As req
		if (bDgn)
		{
			StripResult.aVal1[0] = m_pDoc->m_pPostCtrl->GetDesignResult()->GetStripResult(MstrK, STRIP_POS_I, STRIP_RES_ASREQ, Top);
			StripResult.aVal1[1] = m_pDoc->m_pPostCtrl->GetDesignResult()->GetStripResult(MstrK, STRIP_POS_I, STRIP_RES_ASREQ, Bot);
			StripResult.aVal1[2] = m_pDoc->m_pPostCtrl->GetDesignResult()->GetStripResult(MstrK, STRIP_POS_M, STRIP_RES_ASREQ, Top);
			StripResult.aVal1[3] = m_pDoc->m_pPostCtrl->GetDesignResult()->GetStripResult(MstrK, STRIP_POS_M, STRIP_RES_ASREQ, Bot);
			StripResult.aVal1[4] = m_pDoc->m_pPostCtrl->GetDesignResult()->GetStripResult(MstrK, STRIP_POS_J, STRIP_RES_ASREQ, Top);
			StripResult.aVal1[5] = m_pDoc->m_pPostCtrl->GetDesignResult()->GetStripResult(MstrK, STRIP_POS_J, STRIP_RES_ASREQ, Bot);
		}
		// Checking일 경우에는 As use
		else
		{
			StripResult.aVal1[0] = m_pDoc->m_pPostCtrl->GetDesignResult()->GetStripResult(MstrK, STRIP_POS_I, STRIP_RES_ASUSE, Top);
			StripResult.aVal1[1] = m_pDoc->m_pPostCtrl->GetDesignResult()->GetStripResult(MstrK, STRIP_POS_I, STRIP_RES_ASUSE, Bot);
			StripResult.aVal1[2] = m_pDoc->m_pPostCtrl->GetDesignResult()->GetStripResult(MstrK, STRIP_POS_M, STRIP_RES_ASUSE, Top);
			StripResult.aVal1[3] = m_pDoc->m_pPostCtrl->GetDesignResult()->GetStripResult(MstrK, STRIP_POS_M, STRIP_RES_ASUSE, Bot);
			StripResult.aVal1[4] = m_pDoc->m_pPostCtrl->GetDesignResult()->GetStripResult(MstrK, STRIP_POS_J, STRIP_RES_ASUSE, Top);
			StripResult.aVal1[5] = m_pDoc->m_pPostCtrl->GetDesignResult()->GetStripResult(MstrK, STRIP_POS_J, STRIP_RES_ASUSE, Bot);
		}

		// 2:Resistance Ratio
		StripResult.aVal2[0] = m_pDoc->m_pPostCtrl->GetDesignResult()->GetStripResult(MstrK, STRIP_POS_I, STRIP_RES_RATIO, Top);
		StripResult.aVal2[1] = m_pDoc->m_pPostCtrl->GetDesignResult()->GetStripResult(MstrK, STRIP_POS_I, STRIP_RES_RATIO, Bot);
		StripResult.aVal2[2] = m_pDoc->m_pPostCtrl->GetDesignResult()->GetStripResult(MstrK, STRIP_POS_M, STRIP_RES_RATIO, Top);
		StripResult.aVal2[3] = m_pDoc->m_pPostCtrl->GetDesignResult()->GetStripResult(MstrK, STRIP_POS_M, STRIP_RES_RATIO, Bot);
		StripResult.aVal2[4] = m_pDoc->m_pPostCtrl->GetDesignResult()->GetStripResult(MstrK, STRIP_POS_J, STRIP_RES_RATIO, Top);
		StripResult.aVal2[5] = m_pDoc->m_pPostCtrl->GetDesignResult()->GetStripResult(MstrK, STRIP_POS_J, STRIP_RES_RATIO, Bot);

		// 3:Bending Moment Diagram은 CForceEngine에서 그려준다.

		// Active 갱신시마다 InitEngine이 호출되기 때문에,
		// Apply 눌렀을 때만 MakeUnbalancedMomentData() 함수가 호출되도록
		// 아래 위치로 이동함
		// wg_gps\GPSBarStripChk.cpp > BOOL CGPSBarStripChk::SetDgnData(int nPrint)
		//     // 4:Unbalanced Moment
		//     // 스트립 양단의 부재력 차를 출력하던 코드. 불균형모멘트는 기둥의 부재력 차를 출력하는 것으로 변경(141125)
		//     //MakeUnbalancedMomentData(MstrK, i, StripResult, aForce);
		//     if (m_nRebarRatio == 4)   // Unbalanced Moment 데이터 계산 
		//     {
		//       MakeUnbalancedMomentData();
		//     }

		// 끝
		m_mapStripResData.SetAt(MstrK, StripResult);
	}

	// 서브도메인 결과데이터 생성
	MakeSubdomainRebarDataList();

	gm->m_pMyView->EndWaitCursor();
	m_bDsgnDataSet = TRUE;

	return TRUE;
}

void CDesignEngine::MakeSubdomainRebarDataList()
{
	I_GPSModel *gm = (I_GPSModel *)m_pGPSModel;

	// 화살표의 길이
	C3DPoint min_p, max_p;
	double	 max_l;
	gm->GetRangeModel(&min_p, &max_p);
	max_l = max(max(max_p.x - min_p.x, max_p.y - min_p.y), max_p.z - min_p.z);
	double dLeng_Arrow = max_l / 100;

	T_GPS_SBDO_RESULT SbdoResult;
	std::vector<T_SBDO_K> aSbdoK;
	T_SBDO_D SbdoD;
	double dCenter[3], dCenterMoved[3], dPtTemp[3], dPt1[3], dPt2[3];
	m_pDoc->m_pAttrCtrl->GetSbdoKeyList(aSbdoK);
	const BOOL bTop = TRUE, bBot = FALSE;
	double dB, dH;
	CString str1, str2;
	for (int i = 0; i < aSbdoK.size(); i++)
	{
		m_pDoc->m_pAttrCtrl->GetSbdo(aSbdoK[i], SbdoD);
		SbdoResult.Initialize();

		// 중심점에서 글로벌X,Y축으로 -B/8만큼 이동하여
		// 글로벌X축으로 dLeng_Arrow만큼 이동한 뒤, dAngle[0], dAngle[0]+dAngle[1]만큼 회전변환함
		m_pDoc->m_pAttrCtrl2->GetSubdomainCenterPoint(aSbdoK[i], dCenter, dB, dH);
		double dMinOffset = min(dB, dH);
		dCenterMoved[0] = dCenter[0] - dMinOffset / 8;
		dCenterMoved[1] = dCenter[1] - dMinOffset / 8;
		dCenterMoved[2] = dCenter[2];

		dPtTemp[0] = dCenterMoved[0] + dLeng_Arrow;
		dPtTemp[1] = dCenterMoved[1];
		dPtTemp[2] = dCenterMoved[2];

		CMathFunc::mathRotate(SbdoD.dAngle[0], dCenterMoved[0], dCenterMoved[1], dCenterMoved[2], 0, 0, 1, dPtTemp[0], dPtTemp[1], dPtTemp[2]);
		dPt1[0] = dPtTemp[0];
		dPt1[1] = dPtTemp[1];
		dPt1[2] = dPtTemp[2];

		CMathFunc::mathRotate(SbdoD.dAngle[1], dCenterMoved[0], dCenterMoved[1], dCenterMoved[2], 0, 0, 1, dPtTemp[0], dPtTemp[1], dPtTemp[2]);
		dPt2[0] = dPtTemp[0];
		dPt2[1] = dPtTemp[1];
		dPt2[2] = dPtTemp[2];

		SbdoResult.ptArrowDir1[0].Set(dCenterMoved[0], dCenterMoved[1], dCenterMoved[2]);
		SbdoResult.ptArrowDir1[1].Set(dPt1[0], dPt1[1], dPt1[2]);
		SbdoResult.ptArrowDir2[0].Set(dCenterMoved[0], dCenterMoved[1], dCenterMoved[2]);
		SbdoResult.ptArrowDir2[1].Set(dPt2[0], dPt2[1], dPt2[2]);

		// 하부근 결과만 출력
		str1 = m_pDoc->m_pPostCtrl->GetDesignResult()->GetSlabResultOfMiddleStrip(aSbdoK[i], bBot, 0);
		str2 = m_pDoc->m_pPostCtrl->GetDesignResult()->GetSlabResultOfMiddleStrip_AddRebar(aSbdoK[i], bBot, 0);
		if (str1.IsEmpty())
		{
			if (!str2.IsEmpty()) SbdoResult.strRebarDir1[0] = _T("1 ") + str2 + _T("(B)");
		}
		else
		{
			SbdoResult.strRebarDir1[0] = _T("1 ") + str1 + _T("(B)");
			if (!str2.IsEmpty())
				SbdoResult.strRebarDir1[1] = _T("1 ") + str2 + _T("(B)");
		}

		str1 = m_pDoc->m_pPostCtrl->GetDesignResult()->GetSlabResultOfMiddleStrip(aSbdoK[i], bBot, 1);
		str2 = m_pDoc->m_pPostCtrl->GetDesignResult()->GetSlabResultOfMiddleStrip_AddRebar(aSbdoK[i], bBot, 1);
		if (str1.IsEmpty())
		{
			if (!str2.IsEmpty()) SbdoResult.strRebarDir2[0] = _T("2 ") + str2 + _T("(B)");
		}
		else
		{
			SbdoResult.strRebarDir2[0] = _T("2 ") + str1 + _T("(B)");
			if (!str2.IsEmpty())
				SbdoResult.strRebarDir2[1] = _T("2 ") + str2 + _T("(B)");
		}

		m_mapSbdoResData.SetAt(aSbdoK[i], SbdoResult);
	}
}

void CDesignEngine::DrawStripDesignContour(CDC *pDC)
{
	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;

	// Rebar : 화살표를 그려주자
	if (m_nRebarRatio == 0 && m_bStripSlabDgnResult)
	{
		DrawStripRebarResult(pDC);
	}
}

void CDesignEngine::DrawPerformContour(CDC *pDC, int nGPSMode)
{
	DECLARE_GPSMD();
	DECLARE_DBDOC();

	int			  i, ElemNum;
	T_ELEM_D	ElemD;
	CPen		  ElemPen, *pOldPen;
	CArray<int, int>  TypeList;
	CArray<GRE_Atom, GRE_Atom&> AtomList;

	BOOL bEscapePressed = FALSE;
	T_MIRE_K mkey;

	if (!gm->m_bContour) { gm->GPSDrawOriginal(pDC); return; }

	if (m_bDeformedShapeContour)
	{
		if (gm->m_pDeformEngine == NULL)return;
		TypeList.Add(gm->m_MinOTID + OBJECT_TYPE_DEFORMED);
	}
	else
		TypeList.Add(gm->m_MinOTID + OBJECT_TYPE_ORIGINAL);

	if (gm->m_DOPT.DR.m_bFrameLine) // wire frame
		ElemPen.CreatePen(PS_SOLID, gm->m_DOPT.DR.nElemWire*1.7, m_pContourEngine->m_ElemColor);
	else
		ElemPen.CreatePen(PS_SOLID, gm->m_DOPT.DR.nElemHddn, m_pContourEngine->m_ElemColor);

	pOldPen = (CPen *)pDC->SelectObject(&ElemPen);

	gm->m_pGPSCtrl->GetZSortedList(TypeList, gm->m_EKeyListVisible_Mirror, AtomList);
	ElemNum = AtomList.GetSize();

	CMapEx<int, int, int, int> mElemType;
	mElemType.SetAt(TRUSS_EL, TRUSS_EL);
	mElemType.SetAt(TRTENS_EL, TRTENS_EL);
	mElemType.SetAt(TRCOMP_EL, TRCOMP_EL);

	switch (nGPSMode)
	{
	case GPS_COMMAND_SEIS_1ST_MASONRY_PERFORM:
	case GPS_COMMAND_SEIS_2ND_MASONRY_PERFORM:
		break;
	case GPS_COMMAND_SEIS_1ST_STL_PERFORM:
	case GPS_COMMAND_SEIS_2ND_STL_PERFORM:
	case GPS_COMMAND_SEIS_LUMPED_HINGE_PFRM_PO:
	case GPS_COMMAND_SEIS_LUMPED_HINGE_PFRM_TH:
	{
		mElemType.SetAt(BEAM_EL, BEAM_EL);
	}
	break;
	case GPS_COMMAND_SEIS_1ST_RC_PERFORM:
	case GPS_COMMAND_SEIS_2ND_RC_PERFORM:
	case GPS_COMMAND_SEIS_FIBER_HINGE_PFRM_PO:
	case GPS_COMMAND_SEIS_FIBER_HINGE_PFRM_TH:
	case GPS_COMMAND_SEIS_AXIAL_STRAIN_PFRM_PO:
	case GPS_COMMAND_SEIS_AXIAL_STRAIN_PFRM_TH:
	{
		mElemType.SetAt(BEAM_EL, BEAM_EL);
		mElemType.SetAt(WALL_EL, WALL_EL);
	}
	break;
	default:
		ASSERT(0); // Case를 추가할 것
		mElemType.SetAt(BEAM_EL, BEAM_EL);
		break;
	}

	//-----------------------------------------------------------------------------------
	// 요소에 대한 결과출력
	//-----------------------------------------------------------------------------------
	BOOL bExit = FALSE;
	for (i = 0; i < ElemNum; i++)
	{
		if (gm->m_pGPSCtrl->WatchEscKeyPress())
		{
			bExit = TRUE;
			break;
		}

		if (gm->m_pGPSCtrl->IsZoomAllState() ||
			gm->m_pGPSCtrl->IsObjectInClientWindow(AtomList[i].m_OType, AtomList[i].m_OKey))
		{
			mkey.keymap = AtomList[i].m_OKey;
			if (!m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, ElemD)) continue;
			if (!mElemType.Exist(ElemD.eltyp))
			{
				if (m_bDeformedShapeContour)
					gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, AtomList[i].m_OKey);
				else
					gm->GPSDrawInactiveElement(pDC, AtomList[i].m_OKey);
				continue;
			}

			if (gm->m_pGPSCtrl->IsActiveElem(AtomList[i].m_OKey) && !bEscapePressed)
			{
				T_PRFM_RESULT Prfm;
				if (!(m_mSeisPerform.Lookup(mkey.key.elem_k, Prfm) && (Prfm.enLevel >= EN_LEVEL_IO && Prfm.enLevel <= EN_LEVEL_CL)))
				{
					T_ELEM_K ElemK_First = m_pDoc->m_pAttrCtrl->GetFirstElemKInMemb(mkey.key.elem_k);
					if (gm->m_GPSMode == nGPSMode && m_mSeisPerform.Lookup(ElemK_First, Prfm) && (Prfm.enLevel >= EN_LEVEL_IO && Prfm.enLevel <= EN_LEVEL_CL))
					{
						if (m_nDisplayMode != 1)
						{
							if (m_bDeformedShapeContour) gm->m_pDeformEngine->DrawDeformedElement(pDC, AtomList[i].m_OKey);
							else					              gm->GPSDrawElement(pDC, AtomList[i].m_OKey);
							continue;
						}
					}
					else
					{
						if (m_bDeformedShapeContour) gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, AtomList[i].m_OKey);
						else                        gm->GPSDrawInactiveElement(pDC, AtomList[i].m_OKey);
						continue;
					}
				}

				if (m_nDisplayMode == 1)
				{
					double  dVal[3];
					dVal[0] = dVal[1] = dVal[2] = (double)Prfm.enLevel;
					if (pDoc->m_pAttrCtrl->IsWall(ElemD.eltyp) && gm->m_GPSMode == nGPSMode)
					{
						CArray<T_ELEM_K, T_ELEM_K> ElemKeyList;
						m_pDoc->m_pAttrCtrl->GetKeyListBy_WallID_ByStor(ElemKeyList, AtomList[i].m_OKey);
						for (int e = 0; e < ElemKeyList.GetSize(); e++)
						{
							DoElementContourPrfm(pDC, ElemKeyList[e], dVal);
						}
					}
					else
						DoElementContourPrfm(pDC, AtomList[i].m_OKey, dVal);
				}
				else
				{
					if (m_bDeformedShapeContour) gm->m_pDeformEngine->DrawDeformedElement(pDC, AtomList[i].m_OKey);
					else					              gm->GPSDrawElement(pDC, AtomList[i].m_OKey);
				}

				if (m_nDisplayMode == 0)
				{
					if (m_pDoc->m_pAttrCtrl->IsWall(ElemD.eltyp))
					{
						DrawRCPerform_Wall(pDC, AtomList[i].m_OKey);
					}
					else
					{
						DrawSeisPerform_Frame(pDC, AtomList[i].m_OKey);
					}
				}
			}
			else
			{
				if (m_bDeformedShapeContour)
					gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, AtomList[i].m_OKey);
				else
					gm->GPSDrawInactiveElement(pDC, AtomList[i].m_OKey);
			}
		}
	}

	pDC->SelectObject(pOldPen);
	ElemPen.DeleteObject();

	if (bExit)return;

	// 변형된 그림에 Undeformed Shape을 같이 그릴 경우.
	// Contour를 그릴 경우는 Hidden이 default
	// 따라서 Undeformed Shape은 무조건 나중에 그린다...
	if (m_bDeformedShapeContour && gm->m_DOPT.DR.m_bDrawInactive && !bEscapePressed)
	{
		int	rf_bak = gm->m_DOPT.DR.m_RenderFlag;
		gm->m_DOPT.DR.m_RenderFlag = 2;
		gm->GPSDrawOriginal(pDC, TRUE);
		gm->m_DOPT.DR.m_RenderFlag = rf_bak;
	}
}

void CDesignEngine::DrawStripRebarResult(CDC *pDC)
{
	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;

	gm->m_pGPSCtrl->XGL_Begin_CuttingPLDiagram();

	CPen pen, *old_pen;
	pen.CreatePen(PS_SOLID, gm->m_nLineWidth*2.0, gm->m_CuttinLineColor);
	old_pen = (CPen *)pDC->SelectObject(&pen);

	CArray<T_SBDO_K, T_SBDO_K> aSbdoK;
	m_pDoc->m_pViewCtrl->GetAllActiveSbdo(aSbdoK);
	T_GPS_SBDO_RESULT SbdoResult;
	for (int i = 0; i < aSbdoK.GetSize(); i++)
	{
		if (!GetSbdoDesignResult(aSbdoK[i], SbdoResult)) { ASSERT(0); continue; }

		DrawLine3DByVMode(pDC, SbdoResult.ptArrowDir1[0], SbdoResult.ptArrowDir1[1], gm);
		DrawLine3DByVMode(pDC, SbdoResult.ptArrowDir2[0], SbdoResult.ptArrowDir2[1], gm);
	}

	pDC->SelectObject(old_pen);
	pen.DeleteObject();
	gm->m_pGPSCtrl->XGL_End_CuttingPLDiagram();
}

void CDesignEngine::DrawStripArrow(CDC *pDC, C3DPoint ps, C3DPoint pe)
{
	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;

	gm->m_pGPSCtrl->XGL_Begin_CuttingPLDiagram();

	CPen pen, *old_pen;
	pen.CreatePen(PS_SOLID, gm->m_nLineWidth*2.0, gm->m_CuttinLineColor);
	old_pen = (CPen *)pDC->SelectObject(&pen);

	C3DPoint	min_p, max_p;
	double		max_l;
	double    leng_ArrowHead; // 화살표 머리부분 길이
	gm->GetRangeModel(&min_p, &max_p);
	max_l = max(max(max_p.x - min_p.x, max_p.y - min_p.y), max_p.z - min_p.z);
	leng_ArrowHead = max_l / 70;

	// 벡터를 구하고 Normalize하자
	double Vector_IJ[3];
	double VectorN_IJ[3];
	Vector_IJ[0] = pe.x - ps.x;
	Vector_IJ[1] = pe.y - ps.y;
	Vector_IJ[2] = pe.z - ps.z;
	if (Vector_IJ[2] > 1.e-8) ASSERT(0);
	CMathFunc::mathNormalize(Vector_IJ, VectorN_IJ);

	// 왼쪽방향, 오른쪽방향 벡터
	double Vector_L[3], Vector_R[3];
	Vector_L[0] = -VectorN_IJ[1];
	Vector_L[1] = VectorN_IJ[0];
	Vector_L[2] = 0.;
	Vector_R[0] = VectorN_IJ[1];
	Vector_R[1] = -VectorN_IJ[0];
	Vector_R[2] = 0.;

	// 후방 45도 벡터
	double Vector_L45[3], Vector_R45[3];
	Vector_L45[0] = Vector_L[0] - VectorN_IJ[0];
	Vector_L45[1] = Vector_L[1] - VectorN_IJ[1];
	Vector_L45[2] = Vector_L[2] - VectorN_IJ[2];
	Vector_R45[0] = Vector_R[0] - VectorN_IJ[0];
	Vector_R45[1] = Vector_R[1] - VectorN_IJ[1];
	Vector_R45[2] = Vector_R[2] - VectorN_IJ[2];

	double VectorN_L45[3], VectorN_R45[3];
	CMathFunc::mathNormalize(Vector_L45, VectorN_L45);
	CMathFunc::mathNormalize(Vector_R45, VectorN_R45);

	C3DPoint pl(pe.x + VectorN_L45[0] * leng_ArrowHead, pe.y + VectorN_L45[1] * leng_ArrowHead, pe.z + VectorN_L45[2] * leng_ArrowHead);
	C3DPoint pr(pe.x + VectorN_R45[0] * leng_ArrowHead, pe.y + VectorN_R45[1] * leng_ArrowHead, pe.z + VectorN_R45[2] * leng_ArrowHead);

	DrawLine3DByVMode(pDC, ps, pe, gm);
	DrawLine3DByVMode(pDC, pe, pl, gm);
	DrawLine3DByVMode(pDC, pe, pr, gm);

	pDC->SelectObject(old_pen);
	pen.DeleteObject();
	gm->m_pGPSCtrl->XGL_End_CuttingPLDiagram();
}

void CDesignEngine::DrawLine3DByVMode(CDC* pDC, C3DPoint& P1, C3DPoint& P2, I_GPSModel* gm)
{
	if (gm->m_bVirtualMode)
	{
		gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, P1, P2);
	}
	else
	{
		gm->m_pGPSCtrl->DrawLine3D(pDC, P1, P2);

		// Cutting Line Diagram을 별도로 Rendering 하기 위한 처리 
		gm->m_pGPSCtrl->XGL_AddLine3D_CuttingPLDiagram(P1, P2, gm->m_nLineWidth*1.0, gm->m_CutPlaneColor);
	}
}

#if defined(__OLD_OUTPUT_VALUE)
void CDesignEngine::OutputStripDesignNumbers(CDC* pDC)
{
	I_GPSModel* gm = (I_GPSModel*)m_pGPSModel;

	CPoint		text_p;
	TCHAR		  fmt_str[10]/*,text_str[512]*/;
	CFont		  ft, * old_ft;
	BOOL		  fl_bak;
	double    dOffsetX, dOffsetY;
	CString   strTop, strBot;
	TCHAR      text_strI[512], text_strC[512], text_strJ[512];;

	if (!m_bDsgnDataSet) return;

	if (gm->m_DOPT.TX.m_bNumberOpaque) pDC->SetBkMode(OPAQUE);
	else                               pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
	pDC->SetBkColor(gm->m_DOPT.TX.m_NumberBackCol);
	pDC->SetTextAlign(TA_CENTER | TA_BOTTOM);

	if (gm->m_DOPT.TX.m_bNumberExponent) _stprintf(fmt_str, _T("%s%de"), _T("%."), gm->m_NumberDecimalPoint);
	else                                 _stprintf(fmt_str, _T("%s%df"), _T("%."), gm->m_NumberDecimalPoint);

	fl_bak = gm->m_DOPT.DR.m_bFrameLine;
	gm->m_DOPT.DR.m_bFrameLine = TRUE;

	CArray<T_MSTR_K, T_MSTR_K> aMstrK;
	GetMstrKeyListForView(aMstrK);
	T_GPS_STRIP_RESULT StripResult;
	T_MSTR_K MstrK;
	int nSlope5Div[5];
	BOOL nInverse5Div[5];
	BOOL bCanDraw[5];
	CPoint DrawPt[5];

	// 글자 간격만큼 오프셋
	TEXTMETRIC tm;
	::GetTextMetrics(pDC->GetSafeHdc(), &tm);
	int nOffset = tm.tmHeight;

	for (int i = 0; i < aMstrK.GetSize(); i++)
	{
		MstrK = aMstrK[i];
		if (!GetStripDesignResult(MstrK, StripResult)) { ASSERT(0); continue; }

		CUtilFuncs::MakeBeamSlopeAt5Div(gm, StripResult.ptStrip[0], StripResult.ptStrip[4], nSlope5Div, nInverse5Div, bCanDraw, DrawPt);
		SET_BFOR_FONT_TYPE(nSlope5Div[0])
			BOOL bInverse = nInverse5Div[0];

		dOffsetX = sin(nSlope5Div[0] / 10.0 * PI / 180.0) * nOffset;
		dOffsetY = cos(nSlope5Div[0] / 10.0 * PI / 180.0) * nOffset;

		// 0:Rebar
		if (m_nRebarRatio == 0)
		{
			text_p = GetWorldToP2D(StripResult.ptStrip[2]);

			strTop = _T(""), strBot = _T("");
			if (!StripResult.aText0[0].IsEmpty() && !StripResult.aText0[1].IsEmpty() && !StripResult.aText0[2].IsEmpty())
			{
				if (!bInverse) strTop.Format(_T("%s : %s : %s"), StripResult.aText0[0], StripResult.aText0[1], StripResult.aText0[2]);
				else          strTop.Format(_T("%s : %s : %s"), StripResult.aText0[2], StripResult.aText0[1], StripResult.aText0[0]);
			}
			if (!StripResult.aText0[3].IsEmpty() && !StripResult.aText0[4].IsEmpty() && !StripResult.aText0[5].IsEmpty())
			{
				if (!bInverse) strBot.Format(_T("%s : %s : %s"), StripResult.aText0[3], StripResult.aText0[4], StripResult.aText0[5]);
				else          strBot.Format(_T("%s : %s : %s"), StripResult.aText0[5], StripResult.aText0[4], StripResult.aText0[3]);
			}
			pDC->TextOut(text_p.x, text_p.y, strTop);
			pDC->TextOut(text_p.x + dOffsetX, text_p.y + dOffsetY, strBot);

			if (m_bStripSlabDgnResult)
			{
				pDC->TextOut(text_p.x + dOffsetX * 2, text_p.y + dOffsetY * 2, StripResult.strSlabRebar[0]);
				pDC->TextOut(text_p.x + dOffsetX * 3, text_p.y + dOffsetY * 3, StripResult.strSlabRebar[1]);
			}
		}
		// 1:AS
		if (m_nRebarRatio == 1)
		{
			text_p = GetWorldToP2D(StripResult.ptStrip[2]);
			_stprintf(text_strI, fmt_str, StripResult.aVal1[0]);
			_stprintf(text_strC, fmt_str, StripResult.aVal1[2]);
			_stprintf(text_strJ, fmt_str, StripResult.aVal1[4]);
			if (!bInverse) strTop.Format(_T("%s : %s : %s"), text_strI, text_strC, text_strJ);
			else          strTop.Format(_T("%s : %s : %s"), text_strJ, text_strC, text_strI);
			pDC->TextOut(text_p.x, text_p.y, strTop);
			_stprintf(text_strI, fmt_str, StripResult.aVal1[1]);
			_stprintf(text_strC, fmt_str, StripResult.aVal1[3]);
			_stprintf(text_strJ, fmt_str, StripResult.aVal1[5]);
			if (!bInverse) strBot.Format(_T("%s : %s : %s"), text_strI, text_strC, text_strJ);
			else          strBot.Format(_T("%s : %s : %s"), text_strJ, text_strC, text_strI);
			pDC->TextOut(text_p.x + dOffsetX, text_p.y + dOffsetY, strBot);
		}
		// 2:Resistance Ratio
		if (m_nRebarRatio == 2)
		{
			text_p = GetWorldToP2D(StripResult.ptStrip[2]);
			_stprintf(text_strI, fmt_str, StripResult.aVal2[0]);
			_stprintf(text_strC, fmt_str, StripResult.aVal2[2]);
			_stprintf(text_strJ, fmt_str, StripResult.aVal2[4]);
			if (!bInverse) strTop.Format(_T("%s : %s : %s"), text_strI, text_strC, text_strJ);
			else          strTop.Format(_T("%s : %s : %s"), text_strJ, text_strC, text_strI);
			pDC->TextOut(text_p.x, text_p.y, strTop);
			_stprintf(text_strI, fmt_str, StripResult.aVal2[1]);
			_stprintf(text_strC, fmt_str, StripResult.aVal2[3]);
			_stprintf(text_strJ, fmt_str, StripResult.aVal2[5]);
			if (!bInverse) strBot.Format(_T("%s : %s : %s"), text_strI, text_strC, text_strJ);
			else          strBot.Format(_T("%s : %s : %s"), text_strJ, text_strC, text_strI);
			pDC->TextOut(text_p.x + dOffsetX, text_p.y + dOffsetY, strBot);
		}

		//3.
		//     if(m_nRebarRatio==3)
		//     {
		//       DrawStripBendingMementDiagram 함수 안에 이 케이스에 대한 그리기 코드가 있다.
		//       계산된 데이터의 사용이 필요해 해당 위치에 있으므로, 숫자 출력 처리 수정 할때 주의!
		//     }

		// 4:Unbalanced Moment
		if (m_nRebarRatio == 4)
		{
			// 스트립 양단의 부재력 차를 출력하던 코드. 불균형모멘트는 기둥의 부재력 차를 출력하는 것으로 변경(141125)
			//       text_p = GetWorldToP2D(StripResult.ptStripConv[5]);
			//       _stprintf(text_str,fmt_str,StripResult.aVal4[0]); 
			//       pDC->TextOut(text_p.x, text_p.y, text_str);
			// 
			//       text_p = GetWorldToP2D(StripResult.ptStripConv[6]);
			//       _stprintf(text_str,fmt_str,StripResult.aVal4[1]);
			//       pDC->TextOut(text_p.x, text_p.y, text_str);
		}

		DEL_BFOR_FONT_TYPE()
	}

	// 추가 결과
	// 서브도메인 결과 출력
	if (m_nRebarRatio == 0 && m_bStripSlabDgnResult == TRUE)
	{
		// ------(Axis)------글씨
		// 글씨를 Axis 끝나는데부터 출력해야 하는데, 정렬을 왼쪽/오른쪽으로 하면 뷰 각도에 따라 뒤집히게 됩니다.
		// 정렬을 가운데로 하고, 글자위치를 조작해줘야 항상 축의 끝 부분에 글씨가 나옵니다.
		CArray<T_SBDO_K, T_SBDO_K> aSbdoK;
		m_pDoc->m_pViewCtrl->GetAllActiveSbdo(aSbdoK);
		T_GPS_SBDO_RESULT SbdoResult;
		CPoint text_p_Center;
		double vec[2];
		int nSlope;
		for (int j = 0; j < aSbdoK.GetSize(); j++)
		{
			GetSbdoDesignResult(aSbdoK[j], SbdoResult);

			text_p_Center = GetWorldToP2D(SbdoResult.ptArrowDir1[0]); // 축의 중심
			text_p = GetWorldToP2D(SbdoResult.ptArrowDir1[1]);
			CUtilFuncs::GetSlope2Point(nSlope, text_p_Center.x, text_p_Center.y, text_p.x, text_p.y);
			SET_BFOR_FONT_TYPE(nSlope)

				vec[0] = text_p.x - text_p_Center.x;
			vec[1] = text_p.y - text_p_Center.y;
			CMathFunc::mathNormalize2D(vec, vec);
			text_p.x += int((vec[0] * 2.6) * SbdoResult.strRebarDir1[0].GetLength()) + 1;
			text_p.y += int((vec[1] * 2.6) * SbdoResult.strRebarDir1[0].GetLength()) + 1;
			pDC->SetTextAlign(TA_CENTER | TA_BASELINE);
			pDC->TextOut(text_p.x, text_p.y, SbdoResult.strRebarDir1[0]);
			pDC->SetTextAlign(TA_CENTER | TA_TOP);
			pDC->TextOut(text_p.x, text_p.y, SbdoResult.strRebarDir1[1]);
			DEL_BFOR_FONT_TYPE()

				text_p = GetWorldToP2D(SbdoResult.ptArrowDir2[1]);
			CUtilFuncs::GetSlope2Point(nSlope, text_p_Center.x, text_p_Center.y, text_p.x, text_p.y);
			SET_BFOR_FONT_TYPE(nSlope)

				vec[0] = text_p.x - text_p_Center.x;
			vec[1] = text_p.y - text_p_Center.y;
			CMathFunc::mathNormalize2D(vec, vec);
			text_p.x += int((vec[0] * 2.6) * SbdoResult.strRebarDir2[0].GetLength()) + 1;
			text_p.y += int((vec[1] * 2.6) * SbdoResult.strRebarDir2[0].GetLength()) + 1;
			pDC->SetTextAlign(TA_CENTER | TA_BASELINE);
			pDC->TextOut(text_p.x, text_p.y, SbdoResult.strRebarDir2[0]);
			pDC->SetTextAlign(TA_CENTER | TA_TOP);
			pDC->TextOut(text_p.x, text_p.y, SbdoResult.strRebarDir2[1]);
			DEL_BFOR_FONT_TYPE()
		}
	}

	// 기둥에 불균형 모멘트 출력
	if (m_nRebarRatio == 4)
	{
		SET_BFOR_FONT_TYPE(0)
			TCHAR fmt_str_bracket[12];

		if (gm->m_DOPT.TX.m_bNumberExponent) _stprintf(fmt_str_bracket, _T("%s%de"), _T("%."), gm->m_NumberDecimalPoint);
		else _stprintf(fmt_str_bracket, _T("%s%df"), _T("%."), gm->m_NumberDecimalPoint);

		T_NODE_K NodeK;
		T_NODE_D NodeD;
		CString strFmt1, strFmt2;
		CString strVal1, strVal2;
		C3DPoint point;
		BOOL bDgnResult;
		double dMy, dMz, dDgnVal;
		T_GPS_STRIP_UBM UBMResD;
		POSITION pos = m_mapStripUnbalancedMoment.GetStartPosition();
		while (pos)
		{
			m_mapStripUnbalancedMoment.GetNextAssoc(pos, NodeK, UBMResD);

			if (!m_pDoc->m_pAttrCtrl->GetNode(NodeK, NodeD)) { ASSERT(0); continue; }
			point.Set(NodeD.x, NodeD.y, NodeD.z);
			if (gm->m_bVirtualMode) text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(point);
			else                   text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(point);

			dMy = UBMResD.dUBM_My;
			dMz = UBMResD.dUBM_Mz;
			strFmt1.Format(_T("My:%s, Mz:%s"), fmt_str_bracket, fmt_str_bracket);
			strVal1.Format(strFmt1, dMy, dMz);
			pDC->TextOut(text_p.x, text_p.y, strVal1);

			bDgnResult = m_pDoc->m_pPostCtrl->GetDesignResult()->GetUnbalanceResult(NodeK, dDgnVal);
			if (bDgnResult)
			{
				strFmt2.Format(_T("(%s)"), fmt_str_bracket);
				strVal2.Format(strFmt2, dDgnVal);
				pDC->TextOut(text_p.x, text_p.y + nOffset, strVal2);
			}
		}
		DEL_BFOR_FONT_TYPE()
	}
}
#else
void CDesignEngine::OutputStripDesignNumbers(CDC *pDC)
{
	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;

	CPoint		text_p;
	TCHAR		  fmt_str[10]/*,text_str[512]*/;
	BOOL		  fl_bak;
	double    dOffsetX, dOffsetY;
	CString   strTop, strBot;
	TCHAR      text_strI[512], text_strC[512], text_strJ[512];;

	if (!m_bDsgnDataSet) return;

	GPostTextOut TextOutModel;
	TextOutModel.SetDC(pDC);
	TextOutModel.StartStripVal();
	TextOutModel.SettingStrip(gm);

	if (gm->m_DOPT.TX.m_bNumberExponent) _stprintf(fmt_str, _T("%s%de"), _T("%."), gm->m_NumberDecimalPoint);
	else                                 _stprintf(fmt_str, _T("%s%df"), _T("%."), gm->m_NumberDecimalPoint);

	fl_bak = gm->m_DOPT.DR.m_bFrameLine;
	gm->m_DOPT.DR.m_bFrameLine = TRUE;

	CArray<T_MSTR_K, T_MSTR_K> aMstrK;
	GetMstrKeyListForView(aMstrK);
	T_GPS_STRIP_RESULT StripResult;
	T_MSTR_K MstrK;
	int nSlope5Div[5];
	BOOL nInverse5Div[5];
	BOOL bCanDraw[5];
	CPoint DrawPt[5];

	// 글자 간격만큼 오프셋
	TEXTMETRIC tm;
	::GetTextMetrics(TextOutModel.GetSafeHdc(), &tm);
	int nOffset = tm.tmHeight;

	for (int i = 0; i < aMstrK.GetSize(); i++)
	{
		MstrK = aMstrK[i];
		if (!GetStripDesignResult(MstrK, StripResult)) { ASSERT(0); continue; }

		CUtilFuncs::MakeBeamSlopeAt5Div(gm, StripResult.ptStrip[0], StripResult.ptStrip[4], nSlope5Div, nInverse5Div, bCanDraw, DrawPt);
		TextOutModel.Font4Strip(gm, nSlope5Div[0]);
		BOOL bInverse = nInverse5Div[0];

		dOffsetX = sin(nSlope5Div[0] / 10.0 * PI / 180.0)*nOffset;
		dOffsetY = cos(nSlope5Div[0] / 10.0 * PI / 180.0)*nOffset;

		// 0:Rebar
		if (m_nRebarRatio == 0)
		{
			text_p = GetWorldToP2D(StripResult.ptStrip[2]);

			strTop = _T(""), strBot = _T("");
			if (!StripResult.aText0[0].IsEmpty() && !StripResult.aText0[1].IsEmpty() && !StripResult.aText0[2].IsEmpty())
			{
				if (!bInverse) strTop.Format(_T("%s : %s : %s"), StripResult.aText0[0], StripResult.aText0[1], StripResult.aText0[2]);
				else          strTop.Format(_T("%s : %s : %s"), StripResult.aText0[2], StripResult.aText0[1], StripResult.aText0[0]);
			}
			if (!StripResult.aText0[3].IsEmpty() && !StripResult.aText0[4].IsEmpty() && !StripResult.aText0[5].IsEmpty())
			{
				if (!bInverse) strBot.Format(_T("%s : %s : %s"), StripResult.aText0[3], StripResult.aText0[4], StripResult.aText0[5]);
				else          strBot.Format(_T("%s : %s : %s"), StripResult.aText0[5], StripResult.aText0[4], StripResult.aText0[3]);
			}
			TextOutModel.TextOutStrip(text_p.x, text_p.y, strTop);
			TextOutModel.TextOutStrip(text_p.x + dOffsetX, text_p.y + dOffsetY, strBot);

			if (m_bStripSlabDgnResult)
			{
				TextOutModel.TextOutStrip(text_p.x + dOffsetX * 2, text_p.y + dOffsetY * 2, StripResult.strSlabRebar[0]);
				TextOutModel.TextOutStrip(text_p.x + dOffsetX * 3, text_p.y + dOffsetY * 3, StripResult.strSlabRebar[1]);
			}
		}
		// 1:AS
		if (m_nRebarRatio == 1)
		{
			text_p = GetWorldToP2D(StripResult.ptStrip[2]);
			_stprintf(text_strI, fmt_str, StripResult.aVal1[0]);
			_stprintf(text_strC, fmt_str, StripResult.aVal1[2]);
			_stprintf(text_strJ, fmt_str, StripResult.aVal1[4]);
			if (!bInverse) strTop.Format(_T("%s : %s : %s"), text_strI, text_strC, text_strJ);
			else          strTop.Format(_T("%s : %s : %s"), text_strJ, text_strC, text_strI);
			TextOutModel.TextOutStrip(text_p.x, text_p.y, strTop);
			_stprintf(text_strI, fmt_str, StripResult.aVal1[1]);
			_stprintf(text_strC, fmt_str, StripResult.aVal1[3]);
			_stprintf(text_strJ, fmt_str, StripResult.aVal1[5]);
			if (!bInverse) strBot.Format(_T("%s : %s : %s"), text_strI, text_strC, text_strJ);
			else          strBot.Format(_T("%s : %s : %s"), text_strJ, text_strC, text_strI);
			TextOutModel.TextOutStrip(text_p.x + dOffsetX, text_p.y + dOffsetY, strBot);
		}
		// 2:Resistance Ratio
		if (m_nRebarRatio == 2)
		{
			text_p = GetWorldToP2D(StripResult.ptStrip[2]);
			_stprintf(text_strI, fmt_str, StripResult.aVal2[0]);
			_stprintf(text_strC, fmt_str, StripResult.aVal2[2]);
			_stprintf(text_strJ, fmt_str, StripResult.aVal2[4]);
			if (!bInverse) strTop.Format(_T("%s : %s : %s"), text_strI, text_strC, text_strJ);
			else          strTop.Format(_T("%s : %s : %s"), text_strJ, text_strC, text_strI);
			TextOutModel.TextOutStrip(text_p.x, text_p.y, strTop);
			_stprintf(text_strI, fmt_str, StripResult.aVal2[1]);
			_stprintf(text_strC, fmt_str, StripResult.aVal2[3]);
			_stprintf(text_strJ, fmt_str, StripResult.aVal2[5]);
			if (!bInverse) strBot.Format(_T("%s : %s : %s"), text_strI, text_strC, text_strJ);
			else          strBot.Format(_T("%s : %s : %s"), text_strJ, text_strC, text_strI);
			TextOutModel.TextOutStrip(text_p.x + dOffsetX, text_p.y + dOffsetY, strBot);
		}

		//3.
		//     if(m_nRebarRatio==3)
		//     {
		//       DrawStripBendingMementDiagram 함수 안에 이 케이스에 대한 그리기 코드가 있다.
		//       계산된 데이터의 사용이 필요해 해당 위치에 있으므로, 숫자 출력 처리 수정 할때 주의!
		//     }

		// 4:Unbalanced Moment
		if (m_nRebarRatio == 4)
		{
			// 스트립 양단의 부재력 차를 출력하던 코드. 불균형모멘트는 기둥의 부재력 차를 출력하는 것으로 변경(141125)
			//       text_p = GetWorldToP2D(StripResult.ptStripConv[5]);
			//       _stprintf(text_str,fmt_str,StripResult.aVal4[0]); 
			//       pDC->TextOut(text_p.x, text_p.y, text_str);
			// 
			//       text_p = GetWorldToP2D(StripResult.ptStripConv[6]);
			//       _stprintf(text_str,fmt_str,StripResult.aVal4[1]);
			//       pDC->TextOut(text_p.x, text_p.y, text_str);
		}
		TextOutModel.DeleteFontFlag();
	}

	// 추가 결과
	// 서브도메인 결과 출력
	if (m_nRebarRatio == 0 && m_bStripSlabDgnResult == TRUE)
	{
		// ------(Axis)------글씨
		// 글씨를 Axis 끝나는데부터 출력해야 하는데, 정렬을 왼쪽/오른쪽으로 하면 뷰 각도에 따라 뒤집히게 됩니다.
		// 정렬을 가운데로 하고, 글자위치를 조작해줘야 항상 축의 끝 부분에 글씨가 나옵니다.
		CArray<T_SBDO_K, T_SBDO_K> aSbdoK;
		m_pDoc->m_pViewCtrl->GetAllActiveSbdo(aSbdoK);
		T_GPS_SBDO_RESULT SbdoResult;
		CPoint text_p_Center;
		double vec[2];
		int nSlope;
		for (int j = 0; j < aSbdoK.GetSize(); j++)
		{
			GetSbdoDesignResult(aSbdoK[j], SbdoResult);

			text_p_Center = GetWorldToP2D(SbdoResult.ptArrowDir1[0]); // 축의 중심
			text_p = GetWorldToP2D(SbdoResult.ptArrowDir1[1]);
			CUtilFuncs::GetSlope2Point(nSlope, text_p_Center.x, text_p_Center.y, text_p.x, text_p.y);
			TextOutModel.Font4Strip(gm, nSlope);

				vec[0] = text_p.x - text_p_Center.x;
			vec[1] = text_p.y - text_p_Center.y;
			CMathFunc::mathNormalize2D(vec, vec);
			text_p.x += int((vec[0] * 2.6)*SbdoResult.strRebarDir1[0].GetLength()) + 1;
			text_p.y += int((vec[1] * 2.6)*SbdoResult.strRebarDir1[0].GetLength()) + 1;
			
			TextOutModel.AlignTextBase(TA_CENTER);
			TextOutModel.TextOutStrip(text_p.x, text_p.y, SbdoResult.strRebarDir1[0]);
			TextOutModel.AlignTextTop(TA_CENTER);
			TextOutModel.TextOutStrip(text_p.x, text_p.y, SbdoResult.strRebarDir1[1]);
			TextOutModel.DeleteFontFlag();

			text_p = GetWorldToP2D(SbdoResult.ptArrowDir2[1]);
			CUtilFuncs::GetSlope2Point(nSlope, text_p_Center.x, text_p_Center.y, text_p.x, text_p.y);
			TextOutModel.Font4Strip(gm, nSlope);

			vec[0] = text_p.x - text_p_Center.x;
			vec[1] = text_p.y - text_p_Center.y;
			CMathFunc::mathNormalize2D(vec, vec);
			text_p.x += int((vec[0] * 2.6)*SbdoResult.strRebarDir2[0].GetLength()) + 1;
			text_p.y += int((vec[1] * 2.6)*SbdoResult.strRebarDir2[0].GetLength()) + 1;
			TextOutModel.AlignTextBase(TA_CENTER);
			TextOutModel.TextOutStrip(text_p.x, text_p.y, SbdoResult.strRebarDir2[0]);
			TextOutModel.AlignTextTop(TA_CENTER);
			TextOutModel.TextOutStrip(text_p.x, text_p.y, SbdoResult.strRebarDir2[1]);
			TextOutModel.DeleteFontFlag();
		}
	}

	// 기둥에 불균형 모멘트 출력
	if (m_nRebarRatio == 4)
	{	
		TextOutModel.Font4Strip(gm, 0);
		TCHAR fmt_str_bracket[12];

		if (gm->m_DOPT.TX.m_bNumberExponent) _stprintf(fmt_str_bracket, _T("%s%de"), _T("%."), gm->m_NumberDecimalPoint);
		else _stprintf(fmt_str_bracket, _T("%s%df"), _T("%."), gm->m_NumberDecimalPoint);

		T_NODE_K NodeK;
		T_NODE_D NodeD;
		CString strFmt1, strFmt2;
		CString strVal1, strVal2;
		C3DPoint point;
		BOOL bDgnResult;
		double dMy, dMz, dDgnVal;
		T_GPS_STRIP_UBM UBMResD;
		POSITION pos = m_mapStripUnbalancedMoment.GetStartPosition();
		while (pos)
		{
			m_mapStripUnbalancedMoment.GetNextAssoc(pos, NodeK, UBMResD);

			if (!m_pDoc->m_pAttrCtrl->GetNode(NodeK, NodeD)) { ASSERT(0); continue; }
			point.Set(NodeD.x, NodeD.y, NodeD.z);
			if (gm->m_bVirtualMode) text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(point);
			else                   text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(point);

			dMy = UBMResD.dUBM_My;
			dMz = UBMResD.dUBM_Mz;
			strFmt1.Format(_T("My:%s, Mz:%s"), fmt_str_bracket, fmt_str_bracket);
			strVal1.Format(strFmt1, dMy, dMz);
			TextOutModel.TextOutStrip(text_p.x, text_p.y, strVal1);

			bDgnResult = m_pDoc->m_pPostCtrl->GetDesignResult()->GetUnbalanceResult(NodeK, dDgnVal);
			if (bDgnResult)
			{
				strFmt2.Format(_T("(%s)"), fmt_str_bracket);
				strVal2.Format(strFmt2, dDgnVal);
				TextOutModel.TextOutStrip(text_p.x, text_p.y + nOffset, strVal2);
			}
		}
		TextOutModel.DeleteFontFlag();
	}
	TextOutModel.EndStripVal();
}
#endif

// 기둥의 불균형 모멘트를 계산
// 기둥 위에 기둥이 있을 경우 : 두 기둥이 만나는 절점에서의 부재력 차를 계산하여 저장
// 기둥 위에 기둥이 없을 경우 : 상단 절점의 부재력을 저장
void CDesignEngine::MakeUnbalancedMomentData()
{
	m_mapStripUnbalancedMoment.RemoveAll();

	I_GPSModel *gm = (I_GPSModel *)m_pGPSModel;

	const int COLUMN_TYPE = 1;
	CArray<T_ELEM_K, T_ELEM_K> aElemKAll, aElemK;
	m_pDoc->m_pViewCtrl->GetAllActiveElem(aElemKAll);

	CArray<T_NODE_K, T_NODE_K> aSelNodeList;    aSelNodeList.RemoveAll();
	m_pDoc->m_pViewCtrl->GetAllSelectedNode(aSelNodeList);
	BOOL bUseSelectNode = FALSE;
	if (aSelNodeList.GetSize() > 0) bUseSelectNode = TRUE;

	CMapEx<T_NODE_K, T_NODE_K, int, int> mNodeK;  mNodeK.RemoveAll();
	mNodeK.InitHashTable(997);
	for (int i = 0; i < aSelNodeList.GetSize(); ++i) mNodeK.SetAt(aSelNodeList[i], 0);


	double dMy, dMz, dMx_upper, dMy_upper, dMy_upper_rotated, dMz_upper;
	T_NODE_K NodeK;
	T_NODE_D NodeD_I, NodeD_J;
	T_ELEM_K ElemK, ElemK_upper;
	T_ELEM_D ElemD, ElemD_upper;
	T_STRB_D StrbD, StrbD_upper;
	T_GPS_STRIP_UBM UBMResD;
	for (int i = 0; i < aElemKAll.GetSize(); i++)
	{
		UBMResD.Initialize();
		ElemK = aElemKAll[i];
		if (m_pDoc->m_pAttrCtrl->GetMemberType(ElemK) != 1) continue;
		if (!m_pDoc->m_pAttrCtrl->GetElem(ElemK, ElemD)) { ASSERT(0); continue; }

		if (!m_pDoc->m_pAttrCtrl->GetNode(ElemD.elnod[0], NodeD_I)) { ASSERT(0); continue; }
		if (!m_pDoc->m_pAttrCtrl->GetNode(ElemD.elnod[1], NodeD_J)) { ASSERT(0); continue; }

		NodeK = NodeD_I.z > NodeD_J.z ? ElemD.elnod[0] : ElemD.elnod[1];
		if (bUseSelectNode && !mNodeK.Exist(NodeK))   continue;

		// All combination인 경우 : 불리한 값으로 계산된 결과를 설계에서 받아와 저장
		if (gm->m_LoadCaseKey == 0)
		{
			T_RCSFS_KCI12_INP resRcs;
			m_pDoc->m_pPostCtrl->GetDesignResult()->Get_RcsfsKCI12Input(NodeK, resRcs);

			UBMResD.dUBM_My = resRcs.Forc.dMe1;
			UBMResD.dUBM_Mz = resRcs.Forc.dMe2;
		}
		else
		{
			// 상단의 절점에 출력한다.
			m_pDoc->m_pAttrCtrl2->GetConnectedElemByNode(NodeK, aElemK, COLUMN_TYPE);

			if (aElemK.GetSize() == 1) // 기둥 위에 기둥이 없는 경우
			{
				if (!m_pDoc->m_pAttrCtrl->GetElem(ElemK, ElemD)) { ASSERT(0); continue; }
				m_pDoc->m_pPostCtrl->GetStrbNew(ElemK, &StrbD, NULL, NULL, TRUE);

				dMy = ElemD.elnod[0] == NodeK ? StrbD.dblForce[0][4] : StrbD.dblForce[3][10];
				dMz = ElemD.elnod[0] == NodeK ? StrbD.dblForce[0][5] : StrbD.dblForce[3][11];

				UBMResD.dUBM_My = dMy;
				UBMResD.dUBM_Mz = dMz;
			}
			else if (aElemK.GetSize() == 2) // 기둥 위에 기둥이 있는 경우
			{
				ElemK_upper = aElemK[0] != ElemK ? aElemK[0] : aElemK[1];
				if (!m_pDoc->m_pAttrCtrl->GetElem(ElemK, ElemD)) { ASSERT(0); continue; }
				if (!m_pDoc->m_pAttrCtrl->GetElem(ElemK_upper, ElemD_upper)) { ASSERT(0); continue; }
				m_pDoc->m_pPostCtrl->GetStrbNew(ElemK, &StrbD, NULL, NULL, TRUE);
				m_pDoc->m_pPostCtrl->GetStrbNew(ElemK_upper, &StrbD_upper, NULL, NULL, TRUE);

				dMy = ElemD.elnod[0] == NodeK ? StrbD.dblForce[0][4] : StrbD.dblForce[3][10];
				dMz = ElemD.elnod[0] == NodeK ? StrbD.dblForce[0][5] : StrbD.dblForce[3][11];
				dMx_upper = ElemD_upper.elnod[0] == NodeK ? StrbD_upper.dblForce[0][3] : StrbD_upper.dblForce[3][9];
				dMy_upper = ElemD_upper.elnod[0] == NodeK ? StrbD_upper.dblForce[0][4] : StrbD_upper.dblForce[3][10];
				dMz_upper = ElemD_upper.elnod[0] == NodeK ? StrbD_upper.dblForce[0][5] : StrbD_upper.dblForce[3][11];

				// 불균형 모멘트를 계산할 때, 하단 기둥의 beta angle에 맞춰 상단 기둥의 부재력을 회전한다.
				double dAngle = ElemD_upper.angle - ElemD.angle;
				if (dAngle < 0) dAngle += 360;
				double rad = dAngle * CMathFunc::m_trrad;
				dMy_upper_rotated = dMx_upper * CMathFunc::mathSin(rad) + dMy_upper * CMathFunc::mathCos(rad);

				UBMResD.dUBM_My = /*fabs*/(dMy - dMy_upper_rotated);
				UBMResD.dUBM_Mz = /*fabs*/(dMz - dMz_upper); // beta angle은 z축에 대한 회전이므로 회전변환 필요없음
			}
			else { ASSERT(0); continue; }
		}

		m_mapStripUnbalancedMoment.SetAt(NodeK, UBMResD);
	}
}

// 스트립이랑 평행하게 이어진게 또 있는가 판별
// 있으면: 그 스트립과 붙은 쪽의 모멘트 차를 출력한다.
// 없으면: I,J단과 C의 차를 출력한다.
// void CDesignEngine::MakeUnbalancedMomentData(T_MSTR_K MstrK, int MstrIndex, T_GPS_STRIP_RESULT& StripResut, CArray<T_FORCSTRIP_D,T_FORCSTRIP_D>& aForce)
// {
//   CArray<T_MSTR_K,T_MSTR_K> aMstrK;
//   m_pDoc->m_pPostCtrl->GetDesignResult()->GetDesignedMstrKList(aMstrK);
//   // _Paral 시리즈는 불균형모멘트 다이어그램에서 평행한 스트립을 찾기 위한 변수
//   int nIdx_Paral_I,  nIdx_Paral_J;  // aForce[] 의 인덱스
//   int nPart_Paral_I, nPart_Paral_J; // aForce.dLineForce[][]의 파트. 0:I, 4:J
//   T_NODE_K NodeK_I, NodeK_J;
//   T_NODE_D NodeD_I, NodeD_J;
//   T_NODE_K NodeK_I_Paral, NodeK_J_Paral;
//   T_NODE_D NodeI_Paral, NodeJ_Paral;
//   double pt1[2], pt2[2], vec1[2], vec2[2];
//   
//   m_pDoc->m_pAttrCtrl2->GetMstrNodeK(MstrK,NodeK_I,NodeK_J);
//   m_pDoc->m_pAttrCtrl->GetNode(NodeK_I, NodeD_I);
//   m_pDoc->m_pAttrCtrl->GetNode(NodeK_J, NodeD_J);
// 
//   nIdx_Paral_I = nIdx_Paral_J = nPart_Paral_I = nPart_Paral_J = -1;
//   for(int j=0; j<aMstrK.GetSize(); j++)
//   {      
//     if(MstrK == aMstrK[j]) continue;
//     //m_pDoc->m_pAttrCtrl2->GetMstr(aMstrK[j], MstrD_Paral);
//     m_pDoc->m_pAttrCtrl2->GetMstrNodeK(aMstrK[j],NodeK_I_Paral,NodeK_J_Paral);
// 
//     if(NodeK_I==NodeK_I_Paral || NodeK_I==NodeK_J_Paral ||
//       NodeK_J==NodeK_I_Paral || NodeK_J==NodeK_J_Paral)
//     {
//       m_pDoc->m_pAttrCtrl->GetNode(NodeK_I_Paral, NodeI_Paral);
//       m_pDoc->m_pAttrCtrl->GetNode(NodeK_J_Paral, NodeJ_Paral);
// 
//       pt1[0] = NodeD_I.x; pt1[1] = NodeD_I.y;
//       pt2[0] = NodeD_J.x; pt2[1] = NodeD_J.y;
//       vec1[0] = pt2[0] - pt1[0];
//       vec1[1] = pt2[1] - pt1[1];
//       CMathFunc::mathNormalize(vec1[0], vec1[1], vec1[0], vec1[1]);
// 
//       pt1[0] = NodeI_Paral.x; pt1[1] = NodeI_Paral.y;
//       pt2[0] = NodeJ_Paral.x; pt2[1] = NodeJ_Paral.y;
//       vec2[0] = pt2[0] - pt1[0];
//       vec2[1] = pt2[1] - pt1[1];
//       CMathFunc::mathNormalize(vec2[0], vec2[1], vec2[0], vec2[1]);
// 
//       // 두 벡터가 평행한가?
//       if(fabs(CMathFunc::GetAngle(vec1[0], vec1[1], vec2[0], vec2[1], FALSE)) < 1.e-8) 
//       {
//         // I단이랑 만났었니?
//         if(NodeK_I==NodeK_I_Paral || NodeK_I==NodeK_J_Paral) 
//         {
//           nIdx_Paral_I=j;
//           StripResut.MstrK_Parallel[0] = aMstrK[j];
//           StripResut.ptStripParalCenter[0].Set((NodeI_Paral.x+NodeJ_Paral.x)/2, (NodeI_Paral.y+NodeJ_Paral.y)/2, (NodeI_Paral.z+NodeJ_Paral.z)/2);
//           if(NodeK_I==NodeK_I_Paral) nPart_Paral_I=0; 
//           else if(NodeK_I==NodeK_J_Paral) nPart_Paral_I=4; 
//         }
//         // J단이었습니다.
//         else if(NodeK_J==NodeK_I_Paral || NodeK_J==NodeK_J_Paral) 
//         {
//           nIdx_Paral_J=j;
//           StripResut.MstrK_Parallel[1] = aMstrK[j];
//           StripResut.ptStripParalCenter[1].Set((NodeI_Paral.x+NodeJ_Paral.x)/2, (NodeI_Paral.y+NodeJ_Paral.y)/2, (NodeI_Paral.z+NodeJ_Paral.z)/2);
//           if(NodeK_J==NodeK_I_Paral) nPart_Paral_J=0; 
//           else if(NodeK_J==NodeK_J_Paral) nPart_Paral_J=4; 
//         }          
//       }
//     }
//   }
//   // I단
//   if(nIdx_Paral_I>-1) StripResut.aVal4[0] = fabs(aForce[MstrIndex].dLineForce[0][4] - aForce[nIdx_Paral_I].dLineForce[nPart_Paral_I][4]);
//   else                StripResut.aVal4[0] = fabs(aForce[MstrIndex].dLineForce[0][4] - aForce[MstrIndex].dLineForce[2][4]);
//   // J단
//   if(nIdx_Paral_J>-1) StripResut.aVal4[1] = fabs(aForce[MstrIndex].dLineForce[4][4] - aForce[nIdx_Paral_J].dLineForce[nPart_Paral_J][4]);
//   else                StripResut.aVal4[1] = fabs(aForce[MstrIndex].dLineForce[4][4] - aForce[MstrIndex].dLineForce[2][4]);
// }

CPoint CDesignEngine::GetWorldToP2D(C3DPoint pt3D)
{
	I_GPSModel *gm = (I_GPSModel*)m_pGPSModel;
	if (gm->m_bVirtualMode) return gm->m_pGPSCtrl->GetWorldToWindowP2D(pt3D);
	else                   return gm->m_pGPSCtrl->GetWorldToMemDCP2D(pt3D);
}

// 뷰에 출력할 스트립 키 얻어올 때 사용
void CDesignEngine::GetMstrKeyListForView(CArray<T_MSTR_K, T_MSTR_K>& aMstrK)
{
	aMstrK.RemoveAll();

	CArray<T_MSTR_K, T_MSTR_K> aMstrK_DgnUse;
	m_pDoc->m_pPostCtrl->GetDesignResult()->GetDesignedMstrKList(aMstrK_DgnUse);

	CArray<T_MSTR_K, T_MSTR_K> aMstrK_Active;
	m_pDoc->m_pViewCtrl->GetAllActiveMstr(aMstrK_Active);

	aMstrK.RemoveAll();
	CArrayUtil::IntersectUINT(aMstrK_DgnUse, aMstrK_Active, aMstrK);
}

// Performance 데이터를 만든다.
// 현재 Active Element List에 대해 Loop를 돌며
// 1. DB로 부터 해당 Element의 Performance 데이터를 얻고
// 2. Performance에 대한 최대/최소값을 갱신하고
// 3. Performance값 및 해당 Element번호를 CArray에 저장
BOOL CDesignEngine::MakeSeisRCPerform1stData()
{
	DECLARE_GPSMD();

	gm->m_nLgdMaxValKey = 0;
	gm->m_nLgdMinValKey = 0;

	int			i, elem_num;
	double	max_enLevel = -DBL_MAX, min_enLevel = DBL_MAX;
	BOOL		has_content = FALSE;
	T_ELEM_K	elem_key;
	T_ELEM_D	elem_data;
	T_PRFM_RESULT PRFM;
	T_SCMT_D ScmtD;

	if (!gm->m_bLoadDataSet)return FALSE;
	int nGPSMode = (gm->m_GPSInstruction != -1) ? gm->m_GPSInstruction : gm->m_GPSMode;

	gm->m_pMyView->BeginWaitCursor();

	m_EKeyList.RemoveAll();
	m_mSeisPerform.RemoveAll();
	elem_num = gm->m_EKeyListActive.GetSize();

	CDesignEngine::m_nSeisPrfmElementSummation = 0;
	memset(CDesignEngine::m_nSeisPrfmElement, 0, sizeof(CDesignEngine::m_nSeisPrfmElement));

	CDesignEngine::m_nSeisPrfmNodeSummation = 0;
	memset(CDesignEngine::m_nSeisPrfmNode, 0, sizeof(CDesignEngine::m_nSeisPrfmNode));

	BOOL bShowLevel[4] = { m_bCtShowIO, m_bCtShowLS, m_bCtShowCP, m_bCtShowCL };

	CSeisEvalDataTool Tool;
	CSeisEvalWrapper SeisEval;

	CMapEx<T_ELEM_K, T_ELEM_K, T_ELEM_K, T_ELEM_K> mMInfElemK; mMInfElemK.RemoveAll();
	if (m_pDoc->m_pAttrCtrl2->IsSemeMethod4Masonry())
	{
		T_ELEM_K_LIST aMInfElemK;
		BOOL bConsiderSeisComponentType = TRUE;
		Tool.GetEvalInfilledConColmKeyList(aMInfElemK, bConsiderSeisComponentType);
		mMInfElemK.InitHashTable(aMInfElemK.GetSize() + 1);
		for (int i = 0; i < aMInfElemK.GetSize(); i++)
		{
			mMInfElemK.SetAt(aMInfElemK[i], aMInfElemK[i]);
		}
	}

	// Beam
	BOOL bBeam = (m_SeisRCPerformComponent_1st >= SEIS_RC_PFM_COMP_SHEAR_Z);
	if (bBeam && m_bCtShowBeam)
	{
		T_MATD_D MatdD;
		T_REBB_D RebbD;
		T_EVAL1ST_BEAM EvalBeam;
		for (i = 0; i < elem_num; i++)
		{
			elem_key = gm->m_EKeyListActive[i];
			m_pDoc->m_pAttrCtrl->GetElem(elem_key, elem_data);
			if (m_pDoc->m_pAttrCtrl->GetMemberType(elem_key) != D_MBTP_BEAM) continue;
			if (Tool.GetSeisComponentType(elem_key) == D_SCMT_TYPE_NONE) continue;
			if (!m_pDoc->m_pAttrCtrl->GetDgnGenMatd(elem_key, MatdD)) continue;
			if (MatdD.Type != _LSX(C)) continue;
			if (!m_pDoc->m_pAttrCtrl->GetRebbByElemK(elem_key, RebbD)) continue;
			if (!SeisEval.GetInstance()->GetSeisEval1stRsltConBeam(elem_key, EvalBeam)) continue;

			bool bResult = false;
			switch (m_SeisRCPerformComponent_1st)
			{
			case SEIS_RC_PFM_COMP_SHEAR_Z:
				bResult = EvalBeam.GetLevelVz(gm->m_LoadCaseKey, PRFM.enLevel_1, PRFM.enLevel_2);
				break;
			case SEIS_RC_PFM_COMP_BENDING:
				bResult = EvalBeam.GetLevelMy(gm->m_LoadCaseKey, PRFM.enLevel_1, PRFM.enLevel_2);
				break;
			case SEIS_RC_PFM_COMP_REPRESENT:
				bResult = EvalBeam.GetLevel(gm->m_LoadCaseKey, PRFM.enLevel_1, PRFM.enLevel_2);
				break;
			default:
				continue;
				break;
			}

			if (bResult)
			{
				PRFM.enLevel = max(PRFM.enLevel_1, PRFM.enLevel_2);

				max_enLevel = max(max_enLevel, (double)PRFM.enLevel);
				min_enLevel = min(min_enLevel, (double)PRFM.enLevel);

				if (PRFM.enLevel_1 != EN_LEVEL_INVALID && bShowLevel[PRFM.enLevel_1] == FALSE) PRFM.enLevel_1 = EN_LEVEL_INVALID;
				if (PRFM.enLevel_2 != EN_LEVEL_INVALID && bShowLevel[PRFM.enLevel_2] == FALSE) PRFM.enLevel_2 = EN_LEVEL_INVALID;
				if (PRFM.enLevel != EN_LEVEL_INVALID && bShowLevel[PRFM.enLevel] == FALSE)	PRFM.enLevel = EN_LEVEL_INVALID;

				if (PRFM.enLevel != EN_LEVEL_INVALID)
				{
					m_nSeisPrfmElementSummation++;
					m_nSeisPrfmElement[PRFM.enLevel + 1]++;
				}

				if (PRFM.enLevel_1 != EN_LEVEL_INVALID)
				{
					m_nSeisPrfmNodeSummation++;
					m_nSeisPrfmNode[PRFM.enLevel_1 + 1]++;
				}

				if (PRFM.enLevel_2 != EN_LEVEL_INVALID)
				{
					m_nSeisPrfmNodeSummation++;
					m_nSeisPrfmNode[PRFM.enLevel_2 + 1]++;
				}

				m_EKeyList.Add(elem_key);
				m_mSeisPerform.SetAt(elem_key, PRFM);
				has_content = TRUE;
			}
			else
			{
				ASSERT(0);
			}
		}
	}

	// Colm
	if (m_bCtShowColm || m_bCtShowColmM)
	{
		T_MATD_D MatdD;
		T_REBC_D RebcD;
		T_EVAL1ST_COLM EvalColm;
		for (i = 0; i < elem_num; i++)
		{
			elem_key = gm->m_EKeyListActive[i];
			if (!m_bCtShowColm && !mMInfElemK.Exist(elem_key)) continue;
			if (!m_bCtShowColmM && mMInfElemK.Exist(elem_key)) continue;
			m_pDoc->m_pAttrCtrl->GetElem(elem_key, elem_data);
			if (m_pDoc->m_pAttrCtrl->GetMemberType(elem_key) != D_MBTP_COLUMN) continue;
			if (Tool.GetSeisComponentType(elem_key) == D_SCMT_TYPE_NONE) continue;
			if (!m_pDoc->m_pAttrCtrl->GetDgnGenMatd(elem_key, MatdD)) continue;
			if (MatdD.Type != _LSX(C)) continue;
			if (!m_pDoc->m_pAttrCtrl->GetRebcByElemK(elem_key, RebcD)) continue;
			if (!SeisEval.GetInstance()->GetSeisEval1stRsltConColm(elem_key, EvalColm)) continue;

			bool bResult = false;
			switch (m_SeisRCPerformComponent_1st)
			{
			case SEIS_RC_PFM_COMP_AXIAL:
				bResult = EvalColm.GetLevelP(gm->m_LoadCaseKey, PRFM.enLevel_1, PRFM.enLevel_2);
				break;
			case SEIS_RC_PFM_COMP_SHEAR_Y:
				bResult = EvalColm.GetLevelVy(gm->m_LoadCaseKey, PRFM.enLevel_1, PRFM.enLevel_2);
				break;
			case SEIS_RC_PFM_COMP_SHEAR_Z:
				bResult = EvalColm.GetLevelVz(gm->m_LoadCaseKey, PRFM.enLevel_1, PRFM.enLevel_2);
				break;
			case SEIS_RC_PFM_COMP_BENDING:
				bResult = EvalColm.GetLevelM(gm->m_LoadCaseKey, PRFM.enLevel_1, PRFM.enLevel_2);
				break;
			case SEIS_RC_PFM_COMP_REPRESENT:
				bResult = EvalColm.GetLevel(gm->m_LoadCaseKey, PRFM.enLevel_1, PRFM.enLevel_2);
				break;
			default:
				continue;
				break;
			}

			if (bResult)
			{
				PRFM.enLevel = max(PRFM.enLevel_1, PRFM.enLevel_2);

				max_enLevel = max(max_enLevel, (double)PRFM.enLevel);
				min_enLevel = min(min_enLevel, (double)PRFM.enLevel);

				if (PRFM.enLevel_1 != EN_LEVEL_INVALID && bShowLevel[PRFM.enLevel_1] == FALSE) PRFM.enLevel_1 = EN_LEVEL_INVALID;
				if (PRFM.enLevel_2 != EN_LEVEL_INVALID && bShowLevel[PRFM.enLevel_2] == FALSE) PRFM.enLevel_2 = EN_LEVEL_INVALID;
				if (PRFM.enLevel != EN_LEVEL_INVALID && bShowLevel[PRFM.enLevel] == FALSE)	PRFM.enLevel = EN_LEVEL_INVALID;

				if (PRFM.enLevel != EN_LEVEL_INVALID)
				{
					m_nSeisPrfmElementSummation++;
					m_nSeisPrfmElement[PRFM.enLevel + 1]++;
				}

				if (PRFM.enLevel_1 != EN_LEVEL_INVALID)
				{
					m_nSeisPrfmNodeSummation++;
					m_nSeisPrfmNode[PRFM.enLevel_1 + 1]++;
				}

				if (PRFM.enLevel_2 != EN_LEVEL_INVALID)
				{
					m_nSeisPrfmNodeSummation++;
					m_nSeisPrfmNode[PRFM.enLevel_2 + 1]++;
				}

				m_EKeyList.Add(elem_key);
				m_mSeisPerform.SetAt(elem_key, PRFM);
				has_content = TRUE;
			}
			else
			{
				ASSERT(0);
			}
		}
	}

	// Wall
	BOOL bWall = (m_SeisRCPerformComponent_1st >= SEIS_RC_PFM_COMP_SHEAR_Z);
	if (bWall && m_bCtShowWall)
	{
		CMap<T_ELEM_K, T_ELEM_K, T_ELEM_K, T_ELEM_K> mUsedRootElemK;
		mUsedRootElemK.InitHashTable(HASHSIZEELEM);
		CStoryData* pStoryData = m_pDoc->GetStoryData();
		CArray<T_ELEM_K, T_ELEM_K> atempElemKeyList;
		T_ELEM_K RootElemK = 0;

		T_EVAL1ST_WALL EvalWall;
		T_WALL_D WallD;  WallD.Initialize();
		for (i = 0; i < elem_num; i++)
		{
			elem_key = gm->m_EKeyListActive[i];
			m_pDoc->m_pAttrCtrl->GetElem(elem_key, elem_data);
			if (!m_pDoc->m_pAttrCtrl->IsWall(elem_data.eltyp))continue;

			m_pDoc->m_pAttrCtrl->GetRootWallElemKey(elem_key, RootElemK);
			if (RootElemK == 0) continue;
			if (m_mSeisPerform.Lookup(RootElemK, PRFM))
			{
				m_EKeyList.Add(elem_key);
				m_mSeisPerform.SetAt(elem_key, PRFM);
				continue;
			}

			if (Tool.GetSeisComponentType(RootElemK) == D_SCMT_TYPE_NONE) continue;
			if (!SeisEval.GetInstance()->GetSeisEval1stRsltConWall(RootElemK, EvalWall)) continue;

			bool bResult = false;
			switch (m_SeisRCPerformComponent_1st)
			{
			case SEIS_RC_PFM_COMP_SHEAR_Z:
				bResult = EvalWall.GetLevelV(gm->m_LoadCaseKey, PRFM.enLevel_1, PRFM.enLevel_2);
				break;
			case SEIS_RC_PFM_COMP_BENDING:
				bResult = EvalWall.GetLevelM(gm->m_LoadCaseKey, PRFM.enLevel_1, PRFM.enLevel_2);
				break;
			case SEIS_RC_PFM_COMP_REPRESENT:
				bResult = EvalWall.GetLevel(gm->m_LoadCaseKey, PRFM.enLevel_1, PRFM.enLevel_2);
				break;
			default:
				continue;
				break;
			}

			if (bResult)
			{
				PRFM.enLevel = max(PRFM.enLevel_1, PRFM.enLevel_2);

				max_enLevel = max(max_enLevel, (double)PRFM.enLevel);
				min_enLevel = min(min_enLevel, (double)PRFM.enLevel);

				if (PRFM.enLevel_1 != EN_LEVEL_INVALID && bShowLevel[PRFM.enLevel_1] == FALSE) PRFM.enLevel_1 = EN_LEVEL_INVALID;
				if (PRFM.enLevel_2 != EN_LEVEL_INVALID && bShowLevel[PRFM.enLevel_2] == FALSE) PRFM.enLevel_2 = EN_LEVEL_INVALID;
				if (PRFM.enLevel != EN_LEVEL_INVALID && bShowLevel[PRFM.enLevel] == FALSE)	PRFM.enLevel = EN_LEVEL_INVALID;

				if (PRFM.enLevel != EN_LEVEL_INVALID)
				{
					m_nSeisPrfmElementSummation++;
					m_nSeisPrfmElement[PRFM.enLevel + 1]++;
				}

				if (PRFM.enLevel_1 != EN_LEVEL_INVALID)
				{
					m_nSeisPrfmNodeSummation++;
					m_nSeisPrfmNode[PRFM.enLevel_1 + 1]++;
				}

				if (PRFM.enLevel_2 != EN_LEVEL_INVALID)
				{
					m_nSeisPrfmNodeSummation++;
					m_nSeisPrfmNode[PRFM.enLevel_2 + 1]++;
				}

				m_EKeyList.Add(RootElemK);
				m_mSeisPerform.SetAt(RootElemK, PRFM);

				m_EKeyList.Add(elem_key);
				m_mSeisPerform.SetAt(elem_key, PRFM);

				has_content = TRUE;
			}
			else
			{
				ASSERT(0);
			}
		}
	}

	if (!has_content)
	{
		max_enLevel = min_enLevel = 0.0;
	}
	m_dMaxValue = max_enLevel;
	m_dMinValue = min_enLevel;

	CArray<CString, CString&> aLegendString;
	CArray<double, double&>  aLegendValue;
	aLegendString.SetSize(5);
	aLegendValue.SetSize(5);
	CString strLegend = _T("");
	double dValue = 0.;
	strLegend = _T(" IO");				dValue = 0.0; aLegendString.SetAt(0, strLegend); aLegendValue.SetAt(0, dValue);
	strLegend = _T(" LS");				dValue = 0.5; aLegendString.SetAt(1, strLegend); aLegendValue.SetAt(1, dValue);
	strLegend = _T(" CP");				dValue = 1.5; aLegendString.SetAt(2, strLegend); aLegendValue.SetAt(2, dValue);
	strLegend = _T(" Collapse");	dValue = 2.5; aLegendString.SetAt(3, strLegend); aLegendValue.SetAt(3, dValue);
	strLegend = _T("");						dValue = 3.5; aLegendString.SetAt(4, strLegend); aLegendValue.SetAt(4, dValue);

	if (m_pContourEngine)m_pContourEngine->MakeRankMap(aLegendString, aLegendValue);
	else                m_pContourEngine = new CContourEngine(aLegendString, aLegendValue);

	m_bSeisPerformDataSet = TRUE;
	gm->m_pMyView->EndWaitCursor();
	return TRUE;
}

BOOL CDesignEngine::MakeSeisStlPerform1stData()
{
	DECLARE_GPSMD();

	gm->m_nLgdMaxValKey = 0;
	gm->m_nLgdMinValKey = 0;

	int			i, elem_num;
	double	max_enLevel = -DBL_MAX, min_enLevel = DBL_MAX;
	BOOL		has_content = FALSE;
	T_ELEM_K	elem_key;
	T_ELEM_D	elem_data;
	T_PRFM_RESULT PRFM;
	T_SCMT_D ScmtD;

	if (!gm->m_bLoadDataSet)return FALSE;
	int nGPSMode = (gm->m_GPSInstruction != -1) ? gm->m_GPSInstruction : gm->m_GPSMode;

	gm->m_pMyView->BeginWaitCursor();

	m_EKeyList.RemoveAll();
	m_mSeisPerform.RemoveAll();
	elem_num = gm->m_EKeyListActive.GetSize();

	CDesignEngine::m_nSeisPrfmElementSummation = 0;
	memset(CDesignEngine::m_nSeisPrfmElement, 0, sizeof(CDesignEngine::m_nSeisPrfmElement));

	CDesignEngine::m_nSeisPrfmNodeSummation = 0;
	memset(CDesignEngine::m_nSeisPrfmNode, 0, sizeof(CDesignEngine::m_nSeisPrfmNode));

	CSeisEvalDataTool Tool;
	CSeisEvalWrapper SeisEval;

	BOOL bShowLevel[4] = { m_bCtShowIO, m_bCtShowLS, m_bCtShowCP, m_bCtShowCL };

	// Beam
	BOOL bBeam = (m_SeisStlPerformComponent_1st == SEIS_STL_PFM_COMP_BENDING || m_SeisStlPerformComponent_1st == SEIS_STL_PFM_COMP_REPRESENT);
	if (bBeam && m_bCtShowBeam)
	{
		T_MATD_D MatdD;
		T_EVAL1ST_STLBEAM EvalBeam;
		for (i = 0; i < elem_num; i++)
		{
			elem_key = gm->m_EKeyListActive[i];
			m_pDoc->m_pAttrCtrl->GetElem(elem_key, elem_data);
			if (m_pDoc->m_pAttrCtrl->GetMemberType(elem_key) != D_MBTP_BEAM) continue;
			if (Tool.GetSeisComponentType(elem_key) == D_SCMT_TYPE_NONE) continue;
			if (!m_pDoc->m_pAttrCtrl->GetDgnGenMatd(elem_key, MatdD)) continue;
			if (MatdD.Type != _LSX(S)) continue;
			if (!SeisEval.GetInstance()->GetSeisEval1stRsltStlBeam(elem_key, EvalBeam)) continue;

			int nLcomIndex = -1;
			if (gm->m_LoadCaseKey == 0)
			{
				EN_LEVEL enLevelMax = EN_LEVEL_IO;
				for (int k = 0; k < EvalBeam.aEvalLcom.GetSize(); k++)
				{
					if (EvalBeam.aEvalLcom[k].enLevel < enLevelMax) continue;
					enLevelMax = EvalBeam.aEvalLcom[k].enLevel;
					nLcomIndex = k;
				}
			}
			else
			{
				for (int k = 0; k < EvalBeam.aEvalLcom.GetSize(); k++)
				{
					if (EvalBeam.aEvalLcom[k].LcomK != gm->m_LoadCaseKey) continue;
					nLcomIndex = k;
					break;
				}
			}

			if (nLcomIndex >= 0)
			{
				switch (m_SeisStlPerformComponent_1st)
				{
				case SEIS_STL_PFM_COMP_BENDING:
				case SEIS_STL_PFM_COMP_REPRESENT:
					PRFM.enLevel_1 = EvalBeam.aEvalLcom[nLcomIndex].EndI.enLevel;
					PRFM.enLevel_2 = EvalBeam.aEvalLcom[nLcomIndex].EndJ.enLevel;
					break;
				default:
					continue;
					break;
				}

				PRFM.enLevel = max(PRFM.enLevel_1, PRFM.enLevel_2);

				max_enLevel = max(max_enLevel, (double)PRFM.enLevel);
				min_enLevel = min(min_enLevel, (double)PRFM.enLevel);

				if (PRFM.enLevel_1 != EN_LEVEL_INVALID && bShowLevel[PRFM.enLevel_1] == FALSE) PRFM.enLevel_1 = EN_LEVEL_INVALID;
				if (PRFM.enLevel_2 != EN_LEVEL_INVALID && bShowLevel[PRFM.enLevel_2] == FALSE) PRFM.enLevel_2 = EN_LEVEL_INVALID;
				if (PRFM.enLevel != EN_LEVEL_INVALID && bShowLevel[PRFM.enLevel] == FALSE)	PRFM.enLevel = EN_LEVEL_INVALID;

				if (PRFM.enLevel != EN_LEVEL_INVALID)
				{
					m_nSeisPrfmElementSummation++;
					m_nSeisPrfmElement[PRFM.enLevel + 1]++;
				}

				if (PRFM.enLevel_1 != EN_LEVEL_INVALID)
				{
					m_nSeisPrfmNodeSummation++;
					m_nSeisPrfmNode[PRFM.enLevel_1 + 1]++;
				}

				if (PRFM.enLevel_2 != EN_LEVEL_INVALID)
				{
					m_nSeisPrfmNodeSummation++;
					m_nSeisPrfmNode[PRFM.enLevel_2 + 1]++;
				}

				m_EKeyList.Add(elem_key);
				m_mSeisPerform.SetAt(elem_key, PRFM);
				has_content = TRUE;
			}
			else
			{
				ASSERT(0);
			}
		}
	}

	// Colm
	BOOL bColm = (m_SeisStlPerformComponent_1st == SEIS_STL_PFM_COMP_COMBINED || m_SeisStlPerformComponent_1st == SEIS_STL_PFM_COMP_REPRESENT);
	if (bColm && m_bCtShowColm)
	{
		T_MATD_D MatdD;
		T_EVAL1ST_STLCOLM EvalColm;
		for (i = 0; i < elem_num; i++)
		{
			elem_key = gm->m_EKeyListActive[i];
			m_pDoc->m_pAttrCtrl->GetElem(elem_key, elem_data);
			if (m_pDoc->m_pAttrCtrl->GetMemberType(elem_key) != D_MBTP_COLUMN) continue;
			if (Tool.GetSeisComponentType(elem_key) == D_SCMT_TYPE_NONE) continue;
			if (!m_pDoc->m_pAttrCtrl->GetDgnGenMatd(elem_key, MatdD)) continue;
			if (MatdD.Type != _LSX(S)) continue;
			if (!SeisEval.GetInstance()->GetSeisEval1stRsltStlColm(elem_key, EvalColm)) continue;

			int nLcomIndex = -1;
			if (gm->m_LoadCaseKey == 0)
			{
				EN_LEVEL enLevelMax = EN_LEVEL_IO;
				for (int k = 0; k < EvalColm.aEvalLcom.GetSize(); k++)
				{
					if (EvalColm.aEvalLcom[k].enLevel < enLevelMax) continue;
					enLevelMax = EvalColm.aEvalLcom[k].enLevel;
					nLcomIndex = k;
				}
			}
			else
			{
				for (int k = 0; k < EvalColm.aEvalLcom.GetSize(); k++)
				{
					if (EvalColm.aEvalLcom[k].LcomK != gm->m_LoadCaseKey) continue;
					nLcomIndex = k;
					break;
				}
			}

			if (nLcomIndex >= 0)
			{
				switch (m_SeisStlPerformComponent_1st)
				{
				case SEIS_STL_PFM_COMP_COMBINED:
				case SEIS_STL_PFM_COMP_REPRESENT:
					PRFM.enLevel_1 = EvalColm.aEvalLcom[nLcomIndex].PosI.DCR.enLevel;
					PRFM.enLevel_2 = EvalColm.aEvalLcom[nLcomIndex].PosJ.DCR.enLevel;
					break;
				default:
					continue;
					break;
				}

				PRFM.enLevel = max(PRFM.enLevel_1, PRFM.enLevel_2);

				max_enLevel = max(max_enLevel, (double)PRFM.enLevel);
				min_enLevel = min(min_enLevel, (double)PRFM.enLevel);

				if (PRFM.enLevel_1 != EN_LEVEL_INVALID && bShowLevel[PRFM.enLevel_1] == FALSE) PRFM.enLevel_1 = EN_LEVEL_INVALID;
				if (PRFM.enLevel_2 != EN_LEVEL_INVALID && bShowLevel[PRFM.enLevel_2] == FALSE) PRFM.enLevel_2 = EN_LEVEL_INVALID;
				if (PRFM.enLevel != EN_LEVEL_INVALID && bShowLevel[PRFM.enLevel] == FALSE)	PRFM.enLevel = EN_LEVEL_INVALID;

				if (PRFM.enLevel != EN_LEVEL_INVALID)
				{
					m_nSeisPrfmElementSummation++;
					m_nSeisPrfmElement[PRFM.enLevel + 1]++;
				}

				if (PRFM.enLevel_1 != EN_LEVEL_INVALID)
				{
					m_nSeisPrfmNodeSummation++;
					m_nSeisPrfmNode[PRFM.enLevel_1 + 1]++;
				}

				if (PRFM.enLevel_2 != EN_LEVEL_INVALID)
				{
					m_nSeisPrfmNodeSummation++;
					m_nSeisPrfmNode[PRFM.enLevel_2 + 1]++;
				}

				m_EKeyList.Add(elem_key);
				m_mSeisPerform.SetAt(elem_key, PRFM);
				has_content = TRUE;
			}
			else
			{
				ASSERT(0);
			}
		}
	}

	// BraceBeam
	BOOL bBraceBeam = (m_SeisStlPerformComponent_1st == SEIS_STL_PFM_COMP_COMBINED || m_SeisStlPerformComponent_1st == SEIS_STL_PFM_COMP_REPRESENT);
	if (bBraceBeam && m_bCtShowBrceBeam)
	{
		T_MATD_D MatdD;
		T_EVAL1ST_STLBRAC EvalBrac;
		for (i = 0; i < elem_num; i++)
		{
			elem_key = gm->m_EKeyListActive[i];
			if (m_pDoc->m_pAttrCtrl2->ExistMisa(elem_key)) continue; // Strut 제외
			m_pDoc->m_pAttrCtrl->GetElem(elem_key, elem_data);
			if (m_pDoc->m_pAttrCtrl->GetMemberType(elem_key) != D_MBTP_BRACE) continue;
			if (Tool.GetSeisComponentType(elem_key) == D_SCMT_TYPE_NONE) continue;
			if (elem_data.eltyp != BEAM_EL) continue;
			if (!m_pDoc->m_pAttrCtrl->GetDgnGenMatd(elem_key, MatdD)) continue;
			if (MatdD.Type != _LSX(S)) continue;
			if (!SeisEval.GetInstance()->GetSeisEval1stRsltStlBrac(elem_key, EvalBrac)) continue;

			int nLcomIndex = -1;
			if (gm->m_LoadCaseKey == 0)
			{
				EN_LEVEL enLevelMax = EN_LEVEL_IO;
				for (int k = 0; k < EvalBrac.aEvalLcom.GetSize(); k++)
				{
					if (EvalBrac.aEvalLcom[k].enLevel < enLevelMax) continue;
					enLevelMax = EvalBrac.aEvalLcom[k].enLevel;
					nLcomIndex = k;
				}
			}
			else
			{
				for (int k = 0; k < EvalBrac.aEvalLcom.GetSize(); k++)
				{
					if (EvalBrac.aEvalLcom[k].LcomK != gm->m_LoadCaseKey) continue;
					nLcomIndex = k;
					break;
				}
			}

			if (nLcomIndex >= 0)
			{
				switch (m_SeisStlPerformComponent_1st)
				{
				case SEIS_STL_PFM_COMP_COMBINED:
				case SEIS_STL_PFM_COMP_REPRESENT:
					PRFM.enLevel_1 = EvalBrac.aEvalLcom[nLcomIndex].PosI.DCR.enLevel;
					PRFM.enLevel_2 = EvalBrac.aEvalLcom[nLcomIndex].PosJ.DCR.enLevel;
					break;
				default:
					continue;
					break;
				}

				PRFM.enLevel = max(PRFM.enLevel_1, PRFM.enLevel_2);

				max_enLevel = max(max_enLevel, (double)PRFM.enLevel);
				min_enLevel = min(min_enLevel, (double)PRFM.enLevel);

				if (PRFM.enLevel_1 != EN_LEVEL_INVALID && bShowLevel[PRFM.enLevel_1] == FALSE) PRFM.enLevel_1 = EN_LEVEL_INVALID;
				if (PRFM.enLevel_2 != EN_LEVEL_INVALID && bShowLevel[PRFM.enLevel_2] == FALSE) PRFM.enLevel_2 = EN_LEVEL_INVALID;
				if (PRFM.enLevel != EN_LEVEL_INVALID && bShowLevel[PRFM.enLevel] == FALSE)	PRFM.enLevel = EN_LEVEL_INVALID;

				if (PRFM.enLevel != EN_LEVEL_INVALID)
				{
					m_nSeisPrfmElementSummation++;
					m_nSeisPrfmElement[PRFM.enLevel + 1]++;
				}

				if (PRFM.enLevel_1 != EN_LEVEL_INVALID)
				{
					m_nSeisPrfmNodeSummation++;
					m_nSeisPrfmNode[PRFM.enLevel_1 + 1]++;
				}

				if (PRFM.enLevel_2 != EN_LEVEL_INVALID)
				{
					m_nSeisPrfmNodeSummation++;
					m_nSeisPrfmNode[PRFM.enLevel_2 + 1]++;
				}

				m_EKeyList.Add(elem_key);
				m_mSeisPerform.SetAt(elem_key, PRFM);
				has_content = TRUE;
			}
			else
			{
				ASSERT(0);
			}
		}
	}

	// BraceTruss
	BOOL bBraceTruss = (m_SeisStlPerformComponent_1st == SEIS_STL_PFM_COMP_AXIAL || m_SeisStlPerformComponent_1st == SEIS_STL_PFM_COMP_REPRESENT);
	if (bBraceTruss && m_bCtShowBrceTrss)
	{
		T_MATD_D MatdD;
		T_EVAL1ST_STLBRAC EvalBrac;
		for (i = 0; i < elem_num; i++)
		{
			elem_key = gm->m_EKeyListActive[i];
			if (m_pDoc->m_pAttrCtrl2->ExistMisa(elem_key)) continue; // Strut 제외
			m_pDoc->m_pAttrCtrl->GetElem(elem_key, elem_data);
			if (m_pDoc->m_pAttrCtrl->GetMemberType(elem_key) != D_MBTP_BRACE) continue;
			if (!m_pDoc->m_pAttrCtrl->IsTruss(elem_data.eltyp)) continue;
			if (Tool.GetSeisComponentType(elem_key) == D_SCMT_TYPE_NONE) continue;
			if (!m_pDoc->m_pAttrCtrl->GetDgnGenMatd(elem_key, MatdD)) continue;
			if (MatdD.Type != _LSX(S)) continue;
			if (!SeisEval.GetInstance()->GetSeisEval1stRsltStlBrac(elem_key, EvalBrac)) continue;

			int nLcomIndex = -1;
			if (gm->m_LoadCaseKey == 0)
			{
				EN_LEVEL enLevelMax = EN_LEVEL_IO;
				for (int k = 0; k < EvalBrac.aEvalLcom.GetSize(); k++)
				{
					if (EvalBrac.aEvalLcom[k].enLevel < enLevelMax) continue;
					enLevelMax = EvalBrac.aEvalLcom[k].enLevel;
					nLcomIndex = k;
				}
			}
			else
			{
				for (int k = 0; k < EvalBrac.aEvalLcom.GetSize(); k++)
				{
					if (EvalBrac.aEvalLcom[k].LcomK != gm->m_LoadCaseKey) continue;
					nLcomIndex = k;
					break;
				}
			}

			if (nLcomIndex >= 0)
			{
				switch (m_SeisStlPerformComponent_1st)
				{
				case SEIS_STL_PFM_COMP_AXIAL:
				case SEIS_STL_PFM_COMP_REPRESENT:
					PRFM.enLevel_1 = EvalBrac.aEvalLcom[nLcomIndex].PosI.DCR.enLevel;
					PRFM.enLevel_2 = EvalBrac.aEvalLcom[nLcomIndex].PosJ.DCR.enLevel;
					break;
				default:
					continue;
					break;
				}

				PRFM.enLevel = max(PRFM.enLevel_1, PRFM.enLevel_2);

				max_enLevel = max(max_enLevel, (double)PRFM.enLevel);
				min_enLevel = min(min_enLevel, (double)PRFM.enLevel);

				if (PRFM.enLevel_1 != EN_LEVEL_INVALID && bShowLevel[PRFM.enLevel_1] == FALSE) PRFM.enLevel_1 = EN_LEVEL_INVALID;
				if (PRFM.enLevel_2 != EN_LEVEL_INVALID && bShowLevel[PRFM.enLevel_2] == FALSE) PRFM.enLevel_2 = EN_LEVEL_INVALID;
				if (PRFM.enLevel != EN_LEVEL_INVALID && bShowLevel[PRFM.enLevel] == FALSE)	PRFM.enLevel = EN_LEVEL_INVALID;

				if (PRFM.enLevel != EN_LEVEL_INVALID)
				{
					m_nSeisPrfmElementSummation++;
					m_nSeisPrfmElement[PRFM.enLevel + 1]++;
				}

				if (PRFM.enLevel_1 != EN_LEVEL_INVALID)
				{
					m_nSeisPrfmNodeSummation++;
					m_nSeisPrfmNode[PRFM.enLevel_1 + 1]++;
				}

				if (PRFM.enLevel_2 != EN_LEVEL_INVALID)
				{
					m_nSeisPrfmNodeSummation++;
					m_nSeisPrfmNode[PRFM.enLevel_2 + 1]++;
				}

				m_EKeyList.Add(elem_key);
				m_mSeisPerform.SetAt(elem_key, PRFM);
				has_content = TRUE;
			}
			else
			{
				ASSERT(0);
			}
		}
	}

	if (!has_content)
	{
		max_enLevel = min_enLevel = 0.0;
	}
	m_dMaxValue = max_enLevel;
	m_dMinValue = min_enLevel;

	CArray<CString, CString&> aLegendString;
	CArray<double, double&>  aLegendValue;
	aLegendString.SetSize(5);
	aLegendValue.SetSize(5);
	CString strLegend = _T("");
	double dValue = 0.;
	strLegend = _T(" IO");				dValue = 0.0; aLegendString.SetAt(0, strLegend); aLegendValue.SetAt(0, dValue);
	strLegend = _T(" LS");				dValue = 0.5; aLegendString.SetAt(1, strLegend); aLegendValue.SetAt(1, dValue);
	strLegend = _T(" CP");				dValue = 1.5; aLegendString.SetAt(2, strLegend); aLegendValue.SetAt(2, dValue);
	strLegend = _T(" Collapse");	dValue = 2.5; aLegendString.SetAt(3, strLegend); aLegendValue.SetAt(3, dValue);
	strLegend = _T("");						dValue = 3.5; aLegendString.SetAt(4, strLegend); aLegendValue.SetAt(4, dValue);

	if (m_pContourEngine)m_pContourEngine->MakeRankMap(aLegendString, aLegendValue);
	else                m_pContourEngine = new CContourEngine(aLegendString, aLegendValue);

	m_bSeisPerformDataSet = TRUE;
	gm->m_pMyView->EndWaitCursor();
	return TRUE;
}

BOOL CDesignEngine::MakeSeisMasonryPerform1stData()
{
	DECLARE_GPSMD();

	gm->m_nLgdMaxValKey = 0;
	gm->m_nLgdMinValKey = 0;

	int			i, elem_num;
	double	max_enLevel = -DBL_MAX, min_enLevel = DBL_MAX;
	BOOL		has_content = FALSE;
	T_ELEM_K	elem_key;
	//	T_ELEM_D	elem_data;
	T_PRFM_RESULT PRFM;

	if (!gm->m_bLoadDataSet)return FALSE;
	int nGPSMode = (gm->m_GPSInstruction != -1) ? gm->m_GPSInstruction : gm->m_GPSMode;

	gm->m_pMyView->BeginWaitCursor();

	m_EKeyList.RemoveAll();
	m_mSeisPerform.RemoveAll();
	elem_num = gm->m_EKeyListActive.GetSize();

	CDesignEngine::m_nSeisPrfmElementSummation = 0;
	memset(CDesignEngine::m_nSeisPrfmElement, 0, sizeof(CDesignEngine::m_nSeisPrfmElement));

	CDesignEngine::m_nSeisPrfmNodeSummation = 0;
	memset(CDesignEngine::m_nSeisPrfmNode, 0, sizeof(CDesignEngine::m_nSeisPrfmNode));

	BOOL bShowLevel[4] = { m_bCtShowIO, m_bCtShowLS, m_bCtShowCP, m_bCtShowCL };

	CSeisEvalDataTool Tool;
	CSeisEvalWrapper SeisEval;

	CMapEx<T_ELEM_K, T_ELEM_K, T_ELEM_K, T_ELEM_K> mInfillTrussElemK; mInfillTrussElemK.RemoveAll();
	T_ELEM_K_LIST aInfillTrussElemK;
	Tool.GetEvalInfillAllKeyList(aInfillTrussElemK);
	mInfillTrussElemK.InitHashTable(aInfillTrussElemK.GetSize() + 1);
	for (int i = 0; i < aInfillTrussElemK.GetSize(); i++)
	{
		mInfillTrussElemK.SetAt(aInfillTrussElemK[i], aInfillTrussElemK[i]);
	}

	T_EVAL1ST_INFILL EvalInfill;
	T_SCMT_D ScmtD;
	for (i = 0; i < elem_num; i++)
	{
		elem_key = gm->m_EKeyListActive[i];
		if (!mInfillTrussElemK.Exist(elem_key)) continue;
		if (Tool.GetSeisComponentType(elem_key) == D_SCMT_TYPE_NONE) continue;
		if (!SeisEval.GetInstance()->GetSeisEval1stRsltInfWall(elem_key, EvalInfill)) continue;

		int nLcomIndex = -1;
		if (gm->m_LoadCaseKey == 0)
		{
			EN_LEVEL enLevelMax = EN_LEVEL_IO;
			for (int k = 0; k < EvalInfill.aEvalLcom.GetSize(); k++)
			{
				if (EvalInfill.aEvalLcom[k].enLevel < enLevelMax) continue;
				enLevelMax = EvalInfill.aEvalLcom[k].enLevel;
				nLcomIndex = k;
			}
		}
		else
		{
			for (int k = 0; k < EvalInfill.aEvalLcom.GetSize(); k++)
			{
				if (EvalInfill.aEvalLcom[k].LcomK != gm->m_LoadCaseKey) continue;
				nLcomIndex = k;
				break;
			}
		}

		if (nLcomIndex >= 0)
		{
			switch (m_SeisMasonryPerformComponent_1st)
			{
			case SEIS_MASONRY_PFM_COMP_AXIAL:
				PRFM.enLevel_1 = EvalInfill.aEvalLcom[nLcomIndex].EndI.DCR.enLevel;
				PRFM.enLevel_2 = EvalInfill.aEvalLcom[nLcomIndex].EndJ.DCR.enLevel;
				break;
			default:
				continue;
				break;
			}

			PRFM.enLevel = max(PRFM.enLevel_1, PRFM.enLevel_2);

			max_enLevel = max(max_enLevel, (double)PRFM.enLevel);
			min_enLevel = min(min_enLevel, (double)PRFM.enLevel);

			if (PRFM.enLevel_1 != EN_LEVEL_INVALID && bShowLevel[PRFM.enLevel_1] == FALSE) PRFM.enLevel_1 = EN_LEVEL_INVALID;
			if (PRFM.enLevel_2 != EN_LEVEL_INVALID && bShowLevel[PRFM.enLevel_2] == FALSE) PRFM.enLevel_2 = EN_LEVEL_INVALID;
			if (PRFM.enLevel != EN_LEVEL_INVALID && bShowLevel[PRFM.enLevel] == FALSE)	PRFM.enLevel = EN_LEVEL_INVALID;

			if (PRFM.enLevel != EN_LEVEL_INVALID)
			{
				m_nSeisPrfmElementSummation++;
				m_nSeisPrfmElement[PRFM.enLevel + 1]++;
			}

			if (PRFM.enLevel_1 != EN_LEVEL_INVALID)
			{
				m_nSeisPrfmNodeSummation++;
				m_nSeisPrfmNode[PRFM.enLevel_1 + 1]++;
			}

			if (PRFM.enLevel_2 != EN_LEVEL_INVALID)
			{
				m_nSeisPrfmNodeSummation++;
				m_nSeisPrfmNode[PRFM.enLevel_2 + 1]++;
			}

			m_EKeyList.Add(elem_key);
			m_mSeisPerform.SetAt(elem_key, PRFM);
			has_content = TRUE;
		}
		else
		{
			ASSERT(0);
		}
	}

	if (!has_content)
	{
		max_enLevel = min_enLevel = 0.0;
	}
	m_dMaxValue = max_enLevel;
	m_dMinValue = min_enLevel;

	CArray<CString, CString&> aLegendString;
	CArray<double, double&>  aLegendValue;
	aLegendString.SetSize(5);
	aLegendValue.SetSize(5);
	CString strLegend = _T("");
	double dValue = 0.;
	strLegend = _T(" IO");				dValue = 0.0; aLegendString.SetAt(0, strLegend); aLegendValue.SetAt(0, dValue);
	strLegend = _T(" LS");				dValue = 0.5; aLegendString.SetAt(1, strLegend); aLegendValue.SetAt(1, dValue);
	strLegend = _T(" CP");				dValue = 1.5; aLegendString.SetAt(2, strLegend); aLegendValue.SetAt(2, dValue);
	strLegend = _T(" Collapse");	dValue = 2.5; aLegendString.SetAt(3, strLegend); aLegendValue.SetAt(3, dValue);
	strLegend = _T("");						dValue = 3.5; aLegendString.SetAt(4, strLegend); aLegendValue.SetAt(4, dValue);

	if (m_pContourEngine)m_pContourEngine->MakeRankMap(aLegendString, aLegendValue);
	else                m_pContourEngine = new CContourEngine(aLegendString, aLegendValue);

	m_bSeisPerformDataSet = TRUE;
	gm->m_pMyView->EndWaitCursor();
	return TRUE;
}

BOOL CDesignEngine::MakeSeisPerform2ndData(BOOL bRCResult, BOOL bSteelResult, BOOL bMasonryResult, ecPerfomType eType)
{
	DECLARE_GPSMD();

	gm->m_nLgdMaxValKey = 0;
	gm->m_nLgdMinValKey = 0;

	int			i, elem_num;
	double	max_enLevel = -DBL_MAX, min_enLevel = DBL_MAX;
	BOOL		has_content = FALSE;
	T_ELEM_K	elem_key;
	T_ELEM_D	elem_data;
	T_PRFM_RESULT PRFM;

	if (!gm->m_bLoadDataSet)return FALSE;
	int nGPSMode = (gm->m_GPSInstruction != -1) ? gm->m_GPSInstruction : gm->m_GPSMode;

	gm->m_pMyView->BeginWaitCursor();

	m_EKeyList.RemoveAll();
	m_mSeisPerform.RemoveAll();
	elem_num = gm->m_EKeyListActive.GetSize();

	CDesignEngine::m_nSeisPrfmElementSummation = 0;
	memset(CDesignEngine::m_nSeisPrfmElement, 0, sizeof(CDesignEngine::m_nSeisPrfmElement));

	CDesignEngine::m_nSeisPrfmNodeSummation = 0;
	memset(CDesignEngine::m_nSeisPrfmNode, 0, sizeof(CDesignEngine::m_nSeisPrfmNode));

	BOOL bConsiderAddStep = FALSE;
	T_POAS_D PoasD;
	if (gm->m_nCurAdditionalStepIdx != -1 && m_pDoc->m_pAttrCtrl->ExistPoas() &&
		m_pDoc->m_pAttrCtrl->GetPoas(PoasD) && D_POAS_NUMPOAS > gm->m_nCurAdditionalStepIdx)
		bConsiderAddStep = TRUE;

	CMapEx<T_ELEM_K, T_ELEM_K, T_ELEM_K, T_ELEM_K> mMInfElemK; mMInfElemK.RemoveAll();
	if (m_pDoc->m_pAttrCtrl2->IsSemeMethod4Masonry())
	{
		CSeisEvalDataTool Tool;
		T_ELEM_K_LIST aMInfElemK;
		BOOL bConsiderSeisComponentType = TRUE;
		Tool.GetEvalInfilledConColmKeyList(aMInfElemK, bConsiderSeisComponentType);
		mMInfElemK.InitHashTable(aMInfElemK.GetSize() + 1);
		for (int i = 0; i < aMInfElemK.GetSize(); i++)
		{
			mMInfElemK.SetAt(aMInfElemK[i], aMInfElemK[i]);
		}
	}

	CMap<unsigned int, unsigned int, UINT, UINT> mElemK_SerialBeamHinge;
	mElemK_SerialBeamHinge.InitHashTable(HASHSIZEELEM);
	CMap<unsigned int, unsigned int, UINT, UINT> mElemK_SerialWallHinge;
	mElemK_SerialWallHinge.InitHashTable(HASHSIZEELEM);

	// 요소 - Beam-Column/Wall힌지 Serial 번호 (element rotation을 가져오기 위해 필요하대요.)
	CArray<T_PHGE_K, T_PHGE_K> aPhgeK;
	m_pDoc->m_pAttrCtrl->GetPhgeKeyList(aPhgeK);
	int nSerialBeam = 1;
	int nSerialWall = 1;
	for (int i = 0; i < aPhgeK.GetSize(); i++)
	{
		T_PHGE_D PhgeD;
		m_pDoc->m_pAttrCtrl->GetPhge(aPhgeK[i], PhgeD);
		T_PHGT_D PhgtD;
		m_pDoc->m_pAttrCtrl->GetPhgt(PhgeD.HingeTypeK, PhgtD);

		switch (PhgtD.nElemType)
		{
		case D_PHGT_ELEM_BEAM:
			mElemK_SerialBeamHinge.SetAt(aPhgeK[i].key.objK, nSerialBeam++);
			break;
		case D_PHGT_ELEM_WALL:
			mElemK_SerialWallHinge.SetAt(aPhgeK[i].key.objK, nSerialWall++);
			break;
		default:
			break;
		}
	}

	BOOL bShowLevel[4] = { m_bCtShowIO, m_bCtShowLS, m_bCtShowCP, m_bCtShowCL };

	UINT enLevel_1 = -1, enLevel_2 = -1;

	T_EVAL2ND_PHNE Eval2ndPhneD; Eval2ndPhneD.Initialize();
	T_POLC_K PolcK = gm->m_LoadCaseKey;
	UINT nStep = gm->m_nCurStep - 1;

	CString strMatlType = _LSX(S);
	if (bRCResult) strMatlType = _LSX(C);
	if (bMasonryResult) strMatlType = _LSX(U);

	const int nCount = 9;
	BOOL bOutput[nCount] = { 
		m_bCtShowBeam && !bMasonryResult, 		
		m_bCtShowColm && !bMasonryResult, //column
		m_bCtShowWall && bRCResult, 
		m_bCtShowBrceBeam && bSteelResult,
		m_bCtShowBrceTrss && bSteelResult, 
		m_bCtShowColmM && !bMasonryResult, //column(M)
		m_bCtShowStrut && bMasonryResult, 
		m_bCtShowBrceTrss && bSteelResult, 
		m_bCtShowBrceTrss && bSteelResult };
	int nElemType[nCount] = { BEAM_EL, BEAM_EL, WALL_EL, BEAM_EL, TRUSS_EL, BEAM_EL, TRUSS_EL, TRTENS_EL, TRCOMP_EL };
	int nMembType[nCount] = { D_MBTP_BEAM, D_MBTP_COLUMN, D_MBTP_WALL, D_MBTP_BRACE, D_MBTP_BRACE, D_MBTP_COLUMN, D_MBTP_BRACE, D_MBTP_BRACE, D_MBTP_BRACE };
	UINT nPhge[nCount] = { D_PHGE_BEAMCOLUMN, D_PHGE_BEAMCOLUMN, D_PHGE_WALL, D_PHGE_BEAMCOLUMN, D_PHGE_TRUSS, D_PHGE_BEAMCOLUMN, D_PHGE_TRUSS, D_PHGE_TRUSS, D_PHGE_TRUSS };
	BOOL bMatlChk[nCount] = { TRUE, TRUE, FALSE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE };

	const bool bConsiderSeisComponentType = [](int nSemeMethod)
	{
		switch (nSemeMethod)
		{
		case D_SEME_METHOD_KISTEC2013:
		case D_SEME_METHOD_KISTEC2019:
		case D_SEME_METHOD_MOE2018:
		case D_SEME_METHOD_MOE2019:
			return true;
		case D_SEME_METHOD_AIK_G_001_2021:
			return false;
		default:
			ASSERT(0);
			return false;
		}
	}(m_pDoc->m_pAttrCtrl2->GetSemeMethod());

	CSeisEvalWrapper SeisEval;
	CSeisEvalDataTool Tool;

	int nSeisPerformComponent_2nd = bMasonryResult ? m_SeisMasonryPerformComponent_2nd : m_SeisPerformComponent_2nd;
	T_MATL_D MatlD;
	T_SCMT_D ScmtD;
	T_REBB_D RebbD;
	T_REBC_D RebcD;
	for (int nOrder = 0; nOrder < nCount; nOrder++)
	{
		if (!bOutput[nOrder]) continue;

		BOOL bColm = FALSE;
		BOOL bColmM = FALSE;
		if (nOrder == 1) bColm = TRUE;
		if (nOrder == 5) bColmM = TRUE;

		for (i = 0; i < elem_num; i++)
		{
			elem_key = gm->m_EKeyListActive[i];
			if (bColm&&mMInfElemK.Exist(elem_key)) continue;
			if (bColmM && !mMInfElemK.Exist(elem_key)) continue;
			m_pDoc->m_pAttrCtrl->GetElem(elem_key, elem_data);
			if (bConsiderSeisComponentType && Tool.GetSeisComponentType(elem_key) == D_SCMT_TYPE_NONE) continue;
			if (nElemType[nOrder] != elem_data.eltyp) continue;
			if (nMembType[nOrder] != m_pDoc->m_pAttrCtrl->GetMemberType(elem_key)) continue;

			if (bRCResult)
			{
				switch (nMembType[nOrder])
				{
				case D_MBTP_BEAM:
					if (!m_pDoc->m_pAttrCtrl->GetRebbByElemK(elem_key, RebbD)) continue;
					break;
				case D_MBTP_COLUMN:
					if (!m_pDoc->m_pAttrCtrl->GetRebcByElemK(elem_key, RebcD)) continue;
					break;
				default:
					break;
				}
			}

			if (bMatlChk[nOrder])
			{
				if (!m_pDoc->m_pAttrCtrl->GetMatl(elem_data.elmat, MatlD)) continue;
				if (MatlD.Type != strMatlType) continue;
			}

			T_PHGT_D PhgtD;
			if (!m_pDoc->m_pAttrCtrl->GetPhgtByElemK(elem_key, PhgtD)) continue;
			if (eType == ecPerfomType::SEIS_PO_LUMPED)
			{
				if (PhgtD.nDefinition == D_PHGT_DEFINITION_MPHI_DIST) continue;
			}
			else if (eType == ecPerfomType::SEIS_PO_FIBER)
			{
				if (PhgtD.nDefinition != D_PHGT_DEFINITION_MPHI_DIST) continue;
			}

			UINT nPhgeType = nPhge[nOrder];
			UINT nSerialAgxp = 0;
			switch (nPhgeType)
			{
			case D_PHGE_BEAMCOLUMN:
			{
				if (!mElemK_SerialBeamHinge.Lookup(elem_key, nSerialAgxp))
				{
					nSerialAgxp = 0;
				}
			}
			break;
			case D_PHGE_WALL:
			{
				if (!mElemK_SerialWallHinge.Lookup(elem_key, nSerialAgxp))
				{
					nSerialAgxp = 0;
				}
			}
			break;
			default:
			break;
			}

			if (eType == ecPerfomType::SEIS_PO_LUMPED)
			{
				if (nSeisPerformComponent_2nd == DUTL_FACTOR_ALL)
				{
					BOOL bExist = FALSE;
					PRFM.enLevel_1 = 0, PRFM.enLevel_2 = 0;
					for (int nComp = 0; nComp < 6; nComp++)
					{
						if (!m_pDoc->m_pPostCtrl->GetPhnePushover4SeisEval(nPhgeType, elem_key, gm->m_nCurAdditionalStepIdx, PolcK, nStep, 0, nComp, Eval2ndPhneD)) continue;
						if (!Eval2ndPhneD.bDeformGood) continue;

						PRFM.enLevel_1 = max(Eval2ndPhneD.enLevel, PRFM.enLevel_1);
						if (nPhgeType != D_PHGE_TRUSS)
						{
							if (!m_pDoc->m_pPostCtrl->GetPhnePushover4SeisEval(nPhgeType, elem_key, gm->m_nCurAdditionalStepIdx, PolcK, nStep, 1, nComp, Eval2ndPhneD)) continue;
							PRFM.enLevel_2 = max(Eval2ndPhneD.enLevel, PRFM.enLevel_2);
						}

						bExist = TRUE;
					}
					if (!bExist) continue;
				}
				else
				{
					if (!m_pDoc->m_pPostCtrl->GetPhnePushover4SeisEval(nPhgeType, elem_key, gm->m_nCurAdditionalStepIdx, PolcK, nStep, 0, nSeisPerformComponent_2nd, Eval2ndPhneD)) continue;
					if (!Eval2ndPhneD.bDeformGood) continue;

					PRFM.enLevel_1 = Eval2ndPhneD.enLevel;
					if (nPhgeType != D_PHGE_TRUSS)
					{
						if (!m_pDoc->m_pPostCtrl->GetPhnePushover4SeisEval(nPhgeType, elem_key, gm->m_nCurAdditionalStepIdx, PolcK, nStep, 1, nSeisPerformComponent_2nd, Eval2ndPhneD)) continue;
						PRFM.enLevel_2 = Eval2ndPhneD.enLevel;
					}
				}
			}
			else if (eType == ecPerfomType::SEIS_PO_FIBER)
			{
				switch (nPhgeType)
				{
				case D_PHGE_BEAMCOLUMN:
				{
					T_EVAL2ND_COLM Eval2nd;
					SeisEval.GetInstance()->CalcSeisEval2ndRsltConColmFiber(elem_key, PolcK, nStep, gm->m_nCurAdditionalStepIdx, nSerialAgxp, Eval2nd);

					if(nSeisPerformComponent_2nd == DUTL_FACTOR_ALL)
						PRFM.Set(max(Eval2nd.PosI.Diry.Moment.enLevel, Eval2nd.PosI.Dirz.Moment.enLevel), 
								 max(Eval2nd.PosJ.Diry.Moment.enLevel, Eval2nd.PosJ.Dirz.Moment.enLevel));
					else if(nSeisPerformComponent_2nd == DUTL_FACTOR_RY)
						PRFM.Set(Eval2nd.PosI.Diry.Moment.enLevel, Eval2nd.PosJ.Diry.Moment.enLevel);
					else if(nSeisPerformComponent_2nd == DUTL_FACTOR_RZ)
						PRFM.Set(Eval2nd.PosI.Dirz.Moment.enLevel, Eval2nd.PosJ.Dirz.Moment.enLevel);
				}
				break;
				case D_PHGE_WALL:
				{
					T_EVAL2ND_WALL Eval2nd;
					SeisEval.GetInstance()->CalcSeisEval2ndRsltConWallFiber(elem_key, PolcK, nStep, gm->m_nCurAdditionalStepIdx, nSerialAgxp, Eval2nd);

					if (nSeisPerformComponent_2nd != DUTL_FACTOR_ALL && nSeisPerformComponent_2nd != DUTL_FACTOR_RY) continue;
					PRFM.Set(Eval2nd.PosI.PhneD[4].enLevel, Eval2nd.PosJ.PhneD[4].enLevel);
				}
				break;
				default:
					ASSERT(0);
					break;
				}
			}
			else ASSERT(0);

			PRFM.enLevel = nPhgeType == D_PHGE_TRUSS ? PRFM.enLevel_1 : max(PRFM.enLevel_1, PRFM.enLevel_2);
			max_enLevel = max(max_enLevel, (double)PRFM.enLevel);
			min_enLevel = min(min_enLevel, (double)PRFM.enLevel);

			auto lamda_SetPrfmlevel = [&](UINT& enLevel, bool bSetElem)
			{
				if (enLevel != EN_LEVEL_INVALID && bShowLevel[enLevel] == FALSE) { enLevel = EN_LEVEL_INVALID; return; }
				if (bSetElem) { m_nSeisPrfmElementSummation++; m_nSeisPrfmElement[enLevel + 1]++; }
				else { m_nSeisPrfmNodeSummation++; m_nSeisPrfmNode[enLevel + 1]++; }
			};
			lamda_SetPrfmlevel(PRFM.enLevel, true);
			lamda_SetPrfmlevel(PRFM.enLevel_1, false);
			lamda_SetPrfmlevel(PRFM.enLevel_2, false);

			m_EKeyList.Add(elem_key);
			m_mSeisPerform.SetAt(elem_key, PRFM);
			has_content = TRUE;
		}
	}

	if (!has_content)
	{
		max_enLevel = min_enLevel = 0.0;
	}
	m_dMaxValue = max_enLevel;
	m_dMinValue = min_enLevel;

	CArray<CString, CString&> aLegendString;
	CArray<double, double&>  aLegendValue;
	aLegendString.SetSize(5);
	aLegendValue.SetSize(5);
	CString strLegend = _T("");
	double dValue = 0.;
	strLegend = _T(" IO");			dValue = 0.0; aLegendString.SetAt(0, strLegend); aLegendValue.SetAt(0, dValue);
	strLegend = _T(" LS");			dValue = 0.5; aLegendString.SetAt(1, strLegend); aLegendValue.SetAt(1, dValue);
	strLegend = _T(" CP");			dValue = 1.5; aLegendString.SetAt(2, strLegend); aLegendValue.SetAt(2, dValue);
	strLegend = _T(" Collapse");	dValue = 2.5; aLegendString.SetAt(3, strLegend); aLegendValue.SetAt(3, dValue);
	strLegend = _T("");				dValue = 3.5; aLegendString.SetAt(4, strLegend); aLegendValue.SetAt(4, dValue);

	if (m_pContourEngine)m_pContourEngine->MakeRankMap(aLegendString, aLegendValue);
	else                m_pContourEngine = new CContourEngine(aLegendString, aLegendValue);

	m_bSeisPerformDataSet = TRUE;
	gm->m_pMyView->EndWaitCursor();
	return TRUE;
}

BOOL CDesignEngine::MakeSeisPerform2ndDataTH(BOOL bRCResult, ecPerfomType eType)
{
	DECLARE_GPSMD();
	DECLARE_DBDOC();

	gm->m_nLgdMaxValKey = 0;
	gm->m_nLgdMinValKey = 0;

	if (!gm->m_bLoadDataSet) return FALSE;
	int nGPSMode = (gm->m_GPSInstruction != -1) ? gm->m_GPSInstruction : gm->m_GPSMode;

	gm->m_pMyView->BeginWaitCursor();

	m_EKeyList.RemoveAll();
	m_mSeisPerform.RemoveAll();
	int elem_num = gm->m_EKeyListActive.GetSize();

	CDesignEngine::m_nSeisPrfmElementSummation = 0;
	memset(CDesignEngine::m_nSeisPrfmElement, 0, sizeof(CDesignEngine::m_nSeisPrfmElement));

	CDesignEngine::m_nSeisPrfmNodeSummation = 0;
	memset(CDesignEngine::m_nSeisPrfmNode, 0, sizeof(CDesignEngine::m_nSeisPrfmNode));

	/// Select History Load Case
	m_pDoc->m_pPostCtrl->SelectThis(gm->m_LoadCaseKey);
	
	CMap<unsigned int, unsigned int, UINT, UINT> mElemK_SerialBeamHinge;
	mElemK_SerialBeamHinge.InitHashTable(HASHSIZEELEM);
	CMap<unsigned int, unsigned int, UINT, UINT> mElemK_SerialWallHinge;
	mElemK_SerialWallHinge.InitHashTable(HASHSIZEELEM);

	// 요소 - Beam-Column/Wall힌지 Serial 번호 (element rotation을 가져오기 위해 필요하대요.)
	CArray<T_IEHG_K, T_IEHG_K> aIehgK;
	m_pDoc->m_pAttrCtrl->GetIehgKeyList(aIehgK);
	int nSerialBeam = 1;
	int nSerialWall = 1;
	for (int i = 0; i < aIehgK.GetSize(); i++)
	{
		T_IEHG_K IehgK = aIehgK[i];

		T_IEHG_D IehgD;
		if (!m_pDoc->m_pAttrCtrl->GetIehg(IehgK, IehgD)) continue;
		T_IEHP_D IehpD;
		if (!m_pDoc->m_pAttrCtrl->GetIehp(IehgD.IehpKey, IehpD)) continue;

		switch (IehpD.nHingeType)
		{
		case D_IEHP_HTYP_BEAM_LUMP:
		case D_IEHP_HTYP_BEAM_DIST:
			mElemK_SerialBeamHinge.SetAt(IehgK, nSerialBeam++);
			break;
		case D_IEHP_HTYP_WALL:
			mElemK_SerialWallHinge.SetAt(IehgK, nSerialWall++);
			break;
		default:
			break;
		}
	}

	if (gm->m_LoadCaseType == D_LOADCASE_CB_JSONFILE)
	{
		if (!MakeSeisPerform2ndDataTH_FromJson(eType)) return FALSE;
		if (m_EKeyList.GetSize() == 0 || m_mSeisPerform.GetSize() == 0) { ASSERT(0); return FALSE; }
	}	
	else
	{
		std::map<int, std::set<T_ELEM_K>> mapElem;
		if (!GetSeisPerformElemListTH(eType, mapElem)) return FALSE;

		double max_enLevel = -DBL_MAX;
		double min_enLevel = DBL_MAX;
		BOOL has_content = FALSE;

		BOOL bShowLevel[4] = { m_bCtShowIO, m_bCtShowLS, m_bCtShowCP, m_bCtShowCL };
		T_THIS_K ThisK = gm->m_LoadCaseKey;

		const int nCount = 3;
		BOOL bOutput[nCount] = { m_bCtShowBeam, m_bCtShowColm, m_bCtShowWall };
		int nElemType[nCount] = { BEAM_EL, BEAM_EL, WALL_EL };
		int nMembType[nCount] = { D_MBTP_BEAM, D_MBTP_COLUMN, D_MBTP_WALL };

		CSeisEvalWrapper SeisEval;
		int nOutComponent = m_SeisPerformComponent_2nd;
		T_MATL_D MatlD;
		T_REBB_D RebbD;
		T_REBC_D RebcD;
		for (int nOrder = 0; nOrder < nCount; nOrder++)
		{
			if (!bOutput[nOrder]) continue;

			const int nOutMembType = nMembType[nOrder];
			auto mitr = mapElem.find(nOutMembType);
			if (mitr == mapElem.end()) continue;

			for (auto ElemK : mitr->second)
			{
				T_PRFM_RESULT PRFM;
				PRFM.enLevel_1 = 0, PRFM.enLevel_2 = 0;
				if (eType == ecPerfomType::SEIS_TH_LUMPED)
				{
					auto lamda_CalcSeisEvalLumped = [&](int nComp, int bCompAll)
					{
						UINT unLevelI = EN_LEVEL_IO, unLevelJ = EN_LEVEL_IO;
						if (!SeisEval.GetInstance()->GetLevelSeisEval2ndConFramTH(ElemK, ThisK, m_nHingeTimeIndex, nComp, unLevelI, unLevelJ)) return false;
						PRFM.Set(max(unLevelI, PRFM.enLevel_1), max(unLevelJ, PRFM.enLevel_2));
						return true;
					};

					if (nOutComponent == DUTL_FACTOR_ALL)
					{
						BOOL bExist = FALSE;
						for (int nComp = 0; nComp < 6; nComp++)
						{
							if(!lamda_CalcSeisEvalLumped(nComp, true)) continue;
							bExist = TRUE;
						}
						if (!bExist) continue;
					}
					else
					{
						if (!lamda_CalcSeisEvalLumped(nOutComponent, false)) continue;
					}
				}
				else if (eType == ecPerfomType::SEIS_TH_FIBER)
				{
					auto lamda_CalcSeisEvalColm = [&](int nSerial)
					{
						T_EVAL2ND_COLM Eval2nd;
						if (!SeisEval.GetInstance()->CalcSeisEval2ndRsltConColmFiberTH(ElemK, ThisK, m_nHingeTimeIndex, nSerial, Eval2nd)) return false;
						if (nOutComponent == DUTL_FACTOR_ALL)
						{
							UINT unLevelI = max(Eval2nd.PosI.Diry.Moment.enLevel, Eval2nd.PosI.Dirz.Moment.enLevel);
							UINT unLevelJ = max(Eval2nd.PosJ.Diry.Moment.enLevel, Eval2nd.PosJ.Dirz.Moment.enLevel);
							PRFM.Set(max(unLevelI, PRFM.enLevel_1), max(unLevelJ, PRFM.enLevel_2));
						}
						else if (nOutComponent == DUTL_FACTOR_RY)
							PRFM.Set(Eval2nd.PosI.Diry.Moment.enLevel, Eval2nd.PosJ.Diry.Moment.enLevel);
						else if (nOutComponent == DUTL_FACTOR_RZ)
							PRFM.Set(Eval2nd.PosI.Dirz.Moment.enLevel, Eval2nd.PosJ.Dirz.Moment.enLevel);
						else { ASSERT(0); return false; }
						return true;
					};

					auto lamda_CalcSeisEvalWall = [&](int nSerial)
					{
						T_EVAL2ND_WALL Eval2nd;
						if (!SeisEval.GetInstance()->CalcSeisEval2ndRsltConWallFiberTH(ElemK, ThisK, m_nHingeTimeIndex, nSerial, Eval2nd)) return false;
						if (nOutComponent == DUTL_FACTOR_ALL)						
							PRFM.Set(max(Eval2nd.PosI.PhneD[4].enLevel, PRFM.enLevel_1), max(Eval2nd.PosJ.PhneD[4].enLevel, PRFM.enLevel_2));						
						else if (nOutComponent == DUTL_FACTOR_RY)
							PRFM.Set(Eval2nd.PosI.PhneD[4].enLevel, Eval2nd.PosJ.PhneD[4].enLevel);						
						else { ASSERT(0); return false; }
						return true;
					};

					UINT nSerialAgxt = 0;
					PRFM.enLevel_1 = 0, PRFM.enLevel_2 = 0;
					if (nOutMembType == D_MBTP_COLUMN)
					{
						if (!mElemK_SerialBeamHinge.Lookup(ElemK, nSerialAgxt))
							nSerialAgxt = 0;
						if (!lamda_CalcSeisEvalColm(nSerialAgxt)) continue;
					}
					else if (nOutMembType == D_MBTP_WALL)
					{						
						if (!mElemK_SerialWallHinge.Lookup(ElemK, nSerialAgxt))
							nSerialAgxt = 0;
						if (!lamda_CalcSeisEvalWall(nSerialAgxt)) continue;
					}
				}
				else ASSERT(0);
				
				PRFM.enLevel = max(PRFM.enLevel_1, PRFM.enLevel_2);
				max_enLevel = max(max_enLevel, (double)PRFM.enLevel);
				min_enLevel = min(min_enLevel, (double)PRFM.enLevel);
				
				auto lamda_SetPrfmlevel = [&](UINT& enLevel, bool bSetElem)
				{
					if (enLevel != EN_LEVEL_INVALID && bShowLevel[enLevel] == FALSE) { enLevel = EN_LEVEL_INVALID; return; }
					if (bSetElem) {	m_nSeisPrfmElementSummation++; m_nSeisPrfmElement[enLevel + 1]++; }
					else          {	m_nSeisPrfmNodeSummation++; m_nSeisPrfmNode[enLevel + 1]++;	}					
				};
				lamda_SetPrfmlevel(PRFM.enLevel, true);
				lamda_SetPrfmlevel(PRFM.enLevel_1, false);
				lamda_SetPrfmlevel(PRFM.enLevel_2, false);

				m_EKeyList.Add(ElemK);
				m_mSeisPerform.SetAt(ElemK, PRFM);
				has_content = TRUE;
			}
		}	
		if (!has_content) { max_enLevel = min_enLevel = 0.0; }
		m_dMaxValue = max_enLevel;
		m_dMinValue = min_enLevel;
	}

	CArray<CString, CString&> aLegendString;
	CArray<double, double&>  aLegendValue;
	aLegendString.SetSize(5);
	aLegendValue.SetSize(5);
	CString strLegend = _T("");
	double dValue = 0.;
	strLegend = _T(" IO");			dValue = 0.0; aLegendString.SetAt(0, strLegend); aLegendValue.SetAt(0, dValue);
	strLegend = _T(" LS");			dValue = 0.5; aLegendString.SetAt(1, strLegend); aLegendValue.SetAt(1, dValue);
	strLegend = _T(" CP");			dValue = 1.5; aLegendString.SetAt(2, strLegend); aLegendValue.SetAt(2, dValue);
	strLegend = _T(" Collapse");	dValue = 2.5; aLegendString.SetAt(3, strLegend); aLegendValue.SetAt(3, dValue);
	strLegend = _T("");				dValue = 3.5; aLegendString.SetAt(4, strLegend); aLegendValue.SetAt(4, dValue);

	if (m_pContourEngine)	m_pContourEngine->MakeRankMap(aLegendString, aLegendValue);
	else					m_pContourEngine = new CContourEngine(aLegendString, aLegendValue);
	m_bSeisPerformDataSet = TRUE;
	
	gm->m_pMyView->EndWaitCursor();
	return TRUE;
}

bool CDesignEngine::GetSeisPerformElemListTH(ecPerfomType eType, std::map<int, std::set<T_ELEM_K>>& mapElem, BOOL bOnlyAllMaxMin/* = FALSE*/)
{
	DECLARE_GPSMD();
	DECLARE_DBDOC();

	/////////////////////////////////////////////////////////////////////////
	/// 동적탄소성 결과가 있는 평가대상 요소 추가 	
	BOOL bSelectOutputOnly = TRUE;
	if (bOnlyAllMaxMin) bSelectOutputOnly = FALSE;
	else bSelectOutputOnly = GetLoadMinMaxType(m_nHingeTimeIndex) == LOADTYPE_NORMAL ? TRUE : FALSE;

	CArray<UINT, UINT> arInElastElem;
	pDoc->m_pPostCtrl->GetThisInfo()->GetInelasticDynHingeElemList(arInElastElem, bSelectOutputOnly);
	const int nSize = arInElastElem.GetSize();
	std::set<T_ELEM_K> stElemK;
	for (int i = 0; i < nSize; ++i)
		stElemK.insert(arInElastElem[i]);

	////////////////////////////////////////////////////////////////////////////////////////
	// valid elements
	mapElem.clear();
	if (m_bCtShowBeam) mapElem[D_MBTP_BEAM] = std::set<T_ELEM_K>();
	if (m_bCtShowColm) mapElem[D_MBTP_COLUMN] = std::set<T_ELEM_K>();
	if (m_bCtShowWall) mapElem[D_MBTP_WALL] = std::set<T_ELEM_K>();

	T_ELEM_D ElemD;
	T_MATL_D MatlD;
	T_REBB_D RebbD;
	T_REBC_D RebcD;
	T_IEHG_D IehgD;
	T_IEHP_D IehpD;
	for (int i = 0; i < gm->m_EKeyListActive.GetSize(); i++)
	{
		T_ELEM_K ElemK = gm->m_EKeyListActive[i];
		if (stElemK.find(ElemK) == stElemK.end())continue;
		if (!m_pDoc->m_pAttrCtrl->GetElem(ElemK, ElemD)) continue;
		if (!m_pDoc->m_pAttrCtrl->GetMatl(ElemD.elmat, MatlD)) continue;
		if (MatlD.Type != _LSX(C)) continue;

		int nMembType = m_pDoc->m_pAttrCtrl->GetMemberType(ElemK);
		if (ElemD.eltyp == BEAM_EL)
		{
			if (nMembType == D_MBTP_BEAM)
			{
				if (!m_bCtShowBeam) continue;
				if (!m_pDoc->m_pAttrCtrl->GetRebbByElemK(ElemK, RebbD)) continue;
			}
			else if (nMembType == D_MBTP_COLUMN)
			{
				if (!m_bCtShowColm) continue;
				if (!m_pDoc->m_pAttrCtrl->GetRebcByElemK(ElemK, RebcD)) continue;
			}
			else { ASSERT(0); continue; }
		}
		else if (ElemD.eltyp == WALL_EL)
		{
			if (!m_bCtShowWall) continue;
		}

		if (!m_pDoc->m_pAttrCtrl->GetIehg(ElemK, IehgD)) continue;
		if (!m_pDoc->m_pAttrCtrl->GetIehp(IehgD.IehpKey, IehpD)) continue;
				
		if (eType == ecPerfomType::SEIS_TH_LUMPED && IehpD.nDefinition == 0) {}
		else if (eType == ecPerfomType::SEIS_TH_FIBER && IehpD.nDefinition == 1) {}
		else if (eType == ecPerfomType::SEIS_TH_AXIAL)
		{
			if (ElemD.eltyp == BEAM_EL && (IehpD.nHingeType == 1 && IehpD.nDefinition == 1)) {}
			else if (ElemD.eltyp == WALL_EL && (IehpD.nHingeType == 4 && IehpD.nDefinition == 1)) {}
			else continue;
		}
		else continue;

		auto mitr = mapElem.find(nMembType);
		if (mitr == mapElem.end()) { ASSERT(0); continue; }
		mapElem[nMembType].insert(ElemK);
	}
	return true;
}

BOOL CDesignEngine::MakeSeisPerform2ndDataTH_FromJson(ecPerfomType eType)
{
	DECLARE_GPSMD();
	DECLARE_DBDOC();

	//////////////////////////////////////////////////////////////////////////	
	std::map<int, std::set<T_ELEM_K>> mapElem;
	if (!GetSeisPerformElemListTH(eType, mapElem, TRUE)) return false;
	
	////////////////////////////////////////////////////////////////////////////////////////
	BOOL bShowLevel[4] = { m_bCtShowIO, m_bCtShowLS, m_bCtShowCP, m_bCtShowCL };
	int nOutComponent = m_SeisPerformComponent_2nd;
	////////////////////////////////////////////////////////////////////////////////////////
	// filter
	T_THJI_D DataThji;
	if (!m_pDoc->m_pAttrCtrl->GetThji(gm->m_LoadCaseKey, DataThji)) return false;

	int nCalcMinMax = 0; // -1 : min, 0 : normal, 1 : max
	enStep nStep = enStep::ALL;
	if (m_nMaxMin == GPS_STEP_MAX) { nStep = enStep::MAX; nCalcMinMax = 1; }
	else if (m_nMaxMin == GPS_STEP_MIN) { nStep = enStep::MIN; nCalcMinMax = -1; }

	CArray<int, int> aStoryK;
	std::map<T_ELEM_K, T_PRFM_RESULT> mapPerform;
	////////////////////////////////////////////////////////////////////////////////////////

	CSeisResultAvgCalculator Calc;
	CSeisResultsReCalculator ReCalc;
	if (m_pJsonMgr == nullptr) m_pJsonMgr = new CJsonPostDataManager();
	////////////////////////////////////////////////////////////////////////////////////////

	m_EKeyList.RemoveAll();
	m_mSeisPerform.RemoveAll();
	m_mapFiberAsValue.clear();
	m_dMaxValue = -DBL_MAX;
	m_dMinValue = DBL_MAX;
	if ( eType == ecPerfomType::SEIS_TH_LUMPED || eType == ecPerfomType::SEIS_TH_FIBER )
	{
		////////////////////////////////////////////////////////////////////////////////////////		
		std::vector<BOOL> svCompBeam(DUTL_FACTOR_ALL, FALSE), svCompCol(DUTL_FACTOR_ALL, FALSE), svCompWall(DUTL_FACTOR_ALL, FALSE);
		BOOL bAllComp = ( nOutComponent == DUTL_FACTOR_ALL );
		{
			if ( m_bCtShowBeam )
			{
				svCompBeam[DUTL_FACTOR_DZ] = ( bAllComp || nOutComponent == DUTL_FACTOR_DZ );
				svCompBeam[DUTL_FACTOR_RY] = ( bAllComp || nOutComponent == DUTL_FACTOR_RY );
			}
			if ( m_bCtShowColm )
			{
				if ( eType == ecPerfomType::SEIS_TH_LUMPED )
				{
					svCompCol[DUTL_FACTOR_DX] = ( bAllComp || nOutComponent == DUTL_FACTOR_DX );
					svCompCol[DUTL_FACTOR_DY] = ( bAllComp || nOutComponent == DUTL_FACTOR_DY );
					svCompCol[DUTL_FACTOR_DZ] = ( bAllComp || nOutComponent == DUTL_FACTOR_DZ );
					svCompCol[DUTL_FACTOR_RY] = ( bAllComp || nOutComponent == DUTL_FACTOR_RY );
					svCompCol[DUTL_FACTOR_RZ] = ( bAllComp || nOutComponent == DUTL_FACTOR_RZ );
				}
				else if ( eType == ecPerfomType::SEIS_TH_FIBER )
				{
					svCompCol[DUTL_FACTOR_RY] = ( bAllComp || nOutComponent == DUTL_FACTOR_RY );
					svCompCol[DUTL_FACTOR_RZ] = ( bAllComp || nOutComponent == DUTL_FACTOR_RZ );
				}
				else ASSERT(0);
			}
			if ( m_bCtShowWall )
			{
				svCompWall[DUTL_FACTOR_RY] = ( bAllComp || nOutComponent == DUTL_FACTOR_RY );
			}
		}

		auto lamda_SetLevel = [&](T_EVAL2ND_PHNE& PhneD, bool bPartI, int nDOF, bool bFiberWall, OUT T_PRFM_RESULT& PRFM)
		{
			UINT nLevel = (nDOF < 3) ? PhneD.enLevel_Force : PhneD.enLevel_Deform;
			if ( bFiberWall )
			{
				nLevel = PhneD.enLevel; // FiberWall RA 에서만 enLevel 을 사용함
			}
			if (bPartI)	PRFM.enLevel_1 = max(PRFM.enLevel_1, nLevel);
			else 		PRFM.enLevel_2 = max(PRFM.enLevel_2, nLevel);
		};
		auto lamda_SetPerfom = [&](T_ELEM_K elemK, bool bPartI, int nDOF, T_EVAL2ND_PHNE& PhneD, bool bFiberWall)
		{
			auto mitr = mapPerform.find(elemK);
			if (mitr == mapPerform.end())
			{
				T_PRFM_RESULT data; data.Initialize();
				lamda_SetLevel(PhneD, bPartI, nDOF, bFiberWall, data);
				mapPerform[elemK] = data;
			}
			else
			{
				lamda_SetLevel(PhneD, bPartI, nDOF, bFiberWall, mitr->second);
			}
		};

		if (eType == ecPerfomType::SEIS_TH_LUMPED)
		{
			if (m_bCtShowBeam)
			{
				MAP_CONBEAM mapData;
				auto mitr = mapElem.find(D_MBTP_BEAM);
				if (mitr == mapElem.end()) { ASSERT(0); return false; }
				if (!m_pJsonMgr->GetData(gm->m_LoadCaseKey, aStoryK, nStep, mitr->second, mapData)) return false;

				for (auto& data : mapData)
				{
					for (int i = 0; i < DUTL_FACTOR_ALL; i++)
					{
						if (!svCompBeam[i]) continue;
						std::vector<T_SEIS_PFRM_CONBEAM_D> vAvgResult;
						if (!Calc.AvgSeisPBDTHLumpedBeam(DataThji, nCalcMinMax, i, data.second, vAvgResult)) continue;
						if (!ReCalc.ReCalcLumpedBeam(i, vAvgResult)) continue;

						for (auto& rst : vAvgResult)
							lamda_SetPerfom(rst.ElemK, rst.bPartI, i, rst.EvalPos.PhneD[i], false);
					}
				}
			}
			if (m_bCtShowColm)
			{
				MAP_CONCOLM mapData;
				auto mitr = mapElem.find(D_MBTP_COLM);
				if (mitr == mapElem.end()) { ASSERT(0); return false; }
				if (!m_pJsonMgr->GetData(gm->m_LoadCaseKey, aStoryK, nStep, mitr->second, enPostTableType::LUMP_COLM, mapData)) return false;

				for (auto& data : mapData)
				{
					for (int i = 0; i < DUTL_FACTOR_ALL; i++)
					{
						if (!svCompCol[i]) continue;
						std::vector<T_SEIS_PFRM_CONCOLM_D> vAvgResult;
						if (!Calc.AvgSeisPBDTHLumpedColm(DataThji, nCalcMinMax, i, data.second, vAvgResult)) continue;
						if (!ReCalc.ReCalcLumpedColm(i, vAvgResult)) continue;

						for (auto& rst : vAvgResult)
							lamda_SetPerfom(rst.ElemK, rst.bPartI, i, rst.EvalPos.PhneD[i], false);
					}
				}
			}
		}
		else if (eType == ecPerfomType::SEIS_TH_FIBER)
		{
			if (m_bCtShowColm)
			{
				MAP_CONCOLM mapData;
				auto mitr = mapElem.find(D_MBTP_COLM);
				if (mitr == mapElem.end()) { ASSERT(0); return false; }
				if (!m_pJsonMgr->GetData(gm->m_LoadCaseKey, aStoryK, nStep, mitr->second, enPostTableType::FIBERC_ANGLE, mapData)) return false;

				for (auto& data : mapData)
				{
					for (int i = 0; i < DUTL_FACTOR_ALL; i++)
					{
						if (!svCompCol[i]) continue;
						T_SEIS_PFRM_CONCOLM_D rst;
						if (!Calc.AvgSeisPBDTHFiberColmRA(DataThji, nCalcMinMax, data.second, rst)) continue;
						if (!ReCalc.ReCalcFiberColmRA(rst)) continue;

						lamda_SetPerfom(rst.ElemK, rst.bPartI, i, rst.EvalPos.PhneD[i], false);
					}
				}
			}
			if (m_bCtShowWall)
			{
				MAP_CONWALL mapData;
				auto mitr = mapElem.find(D_MBTP_WALL);
				if (mitr == mapElem.end()) { ASSERT(0); return false; }

				T_KEY_LIST aWallK;
				aWallK.SetSize(mitr->second.size());
				int idx = 0;
				for (auto key : mitr->second)
					aWallK[idx++] = key;

				if (!m_pJsonMgr->GetData(gm->m_LoadCaseKey, aStoryK, nStep, aWallK, mapData)) return false;
				for (auto& data : mapData)
				{
					for (int i = 0; i < DUTL_FACTOR_ALL; i++)
					{
						if (!svCompWall[i]) continue;
						T_SEIS_PFRM_CONWALL_D rst;
						if (!Calc.AvgSeisPBDTHFiberWallRA(DataThji, nCalcMinMax, data.second, rst)) continue;
						if (!ReCalc.ReCalcFiberWallRA(rst)) continue;
						T_ELEM_D  ElemD;
						if ( !m_pDoc->m_pAttrCtrl->GetElem(rst.ElemK, ElemD) ) { ASSERT(0); continue; }
						rst.ElemK = m_pDoc->m_pAttrCtrl->GetElemKByWallIDStorK(ElemD.nWallId, rst.StorK);
						lamda_SetPerfom(rst.ElemK, true, i, rst.EvalPos.PhneD[i], true);
						lamda_SetPerfom(rst.ElemK, false, i, rst.EvalPos.PhneD[i], true);
					}
				}
			}
		}

		for (auto& data : mapPerform)
		{
			T_PRFM_RESULT PRFM = data.second;
			PRFM.enLevel = max(PRFM.enLevel_1, PRFM.enLevel_2);
			m_dMaxValue = max(m_dMaxValue, (double)PRFM.enLevel);
			m_dMinValue = min(m_dMinValue, (double)PRFM.enLevel);
			auto lamda_SetPrfmlevel = [&](UINT& enLevel, bool bSetElem)
			{
				if (enLevel != EN_LEVEL_INVALID && bShowLevel[enLevel] == FALSE) { enLevel = EN_LEVEL_INVALID; return; }
				if (bSetElem) { m_nSeisPrfmElementSummation++; m_nSeisPrfmElement[enLevel + 1]++; }
				else { m_nSeisPrfmNodeSummation++; m_nSeisPrfmNode[enLevel + 1]++; }
			};
			lamda_SetPrfmlevel(PRFM.enLevel, true);
			lamda_SetPrfmlevel(PRFM.enLevel_1, false);
			lamda_SetPrfmlevel(PRFM.enLevel_2, false);

			m_EKeyList.Add(data.first);
			m_mSeisPerform.SetAt(data.first, PRFM);
		}

		if ( !mapPerform.size() )
		{
			m_dMaxValue = m_dMinValue = 0.0;
		}
	}
	else if (eType == ecPerfomType::SEIS_TH_AXIAL)
	{
		if (m_nSeisFiberMatl == enMatl::ALL) ASSERT(0);
		
		////////////////////////////////////////////////
		std::set<UINT> stWallID;
		auto mitr = mapElem.find(D_MBTP_WALL);
		if (mitr != mapElem.end())
		{
			for (auto elemK : mitr->second)
			{
				UINT nWall_id = m_pDoc->m_pPostCtrl->GetUserWallId(elemK);
				stWallID.insert(nWall_id);
			}
		}
		////////////////////////////////////////////////

		BOOL bConc = (m_nSeisFiberMatl == enMatl::CONF_CONC || m_nSeisFiberMatl == enMatl::UNCONF_CONC);
		MAP_AXLSTRN mapData;
		if (m_bCtShowColm)
		{
			auto itr = mapElem.find(D_MBTP_COLM);
			if (!m_pJsonMgr->GetData(gm->m_LoadCaseKey, aStoryK, itr->second, m_nSeisFiberMatl, mapData)) return false;
		}
		if (m_bCtShowWall)
		{
			auto itr = mapElem.find(D_MBTP_WALL);
			if (!m_pJsonMgr->GetData(gm->m_LoadCaseKey, aStoryK, itr->second, stWallID, m_nSeisFiberMatl, mapData)) return false;
		}

		bool bRatio = (m_nDispText == 1);
		std::pair<T_ELEM_K, double> paMax, paMin;
		paMax.second = -DBL_MAX;
		paMin.second = DBL_MAX;		
		for (auto& data : mapData)
		{
			if ( !data.second.size() )
			{
				ASSERT(0);
				continue;
			}

			T_ELEM_AXIAL_STRAIN rst;
			if (!Calc.AvgSeisPBDTHFiberColmWallAS(DataThji.nType, data.second, rst)) continue;
			T_ELEM_AXIAL_STRAIN_BASE& baseD = bConc ? rst.ConAS : rst.BarAS;
			if (!baseD.bValid) continue;		

			T_STOR_K storyK = m_pDoc->m_pAttrCtrl->GetStorKey(rst.strStoryName);
			if(rst.nMembK == 0) rst.nMembK = m_pDoc->m_pAttrCtrl->GetElemKByWallIDStorK(rst.nWallID, storyK);

			auto itr = m_mapFiberAsValue.find(rst.nMembK);
			
			std::pair<double, double> pa;
			pa.first = (bRatio) ? baseD.dStrainRatio : baseD.dStrain;
			pa.second = baseD.dStrainLimit;
			if (itr == m_mapFiberAsValue.end())
			{
				m_mapFiberAsValue[rst.nMembK] = pa;
			}
			else
			{
				if (m_nMaxMin == GPS_STEP_ALL && dgn::AbsLT(pa.first, itr->second.first)) continue;
				else if (m_nMaxMin == GPS_STEP_MAX && dgn::LT(pa.first, itr->second.first)) continue;
				else if (m_nMaxMin == GPS_STEP_MIN && dgn::MT(pa.first, itr->second.first)) continue;
				//
				m_mapFiberAsValue[rst.nMembK] = pa;
			}

			if (paMax.second < pa.first)
			{
				paMax.first = rst.nMembK;
				paMax.second = pa.first;
			}
			if (paMin.second > pa.first)
			{
				paMin.first = rst.nMembK;
				paMin.second = pa.first;
			}
		}

		for(auto& itr : m_mapFiberAsValue)
			m_EKeyList.Add(itr.first);

		gm->m_nLgdMaxValKey = paMax.first;
		gm->m_nLgdMinValKey = paMin.first;
		m_dMaxValue = paMax.second;
		m_dMinValue = paMin.second;
		if (m_mapFiberAsValue.size() == 0)
		{
			m_dMaxValue = m_dMinValue = 0.0;
		}
	}
	else ASSERT(0);

	return TRUE;
}

int CDesignEngine::GetLoadMinMaxType(int nTimeIndex)
{
	DECLARE_GPSMD();
	DECLARE_DBDOC();

	CArray<double, double> aTimeStep;
	pDoc->m_pAttrCtrl->GetTimeStep(gm->m_LoadCaseKey, aTimeStep);
	int nTimeStepCount = aTimeStep.GetSize();

	int nLoadMinMaxType = LOADTYPE_NORMAL;
	if (nTimeStepCount <= nTimeIndex)
	{
		if (nTimeIndex == nTimeStepCount)
		{
			nLoadMinMaxType = LOADTYPE_ALL;
		}
		else if (nTimeIndex == nTimeStepCount + 1)
		{
			nLoadMinMaxType = LOADTYPE_MAX;
		}
		else if (nTimeIndex == nTimeStepCount + 2)
		{
			nLoadMinMaxType = LOADTYPE_MIN;
		}
	}
	return nLoadMinMaxType;
}

void CDesignEngine::DrawSeisPerform_Frame(CDC *pDC, T_ELEM_K ekey)
{
	T_PRFM_RESULT Prfm;
	if (!m_mSeisPerform.Lookup(ekey, Prfm)) return;

	DECLARE_GPSMD();
	DECLARE_DPTDR();

	BOOL			fl_bak;
	C3DPoint	node3D_i, node3D_j;

	POSITION pos;
	CArray<GPS_3DPT_LISTP, GPS_3DPT_LISTP>	polygon_list, polygon_list_J;

	fl_bak = pDR->m_bFrameLine;
	pDR->m_bFrameLine = TRUE;

	T_MEMB_K MembK = 0;
	if (gm->GetDrawPOHingeByMember() && m_pDoc->m_pAttrCtrl->GetMembAssigned(ekey, MembK))
	{
		// [PMS 5388] 내진성능평가 - 멤버별 힌지 결과출력
		T_MEMB_D MembD;
		m_pDoc->m_pAttrCtrl->GetMemb(MembK, MembD);

		T_ELEM_K ElemK_I = MembD.aElemList[0];
		T_ELEM_K ElemK_J = MembD.aElemList[MembD.aElemList.GetSize() - 1];

		// 조적허리벽 고려 시 출력위치 변경
		if (gm->m_pDeformEngine->GetColumnByInfillStrut() == TRUE)
		{
			T_PARTIALCOLUMN_DATA data;
			if (gm->m_pDeformEngine->m_columnDividerByIS.GetData(MembK, data))
			{
				enum { D_DOF_FX = 0, D_DOF_FY, D_DOF_FZ, D_DOF_RX, D_DOF_RY, D_DOF_RZ };
				switch (m_SeisPerformComponent_2nd)
				{
				case DUTL_FACTOR_DY:
				case DUTL_FACTOR_RZ:
					ElemK_I = data.inPlane.ElemK_I;
					ElemK_J = data.inPlane.ElemK_J;
					break;
				case DUTL_FACTOR_DZ:
				case DUTL_FACTOR_RY:
					ElemK_I = data.outOfPlane.ElemK_I;
					ElemK_J = data.outOfPlane.ElemK_J;
					break;
				case DUTL_FACTOR_DX:
				case DUTL_FACTOR_RX:
					break; // 기존 위치 그대로
				}
			}
		}

		if (m_bDeformedShapeContour)
		{
			gm->m_pDeformEngine->GetDeformedShapeElement(ElemK_I, &polygon_list, NULL, NULL);
			gm->m_pDeformEngine->GetDeformedShapeElement(ElemK_J, &polygon_list_J, NULL, NULL);
		}
		else
		{
			gm->GetShapeElement(ElemK_I, polygon_list, NULL, NULL, NULL);
			gm->GetShapeElement(ElemK_J, polygon_list_J, NULL, NULL, NULL);
		}

		// Tail 값을 J요소의 J단으로 교체
		polygon_list[0]->RemoveTail();
		polygon_list[0]->AddTail(polygon_list_J[0]->GetTail());
	}
	else
	{
		if (m_bDeformedShapeContour)	gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, NULL);
		else												gm->GetShapeElement(ekey, polygon_list, NULL);
	}

	pos = polygon_list[0]->GetHeadPosition();
	node3D_i = polygon_list[0]->GetNext(pos);
	node3D_j = polygon_list[0]->GetNext(pos);

	DrawSolidBall4SeisPerform(pDC, node3D_i, node3D_j, Prfm);

	FreeMemoryPolyList(&polygon_list);
	pDR->m_bFrameLine = fl_bak;
}

void CDesignEngine::DrawRCPerform_Wall(CDC *pDC, T_ELEM_K ekey)
{
	T_PRFM_RESULT Prfm;
	if (!m_mSeisPerform.Lookup(ekey, Prfm)) return;

	DECLARE_GPSMD();
	DECLARE_DPTDR();

	BOOL bDSCont = m_bDeformedShapeContour;

	CArray<T_ELEM_K, T_ELEM_K> ElemKeyList;
	m_pDoc->m_pAttrCtrl->GetKeyListBy_WallID_ByStor(ElemKeyList, ekey);

	for (int i = 0; i < ElemKeyList.GetSize(); i++)
	{
		// 요소를 먼저그린다 
		if (bDSCont)	gm->m_pDeformEngine->DrawDeformedElement(pDC, ElemKeyList[i]);
		else		gm->GPSDrawElement(pDC, ElemKeyList[i]);
	}

	C3DPoint BottmPt, TopPt;
	GetCenterPosition4Wall_ByWallID_ByStor(ElemKeyList, TopPt, BottmPt);

	DrawSolidBall4SeisPerform(pDC, BottmPt, TopPt, Prfm);
}

void CDesignEngine::GetCenterPosition4Wall_ByWallID_ByStor(CArray<T_ELEM_K, T_ELEM_K>& ElemKeyList, C3DPoint& TopPt, C3DPoint& BottmPt)
{
	DECLARE_GPSMD();

	BOOL bDSCont = m_bDeformedShapeContour;

	m_pDoc->m_pPostCtrl->SortWallElemByConnect(ElemKeyList);

	POSITION		pos;
	CArray<GPS_3DPT_LISTP, GPS_3DPT_LISTP>	PolyList;
	CArray<GPS_BOOL_ARRYP, GPS_BOOL_ARRYP>  edge_list;
	CArray<GPS_UINT_ARRYP, GPS_UINT_ARRYP>	VertexNode;

	int			order1, order2;
	T_ELEM_D	edata;
	C3DPoint	bi_3D, bj_3D, ti_3D, tj_3D, bc_3D, tc_3D, bc_3D2, tc_3D2, DrawPoint;
	CPoint		text_p, top, bot, cnt;

	C3DPoint BotFirstElemLeft, TopFirstElemLeft;
	C3DPoint BotLastElemRight, TopLastElemRight;
	unsigned int FirstElem, LastElem;
	m_pDoc->m_pAttrCtrl->GetWallIDFirstLastElem(ElemKeyList, FirstElem, LastElem, FALSE);
	for (int i = 0; i < ElemKeyList.GetSize(); i++)
	{
		if (bDSCont)	gm->m_pDeformEngine->GetDeformedShapeElement(ElemKeyList[i], &PolyList, &edge_list, &VertexNode);
		else		gm->GetShapeElement(ElemKeyList[i], PolyList, &edge_list, NULL, &VertexNode);

		order1 = GetNodeOrder(VertexNode[0]->GetAt(0), edata, 4);
		order2 = GetNodeOrder(VertexNode[0]->GetAt(1), edata, 4);

		pos = PolyList[0]->GetHeadPosition();
		bi_3D = PolyList[0]->GetNext(pos);
		bj_3D = PolyList[0]->GetNext(pos);
		tj_3D = PolyList[0]->GetNext(pos);
		ti_3D = PolyList[0]->GetNext(pos);

		if (ElemKeyList[i] == FirstElem)
		{
			BotFirstElemLeft = bi_3D;
			TopFirstElemLeft = ti_3D;
		}

		if (ElemKeyList[i] == LastElem)
		{
			BotLastElemRight = bj_3D;
			TopLastElemRight = tj_3D;
		}

		FreeMemoryPolyList(&PolyList, &edge_list, &VertexNode);
	}

	BottmPt.Set((BotFirstElemLeft.x + BotLastElemRight.x) / 2.0, (BotFirstElemLeft.y + BotLastElemRight.y) / 2.0, (BotFirstElemLeft.z + BotLastElemRight.z) / 2.0);

	TopPt.Set((TopFirstElemLeft.x + TopLastElemRight.x) / 2.0, (TopFirstElemLeft.y + TopLastElemRight.y) / 2.0, (TopFirstElemLeft.z + TopLastElemRight.z) / 2.0);
}

void CDesignEngine::DrawSolidBall4SeisPerform(CDC* pDC, C3DPoint& node3D_i, C3DPoint& node3D_j, T_PRFM_RESULT& Prfm)
{
	DECLARE_GPSMD();

	C3DPoint node3D_i2, node3D_j2;
	CBrush RankBrush, *pOldBrush;
	CBrush RankBrush2, *pOldBrush2;

	// Display Option > Size > Label Symbol에서 크기 조정 50을 기준으로 함... 
	CDispOptMgr* pDispOpt = CDBDoc::GetDocPoint()->m_pDispOpt;
	COptSizeObjNames CSON;
	CDispOptSizeObj* pGLabelFactor = pDispOpt->GetSize(CSON.m_LabelSymbol);
	ASSERT(pGLabelFactor);
	double dLoadSymbolSize = (double)pGLabelFactor->m_CurVal;
	double dUnitLength = pDC->GetDeviceCaps(LOGPIXELSX)*0.12*dLoadSymbolSize / 50.0;

	CUtilFuncs::GetInnerLinePoint(0.1, 0.9, node3D_i, node3D_j, node3D_i2);
	CUtilFuncs::GetInnerLinePoint(0.9, 0.1, node3D_i, node3D_j, node3D_j2);

	BOOL bShow_1 = FALSE;
	BOOL bShow_2 = FALSE;

	if (m_nDisplayMode == 0)
	{
		if (Prfm.enLevel_1 >= EN_LEVEL_IO && Prfm.enLevel_1 <= EN_LEVEL_CL) bShow_1 = TRUE;
		if (Prfm.enLevel_2 >= EN_LEVEL_IO && Prfm.enLevel_2 <= EN_LEVEL_CL) bShow_2 = TRUE;
	}
	else
	{
		if (Prfm.enLevel >= EN_LEVEL_IO && Prfm.enLevel <= EN_LEVEL_CL)
		{
			bShow_1 = TRUE;
			bShow_2 = TRUE;
		}
	}

	double enLevel_1 = double(Prfm.enLevel_1);
	double enLevel_2 = double(Prfm.enLevel_2);

	if (gm->m_AnimEngine.m_bAnimateContour)
	{
		enLevel_1 = m_pContourEngine->GetSubFrameValue(enLevel_1, gm->m_AnimEngine.GetAnimationFactor(TRUE));
		enLevel_2 = m_pContourEngine->GetSubFrameValue(enLevel_2, gm->m_AnimEngine.GetAnimationFactor(TRUE));
	}

	if (bShow_1)
	{
		RankBrush.CreateSolidBrush(m_pContourEngine->GetValueColor(enLevel_1));
		pOldBrush = pDC->SelectObject(&RankBrush);
		DrawPoint(pDC, node3D_i2, dUnitLength);
		pDC->SelectObject(pOldBrush);
	}

	if (bShow_2)
	{
		RankBrush2.CreateSolidBrush(m_pContourEngine->GetValueColor(enLevel_2));
		pOldBrush2 = pDC->SelectObject(&RankBrush2);
		DrawPoint(pDC, node3D_j2, dUnitLength);
		pDC->SelectObject(pOldBrush2);
	}
}

#if defined(__OLD_OUTPUT_VALUE)
void CDesignEngine::OutputSeisAxialStrain(CDC *pDC)
{
	DECLARE_DBDOC();
	DECLARE_GPSMD();
	DECLARE_DPTDR();
	DECLARE_DPTRD();
	DECLARE_DPTTX();

	int	  i, nElemN;
	T_ELEM_D  ElemD;
	GPS_INTG_ARRY  TypeList;
	GPS_ATOM_ARRYR AtomList;

	BOOL bEscapePressed = FALSE;
	if (!gm->m_bContour) { gm->GPSDrawOriginal(pDC); return; }

	pTX->m_NumberDecimalPoint = gm->m_NumberDecimalPoint;
	pTX->m_NumberFont = gm->m_NumberFont;

	CFont	ft, *old_ft;
	ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
	old_ft = (CFont *)pDC->SelectObject(&ft);

	if (m_bDeformedShapeContour) TypeList.Add(gm->m_MinOTID + OBJECT_TYPE_DEFORMED);
	else		                    TypeList.Add(gm->m_MinOTID + OBJECT_TYPE_ORIGINAL);
	gm->m_pGPSCtrl->GetZSortedList(TypeList, gm->m_EKeyListVisible_Mirror, AtomList);
	nElemN = AtomList.GetSize();

	CMap<UINT, UINT, UINT, UINT> mUsedWallK; mUsedWallK.RemoveAll();
	mUsedWallK.InitHashTable(11);
	CArray<T_ELEM_K, T_ELEM_K> ElemKeyList; ElemKeyList.RemoveAll();
	UINT nTemp = 0;

	T_ELEM_K ElemK = NULL;
	for (i = 0; i < nElemN; i++)
	{
		ElemK = AtomList[i].m_OKey;
		if (gm->m_pGPSCtrl->WatchEscKeyPress())break;
		if (gm->m_pGPSCtrl->IsZoomAllState() ||
			gm->m_pGPSCtrl->IsObjectInClientWindow(AtomList[i].m_OType, ElemK))
		{
			if (gm->m_pGPSCtrl->IsActiveElem(ElemK))
			{
				if (!pDoc->m_pAttrCtrl->GetElem(ElemK, ElemD))continue;
				OutputSeisAxialStrainSub(pDC, ElemK);
			}
		}
	}
	pDC->SelectObject(old_ft);
	ft.DeleteObject();
}
#else
void CDesignEngine::OutputSeisAxialStrain(CDC* pDC)
{
	DECLARE_DBDOC();
	DECLARE_GPSMD();
	DECLARE_DPTDR();
	DECLARE_DPTRD();
	DECLARE_DPTTX();

	int	  i, nElemN;
	T_ELEM_D  ElemD;
	GPS_INTG_ARRY  TypeList;
	GPS_ATOM_ARRYR AtomList;

	BOOL bEscapePressed = FALSE;
	if (!gm->m_bContour) { gm->GPSDrawOriginal(pDC); return; }

	pTX->m_NumberDecimalPoint = gm->m_NumberDecimalPoint;
	pTX->m_NumberFont = gm->m_NumberFont;

	GPostTextOut TextOutModel;
	TextOutModel.SetDC(pDC);
	TextOutModel.StartSeisAxialVal();
	TextOutModel.Font4SeisAxial(gm, 0);


	if (m_bDeformedShapeContour) TypeList.Add(gm->m_MinOTID + OBJECT_TYPE_DEFORMED);
	else		                    TypeList.Add(gm->m_MinOTID + OBJECT_TYPE_ORIGINAL);
	gm->m_pGPSCtrl->GetZSortedList(TypeList, gm->m_EKeyListVisible_Mirror, AtomList);
	nElemN = AtomList.GetSize();

	CMap<UINT, UINT, UINT, UINT> mUsedWallK; mUsedWallK.RemoveAll();
	mUsedWallK.InitHashTable(11);
	CArray<T_ELEM_K, T_ELEM_K> ElemKeyList; ElemKeyList.RemoveAll();
	UINT nTemp = 0;

	T_ELEM_K ElemK = NULL;
	for (i = 0; i < nElemN; i++)
	{
		ElemK = AtomList[i].m_OKey;
		if (gm->m_pGPSCtrl->WatchEscKeyPress())break;
		if (gm->m_pGPSCtrl->IsZoomAllState() ||
			gm->m_pGPSCtrl->IsObjectInClientWindow(AtomList[i].m_OType, ElemK))
		{
			if (gm->m_pGPSCtrl->IsActiveElem(ElemK))
			{
				if (!pDoc->m_pAttrCtrl->GetElem(ElemK, ElemD))continue;
				OutputSeisAxialStrainSub(pDC, ElemK);
			}
		}
	}
	TextOutModel.DeleteFont();
	TextOutModel.EndSeisAxialVal();
}
#endif
void CDesignEngine::DrawSeisAxialStrainContour(CDC *pDC)
{
	DECLARE_GPSMD();
	DECLARE_DBDOC();

	int			  i, ElemNum;
	T_ELEM_D	ElemD;
	CPen		  ElemPen, *pOldPen;
	CArray<int, int>  TypeList;
	CArray<GRE_Atom, GRE_Atom&> AtomList;

	BOOL bEscapePressed = FALSE;
	T_MIRE_K mkey;

	if (!gm->m_bContour) { gm->GPSDrawOriginal(pDC); return; }

	if (m_bDeformedShapeContour)
	{
		if (gm->m_pDeformEngine == NULL)return;
		TypeList.Add(gm->m_MinOTID + OBJECT_TYPE_DEFORMED);
	}
	else
		TypeList.Add(gm->m_MinOTID + OBJECT_TYPE_ORIGINAL);

	if (gm->m_DOPT.DR.m_bFrameLine) // wire frame
		ElemPen.CreatePen(PS_SOLID, gm->m_DOPT.DR.nElemWire*1.7, m_pContourEngine->m_ElemColor);
	else
		ElemPen.CreatePen(PS_SOLID, gm->m_DOPT.DR.nElemHddn, m_pContourEngine->m_ElemColor);

	pOldPen = (CPen *)pDC->SelectObject(&ElemPen);

	gm->m_pGPSCtrl->GetZSortedList(TypeList, gm->m_EKeyListVisible_Mirror, AtomList);
	ElemNum = AtomList.GetSize();

	CMapEx<int, int, int, int> mElemType;
	mElemType.SetAt(TRUSS_EL, TRUSS_EL);
	mElemType.SetAt(TRTENS_EL, TRTENS_EL);
	mElemType.SetAt(TRCOMP_EL, TRCOMP_EL);
	mElemType.SetAt(BEAM_EL, BEAM_EL);
	mElemType.SetAt(WALL_EL, WALL_EL);

	//-----------------------------------------------------------------------------------
	// 요소에 대한 결과출력
	//-----------------------------------------------------------------------------------
	BOOL bExit = FALSE;
	for (i = 0; i < ElemNum; i++)
	{
		if (gm->m_pGPSCtrl->WatchEscKeyPress()) { bExit = TRUE; break; }

		if (gm->m_pGPSCtrl->IsZoomAllState() ||
			gm->m_pGPSCtrl->IsObjectInClientWindow(AtomList[i].m_OType, AtomList[i].m_OKey))
		{
			mkey.keymap = AtomList[i].m_OKey;
			if (!m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, ElemD)) continue;
			
			if (!mElemType.Exist(ElemD.eltyp))
			{
				if (m_bDeformedShapeContour) gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, AtomList[i].m_OKey);
				else gm->GPSDrawInactiveElement(pDC, AtomList[i].m_OKey);
				continue;
			}

			if (gm->m_pGPSCtrl->IsActiveElem(AtomList[i].m_OKey) && !bEscapePressed)
			{
				if ( m_bDeformedShapeContour ) gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, AtomList[i].m_OKey);
				else gm->GPSDrawInactiveElement(pDC, AtomList[i].m_OKey);

				auto mitr = m_mapFiberAsValue.find(mkey.key.elem_k);
				if ( mitr == m_mapFiberAsValue.end() )
				{
					continue;
				}

				if (pDoc->m_pAttrCtrl->IsWall(ElemD.eltyp))
				{
					CArray<T_ELEM_K, T_ELEM_K> ElemKeyList;
					m_pDoc->m_pAttrCtrl->GetKeyListBy_WallID_ByStor(ElemKeyList, AtomList[i].m_OKey);
					for (int e = 0; e < ElemKeyList.GetSize(); e++)
						DoSeisAxialStrainElementContour(pDC, ElemKeyList[e], mitr->second.first);
				}
				else DoSeisAxialStrainElementContour(pDC, AtomList[i].m_OKey, mitr->second.first);
				
			}
			else
			{
				if (m_bDeformedShapeContour) gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, AtomList[i].m_OKey);
				else gm->GPSDrawInactiveElement(pDC, AtomList[i].m_OKey);
			}
		}
	}

	pDC->SelectObject(pOldPen);
	ElemPen.DeleteObject();

	if (bExit)return;

	// 변형된 그림에 Undeformed Shape을 같이 그릴 경우.
	// Contour를 그릴 경우는 Hidden이 default
	// 따라서 Undeformed Shape은 무조건 나중에 그린다...
	if (m_bDeformedShapeContour && gm->m_DOPT.DR.m_bDrawInactive && !bEscapePressed)
	{
		int	rf_bak = gm->m_DOPT.DR.m_RenderFlag;
		gm->m_DOPT.DR.m_RenderFlag = 2;
		gm->GPSDrawOriginal(pDC, TRUE);
		gm->m_DOPT.DR.m_RenderFlag = rf_bak;
	}
}

void CDesignEngine::DoSeisAxialStrainElementContour(CDC *pDC, unsigned int ekey, double dValue)
{
	I_GPSModel		*gm = (I_GPSModel *)m_pGPSModel;
	T_MIRE_K mkey;
	mkey.keymap = ekey;

	int				i, j, poly_num, vtx_num, node_in_elem;
	double			as_val[4] = { dValue, dValue, dValue, dValue };
	BOOL			ef[4];
	T_ELEM_D		elem_d;

	CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray <CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					edge_list;
	CArray <CArray <T_NODE_K, T_NODE_K> *, CArray <T_NODE_K, T_NODE_K> *>	VertexNode;

	if ((gm->m_pDeformEngine == NULL) || (m_pContourEngine == NULL)) return;

	m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d);
	node_in_elem = m_pDoc->m_pAttrCtrl->GetNumNode(elem_d.eltyp, elem_d.elnod);
	// 요소의 형상정보를 얻는다.
	if (m_bDeformedShapeContour)
	{		// 변형된 형상
		gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list, &VertexNode);
	}
	else
	{
		gm->GetShapeElement(ekey, polygon_list, &edge_list, NULL, &VertexNode);
	}

	gm->GPS_XGL_Begin_Elem(mkey.key.elem_k, elem_d);
	poly_num = polygon_list.GetSize();
	for (i = 0; i < poly_num; i++) {
		vtx_num = polygon_list[i]->GetCount();
		if (vtx_num == 2)
			continue;
		if (poly_num > 1 && !gm->m_DOPT.DR.m_bFrameLine &&  gm->m_DOPT.DR.m_bPlaneThick && !gm->IsVisibleFace(polygon_list[i], vtx_num))
			continue;

		// 2. 요소의 형상을 이루는 polygon들의 각 Vertex에 해당 Wall Force값을 부여한다.
		for (j = 0; j < vtx_num; j++) {
			ef[j] = edge_list[i]->GetAt(j);
		}
		// 3. polygon별로 Contour를 실시하여 Wall Force값에 따라 나뉘어진 sub-polygon list를 얻는다.
		// 4. sub-polygon들을 그린다.
		DoSubPolyContour(pDC, as_val, polygon_list[i], ef, TRUE);

		// Fill+Outline의 경우 Contour를 수행하기 전의 Polygon의 Outline을 그림.
		if (gm->m_DOPT.DR.m_RenderFlag == 3 || gm->m_DOPT.DR.m_RenderFlag == 2)
			gm->GPSDrawPolygonEdge(pDC, polygon_list[i], edge_list[i]);
	}
	gm->GPS_XGL_End_Elem();
	FreeMemoryPolyList(&polygon_list, &edge_list, &VertexNode);
}

#if defined(__OLD_OUTPUT_VALUE)
void CDesignEngine::OutputSeisAxialStrainSub(CDC* pDC, UINT ElemK)
{
	DECLARE_DBDOC();
	DECLARE_GPSMD();
	DECLARE_DPTDR();
	DECLARE_DPTTX();

	T_PRFM_RESULT  PrfmResult;
	CArray<GPS_3DPT_LISTP, GPS_3DPT_LISTP>	PolyList;

	BOOL m_bDSCont = m_bDeformedShapeContour;
	auto mitr = m_mapFiberAsValue.find(ElemK);
	if (mitr == m_mapFiberAsValue.end()) return;

	BOOL bBackWireFrame = pDR->m_bFrameLine;
	pDR->m_bFrameLine = TRUE;

	if (gm->m_DOPT.TX.m_bNumberOpaque) pDC->SetBkMode(OPAQUE);
	else                               pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
	pDC->SetBkColor(gm->m_DOPT.TX.m_NumberBackCol);
	pDC->SetTextAlign(TA_CENTER | TA_BOTTOM);

	CString strFmt;
	if (pTX->m_bNumberExponent) strFmt.Format(_T("%%.%de"), gm->m_NumberDecimalPoint);
	else strFmt.Format(_T("%%.%df"), gm->m_NumberDecimalPoint);

	CString strSubFmt; strSubFmt.Format(_T("(%s)"), strFmt);

	CPoint Node2D[2];
	T_ELEM_D ElemD;
	if (!pDoc->m_pAttrCtrl->GetElem(ElemK, ElemD)) return;
	if (pDoc->m_pAttrCtrl->IsWall(ElemD.eltyp))
	{
		CArray<T_ELEM_K, T_ELEM_K> ElemKeyList;
		m_pDoc->m_pAttrCtrl->GetKeyListBy_WallID_ByStor(ElemKeyList, ElemK);

		C3DPoint BottmPt, TopPt;
		GetCenterPosition4Wall_ByWallID_ByStor(ElemKeyList, TopPt, BottmPt);

		Node2D[0] = gm->Get3DPtTo2DPt(&BottmPt);
		Node2D[1] = gm->Get3DPtTo2DPt(&TopPt);
	}
	else
	{
		if (m_bDSCont) gm->m_pDeformEngine->GetDeformedShapeElement(ElemK, &PolyList, NULL, NULL);
		else gm->GetShapeElement(ElemK, PolyList, NULL, NULL, NULL);

		C3DPoint  Node3D[2];
		POSITION nPos = PolyList[0]->GetHeadPosition();
		Node3D[0] = PolyList[0]->GetNext(nPos);
		Node3D[1] = PolyList[0]->GetNext(nPos);
		Node2D[0] = gm->Get3DPtTo2DPt(&Node3D[0]);
		Node2D[1] = gm->Get3DPtTo2DPt(&Node3D[1]);

		FreeMemoryPolyList(&PolyList, NULL, NULL);
	}
	pDR->m_bFrameLine = bBackWireFrame;

	CPoint Pt_1, Pt_2;
	Pt_1.x = Node2D[0].x + (Node2D[1].x - Node2D[0].x) * 0.5;
	Pt_1.y = Node2D[0].y + (Node2D[1].y - Node2D[0].y) * 0.5;
	strFmt.Format(strFmt, mitr->second.first);
	pDC->TextOut(Pt_1.x, Pt_1.y, strFmt);

	if (m_nDispText == 0) // criteria
	{
		Pt_1.y += pDC->GetTextExtent(_T(" "), 1).cy;
		strSubFmt.Format(strSubFmt, mitr->second.second);
		pDC->TextOut(Pt_1.x, Pt_1.y, strSubFmt);
	}
#else
void CDesignEngine::OutputSeisAxialStrainSub(CDC* pDC, UINT ElemK)
{
	DECLARE_DBDOC();
	DECLARE_GPSMD();
	DECLARE_DPTDR();
	DECLARE_DPTTX();

	T_PRFM_RESULT  PrfmResult;
	CArray<GPS_3DPT_LISTP, GPS_3DPT_LISTP>	PolyList;

	BOOL m_bDSCont = m_bDeformedShapeContour;
	auto mitr = m_mapFiberAsValue.find(ElemK);
	if (mitr == m_mapFiberAsValue.end()) return;

	BOOL bBackWireFrame = pDR->m_bFrameLine;
	pDR->m_bFrameLine = TRUE;

	GPostTextOut TextOutModel;
	TextOutModel.SetDC(pDC);
	TextOutModel.SettingSeisAxial(gm);

	CString strFmt;
	if (pTX->m_bNumberExponent) strFmt.Format(_T("%%.%de"), gm->m_NumberDecimalPoint);
	else strFmt.Format(_T("%%.%df"), gm->m_NumberDecimalPoint);

	CString strSubFmt; strSubFmt.Format(_T("(%s)"), strFmt);

	CPoint Node2D[2];
	T_ELEM_D ElemD;
	if (!pDoc->m_pAttrCtrl->GetElem(ElemK, ElemD)) return;
	if (pDoc->m_pAttrCtrl->IsWall(ElemD.eltyp))
	{
		CArray<T_ELEM_K, T_ELEM_K> ElemKeyList;
		m_pDoc->m_pAttrCtrl->GetKeyListBy_WallID_ByStor(ElemKeyList, ElemK);

		C3DPoint BottmPt, TopPt;
		GetCenterPosition4Wall_ByWallID_ByStor(ElemKeyList, TopPt, BottmPt);

		Node2D[0] = gm->Get3DPtTo2DPt(&BottmPt);
		Node2D[1] = gm->Get3DPtTo2DPt(&TopPt);
	}
	else
	{
		if (m_bDSCont) gm->m_pDeformEngine->GetDeformedShapeElement(ElemK, &PolyList, NULL, NULL);
		else gm->GetShapeElement(ElemK, PolyList, NULL, NULL, NULL);

		C3DPoint  Node3D[2];
		POSITION nPos = PolyList[0]->GetHeadPosition();
		Node3D[0] = PolyList[0]->GetNext(nPos);
		Node3D[1] = PolyList[0]->GetNext(nPos);
		Node2D[0] = gm->Get3DPtTo2DPt(&Node3D[0]);
		Node2D[1] = gm->Get3DPtTo2DPt(&Node3D[1]);

		FreeMemoryPolyList(&PolyList, NULL, NULL);
	}
	pDR->m_bFrameLine = bBackWireFrame;

	CPoint Pt_1, Pt_2;
	Pt_1.x = Node2D[0].x + (Node2D[1].x - Node2D[0].x) * 0.5;
	Pt_1.y = Node2D[0].y + (Node2D[1].y - Node2D[0].y) * 0.5;
	strFmt.Format(strFmt, mitr->second.first);
	TextOutModel.TextOutSeisAxial(Pt_1.x, Pt_1.y, strFmt);

	if (m_nDispText == 0) // criteria
	{
		Pt_1.y += TextOutModel.GetTextExtent(_T(" "), 1).cy;
		strSubFmt.Format(strSubFmt, mitr->second.second);
		TextOutModel.TextOutSeisAxial(Pt_1.x, Pt_1.y, strSubFmt);
	}
}
#endif


BOOL CDesignEngine::MakeSeisPerform2ndDataTH_AxialStrain()
{
	DECLARE_GPSMD();
	DECLARE_DBDOC();

	gm->m_nLgdMaxValKey = 0;
	gm->m_nLgdMinValKey = 0;
	if (!gm->m_bLoadDataSet) return FALSE;

	gm->m_pMyView->BeginWaitCursor();

	/////////////////////////////////////////////////////////////////////////
	if (gm->m_LoadCaseType == D_LOADCASE_CB_JSONFILE)
	{
		if (!MakeSeisPerform2ndDataTH_FromJson(ecPerfomType::SEIS_TH_AXIAL)) return FALSE;
		if (m_EKeyList.GetSize() == 0 || m_mapFiberAsValue.size() == 0) { ASSERT(0); return FALSE; }
	}
	else
	{
		std::map<int, std::set<T_ELEM_K>> mapElem;
		if (!GetSeisPerformElemListTH(ecPerfomType::SEIS_TH_AXIAL, mapElem, (m_nMaxMin != GPS_STEP_NONE))) return FALSE;
		int iTimeIdx = (m_nMaxMin > GPS_STEP_NONE) ? -1 : m_nHingeTimeIndex;
		CSeisEvalWrapper SeisEval;
		m_mapFiberAsValue.clear();
		if (m_bCtShowColm)
		{
			auto mitr = mapElem.find(D_MBTP_COLUMN);
			if (mitr == mapElem.end()) { ASSERT(0); return FALSE; }
			SeisEval.GetInstance()->GetColmAxialStrainListTHFiber(mitr->second, static_cast<int>(m_nSeisFiberMatl), gm->m_LoadCaseKey, iTimeIdx, m_nMaxMin, (m_nDispText==1), m_mapFiberAsValue);
		}
		if (m_bCtShowWall)
		{
			auto mitr = mapElem.find(D_MBTP_WALL);
			if (mitr == mapElem.end()) { ASSERT(0); return FALSE; }
			SeisEval.GetInstance()->GetWallAxialStrainListTHFiber(mitr->second, static_cast<int>(m_nSeisFiberMatl), gm->m_LoadCaseKey, iTimeIdx, m_nMaxMin, (m_nDispText==1), m_mapFiberAsValue);
		}

		m_dMaxValue = -DBL_MAX;
		m_dMinValue = DBL_MAX;
		m_EKeyList.RemoveAll();
		for (auto& itr : m_mapFiberAsValue)
		{
			m_EKeyList.Add(itr.first);
			if (m_dMinValue > itr.second.first)
			{
				gm->m_nLgdMinValKey = itr.first;
				m_dMinValue = itr.second.first;
			}
			if (m_dMaxValue < itr.second.first)
			{
				gm->m_nLgdMaxValKey = itr.first;
				m_dMaxValue = itr.second.first;
			}
		}
		if (m_mapFiberAsValue.size() == 0) { m_dMaxValue = m_dMinValue = 0.0; }
	}
	if (m_pContourEngine == NULL) m_pContourEngine = new CContourEngine(m_dMinValue, m_dMaxValue);
	else m_pContourEngine->MakeRankMap(m_dMinValue, m_dMaxValue);
	/////////////////////////////////////////////////////////////////////////

	gm->m_pMyView->EndWaitCursor();
	return TRUE;
}

bool CDesignEngine::GetSeisPerformElemListPO(ecPerfomType eType, std::map<int, std::set<T_ELEM_K>>& mapElem)
{
	DECLARE_GPSMD();
	DECLARE_DBDOC();

	////////////////////////////////////////////////////////////////////////////////////////
	// valid elements
	mapElem.clear();	
	if (m_bCtShowColm) mapElem[D_MBTP_COLUMN] = std::set<T_ELEM_K>();
	if (m_bCtShowWall) mapElem[D_MBTP_WALL] = std::set<T_ELEM_K>();

	T_ELEM_D ElemD;
	T_MATL_D MatlD;
	T_REBB_D RebbD;
	T_REBC_D RebcD;
	T_IEHG_D IehgD;
	T_IEHP_D IehpD;
	for (int i = 0; i < gm->m_EKeyListActive.GetSize(); i++)
	{

		T_ELEM_K ElemK = gm->m_EKeyListActive[i];
		if (!m_pDoc->m_pAttrCtrl->GetElem(ElemK, ElemD)) continue;
		if (!m_pDoc->m_pAttrCtrl->GetMatl(ElemD.elmat, MatlD)) continue;
		if (MatlD.Type != _LSX(C)) continue;

		int nMembType = m_pDoc->m_pAttrCtrl->GetMemberType(ElemK);
		if (mapElem.find(nMembType) == mapElem.end()) continue;

		if (ElemD.eltyp == BEAM_EL && nMembType == D_MBTP_COLUMN)
		{
			if (!m_bCtShowColm) continue;
			if (!m_pDoc->m_pAttrCtrl->GetRebcByElemK(ElemK, RebcD)) continue;
		}
		else if (ElemD.eltyp == WALL_EL)
		{
			if (!m_bCtShowWall) continue;
		}
		mapElem[nMembType].insert(ElemK);
	}
	return true;
}

BOOL CDesignEngine::MakeSeisPerform2ndDataPO_AxialStrain()
{
	DECLARE_GPSMD();
	DECLARE_DBDOC();

	gm->m_nLgdMaxValKey = 0;
	gm->m_nLgdMinValKey = 0;
	if (!gm->m_bLoadDataSet) return FALSE;

	gm->m_pMyView->BeginWaitCursor();

	/////////////////////////////////////////////////////////////////////////
	std::map<int, std::set<T_ELEM_K>> mapElem;
	if (!GetSeisPerformElemListPO(ecPerfomType::SEIS_PO_AXIAL, mapElem)) return FALSE;

	const int nMaxStep = m_pDoc->m_pPostCtrl->GetCaseStep_PO(gm->m_LoadCaseKey);

	BOOL bConsiderAddStep = FALSE;
	int iCurStep = 0;
	T_POAS_D PoasD;
	if (gm->m_nCurAdditionalStepIdx != -1 && D_POAS_NUMPOAS > gm->m_nCurAdditionalStepIdx)
	{
		if (!m_pDoc->m_pAttrCtrl->GetPoas(PoasD)) ASSERT(0);
		iCurStep = PoasD.aStep[gm->m_nCurAdditionalStepIdx].nRefStep;
	}
	else
	{
		iCurStep = gm->m_nCurStep;
		gm->m_nCurAdditionalStepIdx = -1;
	}

	CSeisEvalWrapper SeisEval;
	m_mapFiberAsValue.clear();
	if (m_bCtShowColm)
	{
		auto mitr = mapElem.find(D_MBTP_COLUMN);
		if (mitr == mapElem.end()) { ASSERT(0); return FALSE; }
		SeisEval.GetInstance()->GetColmAxialStrainListPOFiber(mitr->second, static_cast<int>(m_nSeisFiberMatl), gm->m_LoadCaseKey, 
			iCurStep, (m_nDispText == 1), m_mapFiberAsValue);
	}
	if (m_bCtShowWall)
	{
		auto mitr = mapElem.find(D_MBTP_WALL);
		if (mitr == mapElem.end()) { ASSERT(0); return FALSE; }
		SeisEval.GetInstance()->GetWallAxialStrainListPOFiber(mitr->second, static_cast<int>(m_nSeisFiberMatl), gm->m_LoadCaseKey, 
			iCurStep, (m_nDispText == 1), m_mapFiberAsValue);
	}

	m_dMaxValue = -DBL_MAX;
	m_dMinValue = DBL_MAX;
	m_EKeyList.RemoveAll();
	for (auto& itr : m_mapFiberAsValue)
	{
		m_EKeyList.Add(itr.first);
		if (m_dMinValue > itr.second.first)
		{
			gm->m_nLgdMinValKey = itr.first;
			m_dMinValue = itr.second.first;
		}
		if (m_dMaxValue < itr.second.first)
		{
			gm->m_nLgdMaxValKey = itr.first;
			m_dMaxValue = itr.second.first;
		}
	}
	if (m_mapFiberAsValue.size() == 0) { m_dMaxValue = m_dMinValue = 0.0; }
	
	if (m_pContourEngine == NULL) m_pContourEngine = new CContourEngine(m_dMinValue, m_dMaxValue);
	else m_pContourEngine->MakeRankMap(m_dMinValue, m_dMaxValue);
	/////////////////////////////////////////////////////////////////////////
	m_bSeisPerformDataSet = TRUE;
	gm->m_pMyView->EndWaitCursor();
	return TRUE;
}