// ForceEngine.cpp: implementation of the CForceEngine class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "wg_gps.h"
#include "ForceEngine.h"
#include "DeformEngine.h"
#include "DesignEngine.h"
//#include "StressEngine.h"
#include "I_GPSModel.h"
#include "BDEngine.h"
#include "GPSDisplayFilter.h"
#include "GPSResultLabelBase.h"
#include "GPSInflGridBase.h"
#include "GPSBeamLabel.h"
#include "GPSAMRUtil.h"
#include "GPostTextOut.h"
#include "..\wg_db\wg_db_AttrCtrl.h"
#include "..\wg_db\wg_db_PostCtrl.h"
#include "..\wg_db\wg_db_MathFunc.h"
#include "..\wg_db\wg_db_FlagCtrl.h"
#include "..\wg_db\wg_db_UnitCtrl.h"
#include "..\wg_db\wg_db_MvldInfo.h"
#include "..\wg_db\wg_db_CscsInfo.h"
#include "..\wg_db\wg_db_StoryData.h"   // for CStoryData
#include "..\wg_db\DesignResult.h"
#include "..\wg_db\MembCtrl.h"
#include "..\wg_db\wg_db_ViewCtrl.h"
#include "..\wg_db\wg_db_AttrCtrl2.h"
#include "..\wg_db\DispOptMgr.h"
#include "..\wg_db\DispOptSizeObj.h"

#ifdef _TOWER
#include "..\wg_db\wg_db_TowerInfo.h"
#endif

#include "..\wg_base\ArrayUtil.h"
#include "..\wg_base\ServiceProvider.h"
#include "..\wg_base\TestEnvMgr.h"
#include "..\wg_rcs\Rcs_ServiceDef.h"

#include <float.h>
#include <set>
#include "GPSElemData.h" // Export GPS Data for VTK Test
#include "DRW_DATA.h"
#include "GPSPostCtrl.h"

//XGLRenderer
#include "Func_GPS_Draw.h"


#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

#define UCS_XY 100000
#define UCS_XZ 100001
#define UCS_YZ 100002

UINT CForceEngine::m_colValAxial = RGB(255,95,17);
UINT CForceEngine::m_colValShear = RGB(0,132,0);
UINT CForceEngine::m_colValMoment= RGB(85,85,255);


/////////////////////////////////////////////////////////////////////
/*
extern _T("C") { void __cdecl MOV_KRNL(char* filename, int fn_len, int type, int number, int component,
int loadcase, int* N_lane, double* F_max, double* F_min, 
int max_lane_array[1000], int min_lane_array[1000],int nProgType,
double scfc_lane_array[20],double turuck_load_dist[20000]); }
extern _T("C") { void __cdecl MOV_KRNL_JAPAN(char* filename, int fn_len, int type, int number, int component,
int loadcase, int* N_lane, double* F_max, double* F_min, 
int max_load[100], int min_load[100],int nProgType); }
extern _T("C") { void __cdecl MOV_KRNL_CHINA(char* filename, int fn_len, int type, int number, int component,
int loadcase, int* N_lane, double* F_max, double* F_min, 
int max_lane_array[1000], int min_lane_array[1000],int nProgType,
double *dimpact,double *simpact,double *scfc_lane_array,
int nm_pmx1,int nm_smx1); }
*/
/////////////////////////////////////////////////////////////////////

#define DECLARE_GPSMD()  I_GPSModel *gm=(I_GPSModel *)m_pGPSModel
#define DECLARE_DBDOC()  CDBDoc		  *pDoc=((I_GPSModel *)m_pGPSModel)->GetDBDoc()
#define DECLARE_DPTDR()  T_GPS_DISP_OPT_DR *pDR = &(gm->m_DOPT.DR) 
#define DECLARE_DPTRD()  T_GPS_DISP_OPT_RD *pRD = &(gm->m_DOPT.RD)
#define DECLARE_DPTCL()  T_GPS_DISP_OPT_CL *pCL = &(gm->m_DOPT.CL)
#define DECLARE_DPTTX()  T_GPS_DISP_OPT_TX *pTX = &(gm->m_DOPT.TX)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CForceEngine::CForceEngine(I_GPSModelBase *pGM)
{
	CEngineBase::CEngineBase();

	m_pGPSModel					= pGM;

	m_NUCS.Initialize();
	m_mapTForcData.InitHashTable(HASHSIZEELEM);
	m_mapBForcData.InitHashTable(HASHSIZEELEM);
	m_mapBForcDataMin.InitHashTable(HASHSIZEELEM);
	m_mapBForcDataByMember.InitHashTable(HASHSIZEELEM);
	m_mapBForcMinPosByMember.InitHashTable(HASHSIZEELEM);
	m_mapBForcMaxPosByMember.InitHashTable(HASHSIZEELEM);
	m_mapBForcMidPosByMember.InitHashTable(HASHSIZEELEM);
	m_mapSFDBMDMax.InitHashTable(HASHSIZEELEM);
	m_mapWForcData.InitHashTable(HASHSIZEELEM);
	m_mapWallInfoData.InitHashTable(HASHSIZEELEM);
	m_mapPForcData.InitHashTable(HASHSIZEELEM);
	m_mapPForcData_G.InitHashTable(HASHSIZEELEM);
	m_mapMbDgrmD.InitHashTable(HASHSIZEELEM);
	m_mapNForcData.InitHashTable(1001);
	m_mapSlabForce.InitHashTable(HASHSIZEELEM);
	m_mapResultantForceData.InitHashTable(HASHSIZEVBEM);
	m_mapResultantForceDataMxMn.InitHashTable(HASHSIZEVBEM);

	ResetEngine();

	//m_nPrdMoving=CProduct::GetMovingType();

	// MNET:XXXX-CJJEONG-20080430
	m_bVectorPositive = m_bVectorNegative = TRUE;

	m_bInitEngine_All_First = FALSE;
}

CForceEngine::~CForceEngine()
{
	m_BeamKeyList.RemoveAll();
	m_BeamReverseFg.RemoveAll();
	m_BForcDataList.RemoveAll();

	m_TrussKeyList.RemoveAll();
	m_TrussReverseFg.RemoveAll();
	m_TForcDataList.RemoveAll();

	m_PlateKeyList.RemoveAll();
	m_PForcDataList.RemoveAll();
	m_PlateReverseFg.RemoveAll(); //KYE-HONG-20020204

	m_WallKeyList.RemoveAll();
	ResetDrawCLWPData(); 

}

// 다른 엔진으로부터 데이터를 Import
void CForceEngine::ImportEngine(CEngineBase* egbase)
{
		int i,j; 
		if(!egbase)return;

		CEngineBase::ImportEngine(egbase); 

		CForceEngine* eg = (CForceEngine*)egbase;

		//m_bContour	= eg->m_bContour;
		// m_dMaxValue = eg->m_dMaxValue;
		// m_dMinValue = eg->m_dMinValue;

		// m_bLockAdjFactor				= eg->m_bLockAdjFactor;
		// m_bDeformedShapeContour		= eg->m_bDeformedShapeContour;
		/*
		m_arLaneInfoNew.RemoveAll();
		for(int i=0; i<eg->m_arLaneInfoNew.GetSize(); i++)
		m_arLaneInfoNew.Add(eg->m_arLaneInfoNew[i]);
		m_InflKeyElem				= eg->m_InflKeyElem;

		m_MaxInflEKey				= eg->m_MaxInflEKey;
		m_MinInflEKey				= eg->m_MinInflEKey;
		m_MaxInflPart				= eg->m_MaxInflPart;
		m_MinInflPart				= eg->m_MinInflPart;
		*/

		m_bBInflMaxLeft				= eg->m_bBInflMaxLeft;
		m_bBInflMinLeft				= eg->m_bBInflMinLeft;

		m_bTForcDataSet				= eg->m_bTForcDataSet;
		m_TForcPart					= eg->m_TForcPart;
		m_TForcComponent			= eg->m_TForcComponent;
		m_TForcOutputSection		= eg->m_TForcOutputSection;

		m_TrussKeyList.RemoveAll();
		m_TrussKeyList.Copy(eg->m_TrussKeyList);
		m_TrussReverseFg.RemoveAll();
		m_TrussReverseFg.Copy(eg->m_TrussReverseFg);
		m_TForcDataList.RemoveAll();
		m_TForcDataList.Copy(eg->m_TForcDataList);
		m_mapTForcData.RemoveAll();
		for(int ii=0; ii<3; ii++) //KYE-HONG-20020208
		{
				m_arTrussEccen[ii].RemoveAll();
				m_arTrussEccen[ii].Copy(eg->m_arTrussEccen[ii]); 
		}

		T_ELEM_K key; T_STRT_D strt_d;
		POSITION pos =eg->m_mapTForcData.GetStartPosition();
		while(pos)
		{
				eg->m_mapTForcData.GetNextAssoc(pos,key,strt_d);
				m_mapTForcData.SetAt(key,strt_d);
		}

		m_bBForcDataSet				= eg->m_bBForcDataSet;
		m_KeyMaxBForcElem			= eg->m_KeyMaxBForcElem;
		m_BForcPart					  = eg->m_BForcPart;
		m_BForcComponent			= eg->m_BForcComponent;
		m_nBForcPscPart       =eg->m_nBForcPscPart;
		m_BForcOutputSection	= eg->m_BForcOutputSection;
		m_bSfdBmdExact				= eg->m_bSfdBmdExact;
		m_bBSfdBmdExact				= eg->m_bBSfdBmdExact;
		m_bBForcOutputMax			= eg->m_bBForcOutputMax;
		m_bBForcOutputMinMax  = eg->m_bBForcOutputMinMax;
		m_bBForcOutputAll			= eg->m_bBForcOutputAll;
		m_bBForcOutputI				= eg->m_bBForcOutputI;
		m_bBForcOutputC				= eg->m_bBForcOutputC;
		m_bBForcOutputJ				= eg->m_bBForcOutputJ;
		m_bBForcOutputByMember= eg->m_bBForcOutputByMember;
		m_bBsfdBmdByMember    = eg->m_bBsfdBmdByMember;
		m_BSfdBmdAdjustFactor		= eg->m_BSfdBmdAdjustFactor;
		m_BSfdBmdScFactor			= eg->m_BSfdBmdScFactor;
		m_bBSfdBmdLineOnly			= eg->m_bBSfdBmdLineOnly;
		m_bVerticalLineFill = eg->m_bVerticalLineFill;
		m_bBInflIclImpFct   = eg->m_bBInflIclImpFct;  //KYE-HONG-20020222
		m_bTInflIclImpFct   = eg->m_bTInflIclImpFct;  //KYE-HONG-20020222
		m_bPInflIclImpFct   = eg->m_bPInflIclImpFct;  //KYE-HONG-20020222

		m_BeamKeyList.RemoveAll();
		m_BeamReverseFg.RemoveAll();
		m_BeamKeyList.Copy(eg->m_BeamKeyList);
		m_BeamReverseFg.Copy(eg->m_BeamReverseFg);
		m_BForcDataList.RemoveAll();
		m_BForcDataList.Copy(eg->m_BForcDataList);
		m_mapBForcData.RemoveAll();
		T_STRB_D strb_d;
		pos =eg->m_mapBForcData.GetStartPosition();
		while(pos)
		{
				eg->m_mapBForcData.GetNextAssoc(pos,key,strb_d);
				m_mapBForcData.SetAt(key,strb_d);
		}
		m_mapBForcDataMin.RemoveAll();
		pos =eg->m_mapBForcDataMin.GetStartPosition();
		while(pos)
		{
				eg->m_mapBForcDataMin.GetNextAssoc(pos,key,strb_d);
				m_mapBForcDataMin.SetAt(key,strb_d);
		}

		m_bPForcDataSet				= eg->m_bPForcDataSet;
		m_PForcComponent			= eg->m_PForcComponent;
		m_PForcPart					= eg->m_PForcPart;
		m_PForcVtAdjustFactor		= eg->m_PForcVtAdjustFactor;
		m_PForcVtScaleFactor		= eg->m_PForcVtScaleFactor;
		m_bAverage					= eg->m_bAverage;
		m_nPlateForceLocalGlobal = eg->m_nPlateForceLocalGlobal;
		m_bAverageNodalActiveOnly = eg->m_bAverageNodalActiveOnly;
		m_MaxAbsValue				= eg->m_MaxAbsValue;
		m_KeyMaxAbsElem				= eg->m_KeyMaxAbsElem;
		m_NUCS								= eg->m_NUCS;
		m_bPrintUCSAxis       = eg->m_bPrintUCSAxis;
		m_ResultantForceComponent = eg->m_ResultantForceComponent;
		m_bResultantForcDataSet   = eg->m_bResultantForcDataSet;

		m_PlateKeyList.RemoveAll();
		m_PlateKeyList.Copy(eg->m_PlateKeyList);
		m_PForcDataList.RemoveAll();
		m_PForcDataList.Copy(eg->m_PForcDataList);
		m_PlateReverseFg.RemoveAll();                 //KYE-HONG-20020204
		m_PlateReverseFg.Copy(eg->m_PlateReverseFg);  //KYE-HONG-20020204
		m_mapPForcData.RemoveAll();
		T_STRP_DL strp_d;
		pos =eg->m_mapPForcData.GetStartPosition();
		while(pos)
		{
				eg->m_mapPForcData.GetNextAssoc(pos,key,strp_d);
				m_mapPForcData.SetAt(key,strp_d);
		}
		T_STRP_DG strp_dg;
		pos =eg->m_mapPForcData_G.GetStartPosition();
		while(pos)
		{
				eg->m_mapPForcData_G.GetNextAssoc(pos,key,strp_dg);
				m_mapPForcData_G.SetAt(key,strp_dg);
		}

		T_NODE_K node_k,serial_k;
		pos =eg->m_mapSerialNode.GetStartPosition();
		while(pos)
		{
				eg->m_mapSerialNode.GetNextAssoc(pos,node_k,serial_k);
				m_mapSerialNode.SetAt(node_k,serial_k);
		}

		T_VBEM_K VbemK; 
		T_RESULTANT_FORCE_D RforcD;
		m_mapResultantForceData.RemoveAll();
		pos = eg->m_mapResultantForceData.GetStartPosition();
		while(pos)
		{
				eg->m_mapResultantForceData.GetNextAssoc(pos,VbemK,RforcD);
				m_mapResultantForceData.SetAt(VbemK,RforcD);
		}
		m_mapResultantForceDataMxMn.RemoveAll();
		pos = eg->m_mapResultantForceDataMxMn.GetStartPosition();
		while(pos)
		{
				eg->m_mapResultantForceDataMxMn.GetNextAssoc(pos,VbemK,RforcD);
				m_mapResultantForceDataMxMn.SetAt(VbemK,RforcD);
		}
		for(i=0; i<6; i++)
		{
				m_dAbsMaxResultantForce[i] = eg->m_dAbsMaxResultantForce[i];
		}


		/*
		//m_bOnCuttingLine      = eg->m_bOnCuttingLine;
		int i,j; 
		ResetCuttingLineData();
		m_aCutLines.Copy(eg->m_aCutLines);
		m_aCutPlanes.Copy(eg->m_aCutPlanes);
		m_aCutLineMinMax.Copy(eg->m_aCutLineMinMax);
		CArray<T_CUTLINE_D,T_CUTLINE_D&>* paCutLineData;
		for( i= 0; i<eg->m_aCutLineData.GetSize(); i++)
		{
		paCutLineData = new CArray<T_CUTLINE_D,T_CUTLINE_D&>;
		m_aCutLineData.Add(paCutLineData);
		m_aCutLineData[i]->Copy(*(eg->m_aCutLineData[i]));
		}
		m_aCutLineOnPlaneMinMax.Copy(eg->m_aCutLineOnPlaneMinMax);
		CArray<T_CUTLINE_D,T_CUTLINE_D&>* paCutLineOnPlaneData;
		for( i= 0; i<eg->m_aCutLineOnPlaneData.GetSize(); i++)
		{
		paCutLineOnPlaneData = new CArray<T_CUTLINE_D,T_CUTLINE_D&>;
		m_aCutLineOnPlaneData.Add(paCutLineOnPlaneData);
		m_aCutLineOnPlaneData[i]->Copy(*(eg->m_aCutLineOnPlaneData[i]));
		}
		*/

		m_bWForcDataSet				= eg->m_bWForcDataSet;
		m_WForcComponent			= eg->m_WForcComponent;
		m_WSfdBmdAdjustFactor		= eg->m_WSfdBmdAdjustFactor;
		m_WSfdBmdScFactor			= eg->m_WSfdBmdScFactor;
		m_bWSfdBmdLineOnly			= eg->m_bWSfdBmdLineOnly;
		m_WForcOutputLocation   = eg->m_WForcOutputLocation;

		m_WallKeyList.RemoveAll();
		m_WallKeyList.Copy(eg->m_WallKeyList);
		m_mapWForcData.RemoveAll();
		T_STRW_D strw_d;
		pos =eg->m_mapWForcData.GetStartPosition();
		while(pos)
		{
				eg->m_mapWForcData.GetNextAssoc(pos,key,strw_d);
				m_mapWForcData.SetAt(key,strw_d);
		}
		m_mapWallInfoData.RemoveAll();
		T_WALL_D wall_d;
		pos =eg->m_mapWallInfoData.GetStartPosition();
		while(pos)
		{
				eg->m_mapWallInfoData.GetNextAssoc(pos,key,wall_d);
				m_mapWallInfoData.SetAt(key,wall_d);
		}

		ResetDrawCLWPData(); 
		for(i=0; i<eg->m_arDrawCLWPMnMx.GetSize(); i++)
				m_arDrawCLWPMnMx.Add(eg->m_arDrawCLWPMnMx[i]);
		CArray<T_CUTLINE_D,T_CUTLINE_D&> *pData; 
		for(i=0; i<eg->m_parDrawCLWP.GetSize(); i++)
		{
				pData=NULL; 
				pData=new CArray<T_CUTLINE_D,T_CUTLINE_D&>;
				pData->RemoveAll(); 
				for(j=0; j<eg->m_parDrawCLWP[i]->GetSize(); j++)
						pData->Add(eg->m_parDrawCLWP[i]->GetAt(j));

				m_parDrawCLWP.Add(pData); 
		}

		m_nSSFRDir    =eg->m_nSSFRDir;
		m_bSSFRDataSet=eg->m_bSSFRDataSet;
		m_nSSFROutType=eg->m_nSSFROutType;
		m_dSSFRAngle  =eg->m_dSSFRAngle;
		m_mapSSFRData.RemoveAll();
		pos=eg->m_mapSSFRData.GetStartPosition();
		T_ELEM_K ElemK;
		double   dSSFRVal;
		while(pos)
		{
				eg->m_mapSSFRData.GetNextAssoc(pos,ElemK,dSSFRVal);
				m_mapSSFRData.SetAt(ElemK,dSSFRVal);
		}

		// Member Diagram
		m_bMbDgramDataSet =eg->m_bMbDgramDataSet; 
		m_nMbDgrmNPlanK   =eg->m_nMbDgrmNPlanK; 
		m_nMbDgrmSelectMode = eg->m_nMbDgrmSelectMode;  //  0:Named Plane, 1:Story
		m_nMbDgrmStorK = eg->m_nMbDgrmStorK;  
		m_arMbDgrmNPlanK.RemoveAll();
		m_arMbDgrmNPlanK.Copy(eg->m_arMbDgrmNPlanK);
		m_bMbDgrmBeamChk  =eg->m_bMbDgrmBeamChk;
		m_bMbDgrmBrceChk  =eg->m_bMbDgrmBrceChk;
		m_bMbDgrmColmChk  =eg->m_bMbDgrmColmChk;
		m_bMbDgrmWallChk  =eg->m_bMbDgrmWallChk;
		m_nMbDgrmDeciPt   =eg->m_nMbDgrmDeciPt;
		m_bMbDgrmExpChk   =eg->m_bMbDgrmExpChk;
		m_nMbDgrmDgrmType =eg->m_nMbDgrmDgrmType;
		m_dMbDgrmScFt     =eg->m_dMbDgrmScFt;
		m_bMbDgrmShowDgrm =eg->m_bMbDgrmShowDgrm;
		m_MSfdBmdAdjustFactor =eg->m_MSfdBmdAdjustFactor;
		m_nMbdgrmDgrmComp = eg->m_nMbdgrmDgrmComp; 
		m_nMbDgrmOutType  = eg->m_nMbDgrmOutType;
		memcpy(m_dMbDgrmLocalVec,eg->m_dMbDgrmLocalVec,sizeof(m_dMbDgrmLocalVec));

		m_bMbDgrmValAxial = eg->m_bMbDgrmValAxial;
		m_bMbDgrmValShear = eg->m_bMbDgrmValShear;
		m_bMbDgrmValMoment= eg->m_bMbDgrmValMoment;
		m_colValAxial = eg->m_colValAxial;
		m_colValShear = eg->m_colValShear;
		m_colValMoment= eg->m_colValMoment;

		T_GPS_MEMB_DGRM_D DgrmD;
		m_mapMbDgrmD.RemoveAll();
		pos = eg->m_mapMbDgrmD.GetStartPosition();
		while(pos)
		{
				eg->m_mapMbDgrmD.GetNextAssoc(pos,ElemK,DgrmD);
				m_mapMbDgrmD.SetAt(ElemK,DgrmD);
		}

		for(i=0; i<3; i++)
		{
				m_dMbDgrmMaxVal[i]=eg->m_dMbDgrmMaxVal[i];
				m_nMbDgrmMaxKey[i]=eg->m_nMbDgrmMaxKey[i];
		}

		m_NlnkPart = eg->m_NlnkPart; 
		m_NlnkComp = eg->m_NlnkComp; 
		m_ElnkPart = eg->m_ElnkPart; 
		m_ElnkComp = eg->m_ElnkComp; 
		m_dNlnkScFc = eg->m_dNlnkScFc;
		m_dElnkScFc = eg->m_dElnkScFc;

		m_dThisTimeStep   = eg->m_dThisTimeStep;
		m_nThisTimeIndex  = eg->m_nThisTimeIndex;
		m_bThisFunction   = eg->m_bThisFunction   ;   
		m_nFunctionKey    = eg->m_nFunctionKey;    //  m_nThisCaseOrFunc = 1일때 Function Key

		T_NLNK_K NlnkK;
		T_STEK_D StekD;
		m_mapNForcData.RemoveAll();
		pos = eg->m_mapNForcData.GetStartPosition();
		while(pos)
		{
				eg->m_mapNForcData.GetNextAssoc(pos,NlnkK,StekD);
				m_mapNForcData.SetAt(NlnkK,StekD);
		}

		m_bMaxMinDgrm     = eg->m_bMaxMinDgrm;
		m_bBForcWithTForc = eg->m_bBForcWithTForc;
		m_bBForcOnlyTForc = eg->m_bBForcOnlyTForc;

		m_dMxxCoeff   = eg->m_dMxxCoeff;
		m_dMyyCoeff   = eg->m_dMyyCoeff;
		m_nMxxMyyMode = eg->m_nMxxMyyMode;
		m_dMxyCoeff   = eg->m_dMxyCoeff;

		m_bEnvelopeLC	= eg->m_bEnvelopeLC;
		m_Mldt = eg->m_Mldt;

		// MNET:XXXX-CJJEONG-20080429
		m_bVectorPositive = eg->m_bVectorPositive;
		m_bVectorNegative = eg->m_bVectorNegative;

		m_nWoodArmerTopBot = eg->m_nWoodArmerTopBot;
		m_dWoodArmerAngle  = eg->m_dWoodArmerAngle;  

		T_SLAB_FORCE_COMPACT SlabForc;
		m_mapSlabForce.RemoveAll();
		pos = eg->m_mapSlabForce.GetStartPosition();
		while(pos)
		{
				eg->m_mapSlabForce.GetNextAssoc(pos,ElemK,SlabForc);
				m_mapSlabForce.SetAt(ElemK,SlabForc);
		}

		m_bStripOutput = eg->m_bStripOutput;
		m_bRFrcdTopAlignment = eg->m_bRFrcdTopAlignment;
		m_nRfrcdOutputPos = eg->m_nRfrcdOutputPos;

		m_bYieldPoint = eg->m_bYieldPoint;
		m_mapYeildPointIdx.clear();
		for(auto itrMap = eg->m_mapYeildPointIdx.begin(); itrMap != eg->m_mapYeildPointIdx.end(); itrMap++)
		{
				m_mapYeildPointIdx[itrMap->first] = itrMap->second;
		}
} 

// 데이터를 만든다.
void CForceEngine::InitEngine(CDeformEngine *pDE,int nGPSInstruction,BOOL bSendedHandleGPSBar/*=FALSE*/)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	if(gm->m_LoadCaseType == D_LOADCASE_PUSHOVER && !m_pDoc->m_pPostCtrl->IsPushOverResultEnable())
	{
		//AfxMessageBox(_LS(IDS_WG_GPS_PUSHOVER_RESULT_UNAVAILABLE));
		return;
	}

	m_bTForcDataSet = FALSE;
	m_bBForcDataSet	= FALSE;
	m_bWForcDataSet	= FALSE;
	m_bPForcDataSet = FALSE;
	m_bSSFRDataSet  = FALSE; 
	m_bStripOutput  = FALSE;
	m_bResultantForcDataSet = FALSE;
	gm->SelectLoad();

	int nGPSMode = (nGPSInstruction != -1)? nGPSInstruction:gm->m_GPSMode;
	switch (nGPSMode) 
	{
	case GPS_COMMAND_TFORC:
		MakeTForcDataList();
		break;
	case GPS_COMMAND_IFSTFORC:
		MakeInflTForcDataListS(pDE);
		break;
	case GPS_COMMAND_BFORC:
	case GPS_COMMAND_BDGRM:
	case GPS_COMMAND_GIRDERSTRS_DGRM:
		MakeBForcDataList();
		break;
	case GPS_COMMAND_IFSBFORC:
		MakeInflBForcDataListS(pDE);
		break;
	case GPS_COMMAND_WFORC:
	case GPS_COMMAND_WSFBM:
		MakeWForcDataList();
		break;
	case GPS_COMMAND_PFORC:
		MakePForcDataList();
		break;
	case GPS_COMMAND_PCLPD:
		MakePForcDataList_UserDir();
		break; 
	case GPS_COMMAND_RESULTANT_FORCE:
		MakeResultantForceDataList();
		break;
	case GPS_COMMAND_ESFBM:
		if(bSendedHandleGPSBar)
			MakeMbDgrmData();
		break; 
	case GPS_COMMAND_IFSPFORC:
		MakeInflPForcDataListS(pDE);
		break;

	case GPS_COMMAND_IFLBFORC:
	case GPS_COMMAND_IFLPFORC:
	case GPS_COMMAND_IFLTFORC:
		MakeInflForcDataList(); // 하나로 통합시킴 
		break;

		// 각 언어별 Version으로 구분하여 
		// Tracer Data를 만들어야 함 
	case GPS_COMMAND_MVLTRCTFORC:
		if(CDBDoc::GetDocPoint()->m_pPostCtrl->GetInflType() == D_INFLTYPE_LINE)
		{
			MakeMvlTrcForcDataList_New2(nGPSMode);
			MakeAvgMvlTrcInflValue(0);
		}
		else  MakeMvlTrcTForcDataListS(pDE);
		break;

	case GPS_COMMAND_MVLTRCBFORC:
		if(CDBDoc::GetDocPoint()->m_pPostCtrl->GetInflType() == D_INFLTYPE_LINE)
		{
			MakeMvlTrcForcDataList_New2(nGPSMode);
			MakeAvgMvlTrcInflValue(1);
		}
		else  MakeMvlTrcBForcDataListS(pDE);
		break;

	case GPS_COMMAND_MVLTRCPFORC:
		if(CDBDoc::GetDocPoint()->m_pPostCtrl->GetInflType() == D_INFLTYPE_LINE)
		{
			MakeMvlTrcForcDataList_New2(nGPSMode); 
			MakeAvgMvlTrcInflValue(2);
		}
		else  MakeMvlTrcPForcDataListS(pDE);
		break;

	case GPS_COMMAND_IFGBFORC:
		RemoveInflGrid();
		m_pInflGrid = CGPSInflGridBase::CreateInflGrid(D_INFL_GRID_BFORC,this);
		if(m_pInflGrid) m_pInflGrid->MakeInfl();
		else            ASSERT(0);
		break; 

	case GPS_COMMAND_IFGTFORC:
		RemoveInflGrid();
		m_pInflGrid = CGPSInflGridBase::CreateInflGrid(D_INFL_GRID_TFORC,this);
		if(m_pInflGrid) m_pInflGrid->MakeInfl();
		else            ASSERT(0);
		break; 

	case GPS_COMMAND_IFGELNK:
		RemoveInflGrid();
		m_pInflGrid = CGPSInflGridBase::CreateInflGrid(D_INFL_GRID_ELNK,this);
		if(m_pInflGrid) m_pInflGrid->MakeInfl();
		else            ASSERT(0);
		break; 

	case GPS_COMMAND_IFGNLNK:
		RemoveInflGrid();
		m_pInflGrid = CGPSInflGridBase::CreateInflGrid(D_INFL_GRID_NLNK,this);
		if(m_pInflGrid) m_pInflGrid->MakeInfl();
		else            ASSERT(0);
		break; 

	case GPS_COMMAND_GRIDTRC_TFORC:
		RemoveInflGrid();
		m_pInflGrid = CGPSInflGridBase::CreateInflGrid(D_INFL_GRID_TFORC,this);
		if(m_pInflGrid) m_pInflGrid->MakeInfl();
		else            ASSERT(0);
		MakeJPGridTrcForcDataList(nGPSMode, m_pInflGrid);
		break; 

	case GPS_COMMAND_GRIDTRC_BFORC:
		RemoveInflGrid();
		m_pInflGrid = CGPSInflGridBase::CreateInflGrid(D_INFL_GRID_BFORC,this);
		if(m_pInflGrid) m_pInflGrid->MakeInfl();
		else            ASSERT(0);
		MakeJPGridTrcForcDataList(nGPSMode, m_pInflGrid);
		break; 

	case GPS_COMMAND_GRIDTRC_ELNK:
		RemoveInflGrid();
		m_pInflGrid = CGPSInflGridBase::CreateInflGrid(D_INFL_GRID_ELNK,this);
		if(m_pInflGrid) m_pInflGrid->MakeInfl();
		else            ASSERT(0);
		MakeJPGridTrcLinkDataList(nGPSMode, m_pInflGrid);
		break; 

	case GPS_COMMAND_GRIDTRC_NLNK:
		RemoveInflGrid();
		m_pInflGrid = CGPSInflGridBase::CreateInflGrid(D_INFL_GRID_NLNK,this);
		if(m_pInflGrid) m_pInflGrid->MakeInfl();
		else            ASSERT(0);
		MakeJPGridTrcLinkDataList(nGPSMode, m_pInflGrid);
		break; 

	case GPS_COMMAND_SSFR:
		MakeSSFRData(); 
		break;

	case GPS_COMMAND_THISBFORC:
	case GPS_COMMAND_THISBDGRM:
		MakeBForcTimeHist();
		break; 

	case GPS_COMMAND_STRIP_DGN:
	case GPS_COMMAND_STRIP_CHK:
		MakeStripForcDataList();
		break;
	case GPS_COMMAND_ISOLATION_FORCE:
		MakeIsolationForceDataList();
		break;
	}

	switch(nGPSMode) 
	{
	case GPS_COMMAND_IFSTFORC:
	case GPS_COMMAND_IFSBFORC:
	case GPS_COMMAND_IFSPFORC:
	case GPS_COMMAND_IFLBFORC:
	case GPS_COMMAND_IFLPFORC:
	case GPS_COMMAND_IFLTFORC:
	case GPS_COMMAND_MVLTRCTFORC:
	case GPS_COMMAND_MVLTRCBFORC:
	case GPS_COMMAND_MVLTRCPFORC:
	case GPS_COMMAND_ESFBM:
	case GPS_COMMAND_IFGBFORC:
	case GPS_COMMAND_IFGTFORC:
	case GPS_COMMAND_IFGELNK:
	case GPS_COMMAND_IFGNLNK:
	case GPS_COMMAND_GRIDTRC_TFORC:
	case GPS_COMMAND_GRIDTRC_BFORC:
	case GPS_COMMAND_GRIDTRC_ELNK:
	case GPS_COMMAND_GRIDTRC_NLNK:
		gm->m_nLgdMaxValKey=0;
		gm->m_nLgdMinValKey=0;
		break;
	}
}

void CForceEngine::InitEngine_All_First()
{
		m_SerialList.RemoveAll();
		m_pDoc->m_pPostCtrl->GetLaneInfo(m_arLaneInfoNew);

		int nNumOfLane = m_arLaneInfoNew.GetSize();
		int nLaneIdx;
		for(int i=0; i<nNumOfLane; i++)
		{
				nLaneIdx = i;
				//nLaneIdx = m_pDoc->m_pPostCtrl->GetSerialLlan(KeyList[i])-1;

				// 해석용 dummy sub lane 제외.      
				if(m_pDoc->m_pPostCtrl->IsDummyLaneForSolver_bySerial(nLaneIdx+1))  continue;
				if(m_pDoc->m_pPostCtrl->IsDummyLaneForSolver_bySerial_op(nLaneIdx+1))   continue;
				m_SerialList.Add(nLaneIdx); 
		}

		DECLARE_GPSMD();
		gm->m_bLoadDataExist = TRUE;

		m_bInitEngine_All_First = TRUE;
}

// Get all the Influence Data for one Element, including all the part of element,and all the components of force. 
void CForceEngine::InitEngine_AllForOneElem(CDeformEngine *pDE,int nGPSInstruction,BOOL bSendedHandleGPSBar)
{
		if (!m_bInitEngine_All_First)
		{
				InitEngine_All_First();
		}

		I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

		if(gm->m_LoadCaseType == D_LOADCASE_PUSHOVER && !m_pDoc->m_pPostCtrl->IsPushOverResultEnable())
		{
				//AfxMessageBox(_LS(IDS_WG_GPS_PUSHOVER_RESULT_UNAVAILABLE));
				return;
		}

		m_bTForcDataSet = FALSE;
		m_bBForcDataSet	= FALSE;
		m_bWForcDataSet	= FALSE;
		m_bPForcDataSet = FALSE;
		m_bSSFRDataSet  = FALSE; 
		m_bStripOutput  = FALSE;
		m_bResultantForcDataSet = FALSE;
		gm->SelectLoad();

		int nGPSMode = (nGPSInstruction != -1)? nGPSInstruction:gm->m_GPSMode;
		switch (nGPSMode) 
		{
		case GPS_COMMAND_IFSTFORC:
				MakeInflTForcDataListS_AllForOneElem(pDE);
				break;
		case GPS_COMMAND_IFSBFORC:
				MakeInflBForcDataListS_AllForOneElem(pDE);
				break;
		case GPS_COMMAND_IFSPFORC:
				MakeInflPForcDataListS_AllForOneElem(pDE);
				break;
		case GPS_COMMAND_IFLBFORC:
		case GPS_COMMAND_IFLPFORC:
		case GPS_COMMAND_IFLTFORC:
				MakeInflForcDataList_AllForOneElem();
				break;
		default:
				break;
		}
}

// 주어진 노드에서의 Truss Force 값을 구함
double CForceEngine::CalcTForcValue(T_STRT_D &tforc_d, int node)
{
	double	ret;

	if(node == I_NODE) 
	{
		ret = tforc_d.dblForce[0];
	}
	else 
	{
		ret = tforc_d.dblForce[1];
	}

	return ret;
}

// i/j 노드의 Truss Force 값 중 큰 것을 구함.
double CForceEngine::GetMaxElemTForc(T_STRT_D &tforc_d)
{
	double		max=-DBL_MAX;

	if (tforc_d.dblForce[0]>tforc_d.dblForce[1])  max = tforc_d.dblForce[0];
	else  max = tforc_d.dblForce[1];
	return max;
}

// i/j 노드의 Truss Force 값 중 작은 것을 구함.
double CForceEngine::GetMinElemTForc(T_STRT_D &tforc_d)
{
	double		min=DBL_MAX;

	if (tforc_d.dblForce[0]>tforc_d.dblForce[1])
		min = tforc_d.dblForce[1];
	else
		min = tforc_d.dblForce[0];

	return min;
}


// Truss Force 데이터를 만든다.
// 현재 Active Element List에 대해 Loop를 돌며
// 1. DB로 부터 해당 요소의 Truss Force 데이터를 얻고
// 2. Truss Force에 대한 최대/최소값을 갱신하고
// 3. Truss Force값 및 해당 요소번호를 CArray에 저장
BOOL CForceEngine::MakeTForcDataList()
{
	if (CTestEnvMgr::IsTestEnvST(_LSX(ProfilingSTL), _LSX(yes)))
	{
		M_PROFILE('MakeTForcDataList()');
	}

	//I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	DECLARE_GPSMD();

	int		    i, elem_num;
	double	  max_tforc=-DBL_MAX, min_tforc=DBL_MAX, len;
	BOOL		  has_content=FALSE;
	T_ELEM_K	elem_key;
	T_ELEM_D	elem_data;
	T_STRT_D	tforc_d;

	if(!gm->m_bLoadDataSet)return FALSE;
	gm->m_pMyView->BeginWaitCursor();

	m_TrussKeyList.RemoveAll();
	m_TrussReverseFg.RemoveAll();
	m_mapTForcData.RemoveAll();
	elem_num = gm->m_EKeyListActive.GetSize();

	for(i=0;i<elem_num;i++) 
	{
		elem_key = gm->m_EKeyListActive[i];
		m_pDoc->m_pAttrCtrl->GetElem(elem_key, elem_data);
		if(IsExcludeTruss(elem_key))continue; 

		switch (gm->m_LoadMinMaxType) 
		{
		case LOADTYPE_NORMAL:
		case LOADTYPE_MAX:
			if(gm->m_bCurStepForce)
			{
				if(!m_pDoc->m_pPostCtrl->GetCtrtNew(elem_key, &tforc_d,NULL,NULL)){ gm->m_pMyView->EndWaitCursor(); return FALSE; }
			}
			else
			{
				if(!m_pDoc->m_pPostCtrl->GetStrtNew(elem_key, &tforc_d,NULL,NULL)){ gm->m_pMyView->EndWaitCursor(); return FALSE; }
			}
			break;
		case LOADTYPE_MIN:
			if(gm->m_bCurStepForce)
			{
				if(!m_pDoc->m_pPostCtrl->GetCtrtNew(elem_key,NULL, &tforc_d,NULL)){ gm->m_pMyView->EndWaitCursor(); return FALSE; }
			}
			else
			{
				if(!m_pDoc->m_pPostCtrl->GetStrtNew(elem_key,NULL, &tforc_d,NULL)){ gm->m_pMyView->EndWaitCursor(); return FALSE; }
			}
			break;
		case LOADTYPE_ALL:
			if(gm->m_bCurStepForce)
			{
				if(!m_pDoc->m_pPostCtrl->GetCtrtNew(elem_key, NULL, NULL, &tforc_d)){ gm->m_pMyView->EndWaitCursor(); return FALSE; }
			}
			else
			{
				if(!m_pDoc->m_pPostCtrl->GetStrtNew(elem_key,NULL, NULL, &tforc_d)){ gm->m_pMyView->EndWaitCursor(); return FALSE; }
			}
			break;
		}

		if(((m_TForcComponent==TFORC_COMPONENT_TENS)&&((tforc_d.dblForce[0]<0.0)&&(tforc_d.dblForce[1]<0.0))) ||
			((m_TForcComponent==TFORC_COMPONENT_COMP)&&((tforc_d.dblForce[0]>0.0)&&(tforc_d.dblForce[1]>0.0))))    
			continue; 

		has_content = TRUE;

		len=GetMaxElemTForc(tforc_d);
		if(len>max_tforc){  max_tforc = len;  gm->m_nLgdMaxValKey = elem_key; }
		len=GetMinElemTForc(tforc_d);
		if(len<min_tforc){  min_tforc = len;  gm->m_nLgdMinValKey = elem_key; }

		m_TrussKeyList.Add(elem_key);
		m_mapTForcData.SetAt(elem_key,tforc_d);
	}

	if(!has_content) 
	{
		min_tforc = max_tforc = 0.0;
		gm->m_nLgdMaxValKey = 0;
		gm->m_nLgdMinValKey = 0;
	}

	m_dMaxValue = max_tforc;
	m_dMinValue = min_tforc;

	if(m_pContourEngine == NULL)m_pContourEngine = new CContourEngine(min_tforc, max_tforc);
	else		                    m_pContourEngine->MakeRankMap(min_tforc, max_tforc);

	gm->m_pMyView->EndWaitCursor();
	m_bTForcDataSet = TRUE;
	return TRUE;
}

BOOL CForceEngine::GetTForcRangeDataList(double& dMaxRange, double& dMinRange, CArray<UINT,UINT>& aElemKeyList)
{
	aElemKeyList.RemoveAll();

	if (CTestEnvMgr::IsTestEnvST(_LSX(ProfilingSTL), _LSX(yes)))
	{
		M_PROFILE('GetTForcRangeDataList()');
	}
	
	DECLARE_GPSMD();

	int		    i, elem_num;
	T_ELEM_K	elem_key;
	T_ELEM_D	elem_data;
	T_STRT_D	tforc_d;
	
	gm->m_pMyView->BeginWaitCursor();

	elem_num = gm->m_EKeyListActive.GetSize();

	for(i=0;i<elem_num;i++) 
	{
		elem_key = gm->m_EKeyListActive[i];
		m_pDoc->m_pAttrCtrl->GetElem(elem_key, elem_data);
		if(IsExcludeTruss(elem_key))continue; 

		switch (gm->m_LoadMinMaxType) 
		{
		case LOADTYPE_NORMAL:
		case LOADTYPE_MAX:
			if(gm->m_bCurStepForce)
			{
				if(!m_pDoc->m_pPostCtrl->GetCtrtNew(elem_key, &tforc_d,NULL,NULL)){ gm->m_pMyView->EndWaitCursor(); return FALSE; }
			}
			else
			{
				if(!m_pDoc->m_pPostCtrl->GetStrtNew(elem_key, &tforc_d,NULL,NULL)){ gm->m_pMyView->EndWaitCursor(); return FALSE; }
			}
			break;
		case LOADTYPE_MIN:
			if(gm->m_bCurStepForce)
			{
				if(!m_pDoc->m_pPostCtrl->GetCtrtNew(elem_key,NULL, &tforc_d,NULL)){ gm->m_pMyView->EndWaitCursor(); return FALSE; }
			}
			else
			{
				if(!m_pDoc->m_pPostCtrl->GetStrtNew(elem_key,NULL, &tforc_d,NULL)){ gm->m_pMyView->EndWaitCursor(); return FALSE; }
			}
			break;
		case LOADTYPE_ALL:
			if(gm->m_bCurStepForce)
			{
				if(!m_pDoc->m_pPostCtrl->GetCtrtNew(elem_key, NULL, NULL, &tforc_d)){ gm->m_pMyView->EndWaitCursor(); return FALSE; }
			}
			else
			{
				if(!m_pDoc->m_pPostCtrl->GetStrtNew(elem_key,NULL, NULL, &tforc_d)){ gm->m_pMyView->EndWaitCursor(); return FALSE; }
			}
			break;
		}

		if(((m_TForcComponent==TFORC_COMPONENT_TENS)&&((tforc_d.dblForce[0]<0.0)&&(tforc_d.dblForce[1]<0.0))) ||
			((m_TForcComponent==TFORC_COMPONENT_COMP)&&((tforc_d.dblForce[0]>0.0)&&(tforc_d.dblForce[1]>0.0))))    
			continue;

		// 2. Truss Force가 최대/최소 범위안에 들어오는가?
		if(!IsWithinRangeElemTForc(tforc_d,dMaxRange,dMinRange)) continue;
		aElemKeyList.Add(elem_key);
	}

	gm->m_pMyView->EndWaitCursor();

	return TRUE;
}

BOOL CForceEngine::IsExcludeTruss(T_ELEM_K ElemK)
{
	T_ELEM_D ElemD;
	if(!m_pDoc->m_pAttrCtrl->GetElem(ElemK,ElemD))return TRUE; 
	if(!m_pDoc->m_pAttrCtrl->IsTruss(ElemD.eltyp))return TRUE;
	/* KYE-HONG-2003-02-28
	// 원래대로 되돌려놓기로 함 
	switch(m_TForcComponent)
	{
	case TFORC_COMPONENT_TENS:
	if(m_pDoc->m_pAttrCtrl->IsCompTruss(ElemD.eltyp))return TRUE; 
	break; 
	case TFORC_COMPONENT_COMP:
	if(m_pDoc->m_pAttrCtrl->IsTensTruss(ElemD.eltyp))return TRUE; 
	break;
	}
	*/
	return FALSE; 
}

#if defined(__OLD_OUTPUT_VALUE)
void CForceEngine::OutputTForcNumbers(CDC *pDC)
{
	I_GPSModel						*gm=(I_GPSModel *) m_pGPSModel;

	int								i, j, elem_num, slope;
	T_ELEM_K						ekey;
	T_ELEM_D						edata;
	T_STRT_D						tforc_d;
	C3DPoint						node3D_i, node3D_j,DrawPoint;
	CPoint							text_p,node_2d_i, node_2d_j;
	TCHAR							fmt_str[10], text_str[512];
	CFont							ft, *old_ft;
	BOOL							fl_bak, is_inverse;

	POSITION						pos;
	CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray <CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					edge_list;

	if (!m_bTForcDataSet)
		return;

	if (gm->m_DOPT.TX.m_bNumberOpaque)
		pDC->SetBkMode(OPAQUE);
	else
		pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
	pDC->SetBkColor(gm->m_DOPT.TX.m_NumberBackCol);
	pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);

	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);

	fl_bak = gm->m_DOPT.DR.m_bFrameLine;
	gm->m_DOPT.DR.m_bFrameLine = TRUE;

	if (gm->m_DOPT.TX.m_bNumberSelOnly) {
	}
	else 
	{
		BOOL bGrpFltMode=gm->m_pGPSCtrl->IsGroupFilterMode();
		if(!bGrpFltMode)elem_num = gm->m_EKeyListActive.GetSize();
		else            elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize(); 

		for (i=0;i<elem_num;i++) 
		{
			if(!bGrpFltMode)ekey = gm->m_EKeyListActive[i];
			else            ekey = gm->m_pDispFilter->m_aGrpEKey[i]; 

			if(!gm->m_pGPSCtrl->IsActiveElem(ekey))
				continue;

			m_pDoc->m_pAttrCtrl->GetElem(ekey, edata);

			//if(!m_pDoc->m_pAttrCtrl->IsTruss(edata.eltyp))
			if(IsExcludeTruss(ekey))continue;
#if defined(_TOWER)
			if(m_pDoc->m_pPostCtrl->GetTowerInfo()->IsRedundantElement(ekey)) 
				continue;
#endif

			if(!GetTrussForce(ekey, tforc_d))continue; 
			if(((m_TForcComponent==TFORC_COMPONENT_TENS)&&((tforc_d.dblForce[0]<0.0)&&(tforc_d.dblForce[1]<0.0))) ||
				((m_TForcComponent==TFORC_COMPONENT_COMP)&&((tforc_d.dblForce[0]>0.0)&&(tforc_d.dblForce[1]>0.0))))
				continue;

			if(m_bDeformedShapeContour) 
			{
				gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list);
			}
			else {
				gm->GetShapeElement(ekey, polygon_list, &edge_list);
			}

			pos = polygon_list[0]->GetHeadPosition();

			node3D_i = polygon_list[0]->GetNext(pos);
			node3D_j = polygon_list[0]->GetNext(pos);

			if (gm->m_bVirtualMode) {
				node_2d_i = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_i);
				node_2d_j = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_j);
			}
			else {
				node_2d_i = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_i);
				node_2d_j = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_j);
			}

			if((node_2d_i.x >= 0 && node_2d_i.y >= 0 && node_2d_j.x >= 0 && node_2d_j.y >= 0))
			{
				slope = (int) (atan2(node_2d_i.y-node_2d_j.y, node_2d_j.x-node_2d_i.x)*1800.0/3.14159);
				slope = (slope+3600)%3600;
				if ((900<slope) && (slope<=2700)) {
					slope = (slope+1800)%3600;
					is_inverse = TRUE;
				}
				else {
					is_inverse = FALSE;
				}

				gm->SetNumberFontOrientation(slope);
				ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
				old_ft = (CFont *) pDC->SelectObject(&ft);

				if(gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
				{
					double dLimit = (m_dMaxValue-m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;
					double dTValue;

					for(int n=0; n<2; n++)
					{
						if(n==0) // I단 또는 MAX
						{
							if (m_TForcOutputSection == TFORC_OUTPUT_JNODE) continue;

							if (m_TForcOutputSection == TFORC_OUTPUT_INODE || m_TForcOutputSection == TFORC_OUTPUT_ALL) 
							{
								if (is_inverse)
									pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
								else
									pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
								DrawPoint = node3D_i;
								dTValue = CalcTForcValue(tforc_d, I_NODE);
							}
							else if (m_TForcOutputSection == TFORC_OUTPUT_MAX) 
							{
								pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);
								DrawPoint.x = (node3D_i.x + node3D_j.x)/2.0;
								DrawPoint.y = (node3D_i.y + node3D_j.y)/2.0;
								DrawPoint.z = (node3D_i.z + node3D_j.z)/2.0;
								dTValue = (fabs(CalcTForcValue(tforc_d, I_NODE)) >= fabs(CalcTForcValue(tforc_d, J_NODE)))? CalcTForcValue(tforc_d, I_NODE) : CalcTForcValue(tforc_d, J_NODE);
							}
						}
						else // J단
						{			  
							if (m_TForcOutputSection == TFORC_OUTPUT_INODE || m_TForcOutputSection == TFORC_OUTPUT_MAX ) continue;
							if (is_inverse)
								pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
							else
								pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
							DrawPoint = node3D_j;
							dTValue = CalcTForcValue(tforc_d, J_NODE);
						}

						switch(gm->m_DOPT.TX.m_nOutputMinMaxType)
						{
						case 0: // Min & Max
							if((m_dMaxValue-dTValue) <= dLimit)
								DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,dTValue);
							else if((dTValue-m_dMinValue) <= dLimit)
								DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,dTValue);
							break;
						case 1: // Abs Max
							if(fabs(m_dMaxValue) >= fabs(m_dMinValue))
							{
								if( fabs(m_dMaxValue)-fabs(dTValue) <= dLimit)
									DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dTValue);
							}
							else
							{
								if( fabs(m_dMinValue)-fabs(dTValue) <= dLimit)
									DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dTValue);
							}
							break;
						case 2: // Max
							if((m_dMaxValue-dTValue) <= dLimit)
								DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,dTValue);
							break;
						case 3: // Min
							if((dTValue-m_dMinValue) <= dLimit)
								DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,dTValue);
							break;
						}
					}
					//////////////////////////////////////////////////////////////////////////////////////
				}      
				else      
				{
					if (m_TForcOutputSection == TFORC_OUTPUT_ALL) {
						pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorI);
						if (is_inverse)
							pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
						else
							pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
						text_p.x = (int) node_2d_i.x;
						text_p.y = (int) node_2d_i.y;
						_stprintf(text_str, fmt_str, tforc_d.dblForce[0]);
						pDC->TextOut(text_p.x, text_p.y, text_str);

						pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorJ);
						if (is_inverse)
							pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
						else
							pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
						text_p.x = (int) node_2d_j.x;
						text_p.y = (int) node_2d_j.y;
						_stprintf(text_str, fmt_str, tforc_d.dblForce[1]);
						pDC->TextOut(text_p.x, text_p.y, text_str);
					}
					else if (m_TForcOutputSection == TFORC_OUTPUT_MAX) {
						text_p.x = (int) ((node_2d_i.x+node_2d_j.x)/2.0);
						text_p.y = (int) ((node_2d_i.y+node_2d_j.y)/2.0);
						_stprintf(text_str, fmt_str, GetMaxElemTForc(tforc_d));
						pDC->TextOut(text_p.x, text_p.y, text_str);
					}
					else if (m_TForcOutputSection == TFORC_OUTPUT_INODE) {
						pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorI);
						if (is_inverse)
							pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
						else
							pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
						text_p.x = (int) node_2d_i.x;
						text_p.y = (int) node_2d_i.y;
						_stprintf(text_str, fmt_str, tforc_d.dblForce[0]);
						pDC->TextOut(text_p.x, text_p.y, text_str);
					}
					else if (m_TForcOutputSection == TFORC_OUTPUT_JNODE) {
						pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorJ);
						if (is_inverse)
							pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
						else
							pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
						text_p.x = (int) node_2d_j.x;
						text_p.y = (int) node_2d_j.y;
						_stprintf(text_str, fmt_str, tforc_d.dblForce[1]);
						pDC->TextOut(text_p.x, text_p.y, text_str);
					}
					else {
						text_p.x = (int) ((node_2d_i.x+node_2d_j.x)/2.0);
						text_p.y = (int) ((node_2d_i.y+node_2d_j.y)/2.0);
						_stprintf(text_str, fmt_str, tforc_d.dblForce[1]);
						pDC->TextOut(text_p.x, text_p.y, text_str);
					}
				}

				pDC->SelectObject(old_ft);
				ft.DeleteObject();
			}

			for (j=0;j<polygon_list.GetSize();j++) {
				polygon_list[j]->RemoveAll();
				delete polygon_list[j];
				edge_list[j]->RemoveAll();
				delete edge_list[j];
			}
			polygon_list.RemoveAll();
			edge_list.RemoveAll();
		}
	}

	gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}
#else
void CForceEngine::OutputTForcNumbers(CDC *pDC)
{
	I_GPSModel						*gm = (I_GPSModel *)m_pGPSModel;

	int								i, j, elem_num, slope;
	T_ELEM_K						ekey;
	T_ELEM_D						edata;
	T_STRT_D						tforc_d;
	C3DPoint						node3D_i, node3D_j, DrawPoint;
	CPoint							text_p, node_2d_i, node_2d_j;
	TCHAR							fmt_str[10], text_str[512];
	CFont							ft, *old_ft;
	BOOL							fl_bak, is_inverse;

	POSITION						pos;
	CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray <CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					edge_list;

	if (!m_bTForcDataSet)
		return;

	GPostTextOut TextOutModel;
	TextOutModel.StartTrussForceVal();
	TextOutModel.SetDC(pDC);
	TextOutModel.SettingTrussForce(gm);

	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);

	fl_bak = gm->m_DOPT.DR.m_bFrameLine;
	gm->m_DOPT.DR.m_bFrameLine = TRUE;

	if (gm->m_DOPT.TX.m_bNumberSelOnly) {
	}
	else
	{
		BOOL bGrpFltMode = gm->m_pGPSCtrl->IsGroupFilterMode();
		if (!bGrpFltMode)elem_num = gm->m_EKeyListActive.GetSize();
		else            elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize();

		for (i = 0; i < elem_num; i++)
		{
			if (!bGrpFltMode)ekey = gm->m_EKeyListActive[i];
			else            ekey = gm->m_pDispFilter->m_aGrpEKey[i];

			if (!gm->m_pGPSCtrl->IsActiveElem(ekey))
				continue;

			m_pDoc->m_pAttrCtrl->GetElem(ekey, edata);

			//if(!m_pDoc->m_pAttrCtrl->IsTruss(edata.eltyp))
			if (IsExcludeTruss(ekey))continue;
#if defined(_TOWER)
			if (m_pDoc->m_pPostCtrl->GetTowerInfo()->IsRedundantElement(ekey))
				continue;
#endif

			if (!GetTrussForce(ekey, tforc_d))continue;
			if (((m_TForcComponent == TFORC_COMPONENT_TENS) && ((tforc_d.dblForce[0] < 0.0) && (tforc_d.dblForce[1] < 0.0))) ||
				((m_TForcComponent == TFORC_COMPONENT_COMP) && ((tforc_d.dblForce[0] > 0.0) && (tforc_d.dblForce[1] > 0.0))))
				continue;

			if (m_bDeformedShapeContour)
			{
				gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list);
			}
			else {
				gm->GetShapeElement(ekey, polygon_list, &edge_list);
			}

			pos = polygon_list[0]->GetHeadPosition();

			node3D_i = polygon_list[0]->GetNext(pos);
			node3D_j = polygon_list[0]->GetNext(pos);

			if (gm->m_bVirtualMode) {
				node_2d_i = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_i);
				node_2d_j = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_j);
			}
			else {
				node_2d_i = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_i);
				node_2d_j = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_j);
			}

			if ((node_2d_i.x >= 0 && node_2d_i.y >= 0 && node_2d_j.x >= 0 && node_2d_j.y >= 0))
			{
				slope = (int)(atan2(node_2d_i.y - node_2d_j.y, node_2d_j.x - node_2d_i.x)*1800.0 / 3.14159);
				slope = (slope + 3600) % 3600;
				if ((900 < slope) && (slope <= 2700)) {
					slope = (slope + 1800) % 3600;
					is_inverse = TRUE;
				}
				else {
					is_inverse = FALSE;
				}

				TextOutModel.Font4TrussForce(gm, slope);

				if (gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
				{
					double dLimit = (m_dMaxValue - m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;
					double dTValue;

					for (int n = 0; n < 2; n++)
					{
						if (n == 0) // I단 또는 MAX
						{
							if (m_TForcOutputSection == TFORC_OUTPUT_JNODE) continue;

							if (m_TForcOutputSection == TFORC_OUTPUT_INODE || m_TForcOutputSection == TFORC_OUTPUT_ALL)
							{
								if (is_inverse)
									TextOutModel.AlignTextBot(TA_RIGHT);
								else
									TextOutModel.AlignTextBot(TA_LEFT);
								DrawPoint = node3D_i;
								dTValue = CalcTForcValue(tforc_d, I_NODE);
							}
							else if (m_TForcOutputSection == TFORC_OUTPUT_MAX)
							{
								TextOutModel.AlignTextBot(TA_CENTER);
								DrawPoint.x = (node3D_i.x + node3D_j.x) / 2.0;
								DrawPoint.y = (node3D_i.y + node3D_j.y) / 2.0;
								DrawPoint.z = (node3D_i.z + node3D_j.z) / 2.0;
								dTValue = (fabs(CalcTForcValue(tforc_d, I_NODE)) >= fabs(CalcTForcValue(tforc_d, J_NODE))) ? CalcTForcValue(tforc_d, I_NODE) : CalcTForcValue(tforc_d, J_NODE);
							}
						}
						else // J단
						{
							if (m_TForcOutputSection == TFORC_OUTPUT_INODE || m_TForcOutputSection == TFORC_OUTPUT_MAX) continue;
							if (is_inverse)
								TextOutModel.AlignTextBot(TA_LEFT);
							else
								TextOutModel.AlignTextBot(TA_RIGHT);
							DrawPoint = node3D_j;
							dTValue = CalcTForcValue(tforc_d, J_NODE);
						}

						switch (gm->m_DOPT.TX.m_nOutputMinMaxType)
						{
						case 0: // Min & Max
							if ((m_dMaxValue - dTValue) <= dLimit)
								DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, dTValue);
							else if ((dTValue - m_dMinValue) <= dLimit)
								DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, dTValue);
							break;
						case 1: // Abs Max
							if (fabs(m_dMaxValue) >= fabs(m_dMinValue))
							{
								if (fabs(m_dMaxValue) - fabs(dTValue) <= dLimit)
									DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, dTValue);
							}
							else
							{
								if (fabs(m_dMinValue) - fabs(dTValue) <= dLimit)
									DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, dTValue);
							}
							break;
						case 2: // Max
							if ((m_dMaxValue - dTValue) <= dLimit)
								DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, dTValue);
							break;
						case 3: // Min
							if ((dTValue - m_dMinValue) <= dLimit)
								DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, dTValue);
							break;
						}
					}
					//////////////////////////////////////////////////////////////////////////////////////
				}
				else
				{
					if (m_TForcOutputSection == TFORC_OUTPUT_ALL) {
						text_p.x = (int)node_2d_i.x;
						text_p.y = (int)node_2d_i.y;
						_stprintf(text_str, fmt_str, tforc_d.dblForce[0]);
						if (is_inverse)
							TextOutModel.TextOutTrussForce(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorI, TA_RIGHT);
						else
							TextOutModel.TextOutTrussForce(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorI, TA_LEFT);

						text_p.x = (int)node_2d_j.x;
						text_p.y = (int)node_2d_j.y;
						_stprintf(text_str, fmt_str, tforc_d.dblForce[1]);
						if (is_inverse)
							TextOutModel.TextOutTrussForce(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorJ, TA_LEFT);
						else
							TextOutModel.TextOutTrussForce(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorJ, TA_RIGHT);
					}
					else if (m_TForcOutputSection == TFORC_OUTPUT_MAX) {
						text_p.x = (int)((node_2d_i.x + node_2d_j.x) / 2.0);
						text_p.y = (int)((node_2d_i.y + node_2d_j.y) / 2.0);
						_stprintf(text_str, fmt_str, GetMaxElemTForc(tforc_d));
						TextOutModel.TextOutTrussForce(text_p.x, text_p.y, text_str);
					}
					else if (m_TForcOutputSection == TFORC_OUTPUT_INODE) {
						text_p.x = (int)node_2d_i.x;
						text_p.y = (int)node_2d_i.y;
						_stprintf(text_str, fmt_str, tforc_d.dblForce[0]);
						if (is_inverse)
							TextOutModel.TextOutTrussForce(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorI, TA_RIGHT);
						else
							TextOutModel.TextOutTrussForce(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorI, TA_LEFT);
					}
					else if (m_TForcOutputSection == TFORC_OUTPUT_JNODE) {
						text_p.x = (int)node_2d_j.x;
						text_p.y = (int)node_2d_j.y;
						_stprintf(text_str, fmt_str, tforc_d.dblForce[1]);
						if (is_inverse)
							TextOutModel.TextOutTrussForce(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorJ, TA_LEFT);
						else
							TextOutModel.TextOutTrussForce(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorJ, TA_RIGHT);
					}
					else {
						text_p.x = (int)((node_2d_i.x + node_2d_j.x) / 2.0);
						text_p.y = (int)((node_2d_i.y + node_2d_j.y) / 2.0);
						_stprintf(text_str, fmt_str, tforc_d.dblForce[1]);
						TextOutModel.TextOutTrussForce(text_p.x, text_p.y, text_str);
					}
				}

				TextOutModel.DeleteFont();
			}

			for (j = 0; j < polygon_list.GetSize(); j++) {
				polygon_list[j]->RemoveAll();
				delete polygon_list[j];
				edge_list[j]->RemoveAll();
				delete edge_list[j];
			}
			polygon_list.RemoveAll();
			edge_list.RemoveAll();
		}
	}
	TextOutModel.EndTrussForceVal();
	gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}
#endif

void CForceEngine::DrawTForcContour(CDC *pDC)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	T_MIRE_K mkey;
	int			i, elem_num;
	T_ELEM_D	elem_d;
	CPen		elem_pen, *old_pen;
	CArray <int, int>				type_list;
	CArray <GRE_Atom, GRE_Atom&>		atom_list;
	BOOL bEscapePressed = FALSE;
	//if (!gm->m_bContour) 
	//{
	//		gm->GPSDrawOriginal(pDC);
	//		return;
	//}

	if(m_bDeformedShapeContour) 
	{
		if(!gm->m_pDeformEngine) 
		{
			gm->GPSDrawOriginal(pDC);
			return;
		}
		type_list.Add(gm->m_MinOTID + OBJECT_TYPE_DEFORMED);
	}
	else 
	{
		type_list.Add(gm->m_MinOTID + OBJECT_TYPE_ORIGINAL);
	}

	elem_pen.CreatePen(PS_SOLID, gm->m_DOPT.DR.nElemHddn, m_pContourEngine->m_ElemColor);
	old_pen = (CPen *) pDC->SelectObject(&elem_pen);

	gm->m_pGPSCtrl->GetZSortedList(type_list, gm->m_EKeyListVisible_Mirror, atom_list);
	elem_num = atom_list.GetSize();
	for (i=0;i<elem_num;i++) 
	{
		if(gm->m_pGPSCtrl->WatchEscKeyPress()) return;
		if(gm->m_pGPSCtrl->IsZoomAllState() ||
			gm->m_pGPSCtrl->IsObjectInClientWindow(atom_list[i].m_OType, atom_list[i].m_OKey)) {
				mkey.keymap = atom_list[i].m_OKey;
				m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d);

				BOOL bRedundant = FALSE;
#if defined(_TOWER)
				bRedundant = m_pDoc->m_pPostCtrl->GetTowerInfo()->IsRedundantElement(mkey.key.elem_k);
#endif
				//if( m_pDoc->m_pAttrCtrl->IsTruss(elem_d.eltyp) && (gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey)) && !bEscapePressed && !bRedundant) 
				if( !IsExcludeTruss(mkey.key.elem_k) && (gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey)) && !bEscapePressed && !bRedundant) 
				{
					if(gm->m_bContour)
						DoTForcElementContour(pDC, atom_list[i].m_OKey);
					else
						gm->GPSDrawElement(pDC,atom_list[i].m_OKey);

				}
				else
				{
					if(m_bDeformedShapeContour)
						gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, atom_list[i].m_OKey);
					else
						gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
				}
		}
	}

	// 변형된 형태에 Undeformed Shape을 같이 그릴 경우.
	if (m_bDeformedShapeContour && gm->m_DOPT.DR.m_bDrawInactive && !bEscapePressed) {
		//int	rf_bak=gm->m_RenderFlag;
		int	rf_bak=gm->m_DOPT.DR.m_RenderFlag;
		//gm->m_RenderFlag = 2;
		gm->m_DOPT.DR.m_RenderFlag = 2;
		gm->GPSDrawOriginal(pDC, TRUE);
		//gm->m_RenderFlag = rf_bak;
		gm->m_DOPT.DR.m_RenderFlag = rf_bak;
	}

	pDC->SelectObject(old_pen);
	elem_pen.DeleteObject();
}

void CForceEngine::DoTForcElementContour(CDC *pDC, unsigned int ekey)
{
	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;
	T_MIRE_K mkey;
	mkey.keymap = ekey;

	int				i, poly_num, vtx_num;
	T_ELEM_D		elem_d;
	T_STRT_D		tforc_d;

	CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray <CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					edge_list;
	CArray <CArray <T_NODE_K, T_NODE_K> *, CArray <T_NODE_K, T_NODE_K> *>	VertexNode;

	if((gm->m_pDeformEngine==NULL) ||
		(m_pContourEngine==NULL) ||
		(!GetTrussForce(mkey.key.elem_k, tforc_d))) 
	{
		if(m_bDeformedShapeContour)
			gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, ekey);
		else
			gm->GPSDrawInactiveElement(pDC, ekey);
		return;
	}

	// tension 혹은 compression이 일어난 요소만 나타낼 경우
	if(((m_TForcComponent==TFORC_COMPONENT_TENS)&&((tforc_d.dblForce[0]<0.0)&&(tforc_d.dblForce[1]<0.0))) ||
		((m_TForcComponent==TFORC_COMPONENT_COMP)&&((tforc_d.dblForce[0]>0.0)&&(tforc_d.dblForce[1]>0.0)))) 
	{
		if (m_bDeformedShapeContour)
			gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, ekey);
		else
			gm->GPSDrawInactiveElement(pDC, ekey);
		return;
	}

	// 요소의 형상정보를 얻음
	m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d);
	if (m_bDeformedShapeContour) {
		gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list, &VertexNode);
	}
	else {
		gm->GetShapeElement(ekey, polygon_list, &edge_list, NULL, &VertexNode);
	}

	T_SECT_D SectD;
	if(gm->m_DOPT.DR.m_bFrameThick)
		m_pDoc->m_pAttrCtrl->GetSect(elem_d.elpro,SectD);
	poly_num = polygon_list.GetSize();

	gm->GPS_XGL_Begin_Elem(mkey.key.elem_k,elem_d);
	for(i=0;i<poly_num;i++) 
	{
		vtx_num = polygon_list[i]->GetCount();

		// Contour를 실시
		if (vtx_num == 2) 
		{
			DoTForcLineContour(pDC, polygon_list[i], tforc_d);
		}
		else 
		{
			if(!gm->IsPossibleDrawingPolyFrame(ekey,&elem_d,&SectD,poly_num,polygon_list[i]))continue;
			//if(poly_num>1 && gm->m_DOPT.DR.m_bFrameThick && !gm->IsVisibleFace(polygon_list[i],vtx_num))
			// continue;

			DoTForcPolyContour(pDC, polygon_list[i], edge_list[i], VertexNode[i], elem_d, tforc_d);

			// Fill+Outline의 경우 Contour를 수행하기 전의 Polygon의 Outline을 그림.
			//if (gm->m_RenderFlag == 3 || gm->m_RenderFlag == 2)
			if (gm->m_DOPT.DR.m_RenderFlag == 3 || gm->m_DOPT.DR.m_RenderFlag == 2)
				gm->GPSDrawPolygonEdge(pDC, polygon_list[i], edge_list[i]);
		}
	}
	gm->GPS_XGL_End_Elem();

	FreeMemoryPolyList(&polygon_list,&edge_list,&VertexNode); 
	/*
	for (i=0;i<poly_num;i++) {
	polygon_list[i]->RemoveAll();
	delete polygon_list[i];
	edge_list[i]->RemoveAll();
	delete edge_list[i];
	VertexNode[i]->RemoveAll();
	delete VertexNode[i];
	}
	polygon_list.RemoveAll();
	edge_list.RemoveAll();
	VertexNode.RemoveAll();
	*/
}

void CForceEngine::DoTForcLineContour(CDC *pDC, CList <C3DPoint, C3DPoint> *Vertex, T_STRT_D &TForcVal)
{
	I_GPSModel						*gm=(I_GPSModel *) m_pGPSModel;
	double							i_val, j_val;
	POSITION						pos=Vertex->GetHeadPosition();
	C3DPoint						p[2];
	CArray <C3DPoint, C3DPoint>		rvtx_list;
	CArray <double, double>			rval_list;

	p[0] = Vertex->GetNext(pos);
	p[1] = Vertex->GetNext(pos);

	i_val = CalcTForcValue(TForcVal, I_NODE);
	j_val = CalcTForcValue(TForcVal, J_NODE);
	if (gm->m_AnimEngine.m_bAnimateContour) {
		i_val = m_pContourEngine->GetSubFrameValue(i_val, gm->m_AnimEngine.GetAnimationFactor(TRUE));
		j_val = m_pContourEngine->GetSubFrameValue(j_val, gm->m_AnimEngine.GetAnimationFactor(TRUE));
	}
	if (i_val > j_val) {
		rvtx_list.Add(p[0]);
		rval_list.Add(i_val);
		m_pContourEngine->GetRankVertices(p[0], p[1], i_val, j_val, rvtx_list, rval_list, NULL);
		rvtx_list.Add(p[1]);
		rval_list.Add(j_val);
	}
	else {
		rvtx_list.Add(p[1]);
		rval_list.Add(j_val);
		m_pContourEngine->GetRankVertices(p[1], p[0], j_val, i_val, rvtx_list, rval_list, NULL);
		rvtx_list.Add(p[0]);
		rval_list.Add(i_val);
	}

	//DrawContourLine(pDC, rvtx_list, rval_list);
	//DrawContourLine(pDC, rvtx_list, rval_list, gm->m_LnWd.nElemWire);
	DrawContourLine(pDC, rvtx_list, rval_list, gm->m_DOPT.DR.nElemWire);

	rvtx_list.RemoveAll();
	rval_list.RemoveAll();
}

void CForceEngine::DoTForcPolyContour(CDC *pDC,
																			CList <C3DPoint, C3DPoint> *Vertex,
																			CArray <BOOL, BOOL> *EdgeFlag,
																			CArray <T_NODE_K, T_NODE_K> *VertexNode,
																			T_ELEM_D &ElemData,
																			T_STRT_D &TForcVal)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	int			i, vertex_num=Vertex->GetCount();
	double		tforc_val[4];
	BOOL		ef[4];
	C3DPoint	p[4];

	// polygon이 i노드에 있는 것일 경우
	if( (VertexNode->GetAt(0)==VertexNode->GetAt(1)) &&
		(VertexNode->GetAt(0)==VertexNode->GetAt(2)) &&
		(VertexNode->GetAt(0)==ElemData.elnod[0])) 
	{
		for (i=0;i<vertex_num;i++) 
		{
			tforc_val[i] = CalcTForcValue(TForcVal, I_NODE);
			if (gm->m_AnimEngine.m_bAnimateContour)
				tforc_val[i] = m_pContourEngine->GetSubFrameValue(tforc_val[i], gm->m_AnimEngine.GetAnimationFactor(TRUE));
			ef[i] = EdgeFlag->GetAt(i);
		}
		DoSubPolyContour(pDC, tforc_val, Vertex, ef, TRUE);
	}
	// polygon이 j노드에 있는 것일 경우
	else if ((VertexNode->GetAt(0)==VertexNode->GetAt(1)) &&
		(VertexNode->GetAt(0)==VertexNode->GetAt(2)) &&
		(VertexNode->GetAt(0)==ElemData.elnod[1])) 
	{
		for (i=0;i<vertex_num;i++) 
		{
			tforc_val[i] = CalcTForcValue(TForcVal, J_NODE);
			if (gm->m_AnimEngine.m_bAnimateContour)
				tforc_val[i] = m_pContourEngine->GetSubFrameValue(tforc_val[i], gm->m_AnimEngine.GetAnimationFactor(TRUE));
			ef[i] = EdgeFlag->GetAt(i);
		}
		DoSubPolyContour(pDC, tforc_val, Vertex, ef, TRUE);
	}
	// polygon이 i, j노드에 걸쳐 있는 것일 경우
	else 
	{
		if(vertex_num!=4)return; 
		tforc_val[0] = tforc_val[1] = CalcTForcValue(TForcVal, I_NODE);
		tforc_val[2] = tforc_val[3] = CalcTForcValue(TForcVal, J_NODE);
		if (gm->m_AnimEngine.m_bAnimateContour) {
			tforc_val[0] = m_pContourEngine->GetSubFrameValue(tforc_val[0], gm->m_AnimEngine.GetAnimationFactor(TRUE));
			tforc_val[1] = m_pContourEngine->GetSubFrameValue(tforc_val[1], gm->m_AnimEngine.GetAnimationFactor(TRUE));
			tforc_val[2] = m_pContourEngine->GetSubFrameValue(tforc_val[2], gm->m_AnimEngine.GetAnimationFactor(TRUE));
			tforc_val[3] = m_pContourEngine->GetSubFrameValue(tforc_val[3], gm->m_AnimEngine.GetAnimationFactor(TRUE));
		}
		for (i=0;i<4;i++) {
			ef[i] = EdgeFlag->GetAt(i);
		}
		DoSubPolyContour(pDC, tforc_val, Vertex, ef, TRUE);
	}
}

BOOL CForceEngine::IsWithinRangeElemTForc(T_STRT_D &StrtD,double& max_strt,double& min_strt)
{
	double len_max = StrtD.dblForce[1];
	double len_min = StrtD.dblForce[0];

	if(len_min>len_max)
	{
		double len_temp = len_max;
		len_max = len_min;
		len_min = len_temp;
	}

	if (len_min <= min_strt && len_max >= max_strt)
		return TRUE;
	if (len_min >= min_strt && len_min <= max_strt)
		return TRUE;
	if (len_max >= min_strt && len_max <= max_strt)
		return TRUE;

	return FALSE;
}

double CForceEngine::CalcNForcValue(T_STEK_D &StekD, int IJPos)
{ 
	// node = 0:좌측, 1:우측
	double	len;

	switch(m_BForcComponent) 
	{
	case BFORC_COMPONENT_FX:
		len = StekD.dblForce[IJPos][0];
		break;
	case BFORC_COMPONENT_FY:
		len = StekD.dblForce[IJPos][1];
		break;
	case BFORC_COMPONENT_FZ:
		len = StekD.dblForce[IJPos][2];
		break;
	case BFORC_COMPONENT_MX:
		len = StekD.dblForce[IJPos][3];
		break;
	case BFORC_COMPONENT_MY:
		len = StekD.dblForce[IJPos][4];
		break;
	case BFORC_COMPONENT_MZ:
		len = StekD.dblForce[IJPos][5];
		break;
	default:
		ASSERT(0);
		return 0.0;
	}

	return len;
}

double CForceEngine::CalcBForcValue(T_STRB_D &bforc_d, int component, int part, int node)
{
	double	len;

	switch (component) {
	case BFORC_COMPONENT_FX:
		len = bforc_d.dblForce[part][node*6+0];
		break;
	case BFORC_COMPONENT_FY:
		len = bforc_d.dblForce[part][node*6+1];
		break;
	case BFORC_COMPONENT_FZ:
		len = bforc_d.dblForce[part][node*6+2];
		break;
	case BFORC_COMPONENT_MX:
		len = bforc_d.dblForce[part][node*6+3];
		break;
	case BFORC_COMPONENT_MY:
		len = bforc_d.dblForce[part][node*6+4];
		break;
	case BFORC_COMPONENT_MZ:
		len = bforc_d.dblForce[part][node*6+5];
		break;
	case BFORC_COMPONENT_W:
		len = bforc_d.dblForce[part][12+node];
		break;
	case BFORC_COMPONENT_MT:
		len = bforc_d.dblForce[part][14+node];
		break;
	case BFORC_COMPONENT_MW:
		len = bforc_d.dblForce[part][16+node];
		break;
	}

	return len;
}

void	  CForceEngine::SetBForcValue(double dValue,T_STRB_D &bforc_d, int component, int part, int node)
{
	switch(component) 
	{
	case BFORC_COMPONENT_FX:
		bforc_d.dblForce[part][node*6+0]  = dValue;
		break;
	case BFORC_COMPONENT_FY:
		bforc_d.dblForce[part][node*6+1]  = dValue;
		break;
	case BFORC_COMPONENT_FZ:
		bforc_d.dblForce[part][node*6+2]  = dValue;
		break;
	case BFORC_COMPONENT_MX:
		bforc_d.dblForce[part][node*6+3]  = dValue;
		break;
	case BFORC_COMPONENT_MY:
		bforc_d.dblForce[part][node*6+4]  = dValue;
		break;
	case BFORC_COMPONENT_MZ:
		bforc_d.dblForce[part][node*6+5]  = dValue;
		break;
	case BFORC_COMPONENT_W:
		bforc_d.dblForce[part][12+node]  = dValue;
		break;
	case BFORC_COMPONENT_MT:
		bforc_d.dblForce[part][14+node]  = dValue;
		break;
	case BFORC_COMPONENT_MW:
		bforc_d.dblForce[part][16+node]  = dValue;
		break;
	}
}

double CForceEngine::CalcBForcValue(T_STRB_D &bforc_d, int part, int node)
{// node = 0:좌측, 1:우측  하나의 part내에서

	double	len;

	switch (m_BForcComponent) {
	case BFORC_COMPONENT_FX:
		len = bforc_d.dblForce[part][node*6+0];
		break;
	case BFORC_COMPONENT_FY:
		len = bforc_d.dblForce[part][node*6+1];
		break;
	case BFORC_COMPONENT_FZ:
		len = bforc_d.dblForce[part][node*6+2];
		break;
	case BFORC_COMPONENT_MX:
		len = bforc_d.dblForce[part][node*6+3];
		break;
	case BFORC_COMPONENT_MY:
		len = bforc_d.dblForce[part][node*6+4];
		break;
	case BFORC_COMPONENT_MZ:
		len = bforc_d.dblForce[part][node*6+5];
		break;
	case BFORC_COMPONENT_W:
		len = bforc_d.dblForce[part][12+node];
		break;
	case BFORC_COMPONENT_MT:
		len = bforc_d.dblForce[part][14+node];
		break;
	case BFORC_COMPONENT_MW:
		len = bforc_d.dblForce[part][16+node];
		break;
	case BFORC_COMPONENT_FYZ:
		if (fabs(bforc_d.dblForce[part][node*6+1]) > fabs(bforc_d.dblForce[part][node*6+2]))
			len = bforc_d.dblForce[part][node*6+1];
		else
			len = bforc_d.dblForce[part][node*6+2];
		break;
	case BFORC_COMPONENT_MYZ:
		if (fabs(bforc_d.dblForce[part][node*6+4]) > fabs(bforc_d.dblForce[part][node*6+5]))
			len = bforc_d.dblForce[part][node*6+4];
		else
			len = bforc_d.dblForce[part][node*6+5];
		break;
	}
	return len;
}

double CForceEngine::CalcBForcValue(T_STRB_D &bforc_d, int out_sec,int* pMxMnPos,double *pMnVal)
{
	double	len=0.0, min, max;

	switch(out_sec) 
	{
	case BFORC_OUTPUT_INODE:
		len = CalcBForcValue(bforc_d, 0, I_NODE);
		break;
	case BFORC_OUTPUT_JNODE:
		len = CalcBForcValue(bforc_d, 3, J_NODE);
		break;
	case BFORC_OUTPUT_CENTER:
		len = CalcBForcValue(bforc_d, 1, J_NODE);
		break;
	case BFORC_OUTPUT_MAX:
		min = GetMinElemBForc(bforc_d);
		max = GetMaxElemBForc(bforc_d);
		if ((-min) > max)
			len = min;
		else
			len = max;
		break;
	case BFORC_OUTPUT_MAXMIN :
		// Min/Max의 위치까지 갖고옴 
		if(pMxMnPos)
		{
			int nMnPos,nMxPos;
			min = GetMinElemBForc(bforc_d,&nMnPos);
			max = GetMaxElemBForc(bforc_d,&nMxPos);
			pMxMnPos[0] = nMnPos;
			pMxMnPos[1] = nMxPos;
		}
		else
		{
			min = GetMinElemBForc(bforc_d);
			max = GetMaxElemBForc(bforc_d);
		}
		len = max; 
		if(pMnVal)*pMnVal = min;
		break;
	}

	return len;
}

// 주어진 position에서의 Beam Force 값을 구함
double CForceEngine::CalcBForcValuePos(T_STRB_D &bforc_d, double pos)
{
	double		len=0.0, vs, vd;

	if (pos == 0.0) {
		len = CalcBForcValue(bforc_d, 0, I_NODE);
	}
	// 1/4
	else if ((pos > 0.0) && (pos < 0.25)) {
		vs = CalcBForcValue(bforc_d, 0, I_NODE);
		vd = CalcBForcValue(bforc_d, 1, I_NODE) - vs;
		len = vs + vd*pos/0.25;
	}
	else if (pos == 0.25) {
		len = CalcBForcValue(bforc_d, 1, I_NODE);
	}
	// 2/4
	else if ((pos > 0.25) && (pos < 0.5)) {
		vs = CalcBForcValue(bforc_d, 1, I_NODE);
		vd = CalcBForcValue(bforc_d, 2, I_NODE) - vs;
		len = vs + vd*(pos-0.25)/0.25;
	}
	else if (pos == 0.5) {
		len = CalcBForcValue(bforc_d, 2, I_NODE);
	}
	// 3/4
	else if ((pos > 0.5) && (pos < 0.75)) {
		vs = CalcBForcValue(bforc_d, 2, I_NODE);
		vd = CalcBForcValue(bforc_d, 3, I_NODE) - vs;
		len = vs + vd*(pos-0.5)/0.25;
	}
	else if (pos == 0.75) {
		len = CalcBForcValue(bforc_d, 3, I_NODE);
	}
	// 4/4
	else if ((pos > 0.75) && (pos < 1.0)) {
		vs = CalcBForcValue(bforc_d, 3, I_NODE);
		vd = CalcBForcValue(bforc_d, 3, J_NODE) - vs;
		len = vs + vd*(pos-0.75)/0.25;
	}
	else if (pos == 1.0) {
		len = CalcBForcValue(bforc_d, 3, J_NODE);
	}

	return len;
}

// position을 global 3D Point로 주었을 때의
// 주어진 position에서의 Beam Force 값을 구함


// 주어진 position이 Beam 내의 어느 Part의 어느 Side인지를 구함
void CForceEngine::FindBeamPart(int component, double pos, int *part, int *side)
{
	*part = -1;	*side = -1;

	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	int			i, dir, part_num;
	double		len;

	if ((component==BFORC_COMPONENT_FY) || (component==BFORC_COMPONENT_MZ))
		dir = 2;
	else
		dir = 3;
	part_num = gm->m_pBeamDiagram->m_arP[dir][SIDE_I].GetSize();
	len = gm->m_pBeamDiagram->m_arP[dir][SIDE_J][part_num-1];

	for (i=0;i<part_num;i++) {
		if (pos == gm->m_pBeamDiagram->m_arP[dir][SIDE_I][i]/len) {
			*part = i;
			*side = SIDE_I;
		}
		else if ((pos > gm->m_pBeamDiagram->m_arP[dir][SIDE_I][i]/len) &&
			(pos < gm->m_pBeamDiagram->m_arP[dir][SIDE_C][i]/len)) {
				*part = i;
				*side = SIDE_L;
		}
		else if (pos == gm->m_pBeamDiagram->m_arP[dir][SIDE_C][i]/len) {
			*part = i;
			*side = SIDE_C;
		}
		else if ((pos > gm->m_pBeamDiagram->m_arP[dir][SIDE_C][i]/len) &&
			(pos < gm->m_pBeamDiagram->m_arP[dir][SIDE_J][i]/len)) {
				*part = i;
				*side = SIDE_R;
		}
		else if (pos == gm->m_pBeamDiagram->m_arP[dir][SIDE_J][i]/len) {
			*part = i;
			*side = SIDE_J;
		}
	}
}

// Sfd/Bmd를 Exact로 그릴 때 주어진 part와 side에서의 Beam Force 값을 구한다.


double CForceEngine::GetMaxElemBForc(T_STRB_D &bforc_d,int *pMxPos)
{
	double		len, max=-DBL_MAX;

	for(int i=0;i<4;i++)
		for(int j=0;j<2;j++) 
		{
			if(m_BForcComponent == BFORC_COMPONENT_FYZ) 
			{
				len = CalcBForcValue(bforc_d, BFORC_COMPONENT_FY, i, j);
				if(max < len) 
				{
					max = len;
					if(pMxPos)*pMxPos = i+j;
				}
				len = CalcBForcValue(bforc_d, BFORC_COMPONENT_FZ, i, j);
				if(max < len) 
				{
					max = len;
					if(pMxPos)*pMxPos = i+j;
				}
			}
			else if (m_BForcComponent == BFORC_COMPONENT_MYZ) {
				len = CalcBForcValue(bforc_d, BFORC_COMPONENT_MY, i, j);
				if(max < len) 
				{
					max = len;
					if(pMxPos)*pMxPos = i+j;
				}
				len = CalcBForcValue(bforc_d, BFORC_COMPONENT_MZ, i, j);
				if(max < len) 
				{
					max = len;
					if(pMxPos)*pMxPos = i+j;
				}
			}
			else {
				len = CalcBForcValue(bforc_d, i, j);
				if (max < len) 
				{
					max = len;
					if(pMxPos)*pMxPos = i+j;
				}
			}
		}
		return max;
}

double CForceEngine::GetMaxWallForc(T_STRW_D &StrwD)
{
	double	dMax=-DBL_MAX;
	for(int i=0;i<2;i++)
		dMax = max(CalcWForcValue(StrwD, i),dMax);
	return dMax;
}

double CForceEngine::GetMinWallForc(T_STRW_D &StrwD)
{
	double	dMin=DBL_MAX;
	for(int i=0;i<2;i++)
		dMin = min(CalcWForcValue(StrwD, i),dMin);
	return dMin;
}

BOOL CForceEngine::IsWithinRangeElemWForc(T_STRW_D &StrwD,double& max_strw,double& min_strw)
{
	double len_max = GetMaxWallForc(StrwD);
	double len_min = GetMinWallForc(StrwD);

	if(len_min>len_max)
	{
		double len_temp = len_max;
		len_max = len_min;
		len_min = len_temp;
	}

	if (len_min <= min_strw && len_max >= max_strw)
		return TRUE;
	if (len_min >= min_strw && len_min <= max_strw)
		return TRUE;
	if (len_max >= min_strw && len_max <= max_strw)
		return TRUE;

	return FALSE;
}

double CForceEngine::GetMaxNlnkForc(T_STEK_D &StekD)
{
	double	dMax=-DBL_MAX;
	for(int i=0;i<2;i++)
		dMax = max(CalcNForcValue(StekD, i),dMax);
	return dMax;
}

double CForceEngine::GetMinNlnkForc(T_STEK_D &StekD)
{
	double	dMin=DBL_MAX;
	for(int i=0;i<2;i++)
		dMin = min(CalcNForcValue(StekD, i),dMin);
	return dMin;
}

BOOL CForceEngine::IsWithinRangeNlnkForc(T_STEK_D &StekD,double& max_stek,double& min_stek)
{
	double len_max = CalcNForcValue(StekD, 0);
	double len_min = CalcNForcValue(StekD, 1);

	if(len_min>len_max)
	{
		double len_temp = len_max;
		len_max = len_min;
		len_min = len_temp;
	}

	if (len_min <= min_stek && len_max >= max_stek)
		return TRUE;
	if (len_min >= min_stek && len_min <= max_stek)
		return TRUE;
	if (len_max >= min_stek && len_max <= max_stek)
		return TRUE;

	return FALSE;
}

double CForceEngine::GetMinElemBForc(T_STRB_D &bforc_d,int *pMnPos)
{
	double		len, min=DBL_MAX;
	for(int i=0;i<4;i++) 
		for(int j=0;j<2;j++) 
		{
			if(m_BForcComponent == BFORC_COMPONENT_FYZ) 
			{
				len = CalcBForcValue(bforc_d, BFORC_COMPONENT_FY, i, j);
				if(min > len) 
				{
					min = len;
					if(pMnPos)*pMnPos = i+j;
				}
				len = CalcBForcValue(bforc_d, BFORC_COMPONENT_FZ, i, j);
				if(min > len) 
				{
					min = len;
					if(pMnPos)*pMnPos = i+j;
				}
			}
			else if(m_BForcComponent == BFORC_COMPONENT_MYZ) 
			{
				len = CalcBForcValue(bforc_d, BFORC_COMPONENT_MY, i, j);
				if(min > len) 
				{
					min = len;
					if(pMnPos)*pMnPos = i+j;
				}
				len = CalcBForcValue(bforc_d, BFORC_COMPONENT_MZ, i, j);
				if (min > len) 
				{
					min = len;
					if(pMnPos)*pMnPos = i+j;
				}
			}
			else 
			{
				len = CalcBForcValue(bforc_d, i, j);
				if(min > len) 
				{
					min = len;
					if(pMnPos)*pMnPos = i+j;
				}
			}
		}
		return min;
}

// Mid값은 뭔가요? : 해당 요소(멤버)의 I,J단을 제외하고 가장 절대값이 큰 값이오.
// 받은 Beam Force구조체의 Mid값을 반환
// bIncludeI,J : I,J단 포함하여 Mid값 구함
double CForceEngine::GetMidElemBForc(T_STRB_D &bforc_d, BOOL bIncludeI, BOOL bIncludeJ, int *pMidPos/*=NULL*/)
{
	double len=0, mid=0;
	for(int i=0;i<4;i++) 
		for(int j=0;j<2;j++) 
		{
			if(i+j==0 && !bIncludeI) continue; // I단 제외
			if(i+j==4 && !bIncludeJ) continue; // J단 제외

			if(m_BForcComponent == BFORC_COMPONENT_FYZ) 
			{
				len = CalcBForcValue(bforc_d, BFORC_COMPONENT_FY, i, j);
				if(fabs(mid) < fabs(len))
				{
					mid = len;
					if(pMidPos)*pMidPos = i+j;
				}
				len = CalcBForcValue(bforc_d, BFORC_COMPONENT_FZ, i, j);
				if(fabs(mid) < fabs(len))
				{
					mid = len;
					if(pMidPos)*pMidPos = i+j;
				}
			}
			else if(m_BForcComponent == BFORC_COMPONENT_MYZ) 
			{
				len = CalcBForcValue(bforc_d, BFORC_COMPONENT_MY, i, j);
				if(fabs(mid) < fabs(len))
				{
					mid = len;
					if(pMidPos)*pMidPos = i+j;
				}
				len = CalcBForcValue(bforc_d, BFORC_COMPONENT_MZ, i, j);
				if(fabs(mid) < fabs(len))
				{
					mid = len;
					if(pMidPos)*pMidPos = i+j;
				}
			}
			else 
			{
				len = CalcBForcValue(bforc_d, i, j);
				if(fabs(mid) < fabs(len))
				{
					mid = len;
					if(pMidPos)*pMidPos = i+j;
				}
			}
		}
		return mid;
}

void CForceEngine::InitBSfdBmdAdjustFactor(double max_bforc)
{
	C3DPoint	min_p, max_p;
	double		max_l;

	if(m_bLockAdjFactor)return;
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	gm->GetRangeModel(&min_p,&max_p);
	max_l = max(max(max_p.x-min_p.x, max_p.y-min_p.y), max_p.z-min_p.z);
	m_dMaxModelLength = max_l;

	if(max_bforc > -1e-15 && max_bforc < 1e-15)max_bforc = 1.0f;
	// 최대값이 전체모델의 1/20의 크기로 나오도록...
	m_BSfdBmdAdjustFactor = max_l / (fabs(max_bforc)*20.0);
}

// Beam Force 데이터를 만든다.
// 현재 Active Element List에 대해 Loop를 돌며
// 1. DB로 부터 해당 Element의 Beam Force 데이터를 얻고
// 2. Beam Force에 대한 최대/최소값을 갱신하고
// 3. Beam Force값 및 해당 Element번호를 CArray에 저장
BOOL CForceEngine::MakeBForcDataList()
{
	if (CTestEnvMgr::IsTestEnvST(_LSX(ProfilingSTL), _LSX(yes)))
	{
		M_PROFILE('MakeBForcDataList()');
	}

	//I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	DECLARE_GPSMD();

	int			i, elem_num;
	double	max_bforc=-DBL_MAX, min_bforc=DBL_MAX;
	BOOL		has_content=FALSE;
	T_ELEM_K	elem_key;
	T_ELEM_D	elem_data;
	T_STRB_D	bforc_d, bforc_dm;

	if(!gm->m_bLoadDataSet)return FALSE;
	int nGPSMode = (gm->m_GPSInstruction != -1)? gm->m_GPSInstruction:gm->m_GPSMode;

	gm->m_pMyView->BeginWaitCursor();
	m_BeamKeyList.RemoveAll();
	m_BeamReverseFg.RemoveAll();
	m_mapBForcData.RemoveAll();
	m_mapBForcDataMin.RemoveAll();
	elem_num = gm->m_EKeyListActive.GetSize();

	if(IsBForcWithTForc() && gm->m_GPSMode!=GPS_COMMAND_GIRDERSTRS_DGRM)
		MakeBForcByTFroc(min_bforc,max_bforc,has_content);

	m_mapYeildPointIdx.clear();  

	int nYeildPointIdx;

	// Beam Force
	for (i=0;i<elem_num;i++) 
	{
		elem_key = gm->m_EKeyListActive[i];
		m_pDoc->m_pAttrCtrl->GetElem(elem_key, elem_data);
		nYeildPointIdx = 0;

		if(!m_pDoc->m_pAttrCtrl->IsBeam(elem_data.eltyp))continue;

		if(gm->m_GPSMode==GPS_COMMAND_GIRDERSTRS_DGRM)
		{
			switch(gm->m_LoadMinMaxType) 
			{
			case LOADTYPE_NORMAL:
			case LOADTYPE_MAX:
				if(!m_pDoc->m_pPostCtrl->GetStrbNew(elem_key, &bforc_d, NULL,NULL, TRUE, &nYeildPointIdx)){  gm->m_pMyView->EndWaitCursor(); return FALSE; }
				break;
			case LOADTYPE_MIN:
				if(!m_pDoc->m_pPostCtrl->GetStrbNew(elem_key, NULL,&bforc_d,NULL, TRUE, &nYeildPointIdx)) {  gm->m_pMyView->EndWaitCursor(); return FALSE; }
				break;
			case LOADTYPE_ALL:
				if(!m_pDoc->m_pPostCtrl->GetStrbNew(elem_key, &bforc_d, &bforc_dm,NULL, TRUE, &nYeildPointIdx)){ gm->m_pMyView->EndWaitCursor(); return FALSE; }
				MinMaxElemBForc(elem_key,bforc_dm,max_bforc,min_bforc,FALSE);
				m_mapBForcDataMin.SetAt(elem_key,bforc_dm);
				break;
			}
		}
		else
		{
			if((nGPSMode==GPS_COMMAND_BDGRM || nGPSMode==GPS_COMMAND_BFORC) && m_nBForcPscPart>0)
			{
				switch(gm->m_LoadMinMaxType) 
				{
				case LOADTYPE_NORMAL:
				case LOADTYPE_MAX:
					if(gm->m_bCurStepForce)
					{
						if(!m_pDoc->m_pPostCtrl->GetCtrbPartNew(elem_key,m_nBForcPscPart,&bforc_d,NULL,NULL))
						{ gm->m_pMyView->EndWaitCursor(); continue; }
					}
					else
					{
						if(!m_pDoc->m_pPostCtrl->GetStrbPartNew(elem_key,m_nBForcPscPart,&bforc_d,NULL,NULL))
						{ gm->m_pMyView->EndWaitCursor(); continue; }
					}
					break;
				case LOADTYPE_MIN:
					if(gm->m_bCurStepForce)
					{
						if(!m_pDoc->m_pPostCtrl->GetCtrbPartNew(elem_key,m_nBForcPscPart,NULL,&bforc_d,NULL))
						{ gm->m_pMyView->EndWaitCursor(); continue; }
					}
					else
					{
						if(!m_pDoc->m_pPostCtrl->GetStrbPartNew(elem_key,m_nBForcPscPart,NULL,&bforc_d,NULL)) 
						{ gm->m_pMyView->EndWaitCursor(); continue; }
					}
					break;
				case LOADTYPE_ALL:
					if(gm->m_GPSMode==GPS_COMMAND_BDGRM && this->m_bMaxMinDgrm) 
					{
						if(gm->m_bCurStepForce)
						{
							if(!m_pDoc->m_pPostCtrl->GetCtrbPartNew(elem_key,m_nBForcPscPart,&bforc_d,&bforc_dm,NULL)) 
							{ gm->m_pMyView->EndWaitCursor(); continue; }
						}
						else
						{
							if(!m_pDoc->m_pPostCtrl->GetStrbPartNew(elem_key,m_nBForcPscPart,&bforc_d,&bforc_dm,NULL))
							{ gm->m_pMyView->EndWaitCursor(); continue; }
						}
						MinMaxElemBForc(elem_key,bforc_dm,max_bforc,min_bforc,FALSE);
						m_mapBForcDataMin.SetAt(elem_key,bforc_dm);
					}
					else
					{
						if(gm->m_bCurStepForce)
						{
							if(!m_pDoc->m_pPostCtrl->GetCtrbPartNew(elem_key,m_nBForcPscPart,NULL,NULL,&bforc_d))
							{ gm->m_pMyView->EndWaitCursor(); continue; }
						}
						else
						{
							if(!m_pDoc->m_pPostCtrl->GetStrbPartNew(elem_key,m_nBForcPscPart,NULL,NULL,&bforc_d))
							{ gm->m_pMyView->EndWaitCursor(); continue; }
						}
					}
					break;
				}
			}
			else
			{
				switch(gm->m_LoadMinMaxType) 
				{
				case LOADTYPE_NORMAL:
				case LOADTYPE_MAX:
					if(gm->m_bCurStepForce)
					{
						if(!m_pDoc->m_pPostCtrl->GetCtrbNew(elem_key, &bforc_d, NULL,NULL, TRUE)){  gm->m_pMyView->EndWaitCursor(); return FALSE; }
					}
					else
					{
						if(!m_pDoc->m_pPostCtrl->GetStrbNew(elem_key, &bforc_d, NULL,NULL, TRUE, &nYeildPointIdx)){  gm->m_pMyView->EndWaitCursor(); return FALSE; }
					}
					break;
				case LOADTYPE_MIN:
					if(gm->m_bCurStepForce)
					{
						if(!m_pDoc->m_pPostCtrl->GetCtrbNew(elem_key, NULL,&bforc_d,NULL, TRUE)) {  gm->m_pMyView->EndWaitCursor(); return FALSE; }
					}
					else
					{
						if(!m_pDoc->m_pPostCtrl->GetStrbNew(elem_key, NULL,&bforc_d,NULL, TRUE, &nYeildPointIdx)) {  gm->m_pMyView->EndWaitCursor(); return FALSE; }
					}
					break;
				case LOADTYPE_ALL:
					if(gm->m_GPSMode==GPS_COMMAND_BDGRM && this->m_bMaxMinDgrm) 
					{
						if(gm->m_bCurStepForce)
						{
							if(!m_pDoc->m_pPostCtrl->GetCtrbNew(elem_key, &bforc_d, &bforc_dm,NULL, TRUE)) {  gm->m_pMyView->EndWaitCursor(); return FALSE; }
						}
						else
						{
							if(!m_pDoc->m_pPostCtrl->GetStrbNew(elem_key, &bforc_d, &bforc_dm,NULL, TRUE, &nYeildPointIdx)){ gm->m_pMyView->EndWaitCursor(); return FALSE; }
						}
						MinMaxElemBForc(elem_key,bforc_dm,max_bforc,min_bforc,FALSE);
						m_mapBForcDataMin.SetAt(elem_key,bforc_dm);
					}
					else
					{
						if(gm->m_bCurStepForce)
						{
							if(!m_pDoc->m_pPostCtrl->GetCtrbNew(elem_key, NULL,NULL,&bforc_d, TRUE)){ gm->m_pMyView->EndWaitCursor(); return FALSE; }
						}
						else
						{
							if(!m_pDoc->m_pPostCtrl->GetStrbNew(elem_key, NULL,NULL,&bforc_d, TRUE, &nYeildPointIdx)){ gm->m_pMyView->EndWaitCursor(); return FALSE; }
						}
					}
					break;
				}
			}
		}
		MinMaxElemBForc(elem_key,bforc_d,max_bforc,min_bforc,FALSE);
		m_BeamKeyList.Add(elem_key);
		m_mapBForcData.SetAt(elem_key,bforc_d);
		has_content = TRUE;

		m_mapYeildPointIdx[elem_key] = nYeildPointIdx;
	}

	if(!has_content) 
	{
		min_bforc = max_bforc = 0.0;
		gm->m_nLgdMaxValKey=0;
		gm->m_nLgdMinValKey=0;
	}
	m_dMaxValue = max_bforc;
	m_dMinValue = min_bforc;

	if(fabs(max_bforc)<fabs(min_bforc))InitBSfdBmdAdjustFactor(min_bforc);
	else		                           InitBSfdBmdAdjustFactor(max_bforc);

	if (m_pContourEngine == NULL)m_pContourEngine = new CContourEngine(min_bforc, max_bforc);
	else		                     m_pContourEngine->MakeRankMap(min_bforc, max_bforc);

	gm->m_pMyView->EndWaitCursor();

	m_bBForcDataSet = TRUE;
	return TRUE;
}

BOOL CForceEngine::GetBForcRangeDataList(double& dMaxRange, double& dMinRange, CArray<UINT,UINT>& aElemKeyList)
{
	aElemKeyList.RemoveAll();

	if (CTestEnvMgr::IsTestEnvST(_LSX(ProfilingSTL), _LSX(yes)))
	{
		M_PROFILE('GetBForcRangeDataList()');
	}
	
	DECLARE_GPSMD();

	int			i, elem_num;
	T_ELEM_K	elem_key;
	T_ELEM_D	elem_data;
	T_STRB_D	bforc_d, bforc_dm;

	if(!gm->m_bLoadDataSet)return FALSE;
	int nGPSMode = (gm->m_GPSInstruction != -1)? gm->m_GPSInstruction:gm->m_GPSMode;

	gm->m_pMyView->BeginWaitCursor();

	elem_num = gm->m_EKeyListActive.GetSize();

	int nYeildPointIdx;

	// Beam Force
	for (i=0;i<elem_num;i++) 
	{
		elem_key = gm->m_EKeyListActive[i];
		m_pDoc->m_pAttrCtrl->GetElem(elem_key, elem_data);
		nYeildPointIdx = 0;

		if(!m_pDoc->m_pAttrCtrl->IsBeam(elem_data.eltyp))continue;

		if(gm->m_GPSMode==GPS_COMMAND_GIRDERSTRS_DGRM)
		{
			switch(gm->m_LoadMinMaxType) 
			{
			case LOADTYPE_NORMAL:
			case LOADTYPE_MAX:
				if(!m_pDoc->m_pPostCtrl->GetStrbNew(elem_key, &bforc_d, NULL,NULL, TRUE, &nYeildPointIdx)){  gm->m_pMyView->EndWaitCursor(); return FALSE; }
				break;
			case LOADTYPE_MIN:
				if(!m_pDoc->m_pPostCtrl->GetStrbNew(elem_key, NULL,&bforc_d,NULL, TRUE, &nYeildPointIdx)) {  gm->m_pMyView->EndWaitCursor(); return FALSE; }
				break;
			case LOADTYPE_ALL:
				if(!m_pDoc->m_pPostCtrl->GetStrbNew(elem_key, &bforc_d, &bforc_dm,NULL, TRUE, &nYeildPointIdx)){ gm->m_pMyView->EndWaitCursor(); return FALSE; }
				if(!IsWithinRangeElemBForc(elem_key,bforc_dm,dMaxRange,dMinRange,FALSE)) continue;
				break;
			}
		}
		else
		{
			if((nGPSMode==GPS_COMMAND_BDGRM || nGPSMode==GPS_COMMAND_BFORC) && m_nBForcPscPart>0)
			{
				switch(gm->m_LoadMinMaxType) 
				{
				case LOADTYPE_NORMAL:
				case LOADTYPE_MAX:
					if(gm->m_bCurStepForce)
					{
						if(!m_pDoc->m_pPostCtrl->GetCtrbPartNew(elem_key,m_nBForcPscPart,&bforc_d,NULL,NULL))
						{ gm->m_pMyView->EndWaitCursor(); continue; }
					}
					else
					{
						if(!m_pDoc->m_pPostCtrl->GetStrbPartNew(elem_key,m_nBForcPscPart,&bforc_d,NULL,NULL))
						{ gm->m_pMyView->EndWaitCursor(); continue; }
					}
					break;
				case LOADTYPE_MIN:
					if(gm->m_bCurStepForce)
					{
						if(!m_pDoc->m_pPostCtrl->GetCtrbPartNew(elem_key,m_nBForcPscPart,NULL,&bforc_d,NULL))
						{ gm->m_pMyView->EndWaitCursor(); continue; }
					}
					else
					{
						if(!m_pDoc->m_pPostCtrl->GetStrbPartNew(elem_key,m_nBForcPscPart,NULL,&bforc_d,NULL)) 
						{ gm->m_pMyView->EndWaitCursor(); continue; }
					}
					break;
				case LOADTYPE_ALL:
					if(gm->m_GPSMode==GPS_COMMAND_BDGRM && this->m_bMaxMinDgrm) 
					{
						if(gm->m_bCurStepForce)
						{
							if(!m_pDoc->m_pPostCtrl->GetCtrbPartNew(elem_key,m_nBForcPscPart,&bforc_d,&bforc_dm,NULL)) 
							{ gm->m_pMyView->EndWaitCursor(); continue; }
						}
						else
						{
							if(!m_pDoc->m_pPostCtrl->GetStrbPartNew(elem_key,m_nBForcPscPart,&bforc_d,&bforc_dm,NULL))
							{ gm->m_pMyView->EndWaitCursor(); continue; }
						}
						if(!IsWithinRangeElemBForc(elem_key,bforc_dm,dMaxRange,dMinRange,FALSE)) continue;
					}
					else
					{
						if(gm->m_bCurStepForce)
						{
							if(!m_pDoc->m_pPostCtrl->GetCtrbPartNew(elem_key,m_nBForcPscPart,NULL,NULL,&bforc_d))
							{ gm->m_pMyView->EndWaitCursor(); continue; }
						}
						else
						{
							if(!m_pDoc->m_pPostCtrl->GetStrbPartNew(elem_key,m_nBForcPscPart,NULL,NULL,&bforc_d))
							{ gm->m_pMyView->EndWaitCursor(); continue; }
						}
					}
					break;
				}
			}
			else
			{
				switch(gm->m_LoadMinMaxType) 
				{
				case LOADTYPE_NORMAL:
				case LOADTYPE_MAX:
					if(gm->m_bCurStepForce)
					{
						if(!m_pDoc->m_pPostCtrl->GetCtrbNew(elem_key, &bforc_d, NULL,NULL, TRUE)){  gm->m_pMyView->EndWaitCursor(); return FALSE; }
					}
					else
					{
						if(!m_pDoc->m_pPostCtrl->GetStrbNew(elem_key, &bforc_d, NULL,NULL, TRUE, &nYeildPointIdx)){  gm->m_pMyView->EndWaitCursor(); return FALSE; }
					}
					break;
				case LOADTYPE_MIN:
					if(gm->m_bCurStepForce)
					{
						if(!m_pDoc->m_pPostCtrl->GetCtrbNew(elem_key, NULL,&bforc_d,NULL, TRUE)) {  gm->m_pMyView->EndWaitCursor(); return FALSE; }
					}
					else
					{
						if(!m_pDoc->m_pPostCtrl->GetStrbNew(elem_key, NULL,&bforc_d,NULL, TRUE, &nYeildPointIdx)) {  gm->m_pMyView->EndWaitCursor(); return FALSE; }
					}
					break;
				case LOADTYPE_ALL:
					if(gm->m_GPSMode==GPS_COMMAND_BDGRM && this->m_bMaxMinDgrm) 
					{
						if(gm->m_bCurStepForce)
						{
							if(!m_pDoc->m_pPostCtrl->GetCtrbNew(elem_key, &bforc_d, &bforc_dm,NULL, TRUE)) {  gm->m_pMyView->EndWaitCursor(); return FALSE; }
						}
						else
						{
							if(!m_pDoc->m_pPostCtrl->GetStrbNew(elem_key, &bforc_d, &bforc_dm,NULL, TRUE, &nYeildPointIdx)){ gm->m_pMyView->EndWaitCursor(); return FALSE; }
						}
						if(!IsWithinRangeElemBForc(elem_key,bforc_dm,dMaxRange,dMinRange,FALSE)) continue;
					}
					else
					{
						if(gm->m_bCurStepForce)
						{
							if(!m_pDoc->m_pPostCtrl->GetCtrbNew(elem_key, NULL,NULL,&bforc_d, TRUE)){ gm->m_pMyView->EndWaitCursor(); return FALSE; }
						}
						else
						{
							if(!m_pDoc->m_pPostCtrl->GetStrbNew(elem_key, NULL,NULL,&bforc_d, TRUE, &nYeildPointIdx)){ gm->m_pMyView->EndWaitCursor(); return FALSE; }
						}
					}
					break;
				}
			}
		}

		if(!IsWithinRangeElemBForc(elem_key,bforc_d,dMaxRange,dMinRange,FALSE)) continue;
		aElemKeyList.Add(elem_key);
	}

	gm->m_pMyView->EndWaitCursor();
	
	return TRUE;
}

BOOL CForceEngine::MakeBForcByTFroc(double &min_bforc,double &max_bforc,BOOL &has_content)
{
	//I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	DECLARE_GPSMD();

	int			i, elem_num;
	T_ELEM_K	elem_key;
	T_ELEM_D	elem_data;
	T_STRB_D	bforc_d, bforc_dm;
	T_STRT_D	tforc_d, tforc_dm;

	if(!gm->m_bLoadDataSet)return FALSE;
	elem_num = gm->m_EKeyListActive.GetSize();

	// Truss Force
	for (i=0;i<elem_num;i++) 
	{
		elem_key = gm->m_EKeyListActive[i];
		m_pDoc->m_pAttrCtrl->GetElem(elem_key, elem_data);
		if(!m_pDoc->m_pAttrCtrl->IsTruss(elem_data.eltyp))continue;

		if(gm->m_GPSMode==GPS_COMMAND_GIRDERSTRS_DGRM)
		{
			continue; 
		}
		else
		{
			switch(gm->m_LoadMinMaxType) 
			{
			case LOADTYPE_NORMAL:
			case LOADTYPE_MAX:
				if(gm->m_bCurStepForce)
				{
					if(!m_pDoc->m_pPostCtrl->GetCtrtNew(elem_key, &tforc_d,NULL,NULL)){ return FALSE; }
				}
				else
				{
					if(!m_pDoc->m_pPostCtrl->GetStrtNew(elem_key, &tforc_d,NULL,NULL)){ return FALSE; }
				}
				break;
			case LOADTYPE_MIN:
				if(gm->m_bCurStepForce)
				{
					if(!m_pDoc->m_pPostCtrl->GetCtrtNew(elem_key,NULL, &tforc_d,NULL)){ return FALSE; }
				}
				else
				{
					if(!m_pDoc->m_pPostCtrl->GetStrtNew(elem_key,NULL, &tforc_d,NULL)){ return FALSE; }
				}
				break;
			case LOADTYPE_ALL:
				if(gm->m_GPSMode==GPS_COMMAND_BDGRM && this->m_bMaxMinDgrm) 
				{
					if(gm->m_bCurStepForce)
					{
						if(!m_pDoc->m_pPostCtrl->GetCtrtNew(elem_key, &tforc_d, &tforc_dm,NULL)) { return FALSE; }
					}
					else
					{
						if(!m_pDoc->m_pPostCtrl->GetStrtNew(elem_key, &tforc_d, &tforc_dm,NULL)) { return FALSE; }
					}
					ConvertStrt2StrbForceOnly(tforc_dm,bforc_dm);
					MinMaxElemBForc(elem_key,bforc_dm,max_bforc,min_bforc,TRUE);
					m_mapBForcDataMin.SetAt(elem_key,bforc_dm);
				}
				else
				{
					if(gm->m_bCurStepForce)
					{
						if(!m_pDoc->m_pPostCtrl->GetCtrtNew(elem_key, NULL,NULL,&tforc_d)){ return FALSE; }
					}
					else
					{
						if(!m_pDoc->m_pPostCtrl->GetStrtNew(elem_key, NULL,NULL,&tforc_d)){ return FALSE; }
					}
				}
				break;
			}
		}

		ConvertStrt2StrbForceOnly(tforc_d,bforc_d);
		MinMaxElemBForc(elem_key,bforc_d,max_bforc,min_bforc,TRUE);
		m_BeamKeyList.Add(elem_key);
		m_mapBForcData.SetAt(elem_key,bforc_d);
		has_content = TRUE;
	}

	return TRUE; 
}


void CForceEngine::MinMaxElemBForc(T_ELEM_K elem_key,T_STRB_D bforc_d,double& max_bforc,double& min_bforc,
																	 BOOL bTruss)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	if(IsPossibleExactSfdBmdMode() && !bTruss)
	{
		if (!gm->m_pBeamDiagram)
			gm->m_pBeamDiagram = new CBeamDiagram;
		//int nDiv = m_pDoc->calcLAVElem(ElemKey)/m_dUnitLength; 
		if (!gm->m_pBeamDiagram->MakeBeamSFBM(elem_key, gm->m_LoadCombi, 12))
		{
			gm->SelectLoad(); 
			return;
		}
		gm->SelectLoad(); 

		double dMax=-DBL_MAX,dMin =DBL_MAX;

		if (m_BForcComponent == BFORC_COMPONENT_FYZ) 
		{
			GetMaxMinCompExact(dMax,dMin,BFORC_COMPONENT_FY);
			GetMaxMinCompExact(dMax,dMin,BFORC_COMPONENT_FZ);
		}
		else if (m_BForcComponent == BFORC_COMPONENT_MYZ) 
		{
			GetMaxMinCompExact(dMax,dMin,BFORC_COMPONENT_MY);
			GetMaxMinCompExact(dMax,dMin,BFORC_COMPONENT_MZ);
		}
		else 
			GetMaxMinCompExact(dMax,dMin,m_BForcComponent);


		if(dMax>max_bforc) 
		{
			max_bforc = dMax;
			m_KeyMaxBForcElem = elem_key;
			gm->m_nLgdMaxValKey=elem_key;
		}
		if(dMin<min_bforc) 
		{
			min_bforc = dMin;
			gm->m_nLgdMinValKey=elem_key;
		}
	}
	else
	{
		double len = GetMaxElemBForc(bforc_d);
		if (len > max_bforc) 
		{
			max_bforc = len;
			m_KeyMaxBForcElem = elem_key;
			gm->m_nLgdMaxValKey=elem_key;
		}
		len = GetMinElemBForc(bforc_d);
		if (len < min_bforc) 
		{
			min_bforc = len;
			gm->m_nLgdMinValKey=elem_key;
		}
	}
}

BOOL CForceEngine::IsWithinRangeElemBForc(T_ELEM_K elem_key,T_STRB_D bforc_d,double& max_bforc,double& min_bforc,BOOL bTruss)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	if(IsPossibleExactSfdBmdMode() && !bTruss)
	{
		if (!gm->m_pBeamDiagram)
			gm->m_pBeamDiagram = new CBeamDiagram;
		if (!gm->m_pBeamDiagram->MakeBeamSFBM(elem_key, gm->m_LoadCombi, 12))
		{
			gm->SelectLoad(); 
			return FALSE;
		}
		gm->SelectLoad();

		if (m_BForcComponent == BFORC_COMPONENT_FYZ) 
		{
			if(IsWithinRangeCompExact(max_bforc,min_bforc,BFORC_COMPONENT_FY)) return TRUE;
			if(IsWithinRangeCompExact(max_bforc,min_bforc,BFORC_COMPONENT_FZ)) return TRUE;
		}
		else if (m_BForcComponent == BFORC_COMPONENT_MYZ) 
		{
			if(IsWithinRangeCompExact(max_bforc,min_bforc,BFORC_COMPONENT_MY)) return TRUE;
			if(IsWithinRangeCompExact(max_bforc,min_bforc,BFORC_COMPONENT_MZ)) return TRUE;
		}
		else
		{
			if(IsWithinRangeCompExact(max_bforc,min_bforc,m_BForcComponent)) return TRUE;
		}
	}
	else
	{
		double len_max;
		double len_min;

		for (int i=0;i<4;i++)
		{
			if(m_BForcComponent == BFORC_COMPONENT_FYZ)
			{
				len_max = CalcBForcValue(bforc_d, BFORC_COMPONENT_FY, i, I_NODE);
				len_min = CalcBForcValue(bforc_d, BFORC_COMPONENT_FY, i, J_NODE);
			}
			else if (m_BForcComponent == BFORC_COMPONENT_MYZ)
			{
				len_max = CalcBForcValue(bforc_d, BFORC_COMPONENT_MY, i, I_NODE);
				len_min = CalcBForcValue(bforc_d, BFORC_COMPONENT_MY, i, J_NODE);
			}
			else
			{
				len_max = CalcBForcValue(bforc_d, i, I_NODE);
				len_min = CalcBForcValue(bforc_d, i, J_NODE);
			}

			if(len_min>len_max)
			{
				double len_temp = len_max;
				len_max = len_min;
				len_min = len_temp;
			}

			if (len_min <= min_bforc && len_max >= max_bforc)
				return TRUE;
			if (len_min >= min_bforc && len_min <= max_bforc)
				return TRUE;
			if (len_max >= min_bforc && len_max <= max_bforc)
				return TRUE;
		}
	}

	return FALSE;
}

void CForceEngine::GetMaxMinCompExact(double& dMax, double& dMin,int nComp)
{
	const int DX = 1;
	const int DY = 2;
	const int DZ = 3;

	int nNumPart;
	double dValue;
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	switch(nComp) 
	{
	case BFORC_COMPONENT_FX:
	case BFORC_COMPONENT_MX:
		nNumPart = gm->m_pBeamDiagram->m_arP[DX][0].GetSize();
		break;
	case BFORC_COMPONENT_FY:
	case BFORC_COMPONENT_MZ:
		nNumPart = gm->m_pBeamDiagram->m_arP[DY][0].GetSize();
		break;
	case BFORC_COMPONENT_FZ:
	case BFORC_COMPONENT_MY:
		nNumPart = gm->m_pBeamDiagram->m_arP[DZ][0].GetSize();
		break;
	}

	for(int nPart = 0; nPart < nNumPart; nPart++)
		for(int nSubPos =0; nSubPos <3; nSubPos++)
		{
			switch (nComp) 
			{
			case BFORC_COMPONENT_FX:  dValue = gm->m_pBeamDiagram->m_arV[DX][nSubPos][nPart]; break;
			case BFORC_COMPONENT_FY:  dValue = gm->m_pBeamDiagram->m_arV[DY][nSubPos][nPart];	break;
			case BFORC_COMPONENT_FZ:  dValue = gm->m_pBeamDiagram->m_arV[DZ][nSubPos][nPart]; break;
			case BFORC_COMPONENT_MX:  dValue = gm->m_pBeamDiagram->m_arM[DX][nSubPos][nPart];	break;
			case BFORC_COMPONENT_MZ:  dValue = gm->m_pBeamDiagram->m_arM[DY][nSubPos][nPart]; break;
			case BFORC_COMPONENT_MY:  dValue = gm->m_pBeamDiagram->m_arM[DZ][nSubPos][nPart];	break;
			}
			if( dValue > dMax) dMax = dValue;
			if( dValue < dMin) dMin = dValue;
		}
}

BOOL CForceEngine::IsWithinRangeCompExact(double& dMax, double& dMin,int nComp)
{
	const int DX = 1;
	const int DY = 2;
	const int DZ = 3;

	int nNumPart;
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	switch(nComp) 
	{
	case BFORC_COMPONENT_FX:
	case BFORC_COMPONENT_MX:
		nNumPart = gm->m_pBeamDiagram->m_arP[DX][0].GetSize();
		break;
	case BFORC_COMPONENT_FY:
	case BFORC_COMPONENT_MZ:
		nNumPart = gm->m_pBeamDiagram->m_arP[DY][0].GetSize();
		break;
	case BFORC_COMPONENT_FZ:
	case BFORC_COMPONENT_MY:
		nNumPart = gm->m_pBeamDiagram->m_arP[DZ][0].GetSize();
		break;
	}

	double len_max;
	double len_min;

	for(int nPart = 0; nPart < nNumPart; nPart++)
	{
		for(int nSubPos =0; nSubPos <2; nSubPos++)
		{
			switch (nComp) 
			{
			case BFORC_COMPONENT_FX:  len_max = gm->m_pBeamDiagram->m_arV[DX][nSubPos][nPart]; len_min = gm->m_pBeamDiagram->m_arV[DX][nSubPos+1][nPart];	break;
			case BFORC_COMPONENT_FY:  len_max = gm->m_pBeamDiagram->m_arV[DY][nSubPos][nPart]; len_min = gm->m_pBeamDiagram->m_arV[DY][nSubPos+1][nPart];	break;
			case BFORC_COMPONENT_FZ:  len_max = gm->m_pBeamDiagram->m_arV[DZ][nSubPos][nPart]; len_min = gm->m_pBeamDiagram->m_arV[DZ][nSubPos+1][nPart];	break;
			case BFORC_COMPONENT_MX:  len_max = gm->m_pBeamDiagram->m_arM[DX][nSubPos][nPart]; len_min = gm->m_pBeamDiagram->m_arM[DX][nSubPos+1][nPart];	break;
			case BFORC_COMPONENT_MZ:  len_max = gm->m_pBeamDiagram->m_arM[DY][nSubPos][nPart]; len_min = gm->m_pBeamDiagram->m_arM[DY][nSubPos+1][nPart];	break;
			case BFORC_COMPONENT_MY:  len_max = gm->m_pBeamDiagram->m_arM[DZ][nSubPos][nPart]; len_min = gm->m_pBeamDiagram->m_arM[DZ][nSubPos+1][nPart];	break;
			}

			if(len_min>len_max)
			{
				double len_temp = len_max;
				len_max = len_min;
				len_min = len_temp;
			}

			if (len_min <= dMin && len_max >= dMax)
				return TRUE;
			if (len_min >= dMin && len_min <= dMax)
				return TRUE;
			if (len_max >= dMin && len_max <= dMax)
				return TRUE;
		}
	}

	return FALSE;
}

#define SET_BFOR_FONT_TYPE(slope) gm->SetNumberFontOrientation(slope);\
	ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);\
	old_ft = (CFont *) pDC->SelectObject(&ft);
#define DEL_BFOR_FONT_TYPE()if(old_ft){\
	pDC->SelectObject(old_ft);\
	ft.DeleteObject();\
	old_ft=NULL; }

#if defined(__OLD_OUTPUT_VALUE)
void CForceEngine::OutputBForcNumbers(CDC *pDC)
{
	DECLARE_GPSMD();
	DECLARE_DPTTX();
	DECLARE_DPTDR();

	int				  i, elem_num;
	T_ELEM_K		ekey;
	T_ELEM_D		edata;
	T_STRB_D		bforc_d;
	C3DPoint		node3D_i, node3D_j,DrawPoint;
	CPoint			text_p;
	TCHAR			  fmt_str[10], text_str[512];
	CFont			  ft, *old_ft;
	BOOL			  fl_bak;

	POSITION		pos;
	CArray<GPS_3DPT_LISTP, GPS_3DPT_LISTP>	polygon_list;
	CArray<GPS_3DPT_LISTP, GPS_3DPT_LISTP>	polygon_list_Mid;  // 멤버의 가운데 요소의 폴리곤
	CArray<GPS_3DPT_LISTP, GPS_3DPT_LISTP>	polygon_list_Last; // 멤버의 끝 요소의 폴리곤
	CArray<GPS_BOOL_ARRYP, GPS_BOOL_ARRYP>  edge_list, edge_list_Mid, edge_list_Last;

	if(!m_bBForcDataSet)return;
	if(m_bBForcOutputByMember) MakeBForcDataListByMember();

	if(pTX->m_bNumberOpaque)pDC->SetBkMode(OPAQUE);
	else		                pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(pTX->m_NumberTextColorC);
	pDC->SetBkColor(pTX->m_NumberBackCol);
	pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);

	if(pTX->m_bNumberExponent)
		_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);

	fl_bak = gm->m_DOPT.DR.m_bFrameLine;
	gm->m_DOPT.DR.m_bFrameLine = TRUE;

	int nGPSMode = (gm->m_GPSInstruction != -1)? gm->m_GPSInstruction:gm->m_GPSMode;
	BOOL bGrpFltMode=gm->m_pGPSCtrl->IsGroupFilterMode();
	if(!bGrpFltMode)elem_num = gm->m_EKeyListActive.GetSize();
	else            elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize(); 

	for (i=0;i<elem_num;i++) 
	{
		if(!bGrpFltMode)ekey = gm->m_EKeyListActive[i];
		else            ekey = gm->m_pDispFilter->m_aGrpEKey[i]; 

		if(!gm->m_pGPSCtrl->IsActiveElem(ekey))
			continue;

		if(m_bBForcOutputByMember)
		{
			if(!GetBeamForceByMember(ekey, bforc_d)) continue;
		}
		else
		{
			if(!GetBeamForce(ekey, bforc_d)) bforc_d.Initialize();
		}

		m_pDoc->m_pAttrCtrl->GetElem(ekey, edata);

		BOOL bBeam  = m_pDoc->m_pAttrCtrl->IsBeam(edata.eltyp);
		BOOL bTruss = IsBForcWithTForc() && m_pDoc->m_pAttrCtrl->IsTruss(edata.eltyp);

		if(!bBeam && !bTruss)continue; 

		if((nGPSMode==GPS_COMMAND_BDGRM || nGPSMode==GPS_COMMAND_BFORC) && m_nBForcPscPart>0)
		{
			if(m_nBForcPscPart>m_pDoc->m_pPostCtrl->GetCscsInfo()->GetNumMaxSectionPart(ekey))
				continue;
		}

		// Member의 처음과 끝 요소의 DrawPt를 구해서 조작해줍시다. [0]:I단 [2]:Center [4]:J단
		T_ELEM_K ElemK_First = ekey;
		T_ELEM_K ElemK_Mid=0, ElemK_Last=0;
		BOOL bHasEvenNumOfElem;
		BOOL bIsMembAssigned = FALSE;
		T_MEMB_K MembK;
		if(m_pDoc->m_pAttrCtrl->GetMembAssigned(ElemK_First, MembK))
		{
			bIsMembAssigned = TRUE;
			ElemK_Mid  = CMembCtrl::GetMembCtrl()->GetMidElemKeyOfMemb(MembK, bHasEvenNumOfElem);
			ElemK_Last = CMembCtrl::GetMembCtrl()->GetLastElemKeyOfMemb(MembK);
		}

		if(m_bDeformedShapeContour) 
		{
			gm->m_pDeformEngine->GetDeformedShapeElement(ElemK_First, &polygon_list, &edge_list);
			if(m_bBForcOutputByMember && ElemK_Mid>0)  gm->m_pDeformEngine->GetDeformedShapeElement(ElemK_Mid , &polygon_list_Mid , &edge_list_Mid);
			if(m_bBForcOutputByMember && ElemK_Last>0) gm->m_pDeformEngine->GetDeformedShapeElement(ElemK_Last, &polygon_list_Last, &edge_list_Last);
		}
		else 
		{
			gm->GetShapeElement(ElemK_First, polygon_list, &edge_list);
			if(m_bBForcOutputByMember && ElemK_Mid>0)  gm->GetShapeElement(ElemK_Mid , polygon_list_Mid , &edge_list_Mid);
			if(m_bBForcOutputByMember && ElemK_Last>0) gm->GetShapeElement(ElemK_Last, polygon_list_Last, &edge_list_Last);
		}

		pos = polygon_list[0]->GetHeadPosition();
		node3D_i = polygon_list[0]->GetNext(pos);
		node3D_j = polygon_list[0]->GetNext(pos);

		int nSlope5Div[5];
		BOOL nInverse5Div[5];
		BOOL bCanDraw[5];
		CPoint DrawPt[5];
		CUtilFuncs::MakeBeamSlopeAt5Div(gm,node3D_i,node3D_j,nSlope5Div,nInverse5Div,bCanDraw,DrawPt);

		if(m_bBForcOutputByMember && ElemK_Mid>0)
		{
			pos = polygon_list_Mid[0]->GetHeadPosition();
			node3D_i = polygon_list_Mid[0]->GetNext(pos);
			node3D_j = polygon_list_Mid[0]->GetNext(pos);

			int nSlope5Div_Mid[5];
			BOOL nInverse5Div_Mid[5];
			BOOL bCanDraw_Mid[5];
			CPoint DrawPt_Mid[5];
			CUtilFuncs::MakeBeamSlopeAt5Div(gm,node3D_i,node3D_j,nSlope5Div_Mid,nInverse5Div_Mid,bCanDraw_Mid,DrawPt_Mid);

			// 가운데 요소의 위치를 구하는 조건문
			if(bHasEvenNumOfElem) DrawPt[2] = DrawPt_Mid[4];
			else                  DrawPt[2] = DrawPt_Mid[2];
		}

		if(m_bBForcOutputByMember && ElemK_Last>0)
		{
			pos = polygon_list_Last[0]->GetHeadPosition();
			node3D_i = polygon_list_Last[0]->GetNext(pos);
			node3D_j = polygon_list_Last[0]->GetNext(pos);

			int nSlope5Div_Last[5];
			BOOL nInverse5Div_Last[5];
			BOOL bCanDraw_Last[5];
			CPoint DrawPt_Last[5];
			CUtilFuncs::MakeBeamSlopeAt5Div(gm,node3D_i,node3D_j,nSlope5Div_Last,nInverse5Div_Last,bCanDraw_Last,DrawPt_Last);

			// 마지막 요소의 위치를 구하는 조건문
			DrawPt[4] = DrawPt_Last[4];
		}

		if(gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
		{
			double dLimit = (m_dMaxValue-m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;
			double dBValue;

			for(int n=0; n<3; n++)
			{
				old_ft = NULL; 

				BOOL bCanTextDraw=FALSE; 
				if(m_bBForcOutputMinMax)
				{
					double dMinVal,dMaxVal;
					int    nMnMxPos[2];
					dMaxVal = CalcBForcValue(bforc_d, BFORC_OUTPUT_MAXMIN,nMnMxPos,&dMinVal);

					// Min
					if(n==0)
					{
						if(nMnMxPos[0]==0)// I Pos
						{
							if(nInverse5Div[0])  pDC->SetTextAlign(TA_RIGHT|TA_TOP);
							else					  pDC->SetTextAlign(TA_LEFT|TA_TOP);
							SET_BFOR_FONT_TYPE(nSlope5Div[0])
								bCanTextDraw = bCanDraw[0];
						}
						else if(nMnMxPos[0]==4)// J Pos
						{
							if(nInverse5Div[4])  pDC->SetTextAlign(TA_LEFT|TA_TOP);
							else					  pDC->SetTextAlign(TA_RIGHT|TA_TOP);
							SET_BFOR_FONT_TYPE(nSlope5Div[4])
								bCanTextDraw = bCanDraw[4];
						}
						else // Mid Pos
						{
							pDC->SetTextAlign(TA_CENTER|TA_TOP);
							SET_BFOR_FONT_TYPE(nSlope5Div[2])
								bCanTextDraw = bCanDraw[2];   
						}
						DrawPoint.x = node3D_i.x + (node3D_j.x-node3D_i.x)*nMnMxPos[0]/4.;
						DrawPoint.y = node3D_i.y + (node3D_j.y-node3D_i.y)*nMnMxPos[0]/4.;
						DrawPoint.z = node3D_i.z + (node3D_j.z-node3D_i.z)*nMnMxPos[0]/4.;
						dBValue   = dMinVal;
					}
					// Max
					else if(n==1)
					{
						if(nMnMxPos[1]==0)
						{
							if(nInverse5Div[0]) pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
							else					      pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
							SET_BFOR_FONT_TYPE(nSlope5Div[0])
								bCanTextDraw = bCanDraw[0];    
						}
						else if(nMnMxPos[1]==4)
						{
							if(nInverse5Div[4])  pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
							else					  pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
							SET_BFOR_FONT_TYPE(nSlope5Div[4])
								bCanTextDraw = bCanDraw[4];       
						}
						else
						{
							pDC->SetTextAlign(TA_CENTER|TA_BOTTOM); 
							SET_BFOR_FONT_TYPE(nSlope5Div[2])
								bCanTextDraw = bCanDraw[2];       
						}
						DrawPoint.x = node3D_i.x + (node3D_j.x-node3D_i.x)*nMnMxPos[1]/4.;
						DrawPoint.y = node3D_i.y + (node3D_j.y-node3D_i.y)*nMnMxPos[1]/4.;
						DrawPoint.z = node3D_i.z + (node3D_j.z-node3D_i.z)*nMnMxPos[1]/4.;
						dBValue   = dMaxVal;
					}
					else continue; 
				}
				else if(n==0) // I단 
				{
					if(!m_bBForcOutputI) continue;

					if(nInverse5Div[0])pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
					else					     pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
					DrawPoint = node3D_i;
					dBValue   = CalcBForcValue(bforc_d, 0, I_NODE);
					SET_BFOR_FONT_TYPE(nSlope5Div[0])
						bCanTextDraw = bCanDraw[0];       
				}
				else if(n==1)// CNT or MAX
				{			  
					if (!(m_bBForcOutputC||m_bBForcOutputMax)) continue;

					pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);
					DrawPoint.x = (node3D_i.x + node3D_j.x)/2.0;
					DrawPoint.y = (node3D_i.y + node3D_j.y)/2.0;
					DrawPoint.z = (node3D_i.z + node3D_j.z)/2.0;

					if(m_bBForcOutputMax)dBValue = CalcBForcValue(bforc_d, BFORC_OUTPUT_MAX);
					else                 dBValue = CalcBForcValue(bforc_d, 1, J_NODE);
					SET_BFOR_FONT_TYPE(nSlope5Div[2])
						bCanTextDraw = bCanDraw[2];       

				}
				else if(n==2)// J단 
				{			  
					if(!m_bBForcOutputJ) continue;
					if(nInverse5Div[4])pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
					else					     pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
					DrawPoint = node3D_j;
					dBValue = CalcBForcValue(bforc_d, 3, J_NODE);
					SET_BFOR_FONT_TYPE(nSlope5Div[4])
						bCanTextDraw = bCanDraw[4]; 
				}

				if(!bCanTextDraw)
				{ 
					DEL_BFOR_FONT_TYPE()
						continue;
				}
				switch(gm->m_DOPT.TX.m_nOutputMinMaxType)
				{
				case 0: // Min & Max
					if((m_dMaxValue-dBValue) <= dLimit)
						DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,dBValue);
					else if((dBValue-m_dMinValue) <= dLimit)
						DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,dBValue);
					break;
				case 1: // Abs Max
					if(fabs(m_dMaxValue) >= fabs(m_dMinValue))
					{
						if( fabs(m_dMaxValue)-fabs(dBValue) <= dLimit)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dBValue);
					}
					else
					{
						if( fabs(m_dMinValue)-fabs(dBValue) <= dLimit)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dBValue);
					}
					break;
				case 2: // Max
					if((m_dMaxValue-dBValue) <= dLimit)
						DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,dBValue);
					break;
				case 3: // Min
					if((dBValue-m_dMinValue) <= dLimit)
						DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,dBValue);
					break;
				}
				DEL_BFOR_FONT_TYPE()    
			}
			//////////////////////////////////////////////////////////////////////////////////////
		}      
		else      
		{
			// Abs Max
			if(m_bBForcOutputMax) 
			{
				SET_BFOR_FONT_TYPE(nSlope5Div[2])
					_stprintf(text_str, fmt_str, CalcBForcValue(bforc_d, BFORC_OUTPUT_MAX));
				if(bCanDraw[2])pDC->TextOut(DrawPt[2].x, DrawPt[2].y, text_str);
				DEL_BFOR_FONT_TYPE() 
			}
			// Min/Max
			else if(m_bBForcOutputMinMax)
			{
				double dMinVal,dMaxVal;
				int    nMnMxPos[2];
				dMaxVal = CalcBForcValue(bforc_d, BFORC_OUTPUT_MAXMIN,nMnMxPos,&dMinVal);

				// Min
				BOOL bCanTextDraw=FALSE; 
				if(m_bBForcOutputByMember && bIsMembAssigned)
				{
					T_BFORC_ELEM_POS_D ElemPosMin;
					m_mapBForcMinPosByMember.Lookup(ElemK_First, ElemPosMin);
					switch(ElemPosMin.nPosIndex)
					{
					case 0:
						if(ElemPosMin.nInverse5Div) pDC->SetTextAlign(TA_RIGHT|TA_TOP);
						else					              pDC->SetTextAlign(TA_LEFT|TA_TOP);
						break;
					case 4:
						if(ElemPosMin.nInverse5Div) pDC->SetTextAlign(TA_LEFT|TA_TOP);
						else					              pDC->SetTextAlign(TA_RIGHT|TA_TOP);
						break;
					default:
						pDC->SetTextAlign(TA_CENTER|TA_TOP);
						break;
					}
					SET_BFOR_FONT_TYPE(ElemPosMin.nSlope5Div)
						bCanTextDraw = ElemPosMin.bCanDraw;
					text_p = ElemPosMin.DrawPt;        
				}
				else
				{
					if(nMnMxPos[0]==0)
					{
						if(nInverse5Div[0]) pDC->SetTextAlign(TA_RIGHT|TA_TOP);
						else					      pDC->SetTextAlign(TA_LEFT|TA_TOP);
						SET_BFOR_FONT_TYPE(nSlope5Div[0])
							bCanTextDraw = bCanDraw[0];
						text_p = DrawPt[0];
					}
					else if(nMnMxPos[0]==4)
					{
						if(nInverse5Div[4])pDC->SetTextAlign(TA_LEFT|TA_TOP);
						else					     pDC->SetTextAlign(TA_RIGHT|TA_TOP);
						SET_BFOR_FONT_TYPE(nSlope5Div[4])
							bCanTextDraw = bCanDraw[4];
						text_p = DrawPt[4];
					}
					else
					{
						pDC->SetTextAlign(TA_CENTER|TA_TOP);
						SET_BFOR_FONT_TYPE(nSlope5Div[2])
							bCanTextDraw = bCanDraw[2];
						text_p = DrawPt[2];
					}
				}   
				_stprintf(text_str, fmt_str, dMinVal);
				if(bCanTextDraw)pDC->TextOut(text_p.x, text_p.y, text_str);
				DEL_BFOR_FONT_TYPE() 

					// Max
					bCanTextDraw=FALSE; 
				if(m_bBForcOutputByMember && bIsMembAssigned)
				{
					T_BFORC_ELEM_POS_D ElemPosMax;
					m_mapBForcMaxPosByMember.Lookup(ElemK_First, ElemPosMax);
					switch(ElemPosMax.nPosIndex)
					{
					case 0:
						if(ElemPosMax.nInverse5Div) pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
						else					              pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
						break;
					case 4:
						if(ElemPosMax.nInverse5Div) pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
						else					              pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
						break;
					default:
						pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);
						break;
					}
					SET_BFOR_FONT_TYPE(ElemPosMax.nSlope5Div)
						bCanTextDraw = ElemPosMax.bCanDraw;
					text_p       = ElemPosMax.DrawPt;        
				}
				else
				{
					if(nMnMxPos[1]==0)
					{
						if(nInverse5Div[0]) pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
						else					      pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
						SET_BFOR_FONT_TYPE(nSlope5Div[0])
							bCanTextDraw = bCanDraw[0];
						text_p = DrawPt[0];
					}
					else if(nMnMxPos[1]==4)
					{
						if(nInverse5Div[4]) pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
						else					      pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
						SET_BFOR_FONT_TYPE(nSlope5Div[4])
							bCanTextDraw = bCanDraw[4];
						text_p = DrawPt[4];
					}
					else
					{
						pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);
						SET_BFOR_FONT_TYPE(nSlope5Div[2])
							bCanTextDraw = bCanDraw[2];
						text_p = DrawPt[2];
					}
				}
				_stprintf(text_str, fmt_str, dMaxVal);
				if(bCanTextDraw)pDC->TextOut(text_p.x, text_p.y, text_str);
				DEL_BFOR_FONT_TYPE()    
			}
			else 
			{
				if(m_bBForcOutputI) 
				{
					pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorI);
					if(nInverse5Div[0]) pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
					else				        pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
					SET_BFOR_FONT_TYPE(nSlope5Div[0])
						_stprintf(text_str, fmt_str, CalcBForcValue(bforc_d, BFORC_OUTPUT_INODE));
					if(bCanDraw[0])pDC->TextOut(DrawPt[0].x, DrawPt[0].y, text_str);
					DEL_BFOR_FONT_TYPE()    
				}
				if(m_bBForcOutputJ) 
				{
					pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorJ);
					if(nInverse5Div[4]) pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
					else				        pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
					SET_BFOR_FONT_TYPE(nSlope5Div[4])
						_stprintf(text_str, fmt_str, CalcBForcValue(bforc_d, BFORC_OUTPUT_JNODE));
					if(bCanDraw[4])pDC->TextOut(DrawPt[4].x, DrawPt[4].y, text_str);
					DEL_BFOR_FONT_TYPE()    
				}
				if(m_bBForcOutputC)
				{
					// 멤버별 출력시 : Mid값, 요소별 출력시 : 가운데 BForc값
					double dCenterValue;
					if(m_bBForcOutputByMember)
					{ 
						if(bIsMembAssigned)
						{
							dCenterValue = CalcBForcValue(bforc_d, 0, J_NODE);

							// Mid
							BOOL bCanTextDraw=FALSE; 
							if(m_bBForcOutputByMember && bIsMembAssigned)
							{
								T_BFORC_ELEM_POS_D ElemPosMid;
								m_mapBForcMidPosByMember.Lookup(ElemK_First, ElemPosMid);
								switch(ElemPosMid.nPosIndex)
								{
								case 0:
									if(ElemPosMid.nInverse5Div) pDC->SetTextAlign(TA_RIGHT|TA_TOP);
									else					              pDC->SetTextAlign(TA_LEFT|TA_TOP);
									break;
								case 4:
									if(ElemPosMid.nInverse5Div) pDC->SetTextAlign(TA_LEFT|TA_TOP);
									else					              pDC->SetTextAlign(TA_RIGHT|TA_TOP);
									break;
								default:
									pDC->SetTextAlign(TA_CENTER|TA_TOP);
									break;
								}
								SET_BFOR_FONT_TYPE(ElemPosMid.nSlope5Div)
									bCanTextDraw = ElemPosMid.bCanDraw;
								text_p = ElemPosMid.DrawPt;  
								_stprintf(text_str, fmt_str, dCenterValue);
								if(bCanTextDraw)pDC->TextOut(text_p.x, text_p.y, text_str);
								DEL_BFOR_FONT_TYPE()
							}
							else                
							{
								dCenterValue = GetMidElemBForc(bforc_d, FALSE, FALSE);  

								pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
								pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);
								SET_BFOR_FONT_TYPE(nSlope5Div[2])
									_stprintf(text_str, fmt_str, dCenterValue);
								if(bCanDraw[2])pDC->TextOut(DrawPt[2].x, DrawPt[2].y, text_str);
								DEL_BFOR_FONT_TYPE() 

							}
						}
						else
						{
							dCenterValue= CalcBForcValue(bforc_d, 1, J_NODE);

							pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
							pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);
							SET_BFOR_FONT_TYPE(nSlope5Div[2])
								_stprintf(text_str, fmt_str, dCenterValue);
							if(bCanDraw[2])pDC->TextOut(DrawPt[2].x, DrawPt[2].y, text_str);
							DEL_BFOR_FONT_TYPE()  
						}
					}
				}
			}
		}
		FreeMemoryPolyList(&polygon_list,&edge_list);
		FreeMemoryPolyList(&polygon_list_Mid,&edge_list_Mid);
		FreeMemoryPolyList(&polygon_list_Last,&edge_list_Last);
	}
	gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}
#else
void CForceEngine::OutputBForcNumbers(CDC *pDC)
{
	DECLARE_GPSMD();
	DECLARE_DPTTX();
	DECLARE_DPTDR();

	int				  i, elem_num;
	T_ELEM_K		ekey;
	T_ELEM_D		edata;
	T_STRB_D		bforc_d;
	C3DPoint		node3D_i, node3D_j, DrawPoint;
	CPoint			text_p;
	TCHAR			  fmt_str[10], text_str[512];
	BOOL			  fl_bak;

	POSITION		pos;
	CArray<GPS_3DPT_LISTP, GPS_3DPT_LISTP>	polygon_list;
	CArray<GPS_3DPT_LISTP, GPS_3DPT_LISTP>	polygon_list_Mid;  // 멤버의 가운데 요소의 폴리곤
	CArray<GPS_3DPT_LISTP, GPS_3DPT_LISTP>	polygon_list_Last; // 멤버의 끝 요소의 폴리곤
	CArray<GPS_BOOL_ARRYP, GPS_BOOL_ARRYP>  edge_list, edge_list_Mid, edge_list_Last;

	if (!m_bBForcDataSet)return;
	if (m_bBForcOutputByMember) MakeBForcDataListByMember();

	GPostTextOut TextOutModel;
	TextOutModel.StartBeamForceVal();
	TextOutModel.SetDC(pDC);
	TextOutModel.SettingBeamForce(gm);

	if (pTX->m_bNumberExponent)
		_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);

	fl_bak = gm->m_DOPT.DR.m_bFrameLine;
	gm->m_DOPT.DR.m_bFrameLine = TRUE;

	int nGPSMode = (gm->m_GPSInstruction != -1) ? gm->m_GPSInstruction : gm->m_GPSMode;
	BOOL bGrpFltMode = gm->m_pGPSCtrl->IsGroupFilterMode();
	if (!bGrpFltMode)elem_num = gm->m_EKeyListActive.GetSize();
	else            elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize();

	for (i = 0; i < elem_num; i++)
	{
		if (!bGrpFltMode)ekey = gm->m_EKeyListActive[i];
		else            ekey = gm->m_pDispFilter->m_aGrpEKey[i];

		if (!gm->m_pGPSCtrl->IsActiveElem(ekey))
			continue;

		if (m_bBForcOutputByMember)
		{
			if (!GetBeamForceByMember(ekey, bforc_d)) continue;
		}
		else
		{
			if (!GetBeamForce(ekey, bforc_d)) bforc_d.Initialize();
		}

		m_pDoc->m_pAttrCtrl->GetElem(ekey, edata);

		BOOL bBeam = m_pDoc->m_pAttrCtrl->IsBeam(edata.eltyp);
		BOOL bTruss = IsBForcWithTForc() && m_pDoc->m_pAttrCtrl->IsTruss(edata.eltyp);

		if (!bBeam && !bTruss)continue;

		if ((nGPSMode == GPS_COMMAND_BDGRM || nGPSMode == GPS_COMMAND_BFORC) && m_nBForcPscPart > 0)
		{
			if (m_nBForcPscPart > m_pDoc->m_pPostCtrl->GetCscsInfo()->GetNumMaxSectionPart(ekey))
				continue;
		}

		// Member의 처음과 끝 요소의 DrawPt를 구해서 조작해줍시다. [0]:I단 [2]:Center [4]:J단
		T_ELEM_K ElemK_First = ekey;
		T_ELEM_K ElemK_Mid = 0, ElemK_Last = 0;
		BOOL bHasEvenNumOfElem;
		BOOL bIsMembAssigned = FALSE;
		T_MEMB_K MembK;
		if (m_pDoc->m_pAttrCtrl->GetMembAssigned(ElemK_First, MembK))
		{
			bIsMembAssigned = TRUE;
			ElemK_Mid = CMembCtrl::GetMembCtrl()->GetMidElemKeyOfMemb(MembK, bHasEvenNumOfElem);
			ElemK_Last = CMembCtrl::GetMembCtrl()->GetLastElemKeyOfMemb(MembK);
		}

		if (m_bDeformedShapeContour)
		{
			gm->m_pDeformEngine->GetDeformedShapeElement(ElemK_First, &polygon_list, &edge_list);
			if (m_bBForcOutputByMember && ElemK_Mid > 0)  gm->m_pDeformEngine->GetDeformedShapeElement(ElemK_Mid, &polygon_list_Mid, &edge_list_Mid);
			if (m_bBForcOutputByMember && ElemK_Last > 0) gm->m_pDeformEngine->GetDeformedShapeElement(ElemK_Last, &polygon_list_Last, &edge_list_Last);
		}
		else
		{
			gm->GetShapeElement(ElemK_First, polygon_list, &edge_list);
			if (m_bBForcOutputByMember && ElemK_Mid > 0)  gm->GetShapeElement(ElemK_Mid, polygon_list_Mid, &edge_list_Mid);
			if (m_bBForcOutputByMember && ElemK_Last > 0) gm->GetShapeElement(ElemK_Last, polygon_list_Last, &edge_list_Last);
		}

		pos = polygon_list[0]->GetHeadPosition();
		node3D_i = polygon_list[0]->GetNext(pos);
		node3D_j = polygon_list[0]->GetNext(pos);

		int nSlope5Div[5];
		BOOL nInverse5Div[5];
		BOOL bCanDraw[5];
		CPoint DrawPt[5];
		CUtilFuncs::MakeBeamSlopeAt5Div(gm, node3D_i, node3D_j, nSlope5Div, nInverse5Div, bCanDraw, DrawPt);

		if (m_bBForcOutputByMember && ElemK_Mid > 0)
		{
			pos = polygon_list_Mid[0]->GetHeadPosition();
			node3D_i = polygon_list_Mid[0]->GetNext(pos);
			node3D_j = polygon_list_Mid[0]->GetNext(pos);

			int nSlope5Div_Mid[5];
			BOOL nInverse5Div_Mid[5];
			BOOL bCanDraw_Mid[5];
			CPoint DrawPt_Mid[5];
			CUtilFuncs::MakeBeamSlopeAt5Div(gm, node3D_i, node3D_j, nSlope5Div_Mid, nInverse5Div_Mid, bCanDraw_Mid, DrawPt_Mid);

			// 가운데 요소의 위치를 구하는 조건문
			if (bHasEvenNumOfElem) DrawPt[2] = DrawPt_Mid[4];
			else                  DrawPt[2] = DrawPt_Mid[2];
		}

		if (m_bBForcOutputByMember && ElemK_Last > 0)
		{
			pos = polygon_list_Last[0]->GetHeadPosition();
			node3D_i = polygon_list_Last[0]->GetNext(pos);
			node3D_j = polygon_list_Last[0]->GetNext(pos);

			int nSlope5Div_Last[5];
			BOOL nInverse5Div_Last[5];
			BOOL bCanDraw_Last[5];
			CPoint DrawPt_Last[5];
			CUtilFuncs::MakeBeamSlopeAt5Div(gm, node3D_i, node3D_j, nSlope5Div_Last, nInverse5Div_Last, bCanDraw_Last, DrawPt_Last);

			// 마지막 요소의 위치를 구하는 조건문
			DrawPt[4] = DrawPt_Last[4];
		}

		if (gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
		{
			double dLimit = (m_dMaxValue - m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;
			double dBValue;

			for (int n = 0; n < 3; n++)
			{
				TextOutModel.SetOFNull();

				BOOL bCanTextDraw = FALSE;
				if (m_bBForcOutputMinMax)
				{
					double dMinVal, dMaxVal;
					int    nMnMxPos[2];
					dMaxVal = CalcBForcValue(bforc_d, BFORC_OUTPUT_MAXMIN, nMnMxPos, &dMinVal);

					// Min
					if (n == 0)
					{
						if (nMnMxPos[0] == 0)// I Pos
						{
							if (nInverse5Div[0])  TextOutModel.AlignTextTop(TA_RIGHT);
							else					  TextOutModel.AlignTextTop(TA_LEFT);
							TextOutModel.Font4BeamForce(gm, nSlope5Div[0]);
								bCanTextDraw = bCanDraw[0];
						}
						else if (nMnMxPos[0] == 4)// J Pos
						{
							if (nInverse5Div[4])  TextOutModel.AlignTextTop(TA_LEFT);
							else					  TextOutModel.AlignTextTop(TA_RIGHT);
							TextOutModel.Font4BeamForce(gm, nSlope5Div[4]);
								bCanTextDraw = bCanDraw[4];
						}
						else // Mid Pos
						{
							TextOutModel.AlignTextTop(TA_CENTER);
							TextOutModel.Font4BeamForce(gm, nSlope5Div[2]);
								bCanTextDraw = bCanDraw[2];
						}
						DrawPoint.x = node3D_i.x + (node3D_j.x - node3D_i.x)*nMnMxPos[0] / 4.;
						DrawPoint.y = node3D_i.y + (node3D_j.y - node3D_i.y)*nMnMxPos[0] / 4.;
						DrawPoint.z = node3D_i.z + (node3D_j.z - node3D_i.z)*nMnMxPos[0] / 4.;
						dBValue = dMinVal;
					}
					// Max
					else if (n == 1)
					{
						if (nMnMxPos[1] == 0)
						{
							if (nInverse5Div[0]) TextOutModel.AlignTextBot(TA_RIGHT);
							else					      TextOutModel.AlignTextBot(TA_LEFT);
							TextOutModel.Font4BeamForce(gm, nSlope5Div[0]);
								bCanTextDraw = bCanDraw[0];
						}
						else if (nMnMxPos[1] == 4)
						{
							if (nInverse5Div[4])  TextOutModel.AlignTextBot(TA_LEFT);
							else					  TextOutModel.AlignTextBot(TA_RIGHT);
							TextOutModel.Font4BeamForce(gm, nSlope5Div[4]);
								bCanTextDraw = bCanDraw[4];
						}
						else
						{
							TextOutModel.AlignTextBot(TA_RIGHT);
							TextOutModel.Font4BeamForce(gm, nSlope5Div[2]);
								bCanTextDraw = bCanDraw[2];
						}
						DrawPoint.x = node3D_i.x + (node3D_j.x - node3D_i.x)*nMnMxPos[1] / 4.;
						DrawPoint.y = node3D_i.y + (node3D_j.y - node3D_i.y)*nMnMxPos[1] / 4.;
						DrawPoint.z = node3D_i.z + (node3D_j.z - node3D_i.z)*nMnMxPos[1] / 4.;
						dBValue = dMaxVal;
					}
					else continue;
				}
				else if (n == 0) // I단 
				{
					if (!m_bBForcOutputI) continue;

					if (nInverse5Div[0])	TextOutModel.AlignTextBot(TA_RIGHT);
					else					     TextOutModel.AlignTextBot(TA_LEFT);
					DrawPoint = node3D_i;
					dBValue = CalcBForcValue(bforc_d, 0, I_NODE);
					TextOutModel.Font4BeamForce(gm, nSlope5Div[0]);
						bCanTextDraw = bCanDraw[0];
				}
				else if (n == 1)// CNT or MAX
				{
					if (!(m_bBForcOutputC || m_bBForcOutputMax)) continue;

					TextOutModel.AlignTextBot(TA_CENTER);
					DrawPoint.x = (node3D_i.x + node3D_j.x) / 2.0;
					DrawPoint.y = (node3D_i.y + node3D_j.y) / 2.0;
					DrawPoint.z = (node3D_i.z + node3D_j.z) / 2.0;

					if (m_bBForcOutputMax)dBValue = CalcBForcValue(bforc_d, BFORC_OUTPUT_MAX);
					else                 dBValue = CalcBForcValue(bforc_d, 1, J_NODE);
					TextOutModel.Font4BeamForce(gm, nSlope5Div[2]);
						bCanTextDraw = bCanDraw[2];

				}
				else if (n == 2)// J단 
				{
					if (!m_bBForcOutputJ) continue;
					if (nInverse5Div[4])	TextOutModel.AlignTextBot(TA_LEFT);
					else					     TextOutModel.AlignTextBot(TA_RIGHT);
					DrawPoint = node3D_j;
					dBValue = CalcBForcValue(bforc_d, 3, J_NODE);
					TextOutModel.Font4BeamForce(gm, nSlope5Div[4]);
						bCanTextDraw = bCanDraw[4];
				}

				if (!bCanTextDraw)
				{
					TextOutModel.DeleteFontFlag();
						continue;
				}
				switch (gm->m_DOPT.TX.m_nOutputMinMaxType)
				{
				case 0: // Min & Max
					if ((m_dMaxValue - dBValue) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, dBValue);
					else if ((dBValue - m_dMinValue) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, dBValue);
					break;
				case 1: // Abs Max
					if (fabs(m_dMaxValue) >= fabs(m_dMinValue))
					{
						if (fabs(m_dMaxValue) - fabs(dBValue) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, dBValue);
					}
					else
					{
						if (fabs(m_dMinValue) - fabs(dBValue) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, dBValue);
					}
					break;
				case 2: // Max
					if ((m_dMaxValue - dBValue) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, dBValue);
					break;
				case 3: // Min
					if ((dBValue - m_dMinValue) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, dBValue);
					break;
				}
				TextOutModel.DeleteFontFlag();
			}
			//////////////////////////////////////////////////////////////////////////////////////
		}
		else
		{
			// Abs Max
			if (m_bBForcOutputMax)
			{
				TextOutModel.Font4BeamForce(gm, nSlope5Div[2]);
				_stprintf(text_str, fmt_str, CalcBForcValue(bforc_d, BFORC_OUTPUT_MAX));
				if (bCanDraw[2]) TextOutModel.TextOutBeamForce(DrawPt[2].x, DrawPt[2].y, text_str);
				TextOutModel.DeleteFontFlag();
			}
			// Min/Max
			else if (m_bBForcOutputMinMax)
			{
				double dMinVal, dMaxVal;
				int    nMnMxPos[2];
				dMaxVal = CalcBForcValue(bforc_d, BFORC_OUTPUT_MAXMIN, nMnMxPos, &dMinVal);

				// Min
				BOOL bCanTextDraw = FALSE;
				if (m_bBForcOutputByMember && bIsMembAssigned)
				{
					T_BFORC_ELEM_POS_D ElemPosMin;
					m_mapBForcMinPosByMember.Lookup(ElemK_First, ElemPosMin);
					switch (ElemPosMin.nPosIndex)
					{
					case 0:
						if (ElemPosMin.nInverse5Div) TextOutModel.AlignTextTop(TA_RIGHT);
						else					              TextOutModel.AlignTextTop(TA_LEFT);
						break;
					case 4:
						if (ElemPosMin.nInverse5Div) TextOutModel.AlignTextTop(TA_LEFT);
						else					              TextOutModel.AlignTextTop(TA_RIGHT);
						break;
					default:
						TextOutModel.AlignTextTop(TA_CENTER);
						break;
					}
					TextOutModel.Font4BeamForce(gm, ElemPosMin.nSlope5Div);
						bCanTextDraw = ElemPosMin.bCanDraw;
					text_p = ElemPosMin.DrawPt;
				}
				else
				{
					if (nMnMxPos[0] == 0)
					{
						if (nInverse5Div[0]) TextOutModel.AlignTextTop(TA_RIGHT);
						else					      TextOutModel.AlignTextTop(TA_LEFT);
						TextOutModel.Font4BeamForce(gm, nSlope5Div[0]);
							bCanTextDraw = bCanDraw[0];
						text_p = DrawPt[0];
					}
					else if (nMnMxPos[0] == 4)
					{
						if (nInverse5Div[4])	TextOutModel.AlignTextTop(TA_LEFT);
						else					     TextOutModel.AlignTextTop(TA_RIGHT);
						TextOutModel.Font4BeamForce(gm, nSlope5Div[4]);
							bCanTextDraw = bCanDraw[4];
						text_p = DrawPt[4];
					}
					else
					{
						TextOutModel.AlignTextTop(TA_CENTER);
						TextOutModel.Font4BeamForce(gm, nSlope5Div[2]);
							bCanTextDraw = bCanDraw[2];
						text_p = DrawPt[2];
					}
				}
				_stprintf(text_str, fmt_str, dMinVal);
				if (bCanTextDraw)	TextOutModel.TextOutBeamForce(text_p.x, text_p.y, text_str);
				TextOutModel.DeleteFontFlag();

					// Max
					bCanTextDraw = FALSE;
				if (m_bBForcOutputByMember && bIsMembAssigned)
				{
					T_BFORC_ELEM_POS_D ElemPosMax;
					m_mapBForcMaxPosByMember.Lookup(ElemK_First, ElemPosMax);
					switch (ElemPosMax.nPosIndex)
					{
					case 0:
						if (ElemPosMax.nInverse5Div) TextOutModel.AlignTextBot(TA_RIGHT);
						else					              TextOutModel.AlignTextBot(TA_LEFT);
						break;
					case 4:
						if (ElemPosMax.nInverse5Div) TextOutModel.AlignTextBot(TA_LEFT);
						else					              TextOutModel.AlignTextBot(TA_RIGHT);
						break;
					default:
						TextOutModel.AlignTextBot(TA_CENTER);
						break;
					}
					TextOutModel.Font4BeamForce(gm, ElemPosMax.nSlope5Div);
						bCanTextDraw = ElemPosMax.bCanDraw;
					text_p = ElemPosMax.DrawPt;
				}
				else
				{
					if (nMnMxPos[1] == 0)
					{
						if (nInverse5Div[0]) TextOutModel.AlignTextBot(TA_RIGHT);
						else					      TextOutModel.AlignTextBot(TA_LEFT);
						TextOutModel.Font4BeamForce(gm, nSlope5Div[0]);
							bCanTextDraw = bCanDraw[0];
						text_p = DrawPt[0];
					}
					else if (nMnMxPos[1] == 4)
					{
						if (nInverse5Div[4]) TextOutModel.AlignTextBot(TA_LEFT);
						else					      TextOutModel.AlignTextBot(TA_RIGHT);
						TextOutModel.Font4BeamForce(gm, nSlope5Div[4]);
							bCanTextDraw = bCanDraw[4];
						text_p = DrawPt[4];
					}
					else
					{
						TextOutModel.AlignTextBot(TA_CENTER);
						TextOutModel.Font4BeamForce(gm, nSlope5Div[2]);
							bCanTextDraw = bCanDraw[2];
						text_p = DrawPt[2];
					}
				}
				_stprintf(text_str, fmt_str, dMaxVal);
				if (bCanTextDraw)	TextOutModel.TextOutBeamForce(text_p.x, text_p.y, text_str);
				TextOutModel.DeleteFontFlag();
			}
			else
			{
				if (m_bBForcOutputI)
				{
					TextOutModel.Font4BeamForce(gm, nSlope5Div[0]);
					_stprintf(text_str, fmt_str, CalcBForcValue(bforc_d, BFORC_OUTPUT_INODE));
					if (bCanDraw[0])
					{
						if (nInverse5Div[0]) TextOutModel.TextOutBeamForce(DrawPt[0].x, DrawPt[0].y, text_str, gm->m_DOPT.TX.m_NumberTextColorI, TA_RIGHT);
						else				        TextOutModel.TextOutBeamForce(DrawPt[0].x, DrawPt[0].y, text_str, gm->m_DOPT.TX.m_NumberTextColorI, TA_LEFT);
					}
					TextOutModel.DeleteFontFlag();
				}
				if (m_bBForcOutputJ)
				{
					TextOutModel.Font4BeamForce(gm, nSlope5Div[4]);
					_stprintf(text_str, fmt_str, CalcBForcValue(bforc_d, BFORC_OUTPUT_JNODE));
					if (bCanDraw[4])
					{
						if (nInverse5Div[4]) TextOutModel.TextOutBeamForce(DrawPt[4].x, DrawPt[4].y, text_str, gm->m_DOPT.TX.m_NumberTextColorJ, TA_LEFT);
						else TextOutModel.TextOutBeamForce(DrawPt[4].x, DrawPt[4].y, text_str, gm->m_DOPT.TX.m_NumberTextColorJ, TA_RIGHT);
					}
					TextOutModel.DeleteFontFlag();
				}
				if (m_bBForcOutputC)
				{
					// 멤버별 출력시 : Mid값, 요소별 출력시 : 가운데 BForc값
					double dCenterValue;
					if (m_bBForcOutputByMember)
					{
						if (bIsMembAssigned)
						{
							dCenterValue = CalcBForcValue(bforc_d, 0, J_NODE);

							// Mid
							BOOL bCanTextDraw = FALSE;
							if (m_bBForcOutputByMember && bIsMembAssigned)
							{
								T_BFORC_ELEM_POS_D ElemPosMid;
								m_mapBForcMidPosByMember.Lookup(ElemK_First, ElemPosMid);
								switch (ElemPosMid.nPosIndex)
								{
								case 0:
									if (ElemPosMid.nInverse5Div) TextOutModel.AlignTextTop(TA_RIGHT);
									else					              TextOutModel.AlignTextTop(TA_LEFT);
									break;
								case 4:
									if (ElemPosMid.nInverse5Div) TextOutModel.AlignTextTop(TA_LEFT);
									else					              TextOutModel.AlignTextTop(TA_RIGHT);
									break;
								default:
									TextOutModel.AlignTextTop(TA_CENTER);
									break;
								}
								TextOutModel.Font4BeamForce(gm, ElemPosMid.nSlope5Div);
								bCanTextDraw = ElemPosMid.bCanDraw;
								text_p = ElemPosMid.DrawPt;
								_stprintf(text_str, fmt_str, dCenterValue);
								if (bCanTextDraw)	TextOutModel.TextOutBeamForce(text_p.x, text_p.y, text_str);
								TextOutModel.DeleteFontFlag();
							}
							else
							{
								TextOutModel.Font4BeamForce(gm, nSlope5Div[2]);
								dCenterValue = GetMidElemBForc(bforc_d, FALSE, FALSE);
								_stprintf(text_str, fmt_str, dCenterValue);
								if (bCanDraw[2])	TextOutModel.TextOutBeamForce(DrawPt[2].x, DrawPt[2].y, text_str, gm->m_DOPT.TX.m_NumberTextColorC, TA_CENTER);
								TextOutModel.DeleteFontFlag();

							}
						}
						else
						{
							TextOutModel.Font4BeamForce(gm, nSlope5Div[2]);
							dCenterValue = CalcBForcValue(bforc_d, 1, J_NODE);
							_stprintf(text_str, fmt_str, dCenterValue);
							if (bCanDraw[2])	TextOutModel.TextOutBeamForce(DrawPt[2].x, DrawPt[2].y, text_str, gm->m_DOPT.TX.m_NumberTextColorC, TA_CENTER);
							TextOutModel.DeleteFontFlag();
						}
					}
				}
			}
		}
		FreeMemoryPolyList(&polygon_list, &edge_list);
		FreeMemoryPolyList(&polygon_list_Mid, &edge_list_Mid);
		FreeMemoryPolyList(&polygon_list_Last, &edge_list_Last);
	}
	gm->m_DOPT.DR.m_bFrameLine = fl_bak;
	TextOutModel.EndBeamForceVal();
}
#endif

void CForceEngine::DrawContourList(CDC *pDC, CArray <int, int> &vnum_list, CArray <VtxInfo, VtxInfo> &vtx_list)
{
	DECLARE_GPSMD();

	// SFD/BMD용 DrawContourList
	int		i, j, k, poly_num=vnum_list.GetSize();
	BOOL	is_bsfdbmd=FALSE, is_wsfdbmd=FALSE, is_esfdbmd=FALSE, is_thsfdbmd=FALSE, is_stripdgrm=FALSE;
	CPen	edge_pen, *old_pen,*old_pen2;
	CClientDC	 ClientDC(((I_GPSModel*)m_pGPSModel)->m_pMyView);
	CList<C3DPoint,C3DPoint>	vlist;

	if(!m_pContourEngine)return;

	if(gm->m_GPSInstruction==GPS_COMMAND_BDGRM) is_bsfdbmd = TRUE;
	if(gm->m_GPSInstruction==GPS_COMMAND_WSFBM) is_wsfdbmd = TRUE;
	if(gm->m_GPSInstruction==GPS_COMMAND_ESFBM) is_esfdbmd = TRUE;
	if(gm->m_GPSInstruction==GPS_COMMAND_THISBDGRM) is_thsfdbmd = TRUE;
	if(gm->m_GPSInstruction==GPS_COMMAND_THISBDGRM) is_thsfdbmd = TRUE;
	if(gm->m_GPSInstruction==GPS_COMMAND_STRIP_DGN || gm->m_GPSInstruction==GPS_COMMAND_STRIP_CHK) is_stripdgrm = TRUE;

	if(!(is_bsfdbmd||is_wsfdbmd||is_esfdbmd||is_thsfdbmd||is_stripdgrm) || 
		!((is_bsfdbmd   && m_bBSfdBmdLineOnly)||
		(is_wsfdbmd   && m_bWSfdBmdLineOnly)||
		(is_esfdbmd   && m_bBSfdBmdLineOnly)||
		(is_thsfdbmd  && m_bBSfdBmdLineOnly)||
		(is_stripdgrm && m_bBSfdBmdLineOnly) )) 
	{
		if((is_bsfdbmd||is_wsfdbmd||is_esfdbmd||is_stripdgrm) && !gm->m_bContour)
			DrawSFDBMDContourList_mono(pDC,vnum_list,vtx_list);
		else
			CEngineBase::DrawContourList(pDC,vnum_list,vtx_list);
	}
	else  
	{
		k = 0;
		for(i=0;i<poly_num;i++) 
		{  
			if((gm->m_DOPT.m_PrintMode == 0) && pDC->IsPrinting()) // B&W Mode
				edge_pen.CreatePen(PS_SOLID, gm->m_nLineWidth, RGB(60,60,60));
			else if(!gm->m_bContour)
				edge_pen.CreatePen(PS_SOLID, gm->m_nLineWidth, gm->m_DOPT.CL.m_BeamDiagramColor);
			else // Color Mode
				edge_pen.CreatePen(PS_SOLID, gm->m_nLineWidth, m_pContourEngine->GetValueColor(vtx_list[k].val));

			old_pen = (CPen *) pDC->SelectObject(&edge_pen);
			if(!gm->m_bVirtualMode && !gm->m_bAnimation)
				old_pen2 = (CPen *) ClientDC.SelectObject(&edge_pen);

			for(j=0;j<vnum_list[i];j++) 
			{
				if(vtx_list[k+j].ef) 
				{
					if (gm->m_bVirtualMode)
						gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, vtx_list[k+(j%vnum_list[i])].vtx, vtx_list[k+((j+1)%vnum_list[i])].vtx);
					else
					{
						if(!gm->m_bAnimation)
							gm->m_pGPSCtrl->DrawLine3DOnClientWindow(&ClientDC, vtx_list[k+(j%vnum_list[i])].vtx, vtx_list[k+((j+1)%vnum_list[i])].vtx);
						gm->m_pGPSCtrl->DrawLine3D(pDC, vtx_list[k+(j%vnum_list[i])].vtx, vtx_list[k+((j+1)%vnum_list[i])].vtx);
					}
				}
			}
			k += vnum_list[i];
			pDC->SelectObject(old_pen);
			if(!gm->m_bVirtualMode && !gm->m_bAnimation)
				ClientDC.SelectObject(old_pen2);
			edge_pen.DeleteObject();
		}
	}
}

void CForceEngine::DrawContourListGrad(CDC *pDC, CArray <int, int> &vnum_list, CArray <VtxInfo, VtxInfo> &vtx_list)
{
	int							i, j, k=0, poly_num=vnum_list.GetSize();
	I_GPSModel					*gm=(I_GPSModel *) m_pGPSModel;
	BOOL						is_bsfdbmd=FALSE, is_wsfdbmd=FALSE,is_esfdbmd=FALSE,is_thsfdbmd=FALSE,is_stripdgrm=FALSE;
	CPoint						p1, p2;
	CPen						edge_pen, *old_pen,*old_pen2;
	CClientDC		ClientDC(((I_GPSModel*)m_pGPSModel)->m_pMyView);

	CArray<CPoint, CPoint &>		vtx_output;
	CArray<C3DPoint, C3DPoint &>vtx_input;
	CArray<COLORREF, COLORREF &>col_input, col_output;

	if(m_pContourEngine == NULL)return;

	if(gm->m_GPSInstruction==GPS_COMMAND_THISBDGRM) is_thsfdbmd = TRUE; 
	if(gm->m_GPSInstruction==GPS_COMMAND_BDGRM) is_bsfdbmd = TRUE;
	if(gm->m_GPSInstruction==GPS_COMMAND_WSFBM) is_wsfdbmd = TRUE;
	if(gm->m_GPSInstruction==GPS_COMMAND_ESFBM) is_esfdbmd = TRUE; 
	if(gm->m_GPSInstruction==GPS_COMMAND_STRIP_DGN || gm->m_GPSInstruction==GPS_COMMAND_STRIP_CHK) is_stripdgrm = TRUE;

	if(!(is_bsfdbmd || is_wsfdbmd || is_esfdbmd || is_thsfdbmd || is_stripdgrm) || 
		!((is_bsfdbmd   && m_bBSfdBmdLineOnly)||
		(is_wsfdbmd   && m_bWSfdBmdLineOnly)||
		(is_esfdbmd   && m_bBSfdBmdLineOnly)||
		(is_thsfdbmd  && m_bBSfdBmdLineOnly)||
		(is_stripdgrm && m_bBSfdBmdLineOnly)  )) 
	{
		if( (is_bsfdbmd||is_wsfdbmd||is_esfdbmd||is_thsfdbmd||is_stripdgrm) && !gm->m_bContour)
			DrawSFDBMDContourList_mono(pDC,vnum_list,vtx_list);
		else
			CEngineBase::DrawContourListGrad(pDC,vnum_list,vtx_list);
	}
	else
	{
		k = 0;
		for (i=0;i<poly_num;i++) 
		{
			if((gm->m_DOPT.m_PrintMode == 0) && pDC->IsPrinting()) // B&W Mode
				edge_pen.CreatePen(PS_SOLID, gm->m_nLineWidth, RGB(60,60,60));
			else if(!gm->m_bContour)
				edge_pen.CreatePen(PS_SOLID, gm->m_nLineWidth, gm->m_DOPT.CL.m_BeamDiagramColor);
			else // Color Mode
				edge_pen.CreatePen(PS_SOLID, gm->m_nLineWidth, m_pContourEngine->GetValueColor(vtx_list[k].val));

			old_pen = (CPen *) pDC->SelectObject(&edge_pen);
			if(!gm->m_bVirtualMode && !gm->m_bAnimation)
				old_pen2 = (CPen *) ClientDC.SelectObject(&edge_pen);


			for (j=0;j<vnum_list[i];j++) {
				if (vtx_list[k+j].ef) {
					if (gm->m_bVirtualMode) {
						gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, vtx_list[k+(j%vnum_list[i])].vtx, vtx_list[k+((j+1)%vnum_list[i])].vtx);
					}
					else {
						if(!gm->m_bAnimation)
							gm->m_pGPSCtrl->DrawLine3DOnClientWindow(&ClientDC, vtx_list[k+(j%vnum_list[i])].vtx, vtx_list[k+((j+1)%vnum_list[i])].vtx);
						gm->m_pGPSCtrl->DrawLine3D(pDC, vtx_list[k+(j%vnum_list[i])].vtx, vtx_list[k+((j+1)%vnum_list[i])].vtx);
					}
				}
			}
			k += vnum_list[i];
			pDC->SelectObject(old_pen);
			if(!gm->m_bVirtualMode && !gm->m_bAnimation)
				ClientDC.SelectObject(old_pen2);

			edge_pen.DeleteObject();
		}
	}

}
////////////////////////////////////////////////////////////////////////////////////////
// Routines for Drawing Beam Member Force/Moment Contour           ////////////////////
////////////////////////////////////////////////////////////////////////////////////////
void CForceEngine::DrawBForcContour(CDC *pDC)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	int			i, elem_num;
	T_ELEM_D	elem_d;
	CPen		elem_pen, *old_pen;
	CArray <int, int>				type_list;
	CArray <GRE_Atom, GRE_Atom&>		atom_list;
	BOOL bEscapePressed = FALSE;
	T_MIRE_K mkey;

	/*
	if (!gm->m_bContour) {
	gm->GPSDrawOriginal(pDC);
	return;
	}
	*/

	if (m_bDeformedShapeContour) {
		if (gm->m_pDeformEngine == NULL) {
			return;
		}
		type_list.Add(gm->m_MinOTID + OBJECT_TYPE_DEFORMED);
	}
	else {
		type_list.Add(gm->m_MinOTID + OBJECT_TYPE_ORIGINAL);
	}

	if(gm->m_DOPT.DR.m_bFrameLine) // wire frame
		//elem_pen.CreatePen(PS_SOLID, gm->m_nLineWidth*1.7, m_pContourEngine->m_ElemColor);
			//elem_pen.CreatePen(PS_SOLID, gm->m_LnWd.nElemWire*1.7, m_pContourEngine->m_ElemColor);
				elem_pen.CreatePen(PS_SOLID, gm->m_DOPT.DR.nElemWire*1.7, m_pContourEngine->m_ElemColor);
	else 
		//elem_pen.CreatePen(PS_SOLID, gm->m_nLineWidth, m_pContourEngine->m_ElemColor);
		//elem_pen.CreatePen(PS_SOLID, gm->m_LnWd.nElemHddn, m_pContourEngine->m_ElemColor);
		elem_pen.CreatePen(PS_SOLID, gm->m_DOPT.DR.nElemHddn, m_pContourEngine->m_ElemColor);

	//elem_pen.CreatePen(PS_SOLID, gm->m_nLineWidth, m_pContourEngine->m_ElemColor);
	old_pen = (CPen *) pDC->SelectObject(&elem_pen);

	gm->m_pGPSCtrl->GetZSortedList(type_list, gm->m_EKeyListVisible_Mirror, atom_list);
	elem_num = atom_list.GetSize();
	for (i=0;i<elem_num;i++) 
	{
		//if(gm->m_pGPSCtrl->WatchEscKeyPress()) bEscapePressed = TRUE;
		if(gm->m_pGPSCtrl->WatchEscKeyPress()) return;
		if (gm->m_pGPSCtrl->IsZoomAllState() ||
			gm->m_pGPSCtrl->IsObjectInClientWindow(atom_list[i].m_OType, atom_list[i].m_OKey)) {
				mkey.keymap = atom_list[i].m_OKey;
				if(!m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d))
					continue;

				if( m_pDoc->m_pAttrCtrl->IsBeam(elem_d.eltyp) && !bEscapePressed) 
				{
					if(gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey))
					{
						if(gm->m_bContour)  DoBForcElementContour(pDC, atom_list[i].m_OKey);
						else                gm->GPSDrawElement(pDC,atom_list[i].m_OKey);
					}
					else
					{
						if(m_bDeformedShapeContour) gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, atom_list[i].m_OKey);
						else                        gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
					}
				}
				else if(IsBForcWithTForc() && m_pDoc->m_pAttrCtrl->IsTruss(elem_d.eltyp) && !bEscapePressed)
				{
					if(gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey))
					{
						if(gm->m_bContour)  DoBForcElementContour(pDC, atom_list[i].m_OKey);
						else                gm->GPSDrawElement(pDC,atom_list[i].m_OKey);
					}
					else
					{
						if(m_bDeformedShapeContour) gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, atom_list[i].m_OKey);
						else                        gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
					}
				}
				else 
				{
					if(m_bDeformedShapeContour) gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, atom_list[i].m_OKey);
					else					              gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
				}
		}
	}

	// 변형된 그림에 Undeformed Shape을 같이 그릴 경우.
	// Contour를 그릴 경우는 Hidden이 default
	// 따라서 Undeformed Shape은 무조건 나중에 그린다...
	if (m_bDeformedShapeContour && gm->m_DOPT.DR.m_bDrawInactive && !bEscapePressed) {
		//int	rf_bak=gm->m_RenderFlag;
		int	rf_bak=gm->m_DOPT.DR.m_RenderFlag;
		//gm->m_RenderFlag = 2;
		gm->m_DOPT.DR.m_RenderFlag = 2;
		gm->GPSDrawOriginal(pDC, TRUE);
		//gm->m_RenderFlag = rf_bak;
		gm->m_DOPT.DR.m_RenderFlag = rf_bak;
	}

	pDC->SelectObject(old_pen);
	elem_pen.DeleteObject();
}

void CForceEngine::DoBForcElementContour(CDC *pDC, unsigned int ekey)
{
	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;
	T_MIRE_K mkey;
	mkey.keymap = ekey;

	int				i, poly_num, vtx_num;
	BOOL			is_real=FALSE;
	T_ELEM_D		elem_d;
	T_STRB_D		bforc_d;

	CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list, polygonlistForYieldPoint;
	CArray <CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					edge_list, edge_listDummy;
	CArray <CArray <T_NODE_K, T_NODE_K> *, CArray <T_NODE_K, T_NODE_K> *>	VertexNode, VertexNodeDummy;
	CArray <CArray <double, double> *, CArray <double, double> *>			PosList, PosListDummy;

	if ((gm->m_pDeformEngine==NULL) ||
		(m_pContourEngine==NULL) ||
		(!GetBeamForce(mkey.key.elem_k, bforc_d))) {
			return;
	}

	// 요소의 형상정보를 얻는다.

	m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d);
	if (m_bDeformedShapeContour) {	// 변형된 형상
		is_real = gm->m_pDeformEngine->m_bRealDeform;
		if (is_real) {				// Real Deform
			if (!gm->m_pBeamDiagram)
				gm->m_pBeamDiagram = new CBeamDiagram;
			if (gm->m_pBeamDiagram->MakeBeamDispl(mkey.key.elem_k, gm->m_LoadCombi, 10, 2)) 
			{
				gm->m_pDeformEngine->GetBeamRealDeformedShape(ekey, &polygon_list, &edge_list, &PosList);
				gm->m_pDeformEngine->GetBeamRealDeformedShape(ekey, &polygonlistForYieldPoint, &edge_listDummy, &PosListDummy, NULL, TRUE);
			}
			else 
			{
				gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list, &VertexNode);
				gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygonlistForYieldPoint, &edge_listDummy, &VertexNodeDummy, NULL, NULL, TRUE);
				is_real = FALSE;
			}
		}
		else 
		{
			gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list, &VertexNode);
			gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygonlistForYieldPoint, &edge_listDummy, &VertexNodeDummy, NULL, NULL, TRUE);
		}
	}
	else 
	{
		gm->GetShapeElement(ekey, polygon_list, &edge_list, NULL, &VertexNode);
		gm->GetShapeElement(ekey, polygonlistForYieldPoint, &edge_listDummy, NULL, &VertexNodeDummy, NULL, NULL, TRUE);
	}

	T_SECT_D SectD;
	if(gm->m_DOPT.DR.m_bFrameThick)
		m_pDoc->m_pAttrCtrl->GetSect(elem_d.elpro,SectD);

	gm->GPS_XGL_Begin_Elem(mkey.key.elem_k,elem_d);

	poly_num = polygon_list.GetSize();
	for (i=0;i<poly_num;i++) 
	{
		vtx_num = polygon_list[i]->GetCount();
		if (vtx_num == 2) 
		{
			if(m_bDeformedShapeContour && is_real)
			{
				DoBForcLineContourReal(pDC, polygon_list[i], bforc_d, PosList[i]);
			}
			else
			{
				DoBForcLineContour(pDC, polygon_list[i], VertexNode[i], elem_d, bforc_d);
			}      
		}
		else 
		{
			if(!gm->IsPossibleDrawingPolyFrame(ekey,&elem_d,&SectD,poly_num,polygon_list[i],is_real))continue;
			//if(poly_num>1 &&  gm->m_DOPT.DR.m_bFrameThick && !gm->IsVisibleFace(polygon_list[i],vtx_num))
			// continue;
			/*
			if(poly_num>1 &&  gm->m_DOPT.DR.m_bFrameThick )
			{
			if(is_real)
			{
			if(!gm->IsVisibleFace4RealDeform(ekey,polygon_list[i],vtx_num))continue;
			}
			else 
			{
			if(!gm->IsVisibleFace(polygon_list[i],vtx_num)) continue; 
			}
			}
			*/
			if(m_bDeformedShapeContour && is_real)
				DoBForcPolyContourReal(pDC, polygon_list[i], edge_list[i], bforc_d, PosList[i]);
			else
				DoBForcPolyContour(pDC, polygon_list[i], edge_list[i], VertexNode[i], elem_d, bforc_d);

			// Fill+Outline의 경우 Contour를 수행하기 전의 Polygon의 Outline을 그림.
			//if (gm->m_RenderFlag == 3 || gm->m_RenderFlag == 2)
			if (gm->m_DOPT.DR.m_RenderFlag == 3 || gm->m_DOPT.DR.m_RenderFlag == 2)
				gm->GPSDrawPolygonEdge(pDC, polygon_list[i], edge_list[i]);
		}
	}

	for (i=0;i<polygonlistForYieldPoint.GetSize();i++) 
	{    
		DoBForcYieldPointIdxContour(pDC, polygonlistForYieldPoint[i], ekey);
	}

	gm->GPS_XGL_End_Elem();

	for(i=0;i<poly_num;i++) 
	{
		polygon_list[i]->RemoveAll();
		delete polygon_list[i];
		edge_list[i]->RemoveAll();
		delete edge_list[i];
		if (m_bDeformedShapeContour && is_real) {
			PosList[i]->RemoveAll();
			delete PosList[i];
		}
		else {
			VertexNode[i]->RemoveAll();
			delete VertexNode[i];
		}
	}
	polygon_list.RemoveAll();
	edge_list.RemoveAll();
	VertexNode.RemoveAll();
}

void CForceEngine::GetYieldPointIdxPosAndPointSize(GPS_3DPT_LISTP pVertex, T_ELEM_K ElemK, CArray<C3DPoint, C3DPoint&>& aYieldPointIdxPos)
{
	aYieldPointIdxPos.RemoveAll();

	if(pVertex->GetCount()!=2){ ASSERT(0); return; }

	auto itrMap = m_mapYeildPointIdx.find(ElemK);
	if(itrMap == m_mapYeildPointIdx.end()) { ASSERT(0); return; }

	int i;
	double dPosRatio[] = { 0.1 , 0.9, 0.5};
		
	C3DPoint IPt,JPt,TmpPt;
	POSITION nPos= pVertex->GetHeadPosition();
	IPt = pVertex->GetNext(nPos);
	JPt = pVertex->GetNext(nPos);

	int nYieldPointIdx = itrMap->second;
	// -IJK : [ I Axial Yield Index(Elem중간에표현) 0:Axial Elastic, 1 AxialYield ]
	//        [ J Moment-y Yield Index(Elem양끝에표현) 0:I-End Elastic/J-End Elastic(Before Yield), 1:I-End Yield/J=End Elastic, 2:I-End Elastic, J-End Yield, 3:I-End Yield, J-End Yield
	//        [ J Moment-z Yield Index(Elem양끝에표현) 0:I-End Elastic/J-End Elastic(Before Yield), 1:I-End Yield/J=End Elastic, 2:I-End Elastic, J-End Yield, 3:I-End Yield, J-End Yield
	if(nYieldPointIdx >= 0)
	{
		return;
	}
	BOOL bDrawIJMID[3]; // 0:I 1:J 2:Mid
	int nI, nJ, nK;
	nYieldPointIdx *= -1;
	nI = nYieldPointIdx / 100;
	nJ = (nYieldPointIdx % 100) / 10;
	nK = nYieldPointIdx % 10;
		
	switch (m_BForcComponent)
	{
	case BFORC_COMPONENT_FX:
		bDrawIJMID[0] = FALSE;
		bDrawIJMID[1] = FALSE;
		bDrawIJMID[2] = nI == 1;
		break;
	case BFORC_COMPONENT_MY:
		bDrawIJMID[0] = nJ == 1 || nJ == 3;
		bDrawIJMID[1] = nJ == 2 || nJ == 3;
		bDrawIJMID[2] = FALSE;
		break; 
	case BFORC_COMPONENT_MZ:
		bDrawIJMID[0] = nK == 1 || nK == 3;
		bDrawIJMID[1] = nK == 2 || nK == 3;
		bDrawIJMID[2] = FALSE;
		break;
	default:
		bDrawIJMID[0]  = FALSE;
		bDrawIJMID[1]  = FALSE;
		bDrawIJMID[2]  = FALSE;
	}
	
	for(i=0; i<3; i++)
	{ 
		if(bDrawIJMID[i])
		{
			TmpPt.x = IPt.x + (JPt.x - IPt.x) * dPosRatio[i];
			TmpPt.y = IPt.y + (JPt.y - IPt.y) * dPosRatio[i];
			TmpPt.z = IPt.z + (JPt.z - IPt.z) * dPosRatio[i];     

			aYieldPointIdxPos.Add(TmpPt); 
		}    
	}
}

void CForceEngine::DoBForcYieldPointIdxContour(CDC *pDC, CList <C3DPoint, C3DPoint> *Vertex, T_ELEM_K ElemK)
{
	if(!m_bYieldPoint) return;

	auto itrFind = m_mapYeildPointIdx.find(ElemK);
	if(itrFind == m_mapYeildPointIdx.end())  return;

	// Display Option > Size > Label Symbol에서 크기 조정 50을 기준으로 함... 
	CDispOptMgr* pDispOpt = CDBDoc::GetDocPoint()->m_pDispOpt;
	COptSizeObjNames CSON;   
	CDispOptSizeObj* pGLabelFactor = pDispOpt->GetSize(CSON.m_LabelSymbol);
	ASSERT(pGLabelFactor);
	double dLoadSymbolSize = (double)pGLabelFactor->m_CurVal;
	//!@#$double dUnitSize = pDC->GetDeviceCaps(LOGPIXELSX)*0.12;
	double dUnitSize = pDC->GetDeviceCaps(LOGPIXELSX)*0.12*dLoadSymbolSize/50.0;

	// 동그라미 그릴 위치를 가지고 옴
	CArray<C3DPoint, C3DPoint&> aYieldPointIdxPos;
	GetYieldPointIdxPosAndPointSize(Vertex, ElemK, aYieldPointIdxPos);
	if(aYieldPointIdxPos.GetSize() == 0)
	{
		return;
	}
	
	// DrawPoint
	CBrush RankBrush,*pOldBrush;
	
	// MQC 16834 : Yield Point 색상이 Legend에 따라 변하는 문제
	// 이 점은 위치를 보여주는 용도지 값을 표현하는 건 아니므로 항상 초록색으로 표시(이해주 과장님 협의)
	//COLORREF PointColor = RGB(0, 0, 255);
	//RankBrush.CreateSolidBrush(m_pContourEngine->GetValueColor(PointColor));
	RankBrush.CreateSolidBrush(RGB(0,255,0));
	pOldBrush = (CBrush *)pDC->SelectObject(&RankBrush);

	for (int i = 0; i < aYieldPointIdxPos.GetSize(); i++)
	{
		DrawPoint(pDC, aYieldPointIdxPos[i], dUnitSize);
	}

	pDC->SelectObject(pOldBrush);
	RankBrush.DeleteObject(); 

	
}


void CForceEngine::DoBForcLineContour(CDC *pDC, CList <C3DPoint, C3DPoint> *Vertex, 
																			CArray <T_NODE_K, T_NODE_K> *VertexNode,T_ELEM_D &ElemData,
																			T_STRB_D &BForcVal)
{
	I_GPSModel						*gm=(I_GPSModel *) m_pGPSModel;
	int								i;
	double							dx, dy, dz, i_val, j_val;
	POSITION						pos=Vertex->GetHeadPosition();
	C3DPoint						p[5];
	CArray <C3DPoint, C3DPoint>		rvtx_list;
	CArray <double, double>			rval_list;

	p[0] = Vertex->GetNext(pos);
	p[4] = Vertex->GetNext(pos);

	// Composite Section의 Concrete부분 
	// I,J단의 Line을 Plotting하는 경우는 
	if(VertexNode->GetAt(0) == VertexNode->GetAt(1) )
	{
		double dValue;
		// I단 
		if(ElemData.elnod[0]==VertexNode->GetAt(0))
			dValue = CalcBForcValue(BForcVal, 0, I_NODE);
		// J단 
		else 
			dValue = CalcBForcValue(BForcVal, 3, J_NODE);
		if(gm->m_AnimEngine.m_bAnimateContour) 
			dValue = m_pContourEngine->GetSubFrameValue(dValue, gm->m_AnimEngine.GetAnimationFactor(TRUE));
		rvtx_list.Add(p[0]);  rval_list.Add(dValue);
		rvtx_list.Add(p[4]);  rval_list.Add(dValue);
		DrawContourLine(pDC, rvtx_list, rval_list,gm->m_DOPT.DR.nElemWire);
		rvtx_list.RemoveAll();
		rval_list.RemoveAll();
		return;  
	}

	dx = (p[4].x-p[0].x) / 4.0;
	dy = (p[4].y-p[0].y) / 4.0;
	dz = (p[4].z-p[0].z) / 4.0;
	for (i=1;i<4;i++) {
		p[i].x = p[0].x + dx*((double) i);
		p[i].y = p[0].y + dy*((double) i);
		p[i].z = p[0].z + dz*((double) i);
	}

	for (i=0;i<4;i++) {
		i_val = CalcBForcValue(BForcVal, i, I_NODE);
		j_val = CalcBForcValue(BForcVal, i, J_NODE);
		if (gm->m_AnimEngine.m_bAnimateContour) {
			i_val = m_pContourEngine->GetSubFrameValue(i_val, gm->m_AnimEngine.GetAnimationFactor(TRUE));
			j_val = m_pContourEngine->GetSubFrameValue(j_val, gm->m_AnimEngine.GetAnimationFactor(TRUE));
		}
		if (i_val > j_val) {
			rvtx_list.Add(p[i]);
			rval_list.Add(i_val);
			m_pContourEngine->GetRankVertices(p[i], p[i+1], i_val, j_val, rvtx_list, rval_list, NULL);
			rvtx_list.Add(p[i+1]);
			rval_list.Add(j_val);
		}
		else {
			rvtx_list.Add(p[i+1]);
			rval_list.Add(j_val);
			m_pContourEngine->GetRankVertices(p[i+1], p[i], j_val, i_val, rvtx_list, rval_list, NULL);
			rvtx_list.Add(p[i]);
			rval_list.Add(i_val);
		}

		//DrawContourLine(pDC, rvtx_list, rval_list);
		//DrawContourLine(pDC, rvtx_list, rval_list,gm->m_nMdLineWidth);
		//DrawContourLine(pDC, rvtx_list, rval_list,gm->m_LnWd.nElemWire);
		DrawContourLine(pDC, rvtx_list, rval_list,gm->m_DOPT.DR.nElemWire);

		rvtx_list.RemoveAll();
		rval_list.RemoveAll();
	}
}

void CForceEngine::DoBForcLineContourReal(CDC *pDC, CList <C3DPoint, C3DPoint> *Vertex,
																					T_STRB_D &BForcVal, CArray <double, double> *PosList)
{
	I_GPSModel						*gm=(I_GPSModel *) m_pGPSModel;
	double							i_val, j_val;
	C3DPoint						i_pos, j_pos;
	POSITION						pos=Vertex->GetHeadPosition();
	CArray <C3DPoint, C3DPoint>		rvtx_list;
	CArray <double, double>			rval_list;

	i_pos = Vertex->GetNext(pos);
	j_pos = Vertex->GetNext(pos);
	i_val = CalcBForcValuePos(BForcVal, PosList->GetAt(0));
	i_val = max(i_val, m_pContourEngine->m_MinRange);
	i_val = min(i_val, m_pContourEngine->m_MaxRange);
	j_val = CalcBForcValuePos(BForcVal, PosList->GetAt(1));
	j_val = max(j_val, m_pContourEngine->m_MinRange);
	j_val = min(j_val, m_pContourEngine->m_MaxRange);

	if (gm->m_AnimEngine.m_bAnimateContour) {
		i_val = m_pContourEngine->GetSubFrameValue(i_val, gm->m_AnimEngine.GetAnimationFactor(TRUE));
		j_val = m_pContourEngine->GetSubFrameValue(j_val, gm->m_AnimEngine.GetAnimationFactor(TRUE));
	}

	if (i_val > j_val) {
		rvtx_list.Add(i_pos);	rval_list.Add(i_val);
		m_pContourEngine->GetRankVertices(i_pos, j_pos, i_val, j_val, rvtx_list, rval_list, NULL);
		rvtx_list.Add(j_pos);	rval_list.Add(j_val);
	}
	else {
		rvtx_list.Add(j_pos);	rval_list.Add(j_val);
		m_pContourEngine->GetRankVertices(j_pos, i_pos, j_val, i_val, rvtx_list, rval_list, NULL);
		rvtx_list.Add(i_pos);	rval_list.Add(i_val);
	}

	//DrawContourLine(pDC, rvtx_list, rval_list);
	//DrawContourLine(pDC, rvtx_list, rval_list,gm->m_LnWd.nElemWire);
	DrawContourLine(pDC, rvtx_list, rval_list,gm->m_DOPT.DR.nElemWire);

	rvtx_list.RemoveAll();
	rval_list.RemoveAll();
}

void CForceEngine::DoBForcPolyContour(CDC *pDC,
																			CList<C3DPoint, C3DPoint> *Vertex,
																			CArray<BOOL, BOOL> *EdgeFlag,
																			CArray<T_NODE_K,T_NODE_K> *VertexNode,
																			T_ELEM_D &ElemData,
																			T_STRB_D &BForcVal)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	int			i, vertex_num=Vertex->GetCount();
	double	bforc_val[4], dx1, dy1, dz1, dx2, dy2, dz2;
	BOOL		ef[4];
	POSITION	pos;
	C3DPoint	p[4];
	CList<C3DPoint, C3DPoint>sub_vertex;

	//if(vertex_num!=4)return;  

	T_NODE_K NodeK[4]; 
	NodeK[0] = VertexNode->GetAt(0);
	NodeK[1] = VertexNode->GetAt(1);
	NodeK[2] = VertexNode->GetAt(2);
	if(vertex_num==4)
		NodeK[3] = VertexNode->GetAt(3);

	BOOL bAni= gm->m_AnimEngine.m_bAnimateContour;

	// polygon이 i단 쪽에 있을 경우
	if((NodeK[0]==NodeK[1]) &&  (NodeK[0]==NodeK[2]) && (NodeK[0]==ElemData.elnod[0])) 
	{
		for (i=0;i<vertex_num;i++) 
		{
			bforc_val[i] = CalcBForcValue(BForcVal, 0, I_NODE);
			if(bAni)  bforc_val[i]=m_pContourEngine->GetSubFrameValue(bforc_val[i], gm->m_AnimEngine.GetAnimationFactor(TRUE));
			ef[i] = EdgeFlag->GetAt(i);
		}
		DoSubPolyContour(pDC, bforc_val, Vertex, ef, TRUE);
	}
	// polygon이 j단 쪽에 있을 경우
	else if((NodeK[0]==NodeK[1]) && (NodeK[0]==NodeK[2]) && (NodeK[0]==ElemData.elnod[1])) 
	{
		for (i=0;i<vertex_num;i++) 
		{
			bforc_val[i] = CalcBForcValue(BForcVal, 3, J_NODE);
			if(bAni)  bforc_val[i] = m_pContourEngine->GetSubFrameValue(bforc_val[i], gm->m_AnimEngine.GetAnimationFactor(TRUE));
			ef[i] = EdgeFlag->GetAt(i);
		}
		DoSubPolyContour(pDC, bforc_val, Vertex, ef, TRUE);
	}
	// polygon이 i, j단에 걸쳐 있을 경우
	else 
	{
		if(vertex_num!=4) { ASSERT(0); return; }
		if(NodeK[0]==NodeK[1] && NodeK[2]==NodeK[3] )
		{
			pos = Vertex->GetHeadPosition();
			for(i=0;i<4;i++) p[i] = Vertex->GetNext(pos);
		}
		else if(NodeK[0]==NodeK[3] && NodeK[1]==NodeK[2] )
		{
			C3DPoint	tp[4];  
			pos = Vertex->GetHeadPosition();
			for(i=0;i<4;i++) tp[i] = Vertex->GetNext(pos);
			p[0] = tp[0];
			p[1] = tp[3];
			p[2] = tp[2];
			p[3] = tp[1];
		}
		else 
		{
			ASSERT(FALSE); 
			pos = Vertex->GetHeadPosition();
			for(i=0;i<4;i++) 
			{
				p[i] = Vertex->GetNext(pos);
			}
		}

		dx1 = (p[3].x-p[0].x) / 4.0;
		dy1 = (p[3].y-p[0].y) / 4.0;
		dz1 = (p[3].z-p[0].z) / 4.0;

		dx2 = (p[2].x-p[1].x) / 4.0;
		dy2 = (p[2].y-p[1].y) / 4.0;
		dz2 = (p[2].z-p[1].z) / 4.0;

		p[3] = p[0];
		p[2] = p[1];
		for (i=0;i<4;i++) 
		{
			p[0] = p[3];
			p[1] = p[2];
			p[3].x = p[0].x + dx1;
			p[3].y = p[0].y + dy1;
			p[3].z = p[0].z + dz1;
			p[2].x = p[1].x + dx2;
			p[2].y = p[1].y + dy2;
			p[2].z = p[1].z + dz2;
			sub_vertex.AddTail(p[0]);
			sub_vertex.AddTail(p[1]);
			sub_vertex.AddTail(p[2]);
			sub_vertex.AddTail(p[3]);

			bforc_val[0] = bforc_val[1] = CalcBForcValue(BForcVal, i, I_NODE);
			bforc_val[2] = bforc_val[3] = CalcBForcValue(BForcVal, i, J_NODE);
			if (gm->m_AnimEngine.m_bAnimateContour) {
				bforc_val[0] = m_pContourEngine->GetSubFrameValue(bforc_val[0], gm->m_AnimEngine.GetAnimationFactor(TRUE));
				bforc_val[1] = m_pContourEngine->GetSubFrameValue(bforc_val[1], gm->m_AnimEngine.GetAnimationFactor(TRUE));
				bforc_val[2] = m_pContourEngine->GetSubFrameValue(bforc_val[2], gm->m_AnimEngine.GetAnimationFactor(TRUE));
				bforc_val[3] = m_pContourEngine->GetSubFrameValue(bforc_val[3], gm->m_AnimEngine.GetAnimationFactor(TRUE));
			}

			if (i == 0)
				ef[0] = EdgeFlag->GetAt(0);
			else
				ef[0] = FALSE;
			ef[1] = EdgeFlag->GetAt(1);
			if (i == 3)
				ef[2] = EdgeFlag->GetAt(2);
			else
				ef[2] = FALSE;
			ef[3] = EdgeFlag->GetAt(3);

			DoSubPolyContour(pDC, bforc_val, &sub_vertex, ef, TRUE);
			sub_vertex.RemoveAll();
		}
	}
}

void CForceEngine::DoBForcPolyContourReal(CDC *pDC,
																					CList <C3DPoint, C3DPoint> *Vertex,
																					CArray <BOOL, BOOL> *EdgeFlag,
																					T_STRB_D &BForcVal,
																					CArray <double, double> *PosList)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	int			i, vertex_num=Vertex->GetCount();
	double		val[4];
	BOOL		ef[4];

	if (vertex_num == 3) {
	}
	else if (vertex_num == 4) 
	{
		for (i=0;i<4;i++) 
		{
			val[i] = CalcBForcValuePos(BForcVal, PosList->GetAt(i));
			val[i] = max(val[i], m_pContourEngine->m_MinRange);
			val[i] = min(val[i], m_pContourEngine->m_MaxRange);

			if(gm->m_AnimEngine.m_bAnimateContour)
				val[i] = m_pContourEngine->GetSubFrameValue(val[i], gm->m_AnimEngine.GetAnimationFactor(TRUE));
			ef[i] = EdgeFlag->GetAt(i);
		}
		DoSubPolyContour(pDC, val, Vertex, ef, TRUE);
	}

	//if (gm->m_RenderFlag == 3 || gm->m_RenderFlag == 2)
	if (gm->m_DOPT.DR.m_RenderFlag == 3 || gm->m_DOPT.DR.m_RenderFlag == 2)
		gm->GPSDrawPolygonEdge(pDC, Vertex, EdgeFlag);
}

////////////////////////////////////////////////////////////////////////////////////////
// Routines for Drawing Beam Member SFD/BMD                        ////////////////////
////////////////////////////////////////////////////////////////////////////////////////

void CForceEngine::DrawBeamSfdBmd(CDC *pDC)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	T_MIRE_K mkey;

	int			i, elem_num;
	BOOL		fl_bak=gm->m_DOPT.DR.m_bFrameLine;
	T_ELEM_D	elem_d;
	CArray <int, int>				type_list;
	CArray <GRE_Atom, GRE_Atom&>		atom_list;
	BOOL bEscapePressed = FALSE;
	m_mapSFDBMDMax.RemoveAll();

	CDC	*pdc=gm->m_pMyView->GetDC();
	m_dUnitLength = fabs(gm->m_pGPSCtrl->GetWorldLength(((double) pdc->GetDeviceCaps(LOGPIXELSX))/5.0));

	gm->m_pMyView->ReleaseDC(pdc);

	//KYE-HONG-20020321
	m_arSfdBmdOutPut.RemoveAll();
	m_arSfdBmdOutPutM.RemoveAll();  

	// SFD/BMD 이외의 그림은 Hidden을 끄고 그린다.
	gm->m_DOPT.DR.m_bFrameLine = TRUE;

	if(m_bDeformedShapeContour) 
	{
		if(gm->m_pDeformEngine == NULL) 
		{
			gm->m_DOPT.DR.m_bFrameLine = fl_bak;
			return;
		}
		type_list.Add(gm->m_MinOTID + OBJECT_TYPE_DEFORMED);

		// 변형된 모델에 Undeformed 모델을 같이 그릴 경우
		// Undeformed Shape이 Deformed Shape을 가려서 혼란스럽거나(Fill Mode일 경우)
		// 혹은 Deformed Shape에 가려져서 보이지 않게 되는 것을 피하기 위하여(Fill Mode가 아닐 경우)
		// Fill Mode가 아닐 경우에는 Undeformed Shape을 먼저 그리고
		// 그렇지 않을 경우엔 나중에 그린다.
		if(gm->m_DOPT.DR.m_bDrawInactive && m_bBSfdBmdLineOnly) 
		{
			int	rf_bak=gm->m_DOPT.DR.m_RenderFlag;
			gm->m_DOPT.DR.m_RenderFlag = 2;
			gm->GPSDrawOriginal(pDC, TRUE);
			gm->m_DOPT.DR.m_RenderFlag = rf_bak;
		}
	}
	else 
	{
		type_list.Add(gm->m_MinOTID + OBJECT_TYPE_ORIGINAL);
	}

	gm->m_pGPSCtrl->GetZSortedList(type_list, gm->m_EKeyListVisible_Mirror, atom_list);
	elem_num = atom_list.GetSize();
	for (i=0;i<elem_num;i++) 
	{
		if(gm->m_pGPSCtrl->WatchEscKeyPress()) return;

		if(gm->m_pGPSCtrl->IsZoomAllState() ||
			gm->m_pGPSCtrl->IsObjectInClientWindow(atom_list[i].m_OType, atom_list[i].m_OKey)) 
		{
			mkey.keymap = atom_list[i].m_OKey;
			if(!m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d))continue;
			BOOL bTruss = m_pDoc->m_pAttrCtrl->IsTruss(elem_d.eltyp) && this->IsBForcWithTForc();
			BOOL bBeam  = m_pDoc->m_pAttrCtrl->IsBeam(elem_d.eltyp) ;
			if(IsBForcWithTForc() && m_bBForcOnlyTForc)bBeam = FALSE; //Truss Only인경우 Beam은 출력하지 않음 
			if(gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey) && !bEscapePressed)
			{
				if(m_bDeformedShapeContour)
				{
					if(bBeam || bTruss) gm->m_pDeformEngine->DrawDeformedElement(pDC, atom_list[i].m_OKey);
					else						    gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, atom_list[i].m_OKey);
				}
				else
				{
					if(bBeam || bTruss) gm->GPSDrawElement(pDC, atom_list[i].m_OKey);
					else						    gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
				}
				if(bBeam || bTruss) DoBeamElementSfdBmd(pDC, atom_list[i].m_OKey,bTruss);
			}
			else
			{
				if(m_bDeformedShapeContour)
					gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, atom_list[i].m_OKey);
				else
					gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
			}
		}
	}

	// By member 체크온시 데이타를 멤버별로 정리
	if(m_bBsfdBmdByMember)
	{
		MakeSfdBmdDataListByMember(m_arSfdBmdOutPut,  FALSE);
		MakeSfdBmdDataListByMember(m_arSfdBmdOutPutM, TRUE);
	}

	//KYE-HONG-20020321
	//OutPutValue 출력시.. 그림 뒤에 
	//가리는 문제를 해결하기 위해 
	BOOL bGrpFltMode=gm->m_pGPSCtrl->IsGroupFilterMode();
	for(i=0; i<m_arSfdBmdOutPut.GetSize(); i++)
	{
		if(bGrpFltMode)
		{
			if(!gm->m_pDispFilter->IsExistEKey(m_arSfdBmdOutPut[i].EKey))
				continue;
		}
		OutputSfdBmdNumber(pDC, m_arSfdBmdOutPut[i].EKey, m_arSfdBmdOutPut[i].StrbD, m_arSfdBmdOutPut[i].Pos, m_arSfdBmdOutPut[i].nComp, m_arSfdBmdOutPut[i].dMinMaxVal);
	}
	for(i=0; i<m_arSfdBmdOutPutM.GetSize(); i++)
	{
		if(bGrpFltMode)
		{
			if(!gm->m_pDispFilter->IsExistEKey(m_arSfdBmdOutPutM[i].EKey))
				continue;
		}
		OutputSfdBmdNumber(pDC, m_arSfdBmdOutPutM[i].EKey, m_arSfdBmdOutPutM[i].StrbD, m_arSfdBmdOutPutM[i].Pos, m_arSfdBmdOutPutM[i].nComp, m_arSfdBmdOutPutM[i].dMinMaxVal);
	}
	m_arSfdBmdOutPut.RemoveAll();
	m_arSfdBmdOutPutM.RemoveAll(); 

	// 변형된 모델에 Undeformed 모델을 같이 그릴 경우
	if (m_bDeformedShapeContour && gm->m_DOPT.DR.m_bDrawInactive && !m_bBSfdBmdLineOnly && !bEscapePressed) 
	{
		int	rf_bak=gm->m_DOPT.DR.m_RenderFlag;
		gm->m_DOPT.DR.m_RenderFlag = 2;
		gm->GPSDrawOriginal(pDC, TRUE);
		gm->m_DOPT.DR.m_RenderFlag = rf_bak;
	}
	gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}

void CForceEngine::DoBeamElementSfdBmd(CDC *pDC, unsigned int ekey,BOOL bTruss)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	T_MIRE_K mkey;
	mkey.keymap = ekey;

	int		    poly_num;
	double		local_vector[3][3];
	T_STRB_D	bforc_d, bforc_dm;
	double    dMnMxVal[2];

	POSITION	pos;
	C3DPoint	pnt[2], node_i, node_j, *txt_pnt, *txt_pntm;
	CArray<BOOL, BOOL>				ef_list;
	CArray<BOOL, BOOL>				rect_flag;
	CArray<double, double &>	val_list;
	CArray<C3DPoint,C3DPoint&>vtx_list;
	CArray<CList<C3DPoint,C3DPoint> *, CList <C3DPoint, C3DPoint> *>polygon_list;

	if((gm->m_pDeformEngine==NULL) || (m_pContourEngine==NULL))return;

	if(IsMinMaxDiagram()) 
	{
		if(!GetBeamForce(mkey.key.elem_k, bforc_d) || !GetBeamForceMin(mkey.key.elem_k, bforc_dm))return;
	}
	else 
	{
		if(!GetBeamForce(mkey.key.elem_k, bforc_d))return;
	}

	if(IsPossibleExactSfdBmdMode() && !bTruss) // Beam일때만 가능함 
	{
		if(!gm->m_pBeamDiagram)gm->m_pBeamDiagram = new CBeamDiagram;
		int nDiv = 0.7*(m_pDoc->calcLAVElem(mkey.key.elem_k)/m_dUnitLength); 
		if(nDiv<=4) nDiv = 4;if(nDiv>4 && nDiv<=8) nDiv = 8;// 4등분의 배수로 만들자.
		if(nDiv>280) nDiv = 280; if(!m_bVerticalLineFill) nDiv = 12;
		if (!gm->m_pBeamDiagram->MakeBeamSFBM(mkey.key.elem_k, gm->m_LoadCombi, nDiv))
		{
			gm->SelectLoad();
			return;
		}
		gm->SelectLoad();
	}
	m_pDoc->calcFrameLocalVector(mkey.key.elem_k, local_vector);

	if(m_bDeformedShapeContour)
		gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, NULL, NULL);
	else
		gm->GetShapeElement(ekey, polygon_list, NULL, NULL, NULL);

	poly_num = polygon_list.GetSize();
	if((poly_num!=1) || (polygon_list[0]->GetCount()!=2))return;

	if(gm->m_DOPT.TX.m_bOutputNumber) 
	{
		txt_pnt   = new C3DPoint[4];
		txt_pntm  = new C3DPoint[4];
	}
	else 
	{
		txt_pnt   = NULL;
		txt_pntm  = NULL;
	}

	pos = polygon_list[0]->GetHeadPosition();
	pnt[0] = polygon_list[0]->GetNext(pos);
	pnt[1] = polygon_list[0]->GetNext(pos);

	CArray<T_SFDBMD_OUTVAL_D,T_SFDBMD_OUTVAL_D&> arOutVal; 
	T_SFDBMD_OUTVAL_D OutVal;

	switch (m_BForcComponent) 
	{
	case BFORC_COMPONENT_MY:
	case BFORC_COMPONENT_MZ:
	case BFORC_COMPONENT_FY:
	case BFORC_COMPONENT_FZ:
	case BFORC_COMPONENT_FX:
	case BFORC_COMPONENT_MX:
	case BFORC_COMPONENT_W:
	case BFORC_COMPONENT_MT:
	case BFORC_COMPONENT_MW:
		GetOffsetedPoint(mkey.key.elem_k,pnt[0],pnt[1],node_i,node_j,m_BForcComponent);
		BSfdBmdMakePolygon(bforc_d, m_BForcComponent, local_vector,
			node_i, node_j, vtx_list, val_list, ef_list, rect_flag, txt_pnt, mkey.key.elem_k, dMnMxVal,bTruss);
		if(txt_pnt)AddBSfdBmdOutputData(mkey.key.elem_k,txt_pnt,bforc_d,dMnMxVal,m_BForcComponent,0);

		if(IsMinMaxDiagram())
		{
			BSfdBmdMakePolygon(bforc_dm, m_BForcComponent, local_vector,
				node_i, node_j, vtx_list, val_list, ef_list, rect_flag, txt_pntm, mkey.key.elem_k, dMnMxVal,bTruss);
			if(txt_pntm)AddBSfdBmdOutputData(mkey.key.elem_k,txt_pntm,bforc_dm,dMnMxVal,m_BForcComponent,1);
		}
		break;

	case BFORC_COMPONENT_FYZ:
		if(IsFar(local_vector[1], local_vector[2])) 
		{
			GetOffsetedPoint(mkey.key.elem_k,pnt[0],pnt[1],node_i,node_j,BFORC_COMPONENT_FY);
			BSfdBmdMakePolygon(bforc_d, BFORC_COMPONENT_FY, local_vector,
				node_i, node_j, vtx_list, val_list, ef_list, rect_flag, txt_pnt, mkey.key.elem_k,dMnMxVal,bTruss);
			//if(txt_pnt)AddBSfdBmdOutputData(mkey.key.elem_k,txt_pnt,bforc_d,dMnMxVal,BFORC_COMPONENT_FY,0);
			if(txt_pnt)
			{
				GetBSfdBmdOutputData(OutVal,mkey.key.elem_k,txt_pnt,bforc_d,dMnMxVal,BFORC_COMPONENT_FY,0);
				arOutVal.Add(OutVal);
			}
			if(IsMinMaxDiagram())
			{
				BSfdBmdMakePolygon(bforc_dm, BFORC_COMPONENT_FY, local_vector,
					node_i, node_j, vtx_list, val_list, ef_list, rect_flag, txt_pntm, mkey.key.elem_k,dMnMxVal,bTruss);
				if(txt_pntm)
				{
					//AddBSfdBmdOutputData(mkey.key.elem_k,txt_pntm,bforc_dm,dMnMxVal,BFORC_COMPONENT_FY,1);
					GetBSfdBmdOutputData(OutVal,mkey.key.elem_k,txt_pntm,bforc_dm,dMnMxVal,BFORC_COMPONENT_FY,1);
					arOutVal.Add(OutVal);
				}
			}

			GetOffsetedPoint(mkey.key.elem_k,pnt[0],pnt[1],node_i,node_j,BFORC_COMPONENT_FZ);

			BSfdBmdMakePolygon(bforc_d, BFORC_COMPONENT_FZ, local_vector,
				node_i, node_j, vtx_list, val_list, ef_list, rect_flag, txt_pnt, mkey.key.elem_k,dMnMxVal,bTruss);
			if(txt_pnt)
			{
				//AddBSfdBmdOutputData(mkey.key.elem_k,txt_pnt,bforc_d,dMnMxVal,BFORC_COMPONENT_FZ,0);
				GetBSfdBmdOutputData(OutVal,mkey.key.elem_k,txt_pnt,bforc_d,dMnMxVal,BFORC_COMPONENT_FZ,0);
				arOutVal.Add(OutVal);
			}

			if(IsMinMaxDiagram())  
			{
				BSfdBmdMakePolygon(bforc_dm, BFORC_COMPONENT_FZ, local_vector,
					node_i, node_j, vtx_list, val_list, ef_list, rect_flag, txt_pntm, mkey.key.elem_k,dMnMxVal,bTruss);
				if(txt_pntm)
				{
					//AddBSfdBmdOutputData(mkey.key.elem_k,txt_pntm,bforc_dm,dMnMxVal,BFORC_COMPONENT_FZ,1);
					GetBSfdBmdOutputData(OutVal,mkey.key.elem_k,txt_pntm,bforc_dm,dMnMxVal,BFORC_COMPONENT_FZ,1);
					arOutVal.Add(OutVal);
				}
			}
		}
		else 
		{
			GetOffsetedPoint(mkey.key.elem_k,pnt[0],pnt[1],node_i,node_j,BFORC_COMPONENT_FZ);
			BSfdBmdMakePolygon(bforc_d, BFORC_COMPONENT_FZ, local_vector,
				node_i, node_j, vtx_list, val_list, ef_list, rect_flag, txt_pnt, mkey.key.elem_k,dMnMxVal,bTruss);
			if(txt_pnt)
			{
				//AddBSfdBmdOutputData(mkey.key.elem_k,txt_pnt,bforc_d,dMnMxVal,BFORC_COMPONENT_FZ,0);
				GetBSfdBmdOutputData(OutVal,mkey.key.elem_k,txt_pnt,bforc_d,dMnMxVal,BFORC_COMPONENT_FZ,0);
				arOutVal.Add(OutVal);
			}
			if(IsMinMaxDiagram()) 
			{
				BSfdBmdMakePolygon(bforc_dm, BFORC_COMPONENT_FZ, local_vector,
					node_i, node_j, vtx_list, val_list, ef_list, rect_flag, txt_pntm, mkey.key.elem_k,dMnMxVal,bTruss);
				if(txt_pntm)
				{
					//AddBSfdBmdOutputData(mkey.key.elem_k,txt_pntm,bforc_dm,dMnMxVal,BFORC_COMPONENT_FZ,1);
					GetBSfdBmdOutputData(OutVal,mkey.key.elem_k,txt_pntm,bforc_dm,dMnMxVal,BFORC_COMPONENT_FZ,1);
					arOutVal.Add(OutVal);
				}
			}

			GetOffsetedPoint(mkey.key.elem_k,pnt[0],pnt[1],node_i,node_j,BFORC_COMPONENT_FY);

			BSfdBmdMakePolygon(bforc_d, BFORC_COMPONENT_FY, local_vector,
				node_i, node_j, vtx_list, val_list, ef_list, rect_flag, txt_pnt, mkey.key.elem_k,dMnMxVal,bTruss);
			if(txt_pnt)
			{
				//AddBSfdBmdOutputData(mkey.key.elem_k,txt_pnt,bforc_d,dMnMxVal,BFORC_COMPONENT_FY,0);
				GetBSfdBmdOutputData(OutVal,mkey.key.elem_k,txt_pnt,bforc_d,dMnMxVal,BFORC_COMPONENT_FY,0);
				arOutVal.Add(OutVal);
			}
			if(IsMinMaxDiagram())
			{
				BSfdBmdMakePolygon(bforc_dm, BFORC_COMPONENT_FY, local_vector,
					node_i, node_j, vtx_list, val_list, ef_list, rect_flag, txt_pntm, mkey.key.elem_k,dMnMxVal,bTruss);
				if(txt_pntm)
				{
					//AddBSfdBmdOutputData(mkey.key.elem_k,txt_pntm,bforc_dm,dMnMxVal,BFORC_COMPONENT_FY,1);
					GetBSfdBmdOutputData(OutVal,mkey.key.elem_k,txt_pntm,bforc_dm,dMnMxVal,BFORC_COMPONENT_FY,1);
					arOutVal.Add(OutVal);
				}
			}
		}
		if(arOutVal.GetSize())
		{
			T_SFDBMD_OUTVAL_D OutValAbs;
			if(CalcAbsMax(arOutVal,OutValAbs))
				m_arSfdBmdOutPut.Add(OutValAbs);
		}
		break;

	case BFORC_COMPONENT_MYZ:
		if(IsFar(local_vector[1], local_vector[2])) 
		{
			GetOffsetedPoint(mkey.key.elem_k,pnt[0],pnt[1],node_i,node_j,BFORC_COMPONENT_MZ);
			BSfdBmdMakePolygon(bforc_d, BFORC_COMPONENT_MZ, local_vector,
				node_i, node_j, vtx_list, val_list, ef_list, rect_flag, txt_pnt, mkey.key.elem_k,dMnMxVal,bTruss);
			if(txt_pnt)
			{
				//AddBSfdBmdOutputData(mkey.key.elem_k,txt_pnt,bforc_d,dMnMxVal,BFORC_COMPONENT_MZ,0);
				GetBSfdBmdOutputData(OutVal,mkey.key.elem_k,txt_pnt,bforc_d,dMnMxVal,BFORC_COMPONENT_MZ,0);
				arOutVal.Add(OutVal);
			}
			if(IsMinMaxDiagram())
			{
				BSfdBmdMakePolygon(bforc_dm, BFORC_COMPONENT_MZ, local_vector,
					node_i, node_j, vtx_list, val_list, ef_list, rect_flag, txt_pntm, mkey.key.elem_k,dMnMxVal,bTruss);
				if(txt_pntm)
				{
					//AddBSfdBmdOutputData(mkey.key.elem_k,txt_pntm,bforc_dm,dMnMxVal,BFORC_COMPONENT_MZ,1);
					GetBSfdBmdOutputData(OutVal,mkey.key.elem_k,txt_pntm,bforc_dm,dMnMxVal,BFORC_COMPONENT_MZ,1);
					arOutVal.Add(OutVal);
				}
			}

			GetOffsetedPoint(mkey.key.elem_k,pnt[0],pnt[1],node_i,node_j,BFORC_COMPONENT_MY);

			BSfdBmdMakePolygon(bforc_d, BFORC_COMPONENT_MY, local_vector,
				node_i, node_j, vtx_list, val_list, ef_list, rect_flag, txt_pnt, mkey.key.elem_k,dMnMxVal,bTruss);
			if(txt_pnt)
			{
				//AddBSfdBmdOutputData(mkey.key.elem_k,txt_pnt,bforc_d,dMnMxVal,BFORC_COMPONENT_MY,0);
				GetBSfdBmdOutputData(OutVal,mkey.key.elem_k,txt_pnt,bforc_d,dMnMxVal,BFORC_COMPONENT_MY,0);
				arOutVal.Add(OutVal);
			}
			if(IsMinMaxDiagram())
			{
				BSfdBmdMakePolygon(bforc_dm, BFORC_COMPONENT_MY, local_vector,
					node_i, node_j, vtx_list, val_list, ef_list, rect_flag, txt_pntm, mkey.key.elem_k,dMnMxVal,bTruss);
				if(txt_pntm)
				{
					//AddBSfdBmdOutputData(mkey.key.elem_k,txt_pntm,bforc_dm,dMnMxVal,BFORC_COMPONENT_MY,1);
					GetBSfdBmdOutputData(OutVal,mkey.key.elem_k,txt_pntm,bforc_dm,dMnMxVal,BFORC_COMPONENT_MY,1);
					arOutVal.Add(OutVal);
				}
			}
		}
		else 
		{
			GetOffsetedPoint(mkey.key.elem_k,pnt[0],pnt[1],node_i,node_j,BFORC_COMPONENT_MY);
			BSfdBmdMakePolygon(bforc_d, BFORC_COMPONENT_MY, local_vector,
				node_i, node_j, vtx_list, val_list, ef_list, rect_flag, txt_pnt, mkey.key.elem_k,dMnMxVal,bTruss);
			if(txt_pnt)
			{
				//AddBSfdBmdOutputData(mkey.key.elem_k,txt_pnt,bforc_d,dMnMxVal,BFORC_COMPONENT_MY,0);
				GetBSfdBmdOutputData(OutVal,mkey.key.elem_k,txt_pnt,bforc_d,dMnMxVal,BFORC_COMPONENT_MY,0);
				arOutVal.Add(OutVal);
			}
			if(IsMinMaxDiagram())
			{
				BSfdBmdMakePolygon(bforc_dm, BFORC_COMPONENT_MY, local_vector,
					node_i, node_j, vtx_list, val_list, ef_list, rect_flag, txt_pntm, mkey.key.elem_k,dMnMxVal,bTruss);
				if(txt_pntm)
				{
					//AddBSfdBmdOutputData(mkey.key.elem_k,txt_pntm,bforc_dm,dMnMxVal,BFORC_COMPONENT_MY,1);
					GetBSfdBmdOutputData(OutVal,mkey.key.elem_k,txt_pntm,bforc_dm,dMnMxVal,BFORC_COMPONENT_MY,1);
					arOutVal.Add(OutVal);
				}
			}
			GetOffsetedPoint(mkey.key.elem_k,pnt[0],pnt[1],node_i,node_j,BFORC_COMPONENT_MZ);

			BSfdBmdMakePolygon(bforc_d, BFORC_COMPONENT_MZ, local_vector,
				node_i, node_j, vtx_list, val_list, ef_list, rect_flag, txt_pnt, mkey.key.elem_k,dMnMxVal,bTruss);
			if(txt_pnt)
			{
				//AddBSfdBmdOutputData(mkey.key.elem_k,txt_pnt,bforc_d,dMnMxVal,BFORC_COMPONENT_MZ,0);
				GetBSfdBmdOutputData(OutVal,mkey.key.elem_k,txt_pnt,bforc_d,dMnMxVal,BFORC_COMPONENT_MZ,0);
				arOutVal.Add(OutVal);
			}
			if(IsMinMaxDiagram())
			{
				BSfdBmdMakePolygon(bforc_dm, BFORC_COMPONENT_MZ, local_vector,
					node_i, node_j, vtx_list, val_list, ef_list, rect_flag, txt_pntm, mkey.key.elem_k,dMnMxVal,bTruss);
				if(txt_pntm)
				{
					//AddBSfdBmdOutputData(mkey.key.elem_k,txt_pntm,bforc_dm,dMnMxVal,BFORC_COMPONENT_MZ,1);
					GetBSfdBmdOutputData(OutVal,mkey.key.elem_k,txt_pntm,bforc_dm,dMnMxVal,BFORC_COMPONENT_MZ,1);
					arOutVal.Add(OutVal);
				}
			}
		}
		if(arOutVal.GetSize())
		{
			T_SFDBMD_OUTVAL_D OutValAbs;
			if(CalcAbsMax(arOutVal,OutValAbs))
				m_arSfdBmdOutPut.Add(OutValAbs);
		}
		break;
	}
	gm->GPS_XGL_Begin_Diagram(mkey.key.elem_k);
	DoBSfdBmdContour(pDC, vtx_list, val_list, ef_list, rect_flag);
	if(polygon_list.GetSize() == 1)
	{
		DoBForcYieldPointIdxContour(pDC, polygon_list[0], mkey.key.elem_k);
	}  
	gm->GPS_XGL_End_Elem();

	vtx_list.RemoveAll();
	val_list.RemoveAll();
	ef_list.RemoveAll();
	rect_flag.RemoveAll();

	/*
	T_SFDBMD_OUTVAL_D OutVal;
	if(gm->m_DOPT.TX.m_bOutputNumber) 
	{
	if(txt_pnt)
	//OutputSfdBmdNumber(pDC, mkey.key.elem_k, bforc_d, txt_pnt);//KYE-HONG-20020321
	{
	OutVal.Pos[0]= txt_pnt[0];
	OutVal.Pos[1]= txt_pnt[1];
	OutVal.Pos[2]= txt_pnt[2];
	OutVal.Pos[3]= txt_pnt[3];
	OutVal.EKey = mkey.key.elem_k;
	OutVal.Val  = bforc_d;
	OutVal.dMinMaxVal[0] = dMnMxVal[0];
	OutVal.dMinMaxVal[1] = dMnMxVal[1];
	m_arSfdBmdOutPut.Add(OutVal);//KYE-HONG-20020321
	}
	if(txt_pntm && (gm->m_LoadMinMaxType==LOADTYPE_ALL))
	//OutputSfdBmdNumber(pDC, mkey.key.elem_k, bforc_dm, txt_pntm);
	{
	OutVal.Pos[0]= txt_pntm[0];
	OutVal.Pos[1]= txt_pntm[1];
	OutVal.Pos[2]= txt_pntm[2];
	OutVal.Pos[3]= txt_pntm[3];
	OutVal.EKey = mkey.key.elem_k;
	OutVal.Val  = bforc_dm;
	OutVal.dMinMaxVal[0] = dMnMxVal2[0];
	OutVal.dMinMaxVal[1] = dMnMxVal2[1];
	m_arSfdBmdOutPutM.Add(OutVal);
	}
	}
	*/
	FreeMemoryPolyList(&polygon_list); 

	if(txt_pnt) delete []txt_pnt;
	if(txt_pntm)delete []txt_pntm;
}

BOOL CForceEngine::IsMinMaxDiagram()
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	return gm->m_LoadMinMaxType == LOADTYPE_ALL && m_bMaxMinDgrm;
}

/*
C3DPoint  Pos[4];
T_STRB_D  StrbD;
T_ELEM_K  EKey;
int       nComp;
double    dMinMaxVal[2];
*/

BOOL CForceEngine::CalcAbsMax(CArray<T_SFDBMD_OUTVAL_D,T_SFDBMD_OUTVAL_D&> &arOutVal,T_SFDBMD_OUTVAL_D& OutValAbs)
{
	if(!arOutVal.GetSize())return FALSE; 
	int i,j; 

	OutValAbs.nComp = arOutVal[0].nComp;
	OutValAbs.EKey  = arOutVal[0].EKey;
	// 절대값 비교이기 때문 
	OutValAbs.StrbD.Initialize();
	OutValAbs.dMinMaxVal[0]=0.0;
	OutValAbs.dMinMaxVal[1]=0.0;

	for(i=0; i<arOutVal.GetSize(); i++)
	{
		if(m_bBForcOutputMinMax)
		{
			for(j=0; j<2; j++)
			{
				if(i==0)
				{
					OutValAbs.Pos[j]        = arOutVal[i].Pos[j];
					OutValAbs.dMinMaxVal[j] = arOutVal[i].dMinMaxVal[j];
				}
				else
				{
					if( fabs(arOutVal[i].dMinMaxVal[j])> fabs(OutValAbs.dMinMaxVal[j]) )
					{
						OutValAbs.Pos[j]        = arOutVal[i].Pos[j];
						OutValAbs.dMinMaxVal[j] = arOutVal[i].dMinMaxVal[j];
					}
				}
			}
		}
		else if(m_bBForcOutputMax) 
		{
			if(i==0)
			{
				OutValAbs.Pos[1]        = arOutVal[i].Pos[1];
				OutValAbs.dMinMaxVal[1] = arOutVal[i].dMinMaxVal[1];
			}
			else
			{
				if( fabs(arOutVal[i].dMinMaxVal[1])> fabs(OutValAbs.dMinMaxVal[1]) )
				{
					OutValAbs.Pos[1]        = arOutVal[i].Pos[1];
					OutValAbs.dMinMaxVal[1] = arOutVal[i].dMinMaxVal[1];
				}
			}
		}
		else
		{
			double dArrVal,dAbsMaxVal;
			if(m_bBForcOutputI) 
			{
				dAbsMaxVal  = CalcBForcValue(OutValAbs.StrbD, OutValAbs.nComp, 0, I_NODE);
				dArrVal     = CalcBForcValue(arOutVal[i].StrbD, arOutVal[i].nComp, 0, I_NODE);
				if(i==0)
				{
					SetBForcValue(dArrVal,OutValAbs.StrbD, OutValAbs.nComp, 0, I_NODE);
					OutValAbs.Pos[0] = arOutVal[i].Pos[0];
				}
				else
				{
					if(fabs(dArrVal)>fabs(dAbsMaxVal))
					{
						SetBForcValue(dArrVal,OutValAbs.StrbD, OutValAbs.nComp, 0, I_NODE);
						OutValAbs.Pos[0] = arOutVal[i].Pos[0];
					}
				}
			}
			if(m_bBForcOutputJ) 
			{

				dAbsMaxVal  = CalcBForcValue(OutValAbs.StrbD, OutValAbs.nComp, 3, J_NODE);
				dArrVal     = CalcBForcValue(arOutVal[i].StrbD, arOutVal[i].nComp, 3, J_NODE);
				if(i==0)
				{
					SetBForcValue(dArrVal,OutValAbs.StrbD, OutValAbs.nComp, 3, J_NODE);
					OutValAbs.Pos[2] = arOutVal[i].Pos[2];
				}
				else
				{
					if(fabs(dArrVal)>fabs(dAbsMaxVal))
					{
						SetBForcValue(dArrVal,OutValAbs.StrbD, OutValAbs.nComp, 3, J_NODE);
						OutValAbs.Pos[2] = arOutVal[i].Pos[2];
					}
				}
			}
			if(m_bBForcOutputC) 
			{
				dAbsMaxVal  = CalcBForcValue(OutValAbs.StrbD, OutValAbs.nComp, 1, J_NODE);
				dArrVal     = CalcBForcValue(arOutVal[i].StrbD, arOutVal[i].nComp, 1, J_NODE);
				if(i==0)
				{
					SetBForcValue(dArrVal,OutValAbs.StrbD, OutValAbs.nComp, 1, J_NODE);
					OutValAbs.Pos[1] = arOutVal[i].Pos[1];
				}
				else 
				{
					if(fabs(dArrVal)>fabs(dAbsMaxVal))
					{
						SetBForcValue(dArrVal,OutValAbs.StrbD, OutValAbs.nComp, 1, J_NODE);
						OutValAbs.Pos[1] = arOutVal[i].Pos[1];
					}
				}
			}
		}
	}
	return TRUE; 
}

BOOL CForceEngine::GetBSfdBmdOutputData(T_SFDBMD_OUTVAL_D &OutVal,T_ELEM_K ElemK,C3DPoint *pTxtPt,T_STRB_D &StrbD,double *pMnMxVal,int nComp,int nType)
{
	I_GPSModel  *gm=(I_GPSModel *)m_pGPSModel;
	if(!gm->m_DOPT.TX.m_bOutputNumber)return FALSE; 
	OutVal.Pos[0] = pTxtPt[0];
	OutVal.Pos[1] = pTxtPt[1];
	OutVal.Pos[2] = pTxtPt[2];
	OutVal.Pos[3] = pTxtPt[3];
	OutVal.EKey   = ElemK;
	OutVal.StrbD  = StrbD;
	OutVal.nComp  = nComp;
	OutVal.dMinMaxVal[0] = pMnMxVal[0];
	OutVal.dMinMaxVal[1] = pMnMxVal[1];
	return TRUE; 
}

void CForceEngine::AddBSfdBmdOutputData(T_ELEM_K ElemK,C3DPoint *pTxtPt,T_STRB_D &StrbD,double *pMnMxVal,int nComp,int nType)
{

	T_SFDBMD_OUTVAL_D OutVal;
	if(GetBSfdBmdOutputData(OutVal,ElemK,pTxtPt,StrbD,pMnMxVal,nComp,nType))
	{
		if(nType==0)m_arSfdBmdOutPut.Add(OutVal);
		else        m_arSfdBmdOutPutM.Add(OutVal);
	}
}

void CForceEngine::GetOffsetedPoint(T_ELEM_K ekey,C3DPoint Org_node_i, C3DPoint Org_node_j,
																		C3DPoint &node_i, C3DPoint &node_j,int nComp)
{
	I_GPSModel					*gm=(I_GPSModel *) m_pGPSModel;

	T_CFMO_D						DataCFMO;


	/////////////////////////////////////////////////////////////////////////////////////////////////
	// Offset 설정 
	// [Xi,Xj,Zi,Zj,Yi,Yj] // 이 순서대로 사용하였음.

	if(m_pDoc->m_pPostCtrl->GetCfmo(ekey, DataCFMO))
	{
		DataCFMO.dOffset[0] = 0.0;
		DataCFMO.dOffset[1] = 0.0;

		//nOffsetType   0: global offset
		//nOffsetType   1: building control
		//nOffsetType   2: local offset
		//nOffsetType   3: Section offset

		//if(DataCFMO.nOffsetType == 0) // Type 0일 경우 무시한다.
		if(DataCFMO.nOffsetType==0 || DataCFMO.nOffsetType==3 ) // Type 0일 경우 무시한다.
		{
			DataCFMO.dOffset[2] = 0.0;
			DataCFMO.dOffset[3] = 0.0;
			DataCFMO.dOffset[4] = 0.0;
			DataCFMO.dOffset[5] = 0.0;
		}
	}
	else
	{
		DataCFMO.Initialize();
		DataCFMO.dLength = m_pDoc->calcLAVElem(ekey);         // 빔의 길이 
	}

	double dZeroLength = 1.0e-8;
	double dLength = CMathFunc::mathLength(Org_node_i.x, Org_node_i.y, Org_node_i.z, Org_node_j.x, Org_node_j.y, Org_node_j.z);
	switch(nComp)
	{
	case BFORC_COMPONENT_FX:
	case BFORC_COMPONENT_MX:
	case BFORC_COMPONENT_W:
	case BFORC_COMPONENT_MT:
	case BFORC_COMPONENT_MW:
		node_i = Org_node_i;
		node_j = Org_node_j;
		break;
	case BFORC_COMPONENT_MZ:
	case BFORC_COMPONENT_FY:
		if(fabs(DataCFMO.dOffset[4]) > dLength || fabs(fabs(DataCFMO.dOffset[4])-dLength) <= dZeroLength)   node_i = Org_node_j;
		else CUtilFuncs::GetInnerLinePoint2(DataCFMO.dOffset[4], DataCFMO.dLength, Org_node_i, Org_node_j, node_i);
		if(fabs(DataCFMO.dOffset[5]) > dLength || fabs(fabs(DataCFMO.dOffset[5])-dLength) <= dZeroLength)   node_j = Org_node_i;
		else CUtilFuncs::GetInnerLinePoint2(DataCFMO.dLength-DataCFMO.dOffset[5], DataCFMO.dLength, Org_node_i, Org_node_j, node_j);
		break;

	case BFORC_COMPONENT_MY:
	case BFORC_COMPONENT_FZ:
		if(fabs(DataCFMO.dOffset[2]) > dLength || fabs(fabs(DataCFMO.dOffset[2])-dLength) <= dZeroLength)   node_i = Org_node_j;
		else CUtilFuncs::GetInnerLinePoint2(DataCFMO.dOffset[2], DataCFMO.dLength, Org_node_i, Org_node_j, node_i);
		if(fabs(DataCFMO.dOffset[3]) > dLength || fabs(fabs(DataCFMO.dOffset[3])-dLength) <= dZeroLength)   node_j = Org_node_i;
		else CUtilFuncs::GetInnerLinePoint2(DataCFMO.dLength-DataCFMO.dOffset[3], DataCFMO.dLength, Org_node_i, Org_node_j, node_j);
		break;
	}
}


/*
void CForceEngine::BSfdBmdMakePolygon(T_STRB_D &bforc_d, int component, double local_vector[][3],
C3DPoint &node_i, C3DPoint &node_j,
CArray <C3DPoint, C3DPoint &> &vtx_list,
CArray <double, double &> &val_list,
CArray <BOOL, BOOL> &ef_list,
CArray <BOOL, BOOL> &rect_flag,
C3DPoint *txt_pnt,T_ELEM_K ElemKey,double *pMnMxVal)
{
if(pMnMxVal){ pMnMxVal[0]=0;  pMnMxVal[1]=0;}

if(IsPossibleExactSfdBmdMode()) 
{
BSfdBmdMakeExactPolygon(component, local_vector, node_i, node_j,
vtx_list, val_list, ef_list, rect_flag, txt_pnt, ElemKey,pMnMxVal);
return;
}

DECLARE_GPSMD();    
//I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

int			i, j, sl_num;
double	val_i, val_j;
double  dVal[2];
double  ulen, udist, uval, ldist, vdist;
double  sub_ival, sub_jval, sub_mval;
double  dMaxVal=-DBL_MAX,dMinVal=DBL_MAX;
double  dAbsMax=0;

C3DPoint	ps, pss, pe, pee;
C3DPoint  sub_ps, sub_pss, sub_pe, sub_pee, sub_pm;

CDC	*pdc=gm->m_pMyView->GetDC();
ulen = fabs(gm->m_pGPSCtrl->GetWorldLength(((double) pdc->GetDeviceCaps(LOGPIXELSX))/6.0));
gm->m_pMyView->ReleaseDC(pdc);

// SFD,BMD Inverse 
double SFDvector[3],BMDvector[3];
int nBMDSign = (gm->m_DOPT.DR.m_bInverseBMD == TRUE)? -1:1;
int nSFDSign = (gm->m_DOPT.DR.m_bInverseSFD == TRUE)? -1:1;

pe = node_i;

double prv_j_val;
double pst_i_val;
for(i=0;i<4;i++) 
{
dVal[0] = val_i = CalcBForcValue(bforc_d, component, i, I_NODE);
dVal[1] = val_j = CalcBForcValue(bforc_d, component, i, J_NODE);
if(i==0)prv_j_val = val_i;
else    prv_j_val = CalcBForcValue(bforc_d, component, i-1, J_NODE);

if(i==3)pst_i_val = val_j;
else    pst_i_val = CalcBForcValue(bforc_d, component, i+1, I_NODE);

if (gm->m_AnimEngine.m_bAnimateContour) 
{
val_i = val_i*fabs(gm->m_AnimEngine.GetAnimationFactor(TRUE));
val_j = val_j*fabs(gm->m_AnimEngine.GetAnimationFactor(TRUE));
}

ps = pe;
CUtilFuncs::GetInnerLinePoint((double) (i+1), 4.0-((double) (i+1)), node_i, node_j, pe);
switch(component) 
{
case BFORC_COMPONENT_FY:
for(j=0; j<3; j++)
SFDvector[j] = local_vector[1][j]*nSFDSign;
CUtilFuncs::GetVectorDirectionPoint(SFDvector, val_i, m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, ps, pss);
CUtilFuncs::GetVectorDirectionPoint(SFDvector, val_j, m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, pe, pee);
break;
case BFORC_COMPONENT_FZ:
case BFORC_COMPONENT_FX:
for(j=0; j<3; j++)
SFDvector[j] = local_vector[2][j]*nSFDSign;
CUtilFuncs::GetVectorDirectionPoint(SFDvector, val_i, m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, ps, pss);
CUtilFuncs::GetVectorDirectionPoint(SFDvector, val_j, m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, pe, pee);
break;
case BFORC_COMPONENT_MY:
case BFORC_COMPONENT_MX:
for(j=0; j<3; j++)
BMDvector[j] = local_vector[2][j]*nBMDSign;
CUtilFuncs::GetVectorDirectionPoint(BMDvector, val_i, -m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, ps, pss);
CUtilFuncs::GetVectorDirectionPoint(BMDvector, val_j, -m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, pe, pee);
break;
case BFORC_COMPONENT_MZ:
for(j=0; j<3; j++)
BMDvector[j] = local_vector[1][j]*nBMDSign;
CUtilFuncs::GetVectorDirectionPoint(BMDvector, val_i, -m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, ps, pss);
CUtilFuncs::GetVectorDirectionPoint(BMDvector, val_j, -m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, pe, pee);
break;
default:
return;
}

if(txt_pnt) 
{
// Min/Max
if(m_bBForcOutputMinMax)
{
if(dVal[0]>dMaxVal){ txt_pnt[1] = pss; dMaxVal=dVal[0]; }
if(dVal[1]>dMaxVal){ txt_pnt[1] = pee; dMaxVal=dVal[1]; }
if(dVal[0]<dMinVal){ txt_pnt[0] = pss; dMinVal=dVal[0]; }
if(dVal[1]<dMinVal){ txt_pnt[0] = pee; dMinVal=dVal[1]; }
}
// Abs Max
else if(m_bBForcOutputMax)
{
if(fabs(dVal[0])>fabs(dAbsMax)){ dAbsMax=dVal[0]; }
if(fabs(dVal[1])>fabs(dAbsMax)){ dAbsMax=dVal[1]; }
switch(i) 
{
case 0: txt_pnt[0] = pss; break;
case 2: txt_pnt[1] = pss; break;
case 3: txt_pnt[2] = pee; break;
}
}
else
{
switch(i) 
{
case 0: txt_pnt[0] = pss; break;
case 2: txt_pnt[1] = pss; break;
case 3: txt_pnt[2] = pee; break;
}
}
}

ldist = sqrt( (pe.x-ps.x)*(pe.x-ps.x) +
(pe.y-ps.y)*(pe.y-ps.y) +
(pe.z-ps.z)*(pe.z-ps.z) );
sl_num = (int) (ldist/ulen);
if(((double) sl_num)*ulen == ldist)sl_num--;
udist = ldist/((double) (sl_num+1));

vdist = val_j - val_i;
uval = vdist*udist/ldist;

sub_jval = val_i;
sub_pe = ps;
sub_pee = pss;
for(j=0;j<=sl_num;j++) 
{
sub_ival  = sub_jval;
sub_ps    = sub_pe;
sub_pss   = sub_pee;
if(j == sl_num) 
{
sub_jval = val_j;
sub_pe = pe;
sub_pee = pee;
}
else 
{
sub_jval = val_i + uval*(j+1);
CUtilFuncs::GetInnerLinePoint(fabs(udist*(j+1)), fabs(fabs(ldist)-fabs(udist*(j+1))), ps, pe, sub_pe);
CUtilFuncs::GetInnerLinePoint(fabs(udist*(j+1)), fabs(fabs(ldist)-fabs(udist*(j+1))), pss, pee, sub_pee);
}
BOOL bIsStart     = (i==0 && j==0)?       TRUE:FALSE;
BOOL bIsEnd       = (i==3 && j==sl_num)?  TRUE:FALSE;
BOOL bAnyFill = m_bVerticalLineFill; // No Fill Option일 경우만 FALSE이다.
if(m_bBSfdBmdLineOnly == FALSE && m_bVerticalLineFill == TRUE && gm->m_bGradient) bAnyFill = FALSE; // Gradient Fill시 외곽선을 없앤다.

// x/4지점에서 값이 변하는 경우 Check
BOOL bIsValModifySubStart=FALSE;
BOOL bIsValModifySubEnd=FALSE;

if(i!=0 && j==0)
{
if(sub_ival*prv_j_val < 0)  bIsValModifySubStart=TRUE;
else                        bIsValModifySubStart=FALSE;
}
if(i!=3 && j==sl_num)
{
if(sub_jval*pst_i_val < 0)  bIsValModifySubEnd=TRUE;
else                        bIsValModifySubEnd=FALSE;
}

if((sub_ival==0) && (sub_jval==0)) 
{
continue;
}
else if(sub_ival == 0) 
{
ef_list.Add(TRUE);	vtx_list.Add(sub_ps);	val_list.Add(sub_ival);
ef_list.Add(bAnyFill || bIsEnd);	vtx_list.Add(sub_pee);	val_list.Add(sub_jval);
ef_list.Add(FALSE);	vtx_list.Add(sub_pe);	val_list.Add(sub_jval);
rect_flag.Add(FALSE);
}
else if(sub_jval == 0) 
{
ef_list.Add(bAnyFill || bIsStart);	vtx_list.Add(sub_ps);	val_list.Add(sub_ival);
ef_list.Add(TRUE);	vtx_list.Add(sub_pss);	val_list.Add(sub_ival);
ef_list.Add(FALSE);	vtx_list.Add(sub_pe);	val_list.Add(sub_jval);
rect_flag.Add(FALSE);
}
else if((sub_ival*sub_jval) < 0) 
{
sub_mval = 0.0;
CUtilFuncs::GetInnerLinePoint(fabs(sub_ival), fabs(sub_jval), sub_ps, sub_pe, sub_pm);
ef_list.Add(bAnyFill || bIsStart);	vtx_list.Add(sub_ps);	val_list.Add(sub_ival);
ef_list.Add(TRUE);	vtx_list.Add(sub_pss);	val_list.Add(sub_ival);
ef_list.Add(FALSE);	vtx_list.Add(sub_pm);	val_list.Add(sub_mval);
rect_flag.Add(FALSE);
ef_list.Add(TRUE);	vtx_list.Add(sub_pm);	val_list.Add(sub_mval);
ef_list.Add(bAnyFill || bIsEnd);	vtx_list.Add(sub_pee);	val_list.Add(sub_jval);
ef_list.Add(FALSE);	vtx_list.Add(sub_pe);	val_list.Add(sub_jval);
rect_flag.Add(FALSE);
}
else 
{
ef_list.Add(bAnyFill || bIsStart || bIsValModifySubStart);	vtx_list.Add(sub_ps);	val_list.Add(sub_ival);
ef_list.Add(TRUE);	vtx_list.Add(sub_pss);	val_list.Add(sub_ival);
ef_list.Add(bAnyFill || bIsEnd || bIsValModifySubEnd);	    vtx_list.Add(sub_pee);	val_list.Add(sub_jval);
ef_list.Add(FALSE);	vtx_list.Add(sub_pe);	val_list.Add(sub_jval);
rect_flag.Add(TRUE);
}
}
}

if(pMnMxVal)
{
if(m_bBForcOutputMinMax)
{
pMnMxVal[0] = dMinVal;
pMnMxVal[1] = dMaxVal;
}
if(m_bBForcOutputMax)
{
pMnMxVal[0] = 0.0;
pMnMxVal[1] = dAbsMax;
}
}
}
*/
void CForceEngine::BSfdBmdMakePolygon(T_STRB_D &bforc_d, int component, double local_vector[][3],
																			C3DPoint &node_i, C3DPoint &node_j,
																			CArray <C3DPoint, C3DPoint &> &vtx_list,
																			CArray <double, double &> &val_list,
																			CArray <BOOL, BOOL> &ef_list,
																			CArray <BOOL, BOOL> &rect_flag,
																			C3DPoint *txt_pnt,T_ELEM_K ElemKey,double *pMnMxVal,
																			BOOL bTruss,
																			CArray<C3DPoint,C3DPoint&> *parAddedLine4MembDgrm/*=NULL*/)
{
	if(pMnMxVal){ pMnMxVal[0]=0;  pMnMxVal[1]=0;}

	if(IsPossibleExactSfdBmdMode() && !bTruss) // Truss가 아니어야함 
	{
		BSfdBmdMakeExactPolygon(component, local_vector, node_i, node_j,
			vtx_list, val_list, ef_list, rect_flag, txt_pnt, ElemKey,pMnMxVal,parAddedLine4MembDgrm);
		return;
	}

	DECLARE_GPSMD();    

	int			i, j, sl_num;
	double	val_i, val_j;
	double  dVal[2];
	double  ulen, udist, uval, ldist, vdist;
	double  sub_ival, sub_jval, sub_mval;
	double  dMaxVal=-DBL_MAX,dMinVal=DBL_MAX;
	double  dAbsMax=0;

	C3DPoint	ps, pss, pe, pee;
	C3DPoint  sub_ps, sub_pss, sub_pe, sub_pee, sub_pm;

	CDC	*pdc=gm->m_pMyView->GetDC();
	ulen = fabs(gm->m_pGPSCtrl->GetWorldLength(((double) pdc->GetDeviceCaps(LOGPIXELSX))/6.0));
	gm->m_pMyView->ReleaseDC(pdc);

	// SFD,BMD Inverse 
	double SFDvector[3],BMDvector[3];
	int nBMDSign = (gm->m_DOPT.DR.m_bInverseBMD == TRUE)? -1:1;
	int nSFDSign = (gm->m_DOPT.DR.m_bInverseSFD == TRUE)? -1:1;

	pe = node_i;

	double prv_j_val;
	double pst_i_val;
	for(i=0;i<4;i++) 
	{
		dVal[0] = val_i = CalcBForcValue(bforc_d, component, i, I_NODE);
		dVal[1] = val_j = CalcBForcValue(bforc_d, component, i, J_NODE);
		if(i==0)prv_j_val = val_i;
		else    prv_j_val = CalcBForcValue(bforc_d, component, i-1, J_NODE);

		if(i==3)pst_i_val = val_j;
		else    pst_i_val = CalcBForcValue(bforc_d, component, i+1, I_NODE);

		if (gm->m_AnimEngine.m_bAnimateContour) 
		{
			val_i = val_i*fabs(gm->m_AnimEngine.GetAnimationFactor(TRUE));
			val_j = val_j*fabs(gm->m_AnimEngine.GetAnimationFactor(TRUE));
		}

		// Member Diagram에서 No Fill로 
		// Diagram을 그리는 경우 임시로 
		// Line을 집어넣어준다 
		if(parAddedLine4MembDgrm)
			if(i==1 || i==2 || i==3)
			{
				parAddedLine4MembDgrm->Add(pee);
			}

			ps = pe;
			CUtilFuncs::GetInnerLinePoint((double) (i+1), 4.0-((double) (i+1)), node_i, node_j, pe);
			switch(component) 
			{
			case BFORC_COMPONENT_FY:
				for(j=0; j<3; j++)
					SFDvector[j] = local_vector[1][j]*nSFDSign;
				CUtilFuncs::GetVectorDirectionPoint(SFDvector, val_i, m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, ps, pss);
				CUtilFuncs::GetVectorDirectionPoint(SFDvector, val_j, m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, pe, pee);
				break;
			case BFORC_COMPONENT_FZ:
			case BFORC_COMPONENT_FX:
				for(j=0; j<3; j++)
					SFDvector[j] = local_vector[2][j]*nSFDSign;
				CUtilFuncs::GetVectorDirectionPoint(SFDvector, val_i, m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, ps, pss);
				CUtilFuncs::GetVectorDirectionPoint(SFDvector, val_j, m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, pe, pee);
				break;
			case BFORC_COMPONENT_MY:
			case BFORC_COMPONENT_MX:
			case BFORC_COMPONENT_W:
			case BFORC_COMPONENT_MT:
			case BFORC_COMPONENT_MW:
				for(j=0; j<3; j++)
					BMDvector[j] = local_vector[2][j]*nBMDSign;
				CUtilFuncs::GetVectorDirectionPoint(BMDvector, val_i, -m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, ps, pss);
				CUtilFuncs::GetVectorDirectionPoint(BMDvector, val_j, -m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, pe, pee);
				break;
			case BFORC_COMPONENT_MZ:
				for(j=0; j<3; j++)
					BMDvector[j] = local_vector[1][j]*nBMDSign;
				CUtilFuncs::GetVectorDirectionPoint(BMDvector, val_i, -m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, ps, pss);
				CUtilFuncs::GetVectorDirectionPoint(BMDvector, val_j, -m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, pe, pee);
				break;
			default:
				return;
			}

			// Member Diagram에서 No Fill로 
			// Diagram을 그리는 경우 임시로 
			// Line을 집어넣어준다 
			if(parAddedLine4MembDgrm)
				if(i==1 || i==2 || i==3)
				{
					parAddedLine4MembDgrm->Add(pss);
				}

				if(txt_pnt) 
				{
					// Strip result - Bending moment diagram
					if(m_bStripOutput)
					{
						switch(i) 
						{
						case 0: txt_pnt[0] = pss; break; // I
						case 1: txt_pnt[1] = pss; break; // 1/4
						case 2: txt_pnt[2] = pss; break; // C
						case 3: txt_pnt[3] = pss;        // 3/4
							txt_pnt[4] = pee; break; // J
						}
					}
					// Min/Max
					else if(m_bBForcOutputMinMax)
					{
						if(dVal[0]>dMaxVal){ txt_pnt[1] = pss; dMaxVal=dVal[0]; }
						if(dVal[1]>dMaxVal){ txt_pnt[1] = pee; dMaxVal=dVal[1]; }
						if(dVal[0]<dMinVal){ txt_pnt[0] = pss; dMinVal=dVal[0]; }
						if(dVal[1]<dMinVal){ txt_pnt[0] = pee; dMinVal=dVal[1]; }
					}
					// Abs Max
					else if(m_bBForcOutputMax)
					{
						if(fabs(dVal[0])>fabs(dAbsMax)){ dAbsMax=dVal[0]; }
						if(fabs(dVal[1])>fabs(dAbsMax)){ dAbsMax=dVal[1]; }
						switch(i) 
						{
						case 0: txt_pnt[0] = pss; break;
						case 2: txt_pnt[1] = pss; break;
						case 3: txt_pnt[2] = pee; break;
						}
					}
					else
					{
						switch(i) 
						{
						case 0: txt_pnt[0] = pss; break;
						case 2: txt_pnt[1] = pss; break;
						case 3: txt_pnt[2] = pee; break;
						}
					}
				}

				ldist = sqrt( (pe.x-ps.x)*(pe.x-ps.x) +
					(pe.y-ps.y)*(pe.y-ps.y) +
					(pe.z-ps.z)*(pe.z-ps.z) );
				sl_num = (int) (ldist/ulen);
				if(((double) sl_num)*ulen == ldist)sl_num--;
				if(sl_num==-1) continue; 
				udist = ldist/((double) (sl_num+1));

				vdist = val_j - val_i;
				uval = vdist*udist/ldist;

				sub_jval = val_i;
				sub_pe = ps;
				sub_pee = pss;
				for(j=0;j<=sl_num;j++) 
				{
					sub_ival  = sub_jval;
					sub_ps    = sub_pe;
					sub_pss   = sub_pee;
					if(j == sl_num) 
					{
						sub_jval = val_j;
						sub_pe = pe;
						sub_pee = pee;
					}
					else 
					{
						sub_jval = val_i + uval*(j+1);
						CUtilFuncs::GetInnerLinePoint(fabs(udist*(j+1)), fabs(fabs(ldist)-fabs(udist*(j+1))), ps, pe, sub_pe);
						CUtilFuncs::GetInnerLinePoint(fabs(udist*(j+1)), fabs(fabs(ldist)-fabs(udist*(j+1))), pss, pee, sub_pee);
					}
					BOOL bIsStart     = (i==0 && j==0)?       TRUE:FALSE;
					BOOL bIsEnd       = (i==3 && j==sl_num)?  TRUE:FALSE;
					BOOL bAnyFill = m_bVerticalLineFill; // No Fill Option일 경우만 FALSE이다.
					if(m_bBSfdBmdLineOnly == FALSE && m_bVerticalLineFill == TRUE && gm->m_bGradient) bAnyFill = FALSE; // Gradient Fill시 외곽선을 없앤다.

					// x/4지점에서 값이 변하는 경우 Check
					BOOL bIsValModifySubStart=FALSE;
					BOOL bIsValModifySubEnd=FALSE;

					if(i!=0 && j==0)
					{
						if(sub_ival*prv_j_val < 0)  bIsValModifySubStart=TRUE;
						else                        bIsValModifySubStart=FALSE;
					}
					if(i!=3 && j==sl_num)
					{
						if(sub_jval*pst_i_val < 0)  bIsValModifySubEnd=TRUE;
						else                        bIsValModifySubEnd=FALSE;
					}

					if((sub_ival==0) && (sub_jval==0)) 
					{
						continue;
					}
					else if(sub_ival == 0) 
					{
						ef_list.Add(TRUE);	vtx_list.Add(sub_ps);	val_list.Add(sub_ival);
						ef_list.Add(bAnyFill || bIsEnd);	vtx_list.Add(sub_pee);	val_list.Add(sub_jval);
						ef_list.Add(FALSE);	vtx_list.Add(sub_pe);	val_list.Add(sub_jval);
						rect_flag.Add(FALSE);
					}
					else if(sub_jval == 0) 
					{
						ef_list.Add(bAnyFill || bIsStart);	vtx_list.Add(sub_ps);	val_list.Add(sub_ival);
						ef_list.Add(TRUE);	vtx_list.Add(sub_pss);	val_list.Add(sub_ival);
						ef_list.Add(FALSE);	vtx_list.Add(sub_pe);	val_list.Add(sub_jval);
						rect_flag.Add(FALSE);
					}
					else if((sub_ival*sub_jval) < 0) 
					{
						sub_mval = 0.0;
						CUtilFuncs::GetInnerLinePoint(fabs(sub_ival), fabs(sub_jval), sub_ps, sub_pe, sub_pm);
						ef_list.Add(bAnyFill || bIsStart);	vtx_list.Add(sub_ps);	val_list.Add(sub_ival);
						ef_list.Add(TRUE);	vtx_list.Add(sub_pss);	val_list.Add(sub_ival);
						ef_list.Add(FALSE);	vtx_list.Add(sub_pm);	val_list.Add(sub_mval);
						rect_flag.Add(FALSE);
						ef_list.Add(TRUE);	vtx_list.Add(sub_pm);	val_list.Add(sub_mval);
						ef_list.Add(bAnyFill || bIsEnd);	vtx_list.Add(sub_pee);	val_list.Add(sub_jval);
						ef_list.Add(FALSE);	vtx_list.Add(sub_pe);	val_list.Add(sub_jval);
						rect_flag.Add(FALSE);
					}
					else 
					{
						ef_list.Add(bAnyFill || bIsStart || bIsValModifySubStart);	vtx_list.Add(sub_ps);	val_list.Add(sub_ival);
						ef_list.Add(TRUE);	vtx_list.Add(sub_pss);	val_list.Add(sub_ival);
						ef_list.Add(bAnyFill || bIsEnd || bIsValModifySubEnd);	    vtx_list.Add(sub_pee);	val_list.Add(sub_jval);
						ef_list.Add(FALSE);	vtx_list.Add(sub_pe);	val_list.Add(sub_jval);
						rect_flag.Add(TRUE);
					}
				}
	}

	if(pMnMxVal)
	{
		if(m_bBForcOutputMinMax)
		{
			pMnMxVal[0] = dMinVal;
			pMnMxVal[1] = dMaxVal;
		}
		if(m_bBForcOutputMax)
		{
			pMnMxVal[0] = 0.0;
			pMnMxVal[1] = dAbsMax;
		}
	}
}

// New Version which can draw precise SFD & find exact Maximum in exact mode;
// by LSS;
void CForceEngine::BSfdBmdMakeExactPolygon(int component, double local_vector[][3],
																					 C3DPoint &node_i, C3DPoint &node_j,
																					 CArray <C3DPoint, C3DPoint &> &vtx_list,
																					 CArray <double, double &> &val_list,
																					 CArray <BOOL, BOOL> &ef_list,
																					 CArray <BOOL, BOOL> &rect_flag,
																					 C3DPoint *txt_pnt,T_ELEM_K ElemKey,
																					 double *pMnMxVal,
																					 CArray<C3DPoint,C3DPoint&> *parAddedLine4MembDgrm/*=NULL*/)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	int i;
	double  ulen, sub_jval_prev, sub_ival_next,
		sub_ival, sub_jval, sub_mval;
	C3DPoint	ps, pss, pe, pee,
		sub_ps, sub_pss, sub_pe, sub_pee, sub_pm;

	double dMaxValue,dPrevMax; // absolute maximum
	if(m_mapSFDBMDMax.Lookup(ElemKey,dPrevMax))dMaxValue = dPrevMax;
	else dMaxValue = 0.0;

	double dMnMxValMn=DBL_MAX;
	double dMnMxValMx=-DBL_MAX; 

	if(pMnMxVal)
	{
		pMnMxVal[0]=0.0;
		pMnMxVal[1]=0.0;
	}

	CDC	*pdc=gm->m_pMyView->GetDC();
	ulen = fabs(gm->m_pGPSCtrl->GetWorldLength(((double) pdc->GetDeviceCaps(LOGPIXELSX))/5.0));
	gm->m_pMyView->ReleaseDC(pdc);

	BOOL bLeftCliff, bRightCliff; // SFD에 수직 변형이 있는가?	
	// SFD,BMD Inverse 
	double SFDvector[3],BMDvector[3];
	int nBMDSign = (gm->m_DOPT.DR.m_bInverseBMD == TRUE)? -1:1;
	int nSFDSign = (gm->m_DOPT.DR.m_bInverseSFD == TRUE)? -1:1;

	const int DX = 1;
	const int DY = 2;
	const int DZ = 3;
	const int LEFT = 0;
	const int CENT = 1;
	const int RIGHT = 2;
	const int LEFT_END = 0;
	const int MIN = 0;
	const int MAX = 1;
	const int RIGHT_END = 2;
	int nNumPart,nDir;

	switch(component) 
	{
	case BFORC_COMPONENT_FX:
	case BFORC_COMPONENT_MX:
	case BFORC_COMPONENT_W:
	case BFORC_COMPONENT_MT:
	case BFORC_COMPONENT_MW:
		nDir = DX;
		nNumPart = gm->m_pBeamDiagram->m_arP[DX][0].GetSize();
		break;
	case BFORC_COMPONENT_FY:
		nDir = DY;
		nNumPart = gm->m_pBeamDiagram->m_arP[DY][0].GetSize();
		break;
	case BFORC_COMPONENT_MZ:
		nDir = DY;
		nNumPart = gm->m_pBeamDiagram->m_arP[DY][0].GetSize();
		break;
	case BFORC_COMPONENT_FZ:
		nDir = DZ;
		nNumPart = gm->m_pBeamDiagram->m_arP[DZ][0].GetSize();
		break;
	case BFORC_COMPONENT_MY:
		nDir = DZ;
		nNumPart = gm->m_pBeamDiagram->m_arP[DZ][0].GetSize();
		break;
	}

	T_CFMO_D  DataCFMO;

	/////////////////////////////////////////////////////////////////////////////////////////////////
	// Offset 설정 
	// [Xi,Xj,Zi,Zj,Yi,Yj] // 이 순서대로 사용하였음. 

	if(m_pDoc->m_pPostCtrl->GetCfmo(ElemKey, DataCFMO))
	{
		DataCFMO.dOffset[0] = 0.0;
		DataCFMO.dOffset[1] = 0.0;

		//nOffsetType   0: global offset
		//nOffsetType   1: building control
		//nOffsetType   2: local offset
		//nOffsetType   3: Section offset

		//if(DataCFMO.nOffsetType == 0) // Type 0일 경우 무시한다.
		if(DataCFMO.nOffsetType==0 || DataCFMO.nOffsetType==3 ) // Type 0일 경우 무시한다.
		{
			DataCFMO.dOffset[2] = 0.0;
			DataCFMO.dOffset[3] = 0.0;
			DataCFMO.dOffset[4] = 0.0;
			DataCFMO.dOffset[5] = 0.0;
		}
	}
	else
	{
		DataCFMO.Initialize();
		DataCFMO.dLength = m_pDoc->calcLAVElem(ElemKey);         // 빔의 길이 
	}

	double dOffset; 
	if(nDir==DX) dOffset = 0;
	if(nDir==DY) dOffset = DataCFMO.dOffset[4];
	if(nDir==DZ) dOffset = DataCFMO.dOffset[2];

	int     nDiagmDir;
	double  dDist[3];
	C3DPoint PosPoint[3],ValPoint[3],PosPointMid;

	double dBeamLength	= sqrt((node_j.x-node_i.x)*(node_j.x-node_i.x)+(node_j.y-node_i.y)*(node_j.y-node_i.y)+(node_j.z-node_i.z)*(node_j.z-node_i.z));
	double dShrinkFactor = dBeamLength/(gm->m_pBeamDiagram->m_arP[nDir][RIGHT][nNumPart-1]-gm->m_pBeamDiagram->m_arP[nDir][LEFT][0]);

	for(int nPart=0; nPart<nNumPart; nPart++)
	{
		for(int nSubPos = LEFT; nSubPos <= RIGHT; nSubPos ++)
		{
			dDist[nSubPos] = gm->m_pBeamDiagram->m_arP[nDir][nSubPos][nPart]-dOffset;		
			// p1, p2가 이루는 직선 상의, p1으로부터 factor/length만큼 떨어진 점을 구함.		
			CUtilFuncs::GetInnerLinePoint2(dDist[nSubPos]*dShrinkFactor,dBeamLength,node_i,node_j,PosPoint[nSubPos]);
		}

		switch (component) 
		{
		case BFORC_COMPONENT_FY:
		case BFORC_COMPONENT_FZ:
		case BFORC_COMPONENT_FX:
			sub_ival = gm->m_pBeamDiagram->m_arV[nDir][LEFT][nPart];
			sub_mval = gm->m_pBeamDiagram->m_arV[nDir][CENT][nPart];
			sub_jval = gm->m_pBeamDiagram->m_arV[nDir][RIGHT][nPart];
			if(nPart>0) 
			{
				sub_jval_prev = gm->m_pBeamDiagram->m_arV[nDir][RIGHT][nPart-1]; // Diagram에 수직 변형이 있는가를 알아보기 위해
				bLeftCliff = (sub_jval_prev * sub_ival < 0.0 )? TRUE:FALSE;
			}
			else bLeftCliff= FALSE;

			if(nPart<nNumPart-1) 
			{ 
				sub_ival_next = gm->m_pBeamDiagram->m_arV[nDir][LEFT][nPart+1];	
				bRightCliff = (sub_jval * sub_ival_next < 0.0)? TRUE:FALSE;
			}
			else bRightCliff = FALSE;


			sub_ival = max(sub_ival, m_pContourEngine->m_MinRange);
			sub_ival = min(sub_ival, m_pContourEngine->m_MaxRange);
			sub_mval = max(sub_mval, m_pContourEngine->m_MinRange);
			sub_mval = min(sub_mval, m_pContourEngine->m_MaxRange);
			sub_jval = max(sub_jval, m_pContourEngine->m_MinRange);
			sub_jval = min(sub_jval, m_pContourEngine->m_MaxRange);

			nDiagmDir = (nDir != DX)? nDir-1: nDir+1;

			for(i=0; i<3; i++)
				SFDvector[i] = local_vector[nDiagmDir][i]*nSFDSign;
			CUtilFuncs::GetVectorDirectionPoint(SFDvector, sub_ival, m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, PosPoint[LEFT], ValPoint[LEFT]);
			CUtilFuncs::GetVectorDirectionPoint(SFDvector, sub_mval, m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, PosPoint[CENT], ValPoint[CENT]);
			CUtilFuncs::GetVectorDirectionPoint(SFDvector, sub_jval, m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, PosPoint[RIGHT], ValPoint[RIGHT]);
			break;

		case BFORC_COMPONENT_MX:
		case BFORC_COMPONENT_MY:
		case BFORC_COMPONENT_MZ:
		case BFORC_COMPONENT_W:
		case BFORC_COMPONENT_MT:
		case BFORC_COMPONENT_MW:
			sub_ival = gm->m_pBeamDiagram->m_arM[nDir][LEFT][nPart];
			sub_mval = gm->m_pBeamDiagram->m_arM[nDir][CENT][nPart];
			sub_jval = gm->m_pBeamDiagram->m_arM[nDir][RIGHT][nPart];

			if(nPart>0) 
			{ 
				sub_jval_prev = gm->m_pBeamDiagram->m_arM[nDir][RIGHT][nPart-1]; // Diagram에 수직 변형이 있는가를 알아보기 위해
				bLeftCliff = (sub_jval_prev * sub_ival < 0.0 )? TRUE:FALSE;
			}
			else bLeftCliff= FALSE;

			if(nPart<nNumPart-1) 
			{
				sub_ival_next = gm->m_pBeamDiagram->m_arM[nDir][LEFT][nPart+1];	
				bRightCliff = (sub_jval * sub_ival_next < 0.0)? TRUE:FALSE;
			}
			else bRightCliff = FALSE;

			sub_ival = max(sub_ival, m_pContourEngine->m_MinRange);
			sub_ival = min(sub_ival, m_pContourEngine->m_MaxRange);
			sub_mval = max(sub_mval, m_pContourEngine->m_MinRange);
			sub_mval = min(sub_mval, m_pContourEngine->m_MaxRange);
			sub_jval = max(sub_jval, m_pContourEngine->m_MinRange);
			sub_jval = min(sub_jval, m_pContourEngine->m_MaxRange);

			nDiagmDir = (nDir != DX)? nDir-1: nDir+1;
			for(i=0; i<3; i++)BMDvector[i] = local_vector[nDiagmDir][i]*nBMDSign;

			CUtilFuncs::GetVectorDirectionPoint(BMDvector, sub_ival, -m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, PosPoint[LEFT], ValPoint[LEFT]);
			CUtilFuncs::GetVectorDirectionPoint(BMDvector, sub_mval, -m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, PosPoint[CENT], ValPoint[CENT]);
			CUtilFuncs::GetVectorDirectionPoint(BMDvector, sub_jval, -m_BSfdBmdAdjustFactor*m_BSfdBmdScFactor, PosPoint[RIGHT], ValPoint[RIGHT]);
			break;
		}

		if(gm->m_AnimEngine.m_bAnimateContour)
		{
			sub_ival = sub_ival*fabs(gm->m_AnimEngine.GetAnimationFactor(TRUE));
			sub_mval = sub_mval*fabs(gm->m_AnimEngine.GetAnimationFactor(TRUE));
			sub_jval = sub_jval*fabs(gm->m_AnimEngine.GetAnimationFactor(TRUE));
		}

		if(txt_pnt) 
		{
			if (nPart == 0)									 
				txt_pnt[LEFT_END]= ValPoint[LEFT];
			else if((nPart == (nNumPart-1)/2) && !(m_bBForcOutputMax || m_bBForcOutputMinMax)) // 20090417 mylee
				txt_pnt[CENT]    = ValPoint[CENT];
			else if(nPart == nNumPart-1)		 
				txt_pnt[RIGHT_END] = ValPoint[RIGHT];	
		}

		if(m_bBForcOutputMinMax)
		{
			// Max
			if(sub_ival > dMnMxValMx) 
			{ 
				dMnMxValMx = sub_ival;
				if(txt_pnt)   txt_pnt[MAX] = ValPoint[LEFT];
				if(pMnMxVal)  pMnMxVal[MAX] = dMnMxValMx;
			}
			if(sub_mval > dMnMxValMx) 
			{ 
				dMnMxValMx = sub_mval;
				if(txt_pnt) txt_pnt[MAX] = ValPoint[CENT];
				if(pMnMxVal)  pMnMxVal[MAX] = dMnMxValMx;
			}
			if(sub_jval > dMnMxValMx) 
			{ 
				dMnMxValMx = sub_jval;
				if(txt_pnt) txt_pnt[MAX] = ValPoint[RIGHT];
				if(pMnMxVal)  pMnMxVal[MAX] = dMnMxValMx;
			}
			// Min
			if(sub_ival < dMnMxValMn) 
			{ 
				dMnMxValMn = sub_ival;
				if(txt_pnt) txt_pnt[MIN] = ValPoint[LEFT];
				if(pMnMxVal)  pMnMxVal[MIN] = dMnMxValMn;
			}
			if(sub_mval < dMnMxValMn) 
			{ 
				dMnMxValMn = sub_mval; // 20090417 mylee
				if(txt_pnt) txt_pnt[MIN] = ValPoint[CENT];
				if(pMnMxVal) pMnMxVal[MIN] = dMnMxValMn; // 20090417 mylee
			}
			if(sub_jval < dMnMxValMn) 
			{ 
				dMnMxValMn = sub_jval;
				if(txt_pnt) txt_pnt[MIN] = ValPoint[RIGHT];
				if(pMnMxVal)  pMnMxVal[MIN] = dMnMxValMn;
			}
		}
		else if(m_bBForcOutputMax)
		{
			if(fabs(sub_ival) >= fabs(dMaxValue)) 
			{ 
				dMaxValue = sub_ival;
				if(txt_pnt) txt_pnt[MAX] = ValPoint[LEFT];
				if(pMnMxVal)  pMnMxVal[MAX] = dMaxValue;
			}
			if(fabs(sub_mval) >= fabs(dMaxValue)) 
			{ 
				dMaxValue = sub_mval;
				if(txt_pnt) txt_pnt[MAX] = ValPoint[CENT];
				if(pMnMxVal)  pMnMxVal[MAX] = dMaxValue;
			}
			if(fabs(sub_jval) >= fabs(dMaxValue)) 
			{ 
				dMaxValue = sub_jval;
				if(txt_pnt) txt_pnt[MAX] = ValPoint[RIGHT];
				if(pMnMxVal)  pMnMxVal[MAX] = dMaxValue;
			}
		}

		BOOL bAnyFill = m_bVerticalLineFill; // No Fill Option일 경우만 FALSE이다.
		if(m_bBSfdBmdLineOnly == FALSE && m_bVerticalLineFill == TRUE && gm->m_bGradient) bAnyFill = FALSE; // Gradient Fill시 외곽선을 없앤다.

		if ((sub_ival==0) && (sub_mval==0)) 
		{
			goto NEXTPART;
		}
		else if(sub_ival == 0) 
		{
			ef_list.Add(TRUE);	vtx_list.Add(PosPoint[0]);	val_list.Add(sub_ival);
			ef_list.Add(bAnyFill);	vtx_list.Add(ValPoint[1]);	val_list.Add(sub_mval);
			ef_list.Add(FALSE);	vtx_list.Add(PosPoint[1]);	val_list.Add(sub_mval);
			rect_flag.Add(FALSE);
		}
		else if(sub_mval == 0) 
		{
			ef_list.Add(bAnyFill || nPart == 0 || bLeftCliff);	vtx_list.Add(PosPoint[0]);	val_list.Add(sub_ival);//TRUE
			ef_list.Add(TRUE);	vtx_list.Add(ValPoint[0]);	val_list.Add(sub_ival);
			ef_list.Add(FALSE);	vtx_list.Add(PosPoint[1]);	val_list.Add(sub_mval);
			rect_flag.Add(FALSE);
		}
		else if((sub_ival*sub_mval) < 0) 
		{
			double sub_midval = 0.0;
			CUtilFuncs::GetInnerLinePoint(fabs(sub_ival), fabs(sub_mval), PosPoint[0], PosPoint[1], PosPointMid);
			ef_list.Add(bAnyFill || nPart == 0 || bLeftCliff);	vtx_list.Add(PosPoint[0]);	val_list.Add(sub_ival);//TRUE
			ef_list.Add(TRUE);	vtx_list.Add(ValPoint[0]);	val_list.Add(sub_ival);
			ef_list.Add(FALSE);	vtx_list.Add(PosPointMid);	val_list.Add(sub_midval);
			rect_flag.Add(FALSE);
			ef_list.Add(TRUE);	vtx_list.Add(PosPointMid);	val_list.Add(sub_midval);
			ef_list.Add(bAnyFill);	vtx_list.Add(ValPoint[1]);	val_list.Add(sub_mval);
			ef_list.Add(FALSE);	vtx_list.Add(PosPoint[1]);	val_list.Add(sub_mval);
			rect_flag.Add(FALSE);
		}
		else 
		{
			ef_list.Add(bAnyFill || nPart == 0 || bLeftCliff);	vtx_list.Add(PosPoint[0]);	val_list.Add(sub_ival);//TRUE
			ef_list.Add(TRUE);	vtx_list.Add(ValPoint[0]);	val_list.Add(sub_ival);
			ef_list.Add(bAnyFill);	vtx_list.Add(ValPoint[1]);	val_list.Add(sub_mval);
			ef_list.Add(FALSE);	vtx_list.Add(PosPoint[1]);	val_list.Add(sub_mval);
			rect_flag.Add(TRUE);
		}

NEXTPART:
		if((sub_mval==0) && (sub_jval==0)) 
		{
			continue;
		}
		else if (sub_mval == 0) 
		{
			ef_list.Add(TRUE);	vtx_list.Add(PosPoint[1]);	val_list.Add(sub_mval);
			ef_list.Add(bAnyFill || nPart == nNumPart-1 || bRightCliff);	vtx_list.Add(ValPoint[2]);	val_list.Add(sub_jval); // TRUE
			ef_list.Add(FALSE);	vtx_list.Add(PosPoint[2]);	val_list.Add(sub_jval);
			rect_flag.Add(FALSE);
		}
		else if (sub_jval == 0) 
		{
			ef_list.Add(bAnyFill);	vtx_list.Add(PosPoint[1]);	val_list.Add(sub_mval);
			ef_list.Add(TRUE);	vtx_list.Add(ValPoint[1]);	val_list.Add(sub_mval);
			ef_list.Add(FALSE);	vtx_list.Add(PosPoint[2]);	val_list.Add(sub_jval);
			rect_flag.Add(FALSE);
		}
		else if((sub_mval*sub_jval) < 0) 
		{
			double sub_midval = 0.0;
			CUtilFuncs::GetInnerLinePoint(fabs(sub_mval), fabs(sub_jval), PosPoint[1], PosPoint[2], PosPointMid);
			ef_list.Add(bAnyFill);	vtx_list.Add(PosPoint[1]);	val_list.Add(sub_mval);
			ef_list.Add(TRUE);	vtx_list.Add(ValPoint[1]);	val_list.Add(sub_mval);
			ef_list.Add(FALSE);	vtx_list.Add(PosPointMid);	val_list.Add(sub_midval);
			rect_flag.Add(FALSE);
			ef_list.Add(TRUE);	vtx_list.Add(PosPointMid);	val_list.Add(sub_midval);
			ef_list.Add(bAnyFill || nPart == nNumPart-1 || bRightCliff);	vtx_list.Add(ValPoint[2]);	val_list.Add(sub_jval);
			ef_list.Add(FALSE);	vtx_list.Add(PosPoint[2]);	val_list.Add(sub_jval);
			rect_flag.Add(FALSE);
		}
		else 
		{
			ef_list.Add(bAnyFill);	vtx_list.Add(PosPoint[1]);	val_list.Add(sub_mval);
			ef_list.Add(TRUE);	vtx_list.Add(ValPoint[1]);	val_list.Add(sub_mval);
			ef_list.Add(bAnyFill || nPart == nNumPart-1 || bRightCliff);	vtx_list.Add(ValPoint[2]);	val_list.Add(sub_jval);
			ef_list.Add(FALSE);	vtx_list.Add(PosPoint[2]);	val_list.Add(sub_jval);
			rect_flag.Add(TRUE);
		}
	}
	m_mapSFDBMDMax.SetAt(ElemKey,dMaxValue);
}

void CForceEngine::GetBsfdBmdExactMinMaxVal(T_ELEM_K ElemK, double *pMnMxVal)
{
	DECLARE_GPSMD();

	double		local_vector[3][3];
	m_pDoc->calcFrameLocalVector(ElemK, local_vector);
	T_ELEM_D ElemD;
	m_pDoc->m_pAttrCtrl->GetElem(ElemK, ElemD);
	CArray<C3DPoint,C3DPoint&>vtx_list;
	CArray<double, double &>	val_list;
	CArray<BOOL, BOOL>				ef_list;
	CArray<BOOL, BOOL>				rect_flag;
	C3DPoint pnt[2], node_i, node_j, *txt_pnt;

	CArray<CList<C3DPoint,C3DPoint> *, CList <C3DPoint, C3DPoint> *>polygon_list;

	if(m_bDeformedShapeContour)
		gm->m_pDeformEngine->GetDeformedShapeElement(ElemK, &polygon_list, NULL, NULL);
	else
		gm->GetShapeElement(ElemK, polygon_list, NULL, NULL, NULL);
	auto pos = polygon_list[0]->GetHeadPosition();
	pnt[0] = polygon_list[0]->GetNext(pos);
	pnt[1] = polygon_list[0]->GetNext(pos);

	if(gm->m_DOPT.TX.m_bOutputNumber) 
		txt_pnt   = new C3DPoint[4];
	else 
		txt_pnt   = NULL;

	GetOffsetedPoint(ElemK,pnt[0],pnt[1],node_i,node_j,m_BForcComponent);
	BSfdBmdMakeExactPolygon(m_BForcComponent, local_vector, node_i, node_j,
		vtx_list, val_list, ef_list, rect_flag, txt_pnt, ElemK, pMnMxVal, nullptr);

	if(txt_pnt) delete []txt_pnt;
}

void CForceEngine::DoBSfdBmdContour(CDC *pDC,
																		CArray <C3DPoint, C3DPoint &> &vtx_list,
																		CArray <double, double &> &val_list,
																		CArray <BOOL, BOOL> &ef_list,
																		CArray <BOOL, BOOL> &rect_flag)
{
	I_GPSModel					*gm=(I_GPSModel *) m_pGPSModel;
	int							i, j, k, l, m, poly_num=rect_flag.GetSize();
	C3DPoint					vtx_array[4];
	double						val_array[4];
	BOOL						ef_array[4];
	CArray <int, int>			vnum_list;
	CArray <VtxInfo, VtxInfo>	vinfo_list;

	k = 0;
	l = 0;
	m = 0;
	for(i=0;i<poly_num;i++) 
	{
		if(rect_flag[i]) 
		{
			for(j=0;j<4;j++) 
			{
				val_array[j] = val_list[k++];
				vtx_array[j] = vtx_list[l++];
				ef_array[j] = ef_list[m++];
			}
			m_pContourEngine->SfdBmdFramePoly(vtx_array, val_array, ef_array, 4, vnum_list, vinfo_list,m_bVerticalLineFill);
		}
		else 
		{
			for(j=0;j<3;j++) 
			{
				val_array[j] = val_list[k++];
				vtx_array[j] = vtx_list[l++];
				ef_array[j] = ef_list[m++];
			}
			m_pContourEngine->SfdBmdFramePoly(vtx_array, val_array, ef_array, 3, vnum_list, vinfo_list,m_bVerticalLineFill);
		}
	}

	if (gm->m_bGradient) 
	{
		DrawContourListGrad(pDC, vnum_list, vinfo_list);
	}
	else 
	{
		DrawContourList(pDC, vnum_list, vinfo_list);
	}

	vnum_list.RemoveAll();
	vinfo_list.RemoveAll();
}

////////////////////////////////////////////////////////////////////////////////////////
// Routines for Drawing Plate Member Force/Moment Contour           ////////////////////
////////////////////////////////////////////////////////////////////////////////////////

// Plate Force 데이터를 만든다.
// 전체 Element List에 대해 Loop를 돌며
// 1. DB로 부터 해당 Element의 Beam Force 데이터를 얻고
// 2. Plate Force값 및 해당 Element번호 등을 CArray에 저장
// 3. 필요시 각 노드별로 인접한 요소의 Plate Force의 값의 평균값을 구한다.
// 4. Plate Key List 중 현재 Active인 것들의 List를 구한다.
// 5. 현재 Active Plate Key List에 대해 Loop를 돌며 최대/최소값을 갱신한다.
BOOL CForceEngine::MakePForcDataList()
{
	if (CTestEnvMgr::IsTestEnvST(_LSX(ProfilingSTL), _LSX(yes)))
	{
		M_PROFILE('MakePForcDataList()');
	}

	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	if(!gm->m_bLoadDataSet)	return FALSE;

	int			  i, elem_num, nie;
	double		max_pforc=-DBL_MAX, min_pforc=DBL_MAX, len;
	BOOL		  has_content=FALSE;
	T_ELEM_K	elem_key;
	T_STRP_DL	pforc;
	T_STRP_DL	pforc_max,pforc_min;
	BOOL      bWithSign = m_pDoc->m_pPostCtrl->GetSignFlag();

	gm->m_pMyView->BeginWaitCursor();

	m_pDoc->m_pPostCtrl->ResetDataPoolMap();

	m_PlateKeyList.RemoveAll();
	m_mapPForcData.RemoveAll();
	m_mapNodesInElem.RemoveAll();
	m_mapSlabForce.RemoveAll();

	// Get the Original LoadCombination Data
	T_LCOM_D  LcomOrg=m_pDoc->m_pPostCtrl->GetLoadComb();

	if(m_bAverageNodalActiveOnly || !m_bAverage)
		elem_num = gm->m_EKeyListActive.GetSize(); // Active된 요소에 대해서만 Average Nodal을 계산.
	else
		elem_num = gm->m_EKeyList.GetSize(); // Average Nodal이 가능하도록...전체 요소를 취한다.  

	if(m_bAverage && m_PForcComponent != PFORC_COMPONENT_MOMENT_COMB) MakeSerialNodeMap();    

	CMap<T_ELEM_K,T_ELEM_K,T_STRP_DL,T_STRP_DL&> mapPForcDataMax,mapPForcDataMin;
	mapPForcDataMax.InitHashTable(HASHSIZEELEM);
	mapPForcDataMin.InitHashTable(HASHSIZEELEM);
	// MNET:4110-GYKIM-20091117
	// Wood Armer Moment
	if(m_PForcComponent == PFORC_COMPONENT_MOMENT_COMB)
	{
		m_pDoc->m_pPostCtrl->MakeSubdomainInfo(TRUE);   // Sub Domain의 각 평면 Local Vector 정보 사전 생성. GetWamtNew(), GetWamtNew_AvgNodel() 호출용.. 

		T_ELEM_D edata; 

		T_SLAB_FORCE_COMPACT SlabForce;
		for(i=0;i<gm->m_EKeyListActive.GetSize();i++) 
		{
			SlabForce.initialize();
			elem_key = gm->m_EKeyListActive[i];
			m_PlateKeyList.Add(elem_key);

			edata.Initialize();
			m_pDoc->m_pAttrCtrl->GetElem(elem_key, edata);
			nie = m_pDoc->m_pAttrCtrl->GetNumNode(edata.eltyp, edata.elnod);      
			m_mapNodesInElem.SetAt(elem_key, nie);			

			// 경사진Elem은 출력하지 않음
			// 			if(m_nPlateForceLocalGlobal == 0 && m_pDoc->m_pAttrCtrl->IsPlate(edata.eltyp)) // UCS Mode
			// 			{						
			// 				double UCSV[3][3];
			// 				GetUCSVector(m_NUCS,UCSV);
			// 				if(!IsParallelToUCSPlane(elem_key, UCSV))
			// 				{
			// 					continue;
			// 				}
			// 			}
		}

		T_WAMT_D WamtMax, WamtMin, WamtAbs;
		if(m_bAverage)
		{
			for (i = 0; i < gm->m_EKeyListActive.GetSize(); i++) 
			{
				// GetWamtNew()안에서 SubDomain에 포함되지 않는 Elem이면 Return False하는 내용이 있음
				// 				if(!IsSubDomainElem(gm->m_EKeyListActive[i]))
				// 				{
				// 					continue;
				// 				}
				elem_key = gm->m_EKeyListActive[i];
				if(!m_pDoc->m_pPostCtrl->GetWamtNew_AvgNodel(elem_key, &WamtMax, &WamtMin, &WamtAbs))
				{
					continue;
				}
				GetWoodArmerSlabForce(WamtMax, WamtMin, WamtAbs, SlabForce);
				m_mapSlabForce.SetAt(elem_key, SlabForce);
			}    
		}
		else
		{
			for (i = 0; i < gm->m_EKeyListActive.GetSize(); i++) 
			{
				// GetWamtNew()안에서 SubDomain에 포함되지 않는 Elem이면 Return False하는 내용이 있음
				// 				if(!IsSubDomainElem(gm->m_EKeyListActive[i]))
				// 				{
				// 					continue;
				// 				}
				elem_key = gm->m_EKeyListActive[i];
				if(!m_pDoc->m_pPostCtrl->GetWamtNew(elem_key, &WamtMax, &WamtMin, &WamtAbs, m_bAverage))
				{
					continue;
				}
				GetWoodArmerSlabForce(WamtMax, WamtMin, WamtAbs, SlabForce);
				m_mapSlabForce.SetAt(elem_key, SlabForce);
			}
		}
	}
	else
	{
		MakePForcDataListLcom(LcomOrg,elem_num,1.0,mapPForcDataMax,mapPForcDataMin);	

		for(i=0;i<m_PlateKeyList.GetSize();i++) 
		{
			elem_key = m_PlateKeyList[i];
			mapPForcDataMax.Lookup(elem_key, pforc_max);
			mapPForcDataMin.Lookup(elem_key, pforc_min);

			switch (gm->m_LoadMinMaxType) 
			{
			case LOADTYPE_NORMAL:
			case LOADTYPE_MAX:
				m_mapPForcData.SetAt(elem_key,pforc_max);
				break;
			case LOADTYPE_MIN:
				m_mapPForcData.SetAt(elem_key,pforc_min);
				break;
			case LOADTYPE_ALL:
				if(bWithSign)
					pforc_max.AbsMaxwithSign(pforc_min);
				else
					pforc_max.AbsMax(pforc_min);
				m_mapPForcData.SetAt(elem_key,pforc_max);
				break;
			}
		}
	}

	// Back to the Original LoadCombination Data
	m_pDoc->m_pPostCtrl->ChangeLoadComb(LcomOrg);

	// Plate Key List 중 현재 Active인 것들의 List를 구한다.
	if(!(m_bAverageNodalActiveOnly || !m_bAverage))
		GetActivePlateList();

	elem_num = m_PlateKeyList.GetSize();

	//if(m_mapPForcData.GetCount()) has_content = TRUE;
	m_MaxAbsValue = 0.0;

	for (i=0;i<elem_num;i++) 
	{
		if(m_PForcComponent != PFORC_COMPONENT_MOMENT_COMB)
		{
			if(!m_mapPForcData.Lookup(m_PlateKeyList[i], pforc)) continue; 		  
		}
		if(!m_mapNodesInElem.Lookup(m_PlateKeyList[i],nie)) continue;     

		has_content = TRUE;

		if (m_PForcComponent==PFORC_COMPONENT_MOMENT_COMB)
			len = GetMaxWoodArmer(m_PlateKeyList[i], nie);
		else
		{
			if(gm->m_bElemCenter) len = CalcPForcValue(pforc, 0);
			else len = GetMaxElemPForc(pforc, nie);
		}
		if ( (m_PForcComponent!=PFORC_COMPONENT_FVT && m_PForcComponent!=PFORC_COMPONENT_MVT)
			|| (m_bVectorPositive && m_bVectorNegative))
		{
			if(len > max_pforc) 
			{
				max_pforc = len;
				gm->m_nLgdMaxValKey = m_PlateKeyList[i];
			}
		}
		else if ((m_bVectorPositive && len>0.) || (m_bVectorNegative && len<0.))
		{
			if(len > max_pforc) 
			{
				max_pforc = len;
				gm->m_nLgdMaxValKey = m_PlateKeyList[i];
			}
			if(len < min_pforc) 
			{
				min_pforc = len;
				gm->m_nLgdMinValKey = m_PlateKeyList[i];
			}
		}
		if(fabs(len) > m_MaxAbsValue) 
		{
			m_MaxAbsValue = fabs(len);
			m_KeyMaxAbsElem = m_PlateKeyList[i];
		}

		if (m_PForcComponent==PFORC_COMPONENT_MOMENT_COMB)
			len = GetMinWoodArmer(m_PlateKeyList[i], nie);
		else
		{
			if(gm->m_bElemCenter) len = CalcPForcValue(pforc, 0);
			else len = GetMinElemPForc(pforc, nie);
		}

		if ( (m_PForcComponent!=PFORC_COMPONENT_FVT && m_PForcComponent!=PFORC_COMPONENT_MVT)
			|| (m_bVectorPositive && m_bVectorNegative))
		{
			if(len < min_pforc) 
			{
				min_pforc = len;
				gm->m_nLgdMinValKey = m_PlateKeyList[i];
			}
		}
		else if ((m_bVectorPositive && len>0.) || (m_bVectorNegative && len<0.))
		{
			if(len > max_pforc) 
			{
				max_pforc = len;
				gm->m_nLgdMaxValKey = m_PlateKeyList[i];
			}
			if(len < min_pforc) 
			{
				min_pforc = len;
				gm->m_nLgdMinValKey = m_PlateKeyList[i];
			}
		}
		if(fabs(len) > m_MaxAbsValue) 
		{
			m_MaxAbsValue = fabs(len);
			m_KeyMaxAbsElem = m_PlateKeyList[i];
		}
	}

	if (fabs(max_pforc+DBL_MAX)<1.e-10) max_pforc=0.;
	if (fabs(min_pforc-DBL_MAX)<1.e-10) min_pforc=0.;

	if (!has_content) 
	{
		min_pforc = max_pforc = 0.0;
		gm->m_nLgdMaxValKey=0;
		gm->m_nLgdMinValKey=0;
	}

	m_dMaxValue = max_pforc;
	m_dMinValue = min_pforc;

	if (m_pContourEngine == NULL)
		m_pContourEngine = new CContourEngine(m_dMinValue, m_dMaxValue);
	else
		m_pContourEngine->MakeRankMap(m_dMinValue, m_dMaxValue);

	m_mapNodesInElem.RemoveAll();
	if (m_bOnCuttingLine)
		MakeCuttingLineData();


	gm->m_pMyView->EndWaitCursor();

	m_bPForcDataSet = TRUE;
	return TRUE;
}

BOOL CForceEngine::GetPForcRangeDataList(double& dMaxRange, double& dMinRange, CArray<UINT,UINT>& aElemKeyList)
{
	aElemKeyList.RemoveAll();

	if (CTestEnvMgr::IsTestEnvST(_LSX(ProfilingSTL), _LSX(yes)))
	{
		M_PROFILE('GetPForcRangeDataList()');
	}

	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	int			  i, elem_num, nie;
	T_ELEM_K	elem_key;
	T_ELEM_D	elem_data;
	T_STRP_DL	pforc;
	BOOL      bWithSign = m_pDoc->m_pPostCtrl->GetSignFlag();

	gm->m_pMyView->BeginWaitCursor();

	elem_num = m_PlateKeyList.GetSize();

	for (i=0;i<elem_num;i++) 
	{
		elem_key = m_PlateKeyList[i];
		if(m_PForcComponent != PFORC_COMPONENT_MOMENT_COMB)
		{
			if(!m_mapPForcData.Lookup(elem_key, pforc)) continue;
		}
		elem_data.Initialize();
		m_pDoc->m_pAttrCtrl->GetElem(elem_key, elem_data);
		nie = m_pDoc->m_pAttrCtrl->GetNumNode(elem_data.eltyp, elem_data.elnod);

		if (m_PForcComponent==PFORC_COMPONENT_MOMENT_COMB)
		{
			if(m_bAverage)
			{
				if(!m_pDoc->m_pPostCtrl->GetWamtNew_AvgNodel(elem_key, NULL, NULL, NULL)) continue;
			}
			else
			{
				if(!m_pDoc->m_pPostCtrl->GetWamtNew(elem_key, NULL, NULL, NULL, m_bAverage)) continue;
			}			

			if(!IsWithinRangeWoodArmer(elem_key, nie, dMaxRange, dMinRange)) continue;
		}
		else
		{
			if(!IsWithinRangeElemPForc(pforc, nie, dMaxRange, dMinRange)) continue;
		}
		aElemKeyList.Add(elem_key);
	}

	gm->m_pMyView->EndWaitCursor();
	
	return TRUE;
}

// DATE : 2002.9.12. by KYE-HONG
// FUNC : 임의의 방향으로 Plate Force/Moment를 
//        만드는 함수임 
BOOL CForceEngine::MakePForcDataList_UserDir()
{
	if (CTestEnvMgr::IsTestEnvST(_LSX(ProfilingSTL), _LSX(yes)))
	{
		M_PROFILE('MakePForcDataList_UserDir()');
	}

	I_GPSModel  *gm=(I_GPSModel *) m_pGPSModel;
	if(!gm->m_bLoadDataSet)	return FALSE;

	int			  i, j, elem_num, nie,nCL=0;
	double	  max_pforc=-DBL_MAX, min_pforc=DBL_MAX, len;
	BOOL		  has_content=FALSE;
	T_ELEM_K	elem_key;
	T_STRP_DL	pforc, PFrcD;
	T_STRP_DL	pforc_max,pforc_min;
	BOOL      bWithSign = m_pDoc->m_pPostCtrl->GetSignFlag();
	double    dTolerance=m_pDoc->m_pFlagCtrl->GetGeneralCoordinateToleranceCurrentUnit(); // 1mm고정단위의 Tolerance

	gm->m_pMyView->BeginWaitCursor();

	m_PlateKeyList.RemoveAll();
	m_mapPForcData.RemoveAll();
	m_mapNodesInElem.RemoveAll();
	ResetDrawCLWPData(); 

	if(m_bAverageNodalActiveOnly || !m_bAverage) elem_num = gm->m_EKeyListActive.GetSize(); // Only Active Element
	else                                         elem_num = gm->m_EKeyList.GetSize();       // All Element	
	if(m_bAverage) MakeSerialNodeMap();


	// Cutting Line User Axis
	T_CLWP_D  ClwpD; 
	T_CUTLINE_MINMAX_D CutLineMinMax;
	CArray<double,double>      aCutV;
	CArray<C3DPoint,C3DPoint&> aCutP;


	for(int ii=0; ii<gm->m_pBDT->PFUD.arClwp.GetSize(); ii++)
	{
		double CutLineMax = -DBL_MAX;
		double CutLineMin =  DBL_MAX;

		CArray<T_CUTLINE_D,T_CUTLINE_D&> *paDrawCLWP;
		paDrawCLWP= new CArray<T_CUTLINE_D,T_CUTLINE_D&>;
		m_parDrawCLWP.Add(paDrawCLWP);
		ClwpD=gm->m_pBDT->PFUD.arClwp[ii];


		// Get the User Dir LoadCombination Plate Force Data
		T_LCOM_D  LcomOrg=m_pDoc->m_pPostCtrl->GetLoadComb();

		CMap<T_ELEM_K,T_ELEM_K,T_STRP_DL,T_STRP_DL&> mapPForcDataMax,mapPForcDataMin;
		mapPForcDataMax.InitHashTable(HASHSIZEELEM);
		mapPForcDataMin.InitHashTable(HASHSIZEELEM);
		MakePForcDataListLcomUserDir(LcomOrg,elem_num,1.0,ClwpD,mapPForcDataMax,mapPForcDataMin);

		for(i=0;i<m_PlateKeyList.GetSize();i++) 
		{
			elem_key = m_PlateKeyList[i];
			mapPForcDataMax.Lookup(elem_key, pforc_max);
			mapPForcDataMin.Lookup(elem_key, pforc_min);

			switch (gm->m_LoadMinMaxType) 
			{
			case LOADTYPE_NORMAL:
			case LOADTYPE_MAX:
				m_mapPForcData.SetAt(elem_key,pforc_max);
				break;
			case LOADTYPE_MIN:
				m_mapPForcData.SetAt(elem_key,pforc_min);
				break;
			case LOADTYPE_ALL:
				if(bWithSign)
					pforc_max.AbsMaxwithSign(pforc_min);
				else
					pforc_max.AbsMax(pforc_min);
				m_mapPForcData.SetAt(elem_key,pforc_max);
				break;
			}
		}

		// Back to the Original LoadCombination Data
		m_pDoc->m_pPostCtrl->ChangeLoadComb(LcomOrg);


		// Setting Plate Stress of Elements on that Cutting Line for Drawing
		POSITION nPos2;
		int nNodeInElem;
		UINT nKey;
		T_ELEM_D ElemD; 
		T_NODE_D Node[2];
		C3DPoint CutPt; 
		double V[3][3],dDistance,dPltVal[2],dCutVal,d1,d2;
		nPos2 = m_mapPForcData.GetStartPosition();
		while(nPos2)
		{
			m_mapPForcData.GetNextAssoc(nPos2,nKey,PFrcD);

			aCutV.RemoveAll();
			aCutP.RemoveAll();
			m_pDoc->m_pAttrCtrl->GetElem(nKey,ElemD);

			nNodeInElem = m_pDoc->m_pAttrCtrl->GetNumNode(ElemD.eltyp, ElemD.elnod);
			for(i=0; i<nNodeInElem; i++)
			{
				m_pDoc->m_pAttrCtrl->GetNode(ElemD.elnod[i],Node[0]);
				j = (i==nNodeInElem-1)? 0:(i+1);
				m_pDoc->m_pAttrCtrl->GetNode(ElemD.elnod[j],Node[1]);

				V[0][0]=Node[0].x;  V[0][1]=Node[0].y;  V[0][2]=Node[0].z;
				V[1][0]=Node[1].x;  V[1][1]=Node[1].y;  V[1][2]=Node[1].z;

				BOOL bIntersect = CMathFunc::mathIntersectLine2(ClwpD.Point1,ClwpD.Point2,V[0],V[1],dTolerance,dDistance,V[2]);
				if(bIntersect)
				{
					if(!GetNodalValueforCutting(PFrcD,dPltVal[0],i,dPltVal[1],j))continue; // virtual

					d1 = CMathFunc::mathLength(V[2][0],V[2][1],V[2][2],V[0][0],V[0][1],V[0][2]);
					d2 = CMathFunc::mathLength(V[2][0],V[2][1],V[2][2],V[1][0],V[1][1],V[1][2]);

					dCutVal = dPltVal[0] + (dPltVal[1]-dPltVal[0])*d1/(d1+d2);
					CutPt.x = V[2][0];
					CutPt.y = V[2][1];
					CutPt.z = V[2][2];
					aCutP.Add(CutPt);
					aCutV.Add(dCutVal);
				}
			}

			// 같은 점이 있을 경우 없앤다.
			if(aCutP.GetSize()>1)
			{
				for( i=0;   i<aCutP.GetSize()-1; i++)
					for( j=i+1; j<aCutP.GetSize();   j++)
						if(IsSame3DPoint(aCutP[i],aCutP[j]))
						{
							aCutP.RemoveAt(j);
							aCutV.RemoveAt(j);
							j--;
						}	
			}
			else continue;

			//최종적으로 2개의 서로다른 점이 존재해야한다.
			if(aCutP.GetSize()!= 2)continue;

			T_CUTLINE_D CutLineD;

			CutLineD.dPoint1Val = aCutV[0];
			CutLineD.dPoint2Val = aCutV[1];
			CutLineD.Point1 = aCutP[0];
			CutLineD.Point2 = aCutP[1];
			CutLineD.KeyElem= nKey;
			CutLineD.dDist1 = CMathFunc::mathLength(ClwpD.Point1[0],ClwpD.Point1[1],ClwpD.Point1[2],aCutP[0].x,aCutP[0].y,aCutP[0].z);
			CutLineD.dDist2 = CMathFunc::mathLength(ClwpD.Point1[0],ClwpD.Point1[1],ClwpD.Point1[2],aCutP[1].x,aCutP[1].y,aCutP[1].z);

			if(CutLineMax < aCutV[0]) CutLineMax = aCutV[0];
			if(CutLineMax < aCutV[1]) CutLineMax = aCutV[1];
			if(CutLineMin > aCutV[0]) CutLineMin = aCutV[0];
			if(CutLineMin > aCutV[1]) CutLineMin = aCutV[1];

			m_parDrawCLWP[nCL]->Add(CutLineD);
		}
		CutLineMinMax.Max = CutLineMax;
		CutLineMinMax.Min = CutLineMin;
		m_arDrawCLWPMnMx.Add(CutLineMinMax);

		nCL++; 
	}


	// Get Active List
	//if(!(m_bAverage && !m_bAverageNodalActiveOnly))
	if(!(m_bAverageNodalActiveOnly || !m_bAverage))
		GetActivePlateList();

	elem_num = m_PlateKeyList.GetSize();

	m_MaxAbsValue = 0.0;
	for(i=0;i<elem_num;i++) 
	{
		if(!m_mapPForcData.Lookup(m_PlateKeyList[i],pforc))continue; 
		if(!m_mapNodesInElem.Lookup(m_PlateKeyList[i],nie))continue; 

		has_content=TRUE;
		len = GetMaxElemPForc(pforc, nie);
		if(len > max_pforc) 
		{
			max_pforc = len;
			gm->m_nLgdMaxValKey = m_PlateKeyList[i];
		}
		if(fabs(len) > m_MaxAbsValue) 
		{
			m_MaxAbsValue = fabs(len);
			m_KeyMaxAbsElem = m_PlateKeyList[i];
		}

		len = GetMinElemPForc(pforc, nie);
		if(len < min_pforc) 
		{
			min_pforc = len;
			gm->m_nLgdMinValKey = m_PlateKeyList[i];
		}
		if(fabs(len) > m_MaxAbsValue) 
		{
			m_MaxAbsValue = fabs(len);
			m_KeyMaxAbsElem = m_PlateKeyList[i];
		}
	}

	if(!has_content)
	{
		min_pforc = max_pforc = 0.0;
		gm->m_nLgdMaxValKey=0;
		gm->m_nLgdMinValKey=0;
	}
	m_dMaxValue = max_pforc;
	m_dMinValue = min_pforc;
	//m_mapNodesInElem.RemoveAll();

	// MNET:3025
	//MakeDrawCLWPData();

	gm->m_pMyView->EndWaitCursor();

	m_bPForcDataSet = TRUE;
	return TRUE; 
}

BOOL  CForceEngine::MakeDrawCLWPData()
{
	int i,j,nElemNum,nCL=0;
	double U[3][3],L[3][3],dDot; 
	T_CLWP_D  ClwpD; 
	T_STRP_DL PFrcD; 
	T_CUTLINE_MINMAX_D CutLineMinMax;

	CArray<double,double>      aCutV;
	CArray<C3DPoint,C3DPoint&> aCutP;
	CMap<T_ELEM_K,T_ELEM_K,T_STRP_DL,T_STRP_DL&> mapPForcDataNew;

	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	// 1mm고정단위의 Tolerance를 구해옴 
	double dTolerance=m_pDoc->m_pFlagCtrl->GetGeneralCoordinateToleranceCurrentUnit();

	ResetDrawCLWPData(); 

	for(int ii=0; ii<gm->m_pBDT->PFUD.arClwp.GetSize(); ii++)
	{
		double CutLineMax = -DBL_MAX;
		double CutLineMin =  DBL_MAX;

		CArray<T_CUTLINE_D,T_CUTLINE_D&> *paDrawCLWP;
		paDrawCLWP= new CArray<T_CUTLINE_D,T_CUTLINE_D&>;
		m_parDrawCLWP.Add(paDrawCLWP);

		//////////////////////////////////////////////////
		// 임의방향의 부재력을 요소별로 구한다 
		//////////////////////////////////////////////////
		//m_pDoc->m_pAttrCtrl->GetNextClwp(nPos,ClwpK,ClwpD);

		ClwpD=gm->m_pBDT->PFUD.arClwp[ii];
		double V1[3],V2[3];

		for(i=0; i<3; i++)V1[i]=ClwpD.Point2[i]-ClwpD.Point1[i];
		for(i=0; i<3; i++)V2[i]=ClwpD.Point3[i]-ClwpD.Point1[i];

		CMathFunc::mathCross(V1,V2,U[2]);     // UZ
		CMathFunc::mathCross(U[2],V1,U[1]);   // UY
		CMathFunc::mathCross(U[1],U[2],U[0]); // UX
		for(i=0; i<3; i++)if(!CMathFunc::mathNormalize(U[i],U[i]))return FALSE; 

		mapPForcDataNew.RemoveAll(); 
		nElemNum = m_PlateKeyList.GetSize();
		for(i=0; i<nElemNum; i++) 
		{
			// 해당 Direction방향의 Force값으로 변환 
			if(!m_mapPForcData.Lookup(m_PlateKeyList[i],PFrcD))continue; 
			m_pDoc->calcPlaneLocalVector(m_PlateKeyList[i],L);
			dDot=fabs(CMathFunc::mathDot(L[2],U[2]));
			if(1.0-dDot < 0.0001523) m_pDoc->m_pPostCtrl->ConvertStrp_UCS(L,U,PFrcD);
			else  continue;

			mapPForcDataNew.SetAt(m_PlateKeyList[i],PFrcD); 
		}

		if(m_bAverage)GetAverageNodalDataListPCTL(mapPForcDataNew);

		//////////////////////////////////////////////////
		// Cutting Line에 짤리는 요소의 부재력과 위치를  
		// Drawing을 위해 저장한다 
		//////////////////////////////////////////////////
		POSITION nPos2;
		int nNodeInElem;
		UINT nKey;
		T_ELEM_D ElemD; 
		T_NODE_D Node[2];
		C3DPoint CutPt; 
		double V[3][3],dDistance,dPltVal[2],dCutVal,d1,d2;
		nPos2 = mapPForcDataNew.GetStartPosition();
		while(nPos2)
		{
			mapPForcDataNew.GetNextAssoc(nPos2,nKey,PFrcD);

			aCutV.RemoveAll();
			aCutP.RemoveAll();
			m_pDoc->m_pAttrCtrl->GetElem(nKey,ElemD);

			nNodeInElem = m_pDoc->m_pAttrCtrl->GetNumNode(ElemD.eltyp, ElemD.elnod);
			for(i=0; i<nNodeInElem; i++)
			{
				m_pDoc->m_pAttrCtrl->GetNode(ElemD.elnod[i],Node[0]);
				j = (i==nNodeInElem-1)? 0:(i+1);
				m_pDoc->m_pAttrCtrl->GetNode(ElemD.elnod[j],Node[1]);

				V[0][0]=Node[0].x;  V[0][1]=Node[0].y;  V[0][2]=Node[0].z;
				V[1][0]=Node[1].x;  V[1][1]=Node[1].y;  V[1][2]=Node[1].z;

				BOOL bIntersect = CMathFunc::mathIntersectLine2(ClwpD.Point1,ClwpD.Point2,V[0],V[1],dTolerance,dDistance,V[2]);
				if(bIntersect)
				{
					if(!GetNodalValueforCutting(PFrcD,dPltVal[0],i,dPltVal[1],j))continue; // virtual

					d1 = CMathFunc::mathLength(V[2][0],V[2][1],V[2][2],V[0][0],V[0][1],V[0][2]);
					d2 = CMathFunc::mathLength(V[2][0],V[2][1],V[2][2],V[1][0],V[1][1],V[1][2]);

					dCutVal = dPltVal[0] + (dPltVal[1]-dPltVal[0])*d1/(d1+d2);
					CutPt.x = V[2][0];
					CutPt.y = V[2][1];
					CutPt.z = V[2][2];
					aCutP.Add(CutPt);
					aCutV.Add(dCutVal);
				}
			}

			// 같은 점이 있을 경우 없앤다.
			if(aCutP.GetSize()>1)
			{
				for( i=0;   i<aCutP.GetSize()-1; i++)
					for( j=i+1; j<aCutP.GetSize();   j++)
						if(IsSame3DPoint(aCutP[i],aCutP[j]))
						{
							aCutP.RemoveAt(j);
							aCutV.RemoveAt(j);
							j--;
						}	
			}
			else continue;

			//최종적으로 2개의 서로다른 점이 존재해야한다.
			if(aCutP.GetSize()!= 2)continue;

			T_CUTLINE_D CutLineD;

			CutLineD.dPoint1Val = aCutV[0];
			CutLineD.dPoint2Val = aCutV[1];
			CutLineD.Point1 = aCutP[0];
			CutLineD.Point2 = aCutP[1];
			CutLineD.KeyElem= nKey;
			CutLineD.dDist1 = CMathFunc::mathLength(ClwpD.Point1[0],ClwpD.Point1[1],ClwpD.Point1[2],aCutP[0].x,aCutP[0].y,aCutP[0].z);
			CutLineD.dDist2 = CMathFunc::mathLength(ClwpD.Point1[0],ClwpD.Point1[1],ClwpD.Point1[2],aCutP[1].x,aCutP[1].y,aCutP[1].z);

			if(CutLineMax < aCutV[0]) CutLineMax = aCutV[0];
			if(CutLineMax < aCutV[1]) CutLineMax = aCutV[1];
			if(CutLineMin > aCutV[0]) CutLineMin = aCutV[0];
			if(CutLineMin > aCutV[1]) CutLineMin = aCutV[1];

			m_parDrawCLWP[nCL]->Add(CutLineD);
		}
		CutLineMinMax.Max = CutLineMax;
		CutLineMinMax.Min = CutLineMin;
		m_arDrawCLWPMnMx.Add(CutLineMinMax);

		nCL++; 
	}

	return TRUE; 
}


// 각 노드별로 인접한 요소의 Plate Force의 값의 평균값을 구한다.
void CForceEngine::GetAverageNodalDataList()
{
	if(m_PForcComponent == PFORC_COMPONENT_MOMENT_COMB)
	{
		return; // Wood-Armer Moment는 Avg.Nodal을 고려해서 map에 세팅해 둠
	}

	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	MakeSerialNodeMap();
	T_NODE_K serial_node;

	int i,j,linked_elem_num, nodes_in_elem,node_num,elem_num; 
	double		pforc_val;
	T_ELEM_D	elem_data;
	T_STRP_DL strp_d;
	CArray <double, double &>											*elem_ptr;
	CArray <CArray <double, double &> *, CArray <double, double &> *>	elem_ptr_list;

	node_num=m_pDoc->m_pAttrCtrl->GetCountNode();
	elem_num=m_PlateKeyList.GetSize();

	double UCS_vector[3][3];
	GetUCSVector(m_NUCS,UCS_vector);

	//!@#$: 2131 조합응력의 Average Nodal 계산 방법 변경
	// 각 응력 계산을 하고 그것을 Average한다. 
	if(m_bAverage)
	{
		if(m_PForcComponent == PFORC_COMPONENT_FMX || 
			m_PForcComponent == PFORC_COMPONENT_FMN ||
			m_PForcComponent == PFORC_COMPONENT_MMX || 
			m_PForcComponent == PFORC_COMPONENT_MMN)
		{
			int nBackPForcComponent = m_PForcComponent;
			int nCompNum = 3;
			CArray<int,int> nComponent;
			if(m_PForcComponent == PFORC_COMPONENT_FMX || m_PForcComponent == PFORC_COMPONENT_FMN)
			{ 
				nComponent.Add(PFORC_COMPONENT_FXX);
				nComponent.Add(PFORC_COMPONENT_FYY);
				nComponent.Add(PFORC_COMPONENT_FXY);
			}
			else if(m_PForcComponent == PFORC_COMPONENT_MMX || m_PForcComponent == PFORC_COMPONENT_MMN)
			{ 
				nComponent.Add(PFORC_COMPONENT_MXX);
				nComponent.Add(PFORC_COMPONENT_MYY);
				nComponent.Add(PFORC_COMPONENT_MXY);
			}

			// Component별 Average
			for(i=0; i<nCompNum; i++)
			{
				m_PForcComponent = nComponent[i]; 
				GetAverageNodalDataList();
			}

			// FMax와 FMin을 다시 계산한다. 
			for(i=0; i<elem_num; i++)
			{
				if(!m_mapPForcData.Lookup(m_PlateKeyList[i],strp_d)) continue;
				if(nBackPForcComponent == PFORC_COMPONENT_FMX || nBackPForcComponent == PFORC_COMPONENT_FMN)
					CPostCtrl::CalcPrinForcePlate(strp_d, TRUE);
				else
					CPostCtrl::CalcPrinForcePlate(strp_d, FALSE);
				m_mapPForcData.SetAt(m_PlateKeyList[i],strp_d);
			}
			m_PForcComponent = nBackPForcComponent;
			return; 
		}	
	}


	for(i=0;i<node_num;i++) 
	{
		elem_ptr=new CArray<double, double&>;
		elem_ptr_list.Add(elem_ptr);
	}

	// Moment Combination Mode인 경우 Average를 두번 수행함 
	if(m_PForcComponent == PFORC_COMPONENT_MOMENT_COMB)
	{
		// [2009-11-13] Kim, Geun Young (Tel: 2042, gykim@midasit.com)
		ASSERT(0);

		m_PForcComponent = PFORC_COMPONENT_MXY;
		GetAverageNodalDataList();

		if(m_nMxxMyyMode == 0)
			m_PForcComponent = PFORC_COMPONENT_MXX;
		else
			m_PForcComponent = PFORC_COMPONENT_MYY;
		GetAverageNodalDataList();
		m_PForcComponent = PFORC_COMPONENT_MOMENT_COMB;
		return; 
	}

	for(i=0;i<elem_num;i++) 
	{
		m_pDoc->m_pAttrCtrl->GetElem(m_PlateKeyList[i], elem_data);
		m_mapNodesInElem.Lookup(m_PlateKeyList[i],nodes_in_elem);
		for(j=0;j<nodes_in_elem;j++) 
		{
			m_mapPForcData.Lookup(m_PlateKeyList[i],strp_d);
			pforc_val = CalcPForcValue(strp_d, j+1);
			if(!m_mapSerialNode.Lookup(elem_data.elnod[j],serial_node)) continue;
			elem_ptr_list[serial_node]->Add(pforc_val);
		}
	}

	for(i=0;i<node_num;i++) 
	{
		linked_elem_num = elem_ptr_list[i]->GetSize();
		if(linked_elem_num < 2)continue;
		pforc_val = 0.0;
		for (j=0;j<linked_elem_num;j++) 
			pforc_val += elem_ptr_list[i]->GetAt(j);
		pforc_val /= (double) linked_elem_num;
		elem_ptr_list[i]->SetAt(0, pforc_val);
	}

	for (i=0;i<elem_num;i++) 
	{
		m_pDoc->m_pAttrCtrl->GetElem(m_PlateKeyList[i], elem_data);
		m_mapNodesInElem.Lookup(m_PlateKeyList[i],nodes_in_elem);
		for(j=0;j<nodes_in_elem;j++) 
		{
			m_mapPForcData.Lookup(m_PlateKeyList[i],strp_d);
			if(!m_mapSerialNode.Lookup(elem_data.elnod[j],serial_node)) continue;
			pforc_val = elem_ptr_list[serial_node]->GetAt(0);
			SetPForcComponent(strp_d, j+1, pforc_val);
			m_mapPForcData.SetAt(m_PlateKeyList[i],strp_d);
		}
	}

	for(i=0;i<node_num;i++) 
	{
		elem_ptr_list[i]->RemoveAll();
		delete elem_ptr_list[i];
	}
	elem_ptr_list.RemoveAll();
}

// Plate Cutting Line Diagram의 Average Nodal 
// 을 위해서 사용함 
void CForceEngine::GetAverageNodalDataListPCTL(CMap<T_ELEM_K,T_ELEM_K,T_STRP_DL,T_STRP_DL&> &mapPForcData)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	MakeSerialNodeMap();
	T_NODE_K serial_node;

	int i,j,linked_elem_num, nodes_in_elem,node_num,elem_num; 
	double		pforc_val;
	T_ELEM_D	elem_data;
	T_STRP_DL strp_d;
	CArray <double, double &>											*elem_ptr;
	CArray <CArray <double, double &> *, CArray <double, double &> *>	elem_ptr_list;

	node_num=m_pDoc->m_pAttrCtrl->GetCountNode();
	elem_num=m_PlateKeyList.GetSize();

	for(i=0;i<node_num;i++) 
	{
		elem_ptr=new CArray<double, double&>;
		elem_ptr_list.Add(elem_ptr);
	}

	for(i=0;i<elem_num;i++) 
	{
		m_pDoc->m_pAttrCtrl->GetElem(m_PlateKeyList[i], elem_data);
		nodes_in_elem = m_pDoc->m_pAttrCtrl->GetNumNode(elem_data.eltyp,elem_data.elnod);
		if(!mapPForcData.Lookup(m_PlateKeyList[i],strp_d))continue; 
		for(j=0;j<nodes_in_elem;j++) 
		{
			pforc_val = CalcPForcValue(strp_d, j+1);
			if(!m_mapSerialNode.Lookup(elem_data.elnod[j],serial_node)) continue;
			elem_ptr_list[serial_node]->Add(pforc_val);
		}
	}

	for(i=0;i<node_num;i++) 
	{
		linked_elem_num = elem_ptr_list[i]->GetSize();
		if(linked_elem_num < 2)continue;
		pforc_val = 0.0;
		for (j=0;j<linked_elem_num;j++) 
			pforc_val += elem_ptr_list[i]->GetAt(j);
		pforc_val /= (double) linked_elem_num;
		elem_ptr_list[i]->SetAt(0, pforc_val);
	}

	for (i=0;i<elem_num;i++) 
	{
		m_pDoc->m_pAttrCtrl->GetElem(m_PlateKeyList[i], elem_data);
		nodes_in_elem = m_pDoc->m_pAttrCtrl->GetNumNode(elem_data.eltyp,elem_data.elnod);
		if(!mapPForcData.Lookup(m_PlateKeyList[i],strp_d))continue; 
		for(j=0;j<nodes_in_elem;j++) 
		{
			if(!m_mapSerialNode.Lookup(elem_data.elnod[j],serial_node)) continue;
			pforc_val = elem_ptr_list[serial_node]->GetAt(0);
			SetPForcComponent(strp_d, j+1, pforc_val);
		}
		mapPForcData.SetAt(m_PlateKeyList[i],strp_d);
	}

	for(i=0;i<node_num;i++) 
	{
		elem_ptr_list[i]->RemoveAll();
		delete elem_ptr_list[i];
	}
	elem_ptr_list.RemoveAll();
}

// Plate Key List 중 현재 Active인 것들의 List를 구한다.
void CForceEngine::GetActivePlateList()
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	int			i, elem_num;

	T_ELEM_K	elem_key;
	T_ELEM_D  elem_data;	
	m_PlateKeyList.RemoveAll();
	elem_num = gm->m_EKeyListActive.GetSize(); 

	for (i=0;i<elem_num;i++) 
	{
		elem_key = gm->m_EKeyListActive[i];

		m_pDoc->m_pAttrCtrl->GetElem(elem_key, elem_data);
		if (m_pDoc->m_pAttrCtrl->IsPlate(elem_data.eltyp))
			m_PlateKeyList.Add(elem_key);

	}
}

// FUNC : 주응력벡터의 크기를 적정하게 맞추기 위해 
//        스케일 벡터를 만든다음 이를 저장 
void CForceEngine::InitVectorAdjustFactor(double dMaxAbsValue)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	C3DPoint	min_pm, max_pm, min_pe, max_pe;
	double		max_lm, max_le, max_l;

	if(m_bLockAdjFactor)
		return;

	if (!m_pDoc->m_pAttrCtrl->ExistElem(m_KeyMaxAbsElem)) {
		m_PForcVtAdjustFactor = 1.0;
		return;
	}

	// 전체 모델의 Range와 최대값이 발생한 요소의 Range를 동시에 고려한다.

	//	m_pDoc->calcRangeModel(min_pm.x, min_pm.y, min_pm.z,
	//								   max_pm.x, max_pm.y, max_pm.z,
	//								   NULL, NULL, TRUE, NULL, TRUE,
	//								   gm->m_bFrameThick||gm->m_bPlaneThick);

	gm->GetRangeModel(&min_pm,&max_pm);
	max_lm = max(max(max_pm.x-min_pm.x, max_pm.y-min_pm.y), max_pm.z-min_pm.z);

	gm->GetRangeElement(m_KeyMaxAbsElem, &min_pe, &max_pe);
	max_le = max(max(max_pe.x-min_pe.x, max_pe.y-min_pe.y), max_pe.z-min_pe.z);

	if (dMaxAbsValue > -1e-15 && dMaxAbsValue < 1e-15)
		dMaxAbsValue = 1.0f;

	if ((max_le*0.35) < (max_lm/40.0)) {
		max_l = max_lm/40.0;
	}
	else {
		max_l = max_le*0.35;
	}

	m_PForcVtAdjustFactor = max_l / dMaxAbsValue;
}



double CForceEngine::GetMaxElemPForc(T_STRP_DL &pforc, int node_num)
{
	double		len, max=-DBL_MAX;

	if (m_PForcComponent == PFORC_COMPONENT_FVT) 
	{
		if (max < pforc.dblStress[0][17]) 
		{
			max = pforc.dblStress[0][17];
		}
		if(max < pforc.dblStress[0][18]) 
		{
			max = pforc.dblStress[0][18];
		}
	}
	else if (m_PForcComponent == PFORC_COMPONENT_MVT) 
	{
		if(max < pforc.dblStress[0][23]) 
		{
			max = pforc.dblStress[0][23];
		}
		if(max < pforc.dblStress[0][24]) 
		{
			max = pforc.dblStress[0][24];
		}
	}
	else if (m_PForcComponent == PFORC_COMPONENT_MOMENT_COMB)
		ASSERT(0);
	else 
	{
		for (int i=0;i<node_num;i++) 
		{
			len = CalcPForcValue(pforc, i+1);
			if (len > max) {
				max = len;
			}
		}
	}

	return max;
}

BOOL CForceEngine::IsWithinRangeElemPForc(T_STRP_DL &pforc, int node_num,double& max_strp,double& min_strp)
{
	double len_max;
	double len_min;

	if (m_PForcComponent == PFORC_COMPONENT_FVT) 
	{
		len_max = pforc.dblStress[0][17];
		len_min = pforc.dblStress[0][18];
	}
	else if (m_PForcComponent == PFORC_COMPONENT_MVT) 
	{
		len_max = pforc.dblStress[0][23];
		len_min = pforc.dblStress[0][24];
	}
	else if (m_PForcComponent == PFORC_COMPONENT_MOMENT_COMB)
	{
		ASSERT(0);
		return FALSE;
	}
	else 
	{
		// 인덱스 0은 center
		for (int i=1;i<node_num;i++) 
		{
			len_max = CalcPForcValue(pforc, i);
			len_min = CalcPForcValue(pforc, i+1);

			if(len_min>len_max)
			{
				double len_temp = len_max;
				len_max = len_min;
				len_min = len_temp;
			}

			if (len_min <= min_strp && len_max >= max_strp)
				return TRUE;
			if (len_min >= min_strp && len_min <= max_strp)
				return TRUE;
			if (len_max >= min_strp && len_max <= max_strp)
				return TRUE;
		}
	}

	if(len_min>len_max)
	{
		double len_temp = len_max;
		len_max = len_min;
		len_min = len_temp;
	}

	if (len_min <= min_strp && len_max >= max_strp)
		return TRUE;
	if (len_min >= min_strp && len_min <= max_strp)
		return TRUE;
	if (len_max >= min_strp && len_max <= max_strp)
		return TRUE;

	return FALSE;
}

/*
double CForceEngine::GetMaxElemPForc_G(T_STRP_DG &pforc, int node_num)
{
double		len, max=-DBL_MAX;
//			20,  21,  22,  23,  24,  25,   26,   27,   28
//		 FXX, FYY, FZZ, FXY, FYZ, FXZ, MAXF, MINF, ANGF,
//			29,  30,  31,  32,  33,  34,   35,   36,   37
//     MXX, MYY, MZZ, MXY, MYZ, MXZ, MAXM, MINM, ANGM,
//      38,  39
//     Vxx, Vyy
if (m_PForcComponent == PFORC_COMPONENT_FVT_G) { 
if (max < pforc.dblStress[0][26]) {// FMax
max = pforc.dblStress[0][26];
}
if (max < pforc.dblStress[0][27]) {// FMin
max = pforc.dblStress[0][27];
}
}
else if (m_PForcComponent == PFORC_COMPONENT_MVT_G) {
if (max < pforc.dblStress[0][35]) {// MMax
max = pforc.dblStress[0][35];
}
if (max < pforc.dblStress[0][36]) {// MMin
max = pforc.dblStress[0][36];
}
}
else {
for (int i=0;i<node_num;i++) {
len = CalcPForcValue_G(pforc, i+1);
if (len > max) {
max = len;
}
}
}

return max;
}*/

double CForceEngine::GetMinElemPForc(T_STRP_DL &pforc, int node_num)
{
	double		len, min=DBL_MAX;

	if (m_PForcComponent == PFORC_COMPONENT_FVT) 
	{
		if (min > pforc.dblStress[0][17]) 
		{
			min = pforc.dblStress[0][17];
		}
		if (min > pforc.dblStress[0][18]) 
		{
			min = pforc.dblStress[0][18];
		}
	}
	else if (m_PForcComponent == PFORC_COMPONENT_MVT) 
	{
		if (min > pforc.dblStress[0][23]) 
		{
			min = pforc.dblStress[0][23];
		}
		if (min > pforc.dblStress[0][24]) 
		{
			min = pforc.dblStress[0][24];
		}
	}
	else if (m_PForcComponent == PFORC_COMPONENT_MOMENT_COMB) 
		ASSERT(0);
	else 
	{
		for (int i=0;i<node_num;i++) 
		{
			len = CalcPForcValue(pforc, i+1);
			if (len < min) 
			{
				min = len;
			}
		}
	}

	return min;
}


/*
double CForceEngine::GetMinElemPForc_G(T_STRP_DG &pforc, int node_num)
{
double		len, min=DBL_MAX;

if (m_PForcComponent == PFORC_COMPONENT_FVT_G) {
if (min > pforc.dblStress[0][26]) {
min = pforc.dblStress[0][26];
}
if (min > pforc.dblStress[0][27]) {
min = pforc.dblStress[0][27];
}
}
else if (m_PForcComponent == PFORC_COMPONENT_MVT_G) {
if (min > pforc.dblStress[0][35]) {
min = pforc.dblStress[0][35];
}
if (min > pforc.dblStress[0][36]) {
min = pforc.dblStress[0][36];
}
}
else {
for (int i=0;i<node_num;i++) {
len = CalcPForcValue_G(pforc, i+1);
if (len < min) {
min = len;
}
}
}

return min;
}*/

double CForceEngine::CalcPForcValue(T_STRP_DL &pforc, int node)
{
	double	len;

	switch (m_PForcComponent) 
	{
	case PFORC_COMPONENT_FXX:
		len = pforc.dblStress[node][14];
		break;
	case PFORC_COMPONENT_FYY:
		len = pforc.dblStress[node][15];
		break;
	case PFORC_COMPONENT_FXY:
		len = pforc.dblStress[node][16];
		break;
	case PFORC_COMPONENT_FMX:
		len = pforc.dblStress[node][17];
		break;
	case PFORC_COMPONENT_FMN:
		len = pforc.dblStress[node][18];
		break;
	case PFORC_COMPONENT_MXX:
		len = pforc.dblStress[node][20];
		break;
	case PFORC_COMPONENT_MYY:
		len = pforc.dblStress[node][21];
		break;
	case PFORC_COMPONENT_MXY:
		len = pforc.dblStress[node][22];
		break;
	case PFORC_COMPONENT_MMX:
		len = pforc.dblStress[node][23];
		break;
	case PFORC_COMPONENT_MMN:
		len = pforc.dblStress[node][24];
		break;
	case PFORC_COMPONENT_VXX:
		len = pforc.dblStress[node][26];
		break;
	case PFORC_COMPONENT_VYY:
		len = pforc.dblStress[node][27];
		break;
	case PFORC_COMPONENT_FMX_ABS:
		len = (fabs(pforc.dblStress[node][17]) > fabs(pforc.dblStress[node][18]))? pforc.dblStress[node][17]:pforc.dblStress[node][18];
		break;
	case PFORC_COMPONENT_MMX_ABS:
		len = (fabs(pforc.dblStress[node][23]) > fabs(pforc.dblStress[node][24]))? pforc.dblStress[node][23]:pforc.dblStress[node][24];
		break;
	case PFORC_COMPONENT_VMX_ABS:
		len = (fabs(pforc.dblStress[node][26]) > fabs(pforc.dblStress[node][27]))? pforc.dblStress[node][26]:pforc.dblStress[node][27];
		break;
	case PFORC_COMPONENT_MOMENT_COMB:
		ASSERT(0); return 0;
		if(this->m_nMxxMyyMode == 0)
			len = m_dMxxCoeff*pforc.dblStress[node][20] + m_dMxyCoeff*pforc.dblStress[node][22];
		else
			len = m_dMyyCoeff*pforc.dblStress[node][21] + m_dMxyCoeff*pforc.dblStress[node][22];
		break; 

	}

	return len;
}

double CForceEngine::CalcPForcValue(T_STRP_DL &pforc, int node, int component)
{
		double	len;

		switch (component) 
		{
		case PFORC_COMPONENT_FXX:
				len = pforc.dblStress[node][14];
				break;
		case PFORC_COMPONENT_FYY:
				len = pforc.dblStress[node][15];
				break;
		case PFORC_COMPONENT_FXY:
				len = pforc.dblStress[node][16];
				break;
		case PFORC_COMPONENT_FMX:
				len = pforc.dblStress[node][17];
				break;
		case PFORC_COMPONENT_FMN:
				len = pforc.dblStress[node][18];
				break;
		case PFORC_COMPONENT_MXX:
				len = pforc.dblStress[node][20];
				break;
		case PFORC_COMPONENT_MYY:
				len = pforc.dblStress[node][21];
				break;
		case PFORC_COMPONENT_MXY:
				len = pforc.dblStress[node][22];
				break;
		case PFORC_COMPONENT_MMX:
				len = pforc.dblStress[node][23];
				break;
		case PFORC_COMPONENT_MMN:
				len = pforc.dblStress[node][24];
				break;
		case PFORC_COMPONENT_VXX:
				len = pforc.dblStress[node][26];
				break;
		case PFORC_COMPONENT_VYY:
				len = pforc.dblStress[node][27];
				break;
		case PFORC_COMPONENT_FMX_ABS:
				len = (fabs(pforc.dblStress[node][17]) > fabs(pforc.dblStress[node][18]))? pforc.dblStress[node][17]:pforc.dblStress[node][18];
				break;
		case PFORC_COMPONENT_MMX_ABS:
				len = (fabs(pforc.dblStress[node][23]) > fabs(pforc.dblStress[node][24]))? pforc.dblStress[node][23]:pforc.dblStress[node][24];
				break;
		case PFORC_COMPONENT_VMX_ABS:
				len = (fabs(pforc.dblStress[node][26]) > fabs(pforc.dblStress[node][27]))? pforc.dblStress[node][26]:pforc.dblStress[node][27];
				break;
		case PFORC_COMPONENT_MOMENT_COMB:
				ASSERT(0); return 0;
				if(this->m_nMxxMyyMode == 0)
						len = m_dMxxCoeff*pforc.dblStress[node][20] + m_dMxyCoeff*pforc.dblStress[node][22];
				else
						len = m_dMyyCoeff*pforc.dblStress[node][21] + m_dMxyCoeff*pforc.dblStress[node][22];
				break; 

		}

		return len;
}

double CForceEngine::GetMaxWoodArmer(T_ELEM_K ElemK, int node_num)
{
	double		len, max=-DBL_MAX;
	for (int i=0;i<node_num;i++) 
	{
		len = CalcPForcWoodArmer(ElemK, i);
		if (len > max) {
			max = len;
		}
	}
	return max;
}

double CForceEngine::GetMinWoodArmer(T_ELEM_K ElemK, int node_num)
{
	double		len, min=DBL_MAX;
	for (int i=0;i<node_num;i++) 
	{
		len = CalcPForcWoodArmer(ElemK, i, FALSE);
		if (len < min) 
		{
			min = len;
		}
	}
	return min;
}

BOOL CForceEngine::IsWithinRangeWoodArmer(T_ELEM_K ElemK, int node_num, double& max_val, double& min_val)
{
	double len_max;
	double len_min;

	for (int i=0;i<node_num-1;i++) 
	{
		len_max = CalcPForcWoodArmer(ElemK, i);
		len_min = CalcPForcWoodArmer(ElemK, i+1);

		if(len_min>len_max)
		{
			double len_temp = len_max;
			len_max = len_min;
			len_min = len_temp;
		}

		if (len_min <= min_val && len_max >= max_val)
			return TRUE;
		if (len_min >= min_val && len_min <= max_val)
			return TRUE;
		if (len_max >= min_val && len_max <= max_val)
			return TRUE;
	}
	return FALSE;
}

double CForceEngine::CalcPForcWoodArmer(T_ELEM_K ElemK, int node, BOOL bMax/*=TRUE*/)
{
	double len = 0;
	T_SLAB_FORCE_COMPACT SlabForce; SlabForce.initialize();
	//if(!m_pDoc->m_pPostCtrl->GetDesignResult()->Get_SlabForce(ElemK, 0, SlabForce)) return 0;


	if(!m_mapSlabForce.Lookup(ElemK, SlabForce))
	{
		return 0;
	}

	double dVal1, dVal2;
	if(m_nWoodArmerTopBot == 0) // top          
		len = SlabForce.dForce[node + 1];
	else if(m_nWoodArmerTopBot == 1) // bottom        
		len = SlabForce.dForce[node + 5 + 1];
	else if(m_nWoodArmerTopBot == 2) // both      
	{      
		dVal1 = fabs(SlabForce.dForce[node + 1]);
		dVal2 = fabs(SlabForce.dForce[node + 5 + 1]);
		if(bMax)
			len = max(dVal1, dVal2);
		else
			len = min(dVal1, dVal2);
	}     
	return len;
}

/*
double CForceEngine::CalcPForcValue_G(T_STRP_DG &pforc, int node)
{
double	len;
//			20,  21,  22,  23,  24,  25,   26,   27,   28
//		 FXX, FYY, FZZ, FXY, FYZ, FXZ, MAXF, MINF, ANGF,
//			29,  30,  31,  32,  33,  34,   35,   36,   37
//     MXX, MYY, MZZ, MXY, MYZ, MXZ, MAXM, MINM, ANGM,
//      38,  39
//     Vxx, Vyy
switch (m_PForcComponent) {
case PFORC_COMPONENT_FXX_G:
len = pforc.dblStress[node][20];
break;
case PFORC_COMPONENT_FYY_G:
len = pforc.dblStress[node][21];
break;
case PFORC_COMPONENT_FZZ_G:
len = pforc.dblStress[node][22];
break;
case PFORC_COMPONENT_FXY_G:
len = pforc.dblStress[node][23];
break;
case PFORC_COMPONENT_FYZ_G:
len = pforc.dblStress[node][24];
break;
case PFORC_COMPONENT_FXZ_G:
len = pforc.dblStress[node][25];
break;
case PFORC_COMPONENT_FMX_G:
len = pforc.dblStress[node][26];
break;
case PFORC_COMPONENT_FMN_G:
len = pforc.dblStress[node][27];
break;
case PFORC_COMPONENT_MXX_G:
len = pforc.dblStress[node][29];
break;
case PFORC_COMPONENT_MYY_G:
len = pforc.dblStress[node][30];
break;
case PFORC_COMPONENT_MZZ_G:
len = pforc.dblStress[node][31];
break;
case PFORC_COMPONENT_MXY_G:
len = pforc.dblStress[node][32];
break;
case PFORC_COMPONENT_MYZ_G:
len = pforc.dblStress[node][33];
break;
case PFORC_COMPONENT_MXZ_G:
len = pforc.dblStress[node][34];
break;
case PFORC_COMPONENT_MMX_G:
len = pforc.dblStress[node][35];
break;
case PFORC_COMPONENT_MMN_G:
len = pforc.dblStress[node][36];
break;
case PFORC_COMPONENT_VXX_G:
len = pforc.dblStress[node][38];
break;
case PFORC_COMPONENT_VYY_G:
len = pforc.dblStress[node][39];
break;
case PFORC_COMPONENT_FMX_ABS_G:
len = (fabs(pforc.dblStress[node][26]) > fabs(pforc.dblStress[node][27]))? pforc.dblStress[node][26]:pforc.dblStress[node][27];
break;
case PFORC_COMPONENT_MMX_ABS_G:
len = (fabs(pforc.dblStress[node][35]) > fabs(pforc.dblStress[node][36]))? pforc.dblStress[node][35]:pforc.dblStress[node][36];
break;
case PFORC_COMPONENT_VMX_ABS_G:
len = (fabs(pforc.dblStress[node][38]) > fabs(pforc.dblStress[node][39]))? pforc.dblStress[node][38]:pforc.dblStress[node][39];
break;


}

return len;
}*/

void CForceEngine::SetPForcComponent(T_STRP_DL &pforc, int node, double pforc_val)
{
	switch (m_PForcComponent) {
	case PFORC_COMPONENT_FXX:
		pforc.dblStress[node][14] = pforc_val;
		break;
	case PFORC_COMPONENT_FYY:
		pforc.dblStress[node][15] = pforc_val;
		break;
	case PFORC_COMPONENT_FXY:
		pforc.dblStress[node][16] = pforc_val;
		break;
	case PFORC_COMPONENT_FMX:
		pforc.dblStress[node][17] = pforc_val;
		break;
	case PFORC_COMPONENT_FMN:
		pforc.dblStress[node][18] = pforc_val;
		break;
	case PFORC_COMPONENT_MXX:
		pforc.dblStress[node][20] = pforc_val;
		break;
	case PFORC_COMPONENT_MYY:
		pforc.dblStress[node][21] = pforc_val;
		break;
	case PFORC_COMPONENT_MXY:
		pforc.dblStress[node][22] = pforc_val;
		break;
	case PFORC_COMPONENT_MMX:
		pforc.dblStress[node][23] = pforc_val;
		break;
	case PFORC_COMPONENT_MMN:
		pforc.dblStress[node][24] = pforc_val;
		break;
	case PFORC_COMPONENT_VXX:
		pforc.dblStress[node][26] = pforc_val;
		break;
	case PFORC_COMPONENT_VYY:
		pforc.dblStress[node][27] = pforc_val;
		break;
	}
}

/*
void CForceEngine::SetPForcComponent_G(T_STRP_DG &pforc, int node, double pforc_val)
{
//			20,  21,  22,  23,  24,  25,   26,   27,   28
//		 FXX, FYY, FZZ, FXY, FYZ, FXZ, MAXF, MINF, ANGF,
//			29,  30,  31,  32,  33,  34,   35,   36,   37
//     MXX, MYY, MZZ, MXY, MYZ, MXZ, MAXM, MINM, ANGM,
//      38,  39
//     Vxx, Vyy
switch (m_PForcComponent) {
case PFORC_COMPONENT_FXX_G:
pforc.dblStress[node][20] = pforc_val;
break;
case PFORC_COMPONENT_FYY_G:
pforc.dblStress[node][21] = pforc_val;
break;
case PFORC_COMPONENT_FZZ_G:
pforc.dblStress[node][22] = pforc_val;
break;
case PFORC_COMPONENT_FXY_G:
pforc.dblStress[node][23] = pforc_val;
break;
case PFORC_COMPONENT_FYZ_G:
pforc.dblStress[node][24] = pforc_val;
break;
case PFORC_COMPONENT_FXZ_G:
pforc.dblStress[node][25] = pforc_val;
break;
case PFORC_COMPONENT_FMX_G:
pforc.dblStress[node][26] = pforc_val;
break;
case PFORC_COMPONENT_FMN_G:
pforc.dblStress[node][27] = pforc_val;
break;
case PFORC_COMPONENT_MXX_G:
pforc.dblStress[node][29] = pforc_val;
break;
case PFORC_COMPONENT_MYY_G:
pforc.dblStress[node][30] = pforc_val;
break;
case PFORC_COMPONENT_MZZ_G:
pforc.dblStress[node][31] = pforc_val;
break;
case PFORC_COMPONENT_MXY_G:
pforc.dblStress[node][32] = pforc_val;
break;
case PFORC_COMPONENT_MYZ_G:
pforc.dblStress[node][33] = pforc_val;
break;
case PFORC_COMPONENT_MXZ_G:
pforc.dblStress[node][34] = pforc_val;
break;
case PFORC_COMPONENT_MMX_G:
pforc.dblStress[node][35] = pforc_val;
break;
case PFORC_COMPONENT_MMN_G:
pforc.dblStress[node][36] = pforc_val;
break;
case PFORC_COMPONENT_VXX_G:
pforc.dblStress[node][38] = pforc_val;
break;
case PFORC_COMPONENT_VYY_G:
pforc.dblStress[node][39] = pforc_val;
break;
}
}*/

#if defined(__OLD_OUTPUT_VALUE)
void CForceEngine::OutputPForcNumbers(CDC *pDC)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	int			  i, j, elem_num, node_in_elem, v_num;
	T_ELEM_K	ekey;
	T_ELEM_D	edata;
	T_STRP_DL	pforc;
	C3DPoint	node[4],DrawPoint;
	CPoint		text_p;
	TCHAR		  fmt_str[10], text_str[512];
	CFont		  ft, *old_ft;

	BOOL		fl_bak;
	POSITION	pos;
	CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray <CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					edge_list;

	if (!m_bPForcDataSet)
		return;

	if (gm->m_DOPT.TX.m_bNumberOpaque)
		pDC->SetBkMode(OPAQUE);
	else
		pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
	pDC->SetBkColor(gm->m_DOPT.TX.m_NumberBackCol);
	pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);

	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T("%s%de"), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T("%s%df"), _T("%."), gm->m_NumberDecimalPoint);

	fl_bak = gm->m_DOPT.DR.m_bFrameLine;
	gm->m_DOPT.DR.m_bFrameLine = TRUE;

	if (gm->m_DOPT.TX.m_bNumberSelOnly) {
	}
	else {

		gm->SetNumberFontOrientation(0);
		ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
		old_ft = (CFont *) pDC->SelectObject(&ft);

		//elem_num = gm->m_EKeyListActive.GetSize();
		BOOL bGrpFltMode=gm->m_pGPSCtrl->IsGroupFilterMode();
		if(!bGrpFltMode)elem_num = gm->m_EKeyListActive.GetSize();
		else            elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize(); 

		for (i=0;i<elem_num;i++) 
		{
			//ekey = gm->m_EKeyListActive[i];
			if(!bGrpFltMode)ekey = gm->m_EKeyListActive[i];
			else            ekey = gm->m_pDispFilter->m_aGrpEKey[i]; 

			if(!gm->m_pGPSCtrl->IsActiveElem(ekey))
				continue;

			m_pDoc->m_pAttrCtrl->GetElem(ekey, edata);

			if (!m_pDoc->m_pAttrCtrl->IsPlate(edata.eltyp))
				continue;
			node_in_elem = m_pDoc->m_pAttrCtrl->GetNumNode(edata.eltyp, edata.elnod);

			if (m_bDeformedShapeContour) {
				gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list);
			}
			else {
				gm->GetShapeElement(ekey, polygon_list, &edge_list);
			}

			v_num = polygon_list[0]->GetCount();
			pos = polygon_list[0]->GetHeadPosition();
			for (j=0;j<v_num;j++) 
				node[j] = polygon_list[0]->GetNext(pos);

			BOOL bDelete=FALSE;
			if(m_PForcComponent == PFORC_COMPONENT_MOMENT_COMB)
			{
				T_SLAB_FORCE_COMPACT SlabForce;
				if(m_bAverage)
				{
					if(!IsSubDomainElem(ekey))
					{
						bDelete = TRUE;
					}
				}
				else
				{
					if(!m_mapSlabForce.Lookup(ekey, SlabForce))
					{
						bDelete = TRUE;
					}
				}        
			}
			else
			{
				if(!GetPlateForce(ekey, pforc)) bDelete = TRUE;
			}	

			if(bDelete) 
			{
				for(j=0;j<polygon_list.GetSize();j++) 
				{
					polygon_list[j]->RemoveAll();
					delete polygon_list[j];
					edge_list[j]->RemoveAll();
					delete edge_list[j];
				}
				polygon_list.RemoveAll();
				edge_list.RemoveAll();

				continue; //KYE-HONG-20020515
			}

			for(j=0;j<v_num-1;j++) 
			{
				node[v_num-1].x += node[j].x;
				node[v_num-1].y += node[j].y;
				node[v_num-1].z += node[j].z;
			}

			DrawPoint.x = (node[v_num-1].x/((double) v_num));
			DrawPoint.y = (node[v_num-1].y/((double) v_num));
			DrawPoint.z = (node[v_num-1].z/((double) v_num));


			double dMaxPForc,dMinPForc;
			if(gm->m_nValOpt == 1)
			{
				// Vector Type인경우 Min/Max두개가 존재한다 
				if(m_PForcComponent == PFORC_COMPONENT_FVT || 
					m_PForcComponent == PFORC_COMPONENT_MVT)           
				{
					dMaxPForc = GetMaxElemPForc(pforc, node_in_elem);
					dMinPForc = GetMinElemPForc(pforc, node_in_elem);
				}
				else
					dMaxPForc = dMinPForc = CalcPForcValue(pforc, 0);
			}
			else
			{
				if(m_PForcComponent == PFORC_COMPONENT_MOMENT_COMB)  
				{
					dMaxPForc = GetMaxWoodArmer(ekey, node_in_elem);
					dMinPForc = GetMinWoodArmer(ekey, node_in_elem);
				}
				else
				{
					dMaxPForc = GetMaxElemPForc(pforc, node_in_elem);
					dMinPForc = GetMinElemPForc(pforc, node_in_elem);
				}
			}
			/*if(m_nPlateForceLocalGlobal == 0) // Global Mode
			{
			dMaxPForc = GetMaxElemPForc_G(pforc_g, node_in_elem);
			dMinPForc = GetMinElemPForc_G(pforc_g, node_in_elem);
			}
			else*/
			double dAbsMaxPForc = 0.;
			if ( (m_PForcComponent != PFORC_COMPONENT_FVT && m_PForcComponent != PFORC_COMPONENT_MVT) 
				|| (m_bVectorPositive && m_bVectorNegative) )
				dAbsMaxPForc = (fabs(dMaxPForc) > fabs(dMinPForc))? dMaxPForc:dMinPForc;
			else if (m_bVectorPositive)
				dAbsMaxPForc = fabs(dMaxPForc);
			else if (m_bVectorNegative)
				dAbsMaxPForc = fabs(dMinPForc);

			/////////////////////////////////////////////////////////////////////////////////////////////
			if(gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
			{
				double dLimit = (m_dMaxValue-m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;

				// MNET:XXXX-CJJEONG-20080508
				if ( (m_PForcComponent != PFORC_COMPONENT_FVT && m_PForcComponent != PFORC_COMPONENT_MVT) 
					|| (m_bVectorPositive && m_bVectorNegative) )
				{
					switch(gm->m_DOPT.TX.m_nOutputMinMaxType)
					{
					case 0: // Min & Max
						if((m_dMaxValue-dMaxPForc) <= dLimit)       
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,dMaxPForc);
						else if((dMinPForc-m_dMinValue) <= dLimit)  
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,dMinPForc);
						break;
					case 1: // Abs Max
						if(fabs(m_dMaxValue) >= fabs(m_dMinValue))
						{
							if( fabs(m_dMaxValue)-fabs(dAbsMaxPForc) <= dLimit)
								DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dAbsMaxPForc);
						}
						else
						{
							if( fabs(m_dMinValue)-fabs(dAbsMaxPForc) <= dLimit)
								DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dAbsMaxPForc);
						}
						break;
					case 2: // Max
						if((m_dMaxValue-dMaxPForc) <= dLimit)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,dMaxPForc);
						break;
					case 3: // Min
						if((dMinPForc-m_dMinValue) <= dLimit)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,dMinPForc);
						break;
					}
				}
				else if (m_bVectorPositive && m_dMaxValue>0.)
				{
					switch(gm->m_DOPT.TX.m_nOutputMinMaxType)
					{
					case 0: // Min & Max
						if((m_dMaxValue-dMaxPForc) <= dLimit  && dMaxPForc>0.)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,dMaxPForc);
						else if((dMinPForc-m_dMinValue) <= dLimit && dMinPForc>0.)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,dMinPForc);
						break;
					case 1: // Abs Max
						if(fabs(m_dMaxValue)-fabs(dAbsMaxPForc) <= dLimit)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dAbsMaxPForc);
						break;
					case 2: // Max
						if((m_dMaxValue-dMaxPForc) <= dLimit && dMaxPForc>0.)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,dMaxPForc);
						break;
					case 3: // Min            
						if ((dMaxPForc-m_dMinValue) <= dLimit && dMaxPForc>0.)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,dMaxPForc);            
						break;
					}
				}
				else if (m_bVectorNegative && m_dMinValue<0.)
				{
					switch(gm->m_DOPT.TX.m_nOutputMinMaxType)
					{
					case 0: // Min & Max
						if((m_dMaxValue-dMaxPForc) <= dLimit  && dMaxPForc<0.)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,dMaxPForc);
						else if((dMinPForc-m_dMinValue) <= dLimit && dMinPForc<0.)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,dMinPForc);
						break;
					case 1: // Abs Max
						if( fabs(m_dMinValue)-fabs(dAbsMaxPForc) <= dLimit)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dAbsMaxPForc);
						break;
					case 2: // Max
						if((m_dMaxValue-dMinPForc) <= dLimit && dMinPForc<0)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,dMinPForc);
						break;
					case 3: // Min
						if((dMinPForc-m_dMinValue) <= dLimit && dMinPForc<0.)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,dMinPForc);
						break;
					}
				}
				//////////////////////////////////////////////////////////////////////////////////////
			}
			else // output all values;
			{
				if (gm->m_bVirtualMode)
					text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(DrawPoint);
				else
					text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(DrawPoint);

				// MNET:XXXX-CJJEONG-20080508
				BOOL bText = TRUE;
				if (m_bVectorPositive && m_bVectorNegative)
					_stprintf(text_str, fmt_str, dAbsMaxPForc);
				else if (m_bVectorPositive && dMaxPForc>0.)
					_stprintf(text_str, fmt_str, dMaxPForc);
				else if (m_bVectorNegative && dMinPForc<0.)
					_stprintf(text_str, fmt_str, dMinPForc);
				else bText = FALSE;

				if(text_p.x>=0 && text_p.y>=0 && bText)
					//pDC->TextOut(text_p.x, text_p.y, text_str);
						pDC->TextOut(text_p.x, text_p.y+10, text_str);
			}

			for (j=0;j<polygon_list.GetSize();j++) {
				polygon_list[j]->RemoveAll();
				delete polygon_list[j];
				edge_list[j]->RemoveAll();
				delete edge_list[j];
			}
			polygon_list.RemoveAll();
			edge_list.RemoveAll();
		}
		pDC->SelectObject(old_ft);
		ft.DeleteObject();

	}

	gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}
#else
void CForceEngine::OutputPForcNumbers(CDC *pDC)
{
	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;

	int			  i, j, elem_num, node_in_elem, v_num;
	T_ELEM_K	ekey;
	T_ELEM_D	edata;
	T_STRP_DL	pforc;
	C3DPoint	node[4], DrawPoint;
	CPoint		text_p;
	TCHAR		  fmt_str[10], text_str[512];
	CFont		  ft, *old_ft;

	BOOL		fl_bak;
	POSITION	pos;
	CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray <CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					edge_list;

	if (!m_bPForcDataSet)
		return;

	GPostTextOut TextOutModel;
	TextOutModel.StartPlateForceVal();
	TextOutModel.SetDC(pDC);
	TextOutModel.SettingPlateForce(gm);

	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T("%s%de"), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T("%s%df"), _T("%."), gm->m_NumberDecimalPoint);

	fl_bak = gm->m_DOPT.DR.m_bFrameLine;
	gm->m_DOPT.DR.m_bFrameLine = TRUE;

	if (gm->m_DOPT.TX.m_bNumberSelOnly) {
	}
	else {

		TextOutModel.Font4PlateForce(gm, 0);

		//elem_num = gm->m_EKeyListActive.GetSize();
		BOOL bGrpFltMode = gm->m_pGPSCtrl->IsGroupFilterMode();
		if (!bGrpFltMode)elem_num = gm->m_EKeyListActive.GetSize();
		else            elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize();

		for (i = 0; i < elem_num; i++)
		{
			//ekey = gm->m_EKeyListActive[i];
			if (!bGrpFltMode)ekey = gm->m_EKeyListActive[i];
			else            ekey = gm->m_pDispFilter->m_aGrpEKey[i];

			if (!gm->m_pGPSCtrl->IsActiveElem(ekey))
				continue;

			m_pDoc->m_pAttrCtrl->GetElem(ekey, edata);

			if (!m_pDoc->m_pAttrCtrl->IsPlate(edata.eltyp))
				continue;
			node_in_elem = m_pDoc->m_pAttrCtrl->GetNumNode(edata.eltyp, edata.elnod);

			if (m_bDeformedShapeContour) {
				gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list);
			}
			else {
				gm->GetShapeElement(ekey, polygon_list, &edge_list);
			}

			v_num = polygon_list[0]->GetCount();
			pos = polygon_list[0]->GetHeadPosition();
			for (j = 0; j < v_num; j++)
				node[j] = polygon_list[0]->GetNext(pos);

			BOOL bDelete = FALSE;
			if (m_PForcComponent == PFORC_COMPONENT_MOMENT_COMB)
			{
				T_SLAB_FORCE_COMPACT SlabForce;
				if (m_bAverage)
				{
					if (!IsSubDomainElem(ekey))
					{
						bDelete = TRUE;
					}
				}
				else
				{
					if (!m_mapSlabForce.Lookup(ekey, SlabForce))
					{
						bDelete = TRUE;
					}
				}
			}
			else
			{
				if (!GetPlateForce(ekey, pforc)) bDelete = TRUE;
			}

			if (bDelete)
			{
				for (j = 0; j < polygon_list.GetSize(); j++)
				{
					polygon_list[j]->RemoveAll();
					delete polygon_list[j];
					edge_list[j]->RemoveAll();
					delete edge_list[j];
				}
				polygon_list.RemoveAll();
				edge_list.RemoveAll();

				continue; //KYE-HONG-20020515
			}

			for (j = 0; j < v_num - 1; j++)
			{
				node[v_num - 1].x += node[j].x;
				node[v_num - 1].y += node[j].y;
				node[v_num - 1].z += node[j].z;
			}

			DrawPoint.x = (node[v_num - 1].x / ((double)v_num));
			DrawPoint.y = (node[v_num - 1].y / ((double)v_num));
			DrawPoint.z = (node[v_num - 1].z / ((double)v_num));


			double dMaxPForc, dMinPForc;
			if (gm->m_nValOpt == 1)
			{
				// Vector Type인경우 Min/Max두개가 존재한다 
				if (m_PForcComponent == PFORC_COMPONENT_FVT ||
					m_PForcComponent == PFORC_COMPONENT_MVT)
				{
					dMaxPForc = GetMaxElemPForc(pforc, node_in_elem);
					dMinPForc = GetMinElemPForc(pforc, node_in_elem);
				}
				else
					dMaxPForc = dMinPForc = CalcPForcValue(pforc, 0);
			}
			else
			{
				if (m_PForcComponent == PFORC_COMPONENT_MOMENT_COMB)
				{
					dMaxPForc = GetMaxWoodArmer(ekey, node_in_elem);
					dMinPForc = GetMinWoodArmer(ekey, node_in_elem);
				}
				else
				{
					dMaxPForc = GetMaxElemPForc(pforc, node_in_elem);
					dMinPForc = GetMinElemPForc(pforc, node_in_elem);
				}
			}
			/*if(m_nPlateForceLocalGlobal == 0) // Global Mode
			{
			dMaxPForc = GetMaxElemPForc_G(pforc_g, node_in_elem);
			dMinPForc = GetMinElemPForc_G(pforc_g, node_in_elem);
			}
			else*/
			double dAbsMaxPForc = 0.;
			if ((m_PForcComponent != PFORC_COMPONENT_FVT && m_PForcComponent != PFORC_COMPONENT_MVT)
				|| (m_bVectorPositive && m_bVectorNegative))
				dAbsMaxPForc = (fabs(dMaxPForc) > fabs(dMinPForc)) ? dMaxPForc : dMinPForc;
			else if (m_bVectorPositive)
				dAbsMaxPForc = fabs(dMaxPForc);
			else if (m_bVectorNegative)
				dAbsMaxPForc = fabs(dMinPForc);

			/////////////////////////////////////////////////////////////////////////////////////////////
			if (gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
			{
				double dLimit = (m_dMaxValue - m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;

				// MNET:XXXX-CJJEONG-20080508
				if ((m_PForcComponent != PFORC_COMPONENT_FVT && m_PForcComponent != PFORC_COMPONENT_MVT)
					|| (m_bVectorPositive && m_bVectorNegative))
				{
					switch (gm->m_DOPT.TX.m_nOutputMinMaxType)
					{
					case 0: // Min & Max
						if ((m_dMaxValue - dMaxPForc) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, dMaxPForc);
						else if ((dMinPForc - m_dMinValue) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, dMinPForc);
						break;
					case 1: // Abs Max
						if (fabs(m_dMaxValue) >= fabs(m_dMinValue))
						{
							if (fabs(m_dMaxValue) - fabs(dAbsMaxPForc) <= dLimit)
								DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, dAbsMaxPForc);
						}
						else
						{
							if (fabs(m_dMinValue) - fabs(dAbsMaxPForc) <= dLimit)
								DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, dAbsMaxPForc);
						}
						break;
					case 2: // Max
						if ((m_dMaxValue - dMaxPForc) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, dMaxPForc);
						break;
					case 3: // Min
						if ((dMinPForc - m_dMinValue) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, dMinPForc);
						break;
					}
				}
				else if (m_bVectorPositive && m_dMaxValue > 0.)
				{
					switch (gm->m_DOPT.TX.m_nOutputMinMaxType)
					{
					case 0: // Min & Max
						if ((m_dMaxValue - dMaxPForc) <= dLimit && dMaxPForc > 0.)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, dMaxPForc);
						else if ((dMinPForc - m_dMinValue) <= dLimit && dMinPForc > 0.)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, dMinPForc);
						break;
					case 1: // Abs Max
						if (fabs(m_dMaxValue) - fabs(dAbsMaxPForc) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, dAbsMaxPForc);
						break;
					case 2: // Max
						if ((m_dMaxValue - dMaxPForc) <= dLimit && dMaxPForc > 0.)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, dMaxPForc);
						break;
					case 3: // Min            
						if ((dMaxPForc - m_dMinValue) <= dLimit && dMaxPForc > 0.)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, dMaxPForc);
						break;
					}
				}
				else if (m_bVectorNegative && m_dMinValue < 0.)
				{
					switch (gm->m_DOPT.TX.m_nOutputMinMaxType)
					{
					case 0: // Min & Max
						if ((m_dMaxValue - dMaxPForc) <= dLimit && dMaxPForc < 0.)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, dMaxPForc);
						else if ((dMinPForc - m_dMinValue) <= dLimit && dMinPForc < 0.)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, dMinPForc);
						break;
					case 1: // Abs Max
						if (fabs(m_dMinValue) - fabs(dAbsMaxPForc) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, dAbsMaxPForc);
						break;
					case 2: // Max
						if ((m_dMaxValue - dMinPForc) <= dLimit && dMinPForc < 0)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, dMinPForc);
						break;
					case 3: // Min
						if ((dMinPForc - m_dMinValue) <= dLimit && dMinPForc < 0.)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, dMinPForc);
						break;
					}
				}
				//////////////////////////////////////////////////////////////////////////////////////
			}
			else // output all values;
			{
				if (gm->m_bVirtualMode)
					text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(DrawPoint);
				else
					text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(DrawPoint);

				// MNET:XXXX-CJJEONG-20080508
				BOOL bText = TRUE;
				if (m_bVectorPositive && m_bVectorNegative)
					_stprintf(text_str, fmt_str, dAbsMaxPForc);
				else if (m_bVectorPositive && dMaxPForc > 0.)
					_stprintf(text_str, fmt_str, dMaxPForc);
				else if (m_bVectorNegative && dMinPForc < 0.)
					_stprintf(text_str, fmt_str, dMinPForc);
				else bText = FALSE;

				if (text_p.x >= 0 && text_p.y >= 0 && bText)
					//pDC->TextOut(text_p.x, text_p.y, text_str);
					TextOutModel.TextOutPlateForce(text_p.x, text_p.y + 10, text_str);
			}

			for (j = 0; j < polygon_list.GetSize(); j++) {
				polygon_list[j]->RemoveAll();
				delete polygon_list[j];
				edge_list[j]->RemoveAll();
				delete edge_list[j];
			}
			polygon_list.RemoveAll();
			edge_list.RemoveAll();
		}
		TextOutModel.DeleteFont();
	}
	TextOutModel.EndPlateForceVal();
	gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}
#endif
void CForceEngine::DrawPForcContour(CDC *pDC)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	T_MIRE_K mkey;

	int			i, elem_num;
	BOOL		fl_bak=gm->m_DOPT.DR.m_bFrameLine;
	T_ELEM_D	elem_d;
	CPen		elem_pen, *old_pen;
	CArray <int, int>				type_list;
	CArray <GRE_Atom, GRE_Atom&>		atom_list;
	BOOL bEscapePressed = FALSE;
	BOOL bVectorMode = FALSE;
	BOOL bInActivebyUCSMode;
	double UCSV[3][3];


	if (!gm->m_bContour && !m_bOnCuttingLine ) { 
		gm->GPSDrawOriginal(pDC);
		return;
	}


	if ( (m_PForcComponent==PFORC_COMPONENT_FVT) || (m_PForcComponent==PFORC_COMPONENT_MVT))
	{
		InitVectorAdjustFactor(m_MaxAbsValue);
		bVectorMode = TRUE;
	}

	if(m_nPlateForceLocalGlobal == 0) // UCS Mode
		// Get UCS Vector
			GetUCSVector(m_NUCS,UCSV);

	if (m_bDeformedShapeContour) {
		if (gm->m_pDeformEngine == NULL) {
			return;
		}
		type_list.Add(gm->m_MinOTID + OBJECT_TYPE_DEFORMED);

		// 변형된 그림에 Undeformed Shape을 같이 그릴 경우.
		if (gm->m_DOPT.DR.m_bDrawInactive) {
			if (bVectorMode) {
				gm->m_DOPT.DR.m_bFrameLine = TRUE;
				gm->GPSDrawOriginal(pDC, TRUE);
			}
		}
	}
	else {
		type_list.Add(gm->m_MinOTID + OBJECT_TYPE_ORIGINAL);
	}

	elem_pen.CreatePen(PS_SOLID, gm->m_DOPT.DR.nElemHddn, m_pContourEngine->m_ElemColor);
	old_pen = (CPen *) pDC->SelectObject(&elem_pen);

	gm->m_pGPSCtrl->GetZSortedList(type_list, gm->m_EKeyListVisible_Mirror, atom_list);
	elem_num = atom_list.GetSize();
	for (i=0;i<elem_num;i++) 
	{
		//if(gm->m_pGPSCtrl->WatchEscKeyPress()) bEscapePressed = TRUE;
		if(gm->m_pGPSCtrl->WatchEscKeyPress()) return;
		if (gm->m_pGPSCtrl->IsZoomAllState() ||
			gm->m_pGPSCtrl->IsObjectInClientWindow(atom_list[i].m_OType, atom_list[i].m_OKey)) {
				mkey.keymap = atom_list[i].m_OKey;
				m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d);


				bInActivebyUCSMode = FALSE;
				if(m_nPlateForceLocalGlobal == 0 && m_pDoc->m_pAttrCtrl->IsPlate(elem_d.eltyp)) // UCS Mode
					bInActivebyUCSMode = !IsParallelToUCSPlane(mkey.key.elem_k,UCSV);

				if(gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey) && (m_pDoc->m_pAttrCtrl->IsPlate(elem_d.eltyp)) && !bEscapePressed && !bInActivebyUCSMode)
				{
					if(bVectorMode) 
					{
						//KYE-HONG-20020903 Hidden처리되게 해달라고 함 
						//gm->m_bFrameLine = TRUE;		// Vector를 그릴 경우 Hidden을 끈다.
						if (m_bDeformedShapeContour)
							gm->m_pDeformEngine->DrawDeformedElement(pDC, atom_list[i].m_OKey);
						else
							gm->GPSDrawElement(pDC, atom_list[i].m_OKey);
						DoPForcElementVector(pDC, atom_list[i].m_OKey);
					}
					else {
						gm->m_DOPT.DR.m_bFrameLine = fl_bak;
						DoPForcElementContour(pDC, atom_list[i].m_OKey);
					}
				}
				else {
					//KYE-HONG-20020903 Hidden처리되게 해달라고 함 
					//if (bVectorMode)  gm->m_bFrameLine = TRUE;		// Vector를 그릴 경우 Hidden을 끈다.
					//else              gm->m_bFrameLine = fl_bak;
					if (m_bDeformedShapeContour)
						gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, atom_list[i].m_OKey);
					else
						gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
				}
		}
	}

	gm->m_DOPT.DR.m_bFrameLine = fl_bak;


	gm->m_pGPSCtrl->XGL_Begin_CuttingPLDiagram();
	if (m_bOnCuttingLine)
		DrawCuttingLineDiagrams(pDC);
	gm->m_pGPSCtrl->XGL_End_CuttingPLDiagram();



	// 변형된 그림에 Undeformed Shape을 같이 그릴 경우.
	if (m_bDeformedShapeContour && gm->m_DOPT.DR.m_bDrawInactive && !bEscapePressed) {
		if (!bVectorMode)
			gm->GPSDrawOriginal(pDC, TRUE);
	}

	pDC->SelectObject(old_pen);
	elem_pen.DeleteObject();

	//----------------------------------------------------------------------
	// UCS Icon Drawing
	//----------------------------------------------------------------------
	if(m_nPlateForceLocalGlobal == 0 && gm->m_bVirtualMode && m_bPrintUCSAxis) 
	{
		if(CGPSAMRUtil::GetInstance()->IsPerspectiveMode() != TRUE)
		{      
			double UCS_vector[3][3];      
			GetUCSVector(m_NUCS,UCS_vector);
			DrawUCSPlaneIcon(pDC,UCS_vector);
		}
		//Sjhuh - 2013-08-19 UCS 좌표 설정 후 Perspective View 에서 PrintView 기능을 실행 하면 해당 좌표 축을 나타내는 기능이 깨지기 때문에
		//여기서 기능을 막았음.
	}
}

// DATE : 2002.9.12. by KYE-HONG
// FUNC : 임의 방향으로 pforce를 구한다음 이것에 
//        해당하는 Diagram을 그린다. 
void	CForceEngine::DrawPForcContour_UserDir(CDC *pDC)
{
	I_GPSModel *gm=(I_GPSModel *) m_pGPSModel;
	int i;
	int nNumDatas;

	T_CLWP_D    ClwpD;
	T_CUTLINE_D CutLineD;
	double LVec[3][3];
	double DiagVector[3],LineVector[3];

	double total_max = -DBL_MAX;
	double total_min = DBL_MAX;
	double AbsMax;
	double dCutLineAdjustFactor;


	gm->GPSDrawOriginal(pDC);

	T_ELEM_K tempKey = 10000000;//중복을 피하기 위해 Element Key로 사용되지 않는 번호를 사용
	gm->GPS_XGL_Begin_Diagram(tempKey);

	int nCL = 0;
	for(nCL = 0; nCL<m_arDrawCLWPMnMx.GetSize(); nCL++) 
	{
		if(total_max<m_arDrawCLWPMnMx[nCL].Max) total_max = m_arDrawCLWPMnMx[nCL].Max;
		if(total_min>m_arDrawCLWPMnMx[nCL].Min) total_min = m_arDrawCLWPMnMx[nCL].Min;
	}
	AbsMax = __max(fabs(total_max),fabs(total_min));
	InitCutLineAdjustFactor(AbsMax,dCutLineAdjustFactor);

	nCL=0; 
	for(int ii=0; ii<gm->m_pBDT->PFUD.arClwp.GetSize(); ii++)
	{
		ClwpD=gm->m_pBDT->PFUD.arClwp[ii];    
		for(i=0; i<3; i++)LineVector[i] = ClwpD.Point2[i]-ClwpD.Point1[i];

		int ntype,etype;
		gm->RE_GetNode_ElemTypeByCDBDocSelection(ntype,etype);
		nNumDatas = m_parDrawCLWP[nCL]->GetSize();

		for(i = 0; i < nNumDatas; i++)
		{
			CutLineD = m_parDrawCLWP[nCL]->GetAt(i);

			BOOL bZoomAll   = gm->m_pGPSCtrl->IsZoomAllState();
			BOOL bInClient  = gm->m_pGPSCtrl->IsObjectInClientWindow(etype, CutLineD.KeyElem);
			BOOL bIsActive  = gm->IsActiveElem(CutLineD.KeyElem);
			if(!( bZoomAll || bInClient ))continue;
			if(!bIsActive) continue; 

			m_pDoc->calcPlaneLocalVector(CutLineD.KeyElem, LVec);

			if(gm->m_pBDT->PFUD.nDir == 0) // vertical
			{
				DiagVector[0] = LVec[2][0];
				DiagVector[1] = LVec[2][1];
				DiagVector[2] = LVec[2][2];
			}
			else
			{
				CMathFunc::mathCross(LineVector,LVec[2],DiagVector);
				CMathFunc::mathNormalize(DiagVector,DiagVector);
			}

			if(gm->m_pBDT->PFUD.bRvrs)
			{
				DiagVector[0] = -DiagVector[0];
				DiagVector[1] = -DiagVector[1];
				DiagVector[2] = -DiagVector[2];
			}

			C3DPoint	ps, pss, pe, pee,pm;
			double dVal1,dVal2;

			ps = CutLineD.Point1;
			pe = CutLineD.Point2;
			dVal1 = CutLineD.dPoint1Val;
			dVal2 = CutLineD.dPoint2Val;
			if (gm->m_AnimEngine.m_bAnimateContour)
			{
				dVal1 *= gm->m_AnimEngine.GetAnimationFactor(TRUE);
				dVal2 *= gm->m_AnimEngine.GetAnimationFactor(TRUE);
			}

			CUtilFuncs::GetVectorDirectionPoint(DiagVector,dVal1,gm->m_pBDT->PFUD.dScFc*dCutLineAdjustFactor,ps,pss );
			CUtilFuncs::GetVectorDirectionPoint(DiagVector,dVal2,gm->m_pBDT->PFUD.dScFc*dCutLineAdjustFactor,pe,pee );

			CPen pen,*old_pen;
			pen.CreatePen(PS_SOLID, gm->m_nLineWidth*1.0, gm->m_CuttinLineColor);
			old_pen = (CPen *) pDC->SelectObject(&pen);

			if(gm->m_bVirtualMode)
			{
				gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, ps, pss);
				gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, pe, pee);
			}
			else
			{
				gm->m_pGPSCtrl->DrawLine3D(pDC, ps, pss);
				gm->m_pGPSCtrl->DrawLine3D(pDC, pe, pee);
			}

			pDC->SelectObject(old_pen);
			pen.DeleteObject();

			pen.CreatePen(PS_SOLID, gm->m_nLineWidth*2.0, gm->m_CuttinLineColor);
			old_pen = (CPen *) pDC->SelectObject(&pen);

			if(gm->m_bVirtualMode)
			{
				gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, pss, pee);
				gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, ps, pe);
			}
			else
			{
				gm->m_pGPSCtrl->DrawLine3D(pDC, pss, pee);		
				gm->m_pGPSCtrl->DrawLine3D(pDC, ps, pe);
			}

			pDC->SelectObject(old_pen);
			pen.DeleteObject();
			///////////////////////////////////////////////////////////////////////////
			if(gm->m_pBDT->PFUD.bValOutput == TRUE)
			{
				if(gm->m_pBDT->PFUD.bMnMxOnly == TRUE)
				{
					if(fabs(dVal1-m_arDrawCLWPMnMx[nCL].Max) < 1e-8) 
						OutputCutLineNumber(pDC,&pss,dVal1);
					else if(fabs(dVal1-m_arDrawCLWPMnMx[nCL].Min) < 1e-8) 
						OutputCutLineNumber(pDC,&pss,dVal1);
					if(fabs(dVal2-m_arDrawCLWPMnMx[nCL].Max) < 1e-8) 
						OutputCutLineNumber(pDC,&pee,dVal2);
					else if(fabs(dVal2-m_arDrawCLWPMnMx[nCL].Min) < 1e-8) 
						OutputCutLineNumber(pDC,&pee,dVal2);
				}
				else
				{
					OutputCutLineNumber(pDC,&pss,dVal1);
					OutputCutLineNumber(pDC,&pee,dVal2);
				}
			}      
		}
		nCL++; 
	} 
	gm->GPS_XGL_End_Elem();
}

BOOL CForceEngine::IsOnUCSPlane(T_ELEM_D& elem_d,double UCSD[9])
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	CArray <C3DPoint,C3DPoint> arNodes;
	T_NODE_D node_d;
	C3DPoint pnt;

	int nNode = m_pDoc->m_pAttrCtrl->GetNumNode(elem_d.eltyp, elem_d.elnod);

	for(int i=0; i<nNode; i++)
	{
		m_pDoc->m_pAttrCtrl->GetNode(elem_d.elnod[i],node_d);
		pnt.Set(node_d.x,node_d.y,node_d.z);
		arNodes.Add(pnt);
	}
	if(gm->m_pGPSCtrl->IsOnThePlane(UCSD,arNodes,1e-8))
		return TRUE;

	return FALSE;
}

BOOL CForceEngine::IsParallelToUCSPlane(T_ELEM_K elem_k,double UCSV[3][3])
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	double PlaneLocalVector[3][3];
	if(!m_pDoc->calcPlaneLocalVector(elem_k, PlaneLocalVector)) return FALSE;

	//if(1.0-fabs(CMathFunc::mathDot(PlaneLocalVector[2],UCSV[2])) < 1e-12)
	if(1.0-fabs(CMathFunc::mathDot(PlaneLocalVector[2],UCSV[2]))<0.0001523) // 1.0 Degree를 오차범위로 
		return TRUE;

	return FALSE;
}


void CForceEngine::DoPForcElementVector(CDC *pDC, T_ELEM_K ekey)
{
	T_MIRE_K mkey;
	mkey.keymap = ekey;

	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;
	CClientDC			dc(gm->m_pMyView);
	int				i, node_num;
	double			angle, local_vec[3][3], node_p[4][3],
		max_val, min_val;
	T_STRP_DL		pforc;
	T_ELEM_D		edata;
	CPen			p1_pen, p2_pen, *old_pen,*old_pen2;
	C3DPoint		pnt_p1, arr_p11, arr_p12, pnt_p2, arr_p21, arr_p22, pnt_c;

	if ((gm->m_pDeformEngine==NULL) ||
		(m_pContourEngine==NULL)) return;

	if(!GetPlateForce(mkey.key.elem_k, pforc)) return;
	if (m_PForcComponent == PFORC_COMPONENT_FVT) {
		angle = pforc.dblStress[0][19];
		max_val = pforc.dblStress[0][17];
		min_val = pforc.dblStress[0][18];
	}
	else {
		angle = pforc.dblStress[0][25];
		max_val = pforc.dblStress[0][23];
		min_val = pforc.dblStress[0][24];
	}

	gm->m_pGPSCtrl->XGL_Begin_Diagram(ekey,FALSE); // 20060224 Changkeun

	int nThkLine = GetVectorLineWidth();

	if(gm->m_bGradient) 
	{
		//p1_pen.CreatePen(PS_SOLID, gm->m_nLineWidth*dThkScFc, m_pContourEngine->GetValueColorGrad(max_val));
		//p2_pen.CreatePen(PS_SOLID, gm->m_nLineWidth*dThkScFc, m_pContourEngine->GetValueColorGrad(min_val));
		p1_pen.CreatePen(PS_SOLID, nThkLine, m_pContourEngine->GetValueColorGrad(max_val));
		p2_pen.CreatePen(PS_SOLID, nThkLine, m_pContourEngine->GetValueColorGrad(min_val));
	}
	else 
	{
		//p1_pen.CreatePen(PS_SOLID, gm->m_nLineWidth*dThkScFc, m_pContourEngine->GetValueColor(max_val));
		//p2_pen.CreatePen(PS_SOLID, gm->m_nLineWidth*dThkScFc, m_pContourEngine->GetValueColor(min_val));
		p1_pen.CreatePen(PS_SOLID, nThkLine, m_pContourEngine->GetValueColor(max_val));
		p2_pen.CreatePen(PS_SOLID, nThkLine, m_pContourEngine->GetValueColor(min_val));
	}


	if (m_bDeformedShapeContour) {
		m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, edata);
		node_num = m_pDoc->m_pAttrCtrl->GetNumNode(edata.eltyp, edata.elnod);
		for (i=0;i<node_num;i++) {
			gm->m_pDeformEngine->GetDisplacedPoint(edata.elnod[i], node_p[i]);
		}
		m_pDoc->calcPlaneLocalVector(node_num, node_p, edata.angle, local_vec);
		for (i=0;i<node_num-1;i++) {
			node_p[node_num-1][0] += node_p[i][0];
			node_p[node_num-1][1] += node_p[i][1];
			node_p[node_num-1][2] += node_p[i][2];
		}
		pnt_c.x = node_p[node_num-1][0] / ((double) node_num);
		pnt_c.y = node_p[node_num-1][1] / ((double) node_num);
		pnt_c.z = node_p[node_num-1][2] / ((double) node_num);
	}
	else {
		m_pDoc->calcPlaneLocalVector(mkey.key.elem_k, local_vec);
		m_pDoc->calcCenterElem(mkey.key.elem_k, pnt_c.x, pnt_c.y, pnt_c.z);
	}

	CMathFunc::mathRotate(angle,
		local_vec[2][0], local_vec[2][1], local_vec[2][2],
		local_vec[0][0], local_vec[0][1], local_vec[0][2]);
	CMathFunc::mathRotate(angle,
		local_vec[2][0], local_vec[2][1], local_vec[2][2],
		local_vec[1][0], local_vec[1][1], local_vec[1][2]);

	// Point 1
	CUtilFuncs::GetVectorDirectionPoint(local_vec[0], fabs(max_val),
		m_PForcVtAdjustFactor*m_PForcVtScaleFactor, pnt_c, pnt_p1);
	// Arrow Point 11
	CUtilFuncs::GetVectorDirectionPoint(local_vec[0], -max_val*0.2,
		m_PForcVtAdjustFactor*m_PForcVtScaleFactor, pnt_p1, arr_p11);
	CUtilFuncs::GetVectorDirectionPoint(local_vec[1], fabs(max_val)*0.2,
		m_PForcVtAdjustFactor*m_PForcVtScaleFactor, arr_p11, arr_p11);
	// Arrow Point 12
	CUtilFuncs::GetVectorDirectionPoint(local_vec[0], -max_val*0.2,
		m_PForcVtAdjustFactor*m_PForcVtScaleFactor, pnt_p1, arr_p12);
	CUtilFuncs::GetVectorDirectionPoint(local_vec[1], -fabs(max_val)*0.2,
		m_PForcVtAdjustFactor*m_PForcVtScaleFactor, arr_p12, arr_p12);

	// Point 2
	CUtilFuncs::GetVectorDirectionPoint(local_vec[1], fabs(min_val),
		m_PForcVtAdjustFactor*m_PForcVtScaleFactor, pnt_c, pnt_p2);
	// Arrow Point 21
	CUtilFuncs::GetVectorDirectionPoint(local_vec[1], -min_val*0.2,
		m_PForcVtAdjustFactor*m_PForcVtScaleFactor, pnt_p2, arr_p21);
	CUtilFuncs::GetVectorDirectionPoint(local_vec[0], fabs(min_val)*0.2,
		m_PForcVtAdjustFactor*m_PForcVtScaleFactor, arr_p21, arr_p21);
	// Arrow Point 22
	CUtilFuncs::GetVectorDirectionPoint(local_vec[1], -min_val*0.2,
		m_PForcVtAdjustFactor*m_PForcVtScaleFactor, pnt_p2, arr_p22);
	CUtilFuncs::GetVectorDirectionPoint(local_vec[0], -fabs(min_val)*0.2,
		m_PForcVtAdjustFactor*m_PForcVtScaleFactor, arr_p22, arr_p22);

	// Arrow of P1
	old_pen = (CPen *) pDC->SelectObject(&p1_pen);
	if(!gm->m_bVirtualMode&& !gm->m_bAnimation)
		old_pen2 = (CPen *) dc.SelectObject(&p1_pen);

	// MNET:XXXX-CJJEONG-20080429
	if (max_val < 1.e-10)
	{
		if (gm->m_pForceEngine->m_bVectorNegative)
			DrawVectorArrow(pDC,&dc,pnt_c,pnt_p1,arr_p11,arr_p12,mkey.key.mirror_k);
	}
	else
	{
		if (gm->m_pForceEngine->m_bVectorPositive)
			DrawVectorArrow(pDC,&dc,pnt_c,pnt_p1,arr_p11,arr_p12,mkey.key.mirror_k);
	}


	// Arrow of P2
	pDC->SelectObject(&p2_pen);
	if(!gm->m_bVirtualMode&& !gm->m_bAnimation)
		dc.SelectObject(&p2_pen);

	// MNET:XXXX-CJJEONG-20080429
	if (min_val < 1.e-10)
	{
		if (gm->m_pForceEngine->m_bVectorNegative)
			DrawVectorArrow(pDC,&dc,pnt_c,pnt_p2,arr_p21,arr_p22,mkey.key.mirror_k);
	}
	else
	{
		if (gm->m_pForceEngine->m_bVectorPositive)
			DrawVectorArrow(pDC,&dc,pnt_c,pnt_p2,arr_p21,arr_p22,mkey.key.mirror_k);
	}

	pDC->SelectObject(old_pen);
	if(!gm->m_bAnimation && !gm->m_bVirtualMode)
		dc.SelectObject(old_pen2);
	p1_pen.DeleteObject();
	p2_pen.DeleteObject();

	gm->m_pGPSCtrl->XGL_End_Elem(FALSE); // 20060224 Changkeun
}

// 주어진 요소의 Plate Force Contour를 그린다.
// 1. 요소의 형상정보를 얻는다.
// 2. 요소의 형상을 이루는 polygon들의 각 Vertex에 해당 Plate Force값을 부여한다.
// 3. polygon별로 Contour를 실시하여 Plate Force값에 따라 나뉘어진 sub-polygon list를 얻는다.
// 4. sub-polygon들을 그린다.
void CForceEngine::DoPForcElementContour(CDC *pDC, T_ELEM_K ekey)
{
	T_MIRE_K mkey;
	mkey.keymap = ekey;
	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;

	int				i, j, poly_num, vtx_num, node_in_elem;
	double			pforc_val[4];
	BOOL			ef[4];
	T_ELEM_D		elem_d;
	T_STRP_DL		pforc;

	CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray <CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					edge_list;
	CArray <CArray <T_NODE_K, T_NODE_K> *, CArray <T_NODE_K, T_NODE_K> *>	VertexNode;

	if ((gm->m_pDeformEngine==NULL) ||
		(m_pContourEngine==NULL)) return;

	if(m_PForcComponent == PFORC_COMPONENT_MOMENT_COMB)
	{
		T_SLAB_FORCE_COMPACT SlabForce;

		if(m_bAverage)
		{
			if(!IsSubDomainElem(mkey.key.elem_k))
			{
				gm->GPSDrawInactiveElement(pDC, ekey);
				return;
			}
		}
		else
		{
			if(!m_mapSlabForce.Lookup(mkey.key.elem_k, SlabForce))
			{
				gm->GPSDrawInactiveElement(pDC, ekey);
				return;
			}
		}
	}
	else
	{
		if(!GetPlateForce(mkey.key.elem_k, pforc)) return;
	}	

	// 1. 요소의 형상정보를 얻는다.
	m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d);
	node_in_elem = m_pDoc->m_pAttrCtrl->GetNumNode(elem_d.eltyp, elem_d.elnod);
	if (m_bDeformedShapeContour) {
		gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list, &VertexNode);
	}
	else {
		gm->GetShapeElement(ekey, polygon_list, &edge_list, NULL, &VertexNode);
	}

	gm->GPS_XGL_Begin_Elem(mkey.key.elem_k,elem_d);

	poly_num = polygon_list.GetSize();
	for (i=0;i<poly_num;i++) {
		vtx_num = polygon_list[i]->GetCount();
		if (vtx_num == 2) 
			continue;

		if(poly_num>1 && !gm->m_DOPT.DR.m_bFrameLine &&  gm->m_DOPT.DR.m_bPlaneThick && !gm->IsVisibleFace(polygon_list[i],vtx_num))
			continue;

		// Fill+Outline의 경우 Contour를 수행하기 전의 Polygon의 Outline을 그림.// Line Only 일경우는 먼저그린다.
		//if ((gm->m_RenderFlag == 3 || gm->m_RenderFlag == 2) && m_pContourEngine->m_nContourFill ==1)
		if ((gm->m_DOPT.DR.m_RenderFlag == 3 || gm->m_DOPT.DR.m_RenderFlag == 2) && m_pContourEngine->m_nContourFill ==1)
		{
			//gm->DrawPolygon3DFill(pDC, *(polygon_list[i]), *(edge_list[i]), gm->m_ClientBackColor);
			gm->DrawPolygon3DFill(pDC, *(polygon_list[i]), *(edge_list[i]), gm->m_DOPT.CL.m_ClientBackColor);
			gm->GPSDrawPolygonEdge(pDC, polygon_list[i], edge_list[i]);
		}

		if(gm->m_bContour)
		{

			// 2. 요소의 형상을 이루는 polygon들의 각 Vertex에 해당 Plate Force값을 부여한다.
			for (j=0;j<vtx_num;j++) {
				if(m_PForcComponent == PFORC_COMPONENT_MOMENT_COMB)
					pforc_val[j] = CalcPForcWoodArmer(mkey.key.elem_k, GetNodeOrder(VertexNode[i]->GetAt(j), elem_d, node_in_elem));
				else
				{
					if(gm->m_bElemCenter) pforc_val[j] = CalcPForcValue(pforc, 0);
					else pforc_val[j] = CalcPForcValue(pforc, GetNodeOrder(VertexNode[i]->GetAt(j), elem_d, node_in_elem)+1);
				}
				if (gm->m_AnimEngine.m_bAnimateContour)
					pforc_val[j] = m_pContourEngine->GetSubFrameValue(pforc_val[j], gm->m_AnimEngine.GetAnimationFactor(TRUE));
				ef[j] = edge_list[i]->GetAt(j);
			}
			// 3. polygon별로 Contour를 실시하여 Plate Force값에 따라 나뉘어진 sub-polygon list를 얻는다.
			// 4. sub-polygon들을 그린다.
			DoSubPolyContour(pDC, pforc_val, polygon_list[i], ef, FALSE);
		}

		// Fill+Outline의 경우 Contour를 수행하기 전의 Polygon의 Outline을 그림. Fill Type
		//if ((gm->m_RenderFlag == 3 || gm->m_RenderFlag == 2) && m_pContourEngine->m_nContourFill ==0)
		if ((gm->m_DOPT.DR.m_RenderFlag == 3 || gm->m_DOPT.DR.m_RenderFlag == 2) && m_pContourEngine->m_nContourFill ==0)
			gm->GPSDrawPolygonEdge(pDC, polygon_list[i], edge_list[i]);

	}
	gm->GPS_XGL_End_Elem();
	FreeMemoryPolyList(&polygon_list,&edge_list,&VertexNode); 
	/*
	for (i=0;i<poly_num;i++) {
	polygon_list[i]->RemoveAll();
	delete polygon_list[i];
	edge_list[i]->RemoveAll();
	delete edge_list[i];
	VertexNode[i]->RemoveAll();
	delete VertexNode[i];
	}
	polygon_list.RemoveAll();
	edge_list.RemoveAll();
	VertexNode.RemoveAll();
	*/
}



double CForceEngine::CalcWForcValue(T_STRW_D &wforc, int side)
{
	double	len=0.0;

	switch (m_WForcComponent) {
	case WFORC_COMPONENT_FX:
	case WFORC_COMPONENT_FY:
	case WFORC_COMPONENT_FZ:
	case WFORC_COMPONENT_MX:
	case WFORC_COMPONENT_MY:
	case WFORC_COMPONENT_MZ:
		len = wforc.dblForce[side][m_WForcComponent];
		break;
	case WFORC_COMPONENT_FYZ:
		len = wforc.dblForce[side][WFORC_COMPONENT_FZ];
		break;
	case WFORC_COMPONENT_MYZ:
		len = wforc.dblForce[side][WFORC_COMPONENT_MY];
		break;
	}

	return len;
}

double CForceEngine::CalcWForcValue(T_STRW_D &wforc, int component, int side)
{
	return wforc.dblForce[side][component];
}

void CForceEngine::InitWSfdBmdAdjustFactor(double max_wforc)
{
	C3DPoint	min_p, max_p;
	double		max_l;
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	if(m_bLockAdjFactor)return;
	gm->GetRangeModel(&min_p,&max_p);
	max_l = max(max(max_p.x-min_p.x, max_p.y-min_p.y), max_p.z-min_p.z);


	if(max_wforc > -1e-15 && max_wforc < 1e-15)max_wforc = 1.0f;

	// 최대값이 Model Range의 1/20의 크기가 되도록...
	m_WSfdBmdAdjustFactor = max_l / (fabs(max_wforc)*20.0);
}

// Wall Force 데이터를 만든다.
// 현재 Active Element List에 대해 Loop를 돌며
// 1. DB로 부터 해당 Element의 Wall Information 및 Wall Force 데이터를 얻고
// 2. Wall Force에 대한 최대/최소값을 갱신하고
// 3. Wall Information, Wall Force 및 해당 Element번호를 CArray에 저장
void CForceEngine::MakeWForcDataList()
{
	if (CTestEnvMgr::IsTestEnvST(_LSX(ProfilingSTL), _LSX(yes)))
	{
		M_PROFILE('MakeWForcDataList()');
	}

	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;

	int				i, elem_num;
	double			max_wforc=-DBL_MAX, min_wforc=DBL_MAX, len;
	BOOL			has_content=FALSE;
	T_ELEM_K		elem_key;
	T_ELEM_D		elem_data;
	unsigned int	wall_id;
	T_WALL_KEY		wall_key;
	T_STRW_D		wforc;
	T_WALL_D		winfo;

	if (!gm->m_bLoadDataSet)return;
	gm->m_pMyView->BeginWaitCursor();

	m_WallKeyList.RemoveAll();
	m_mapWForcData.RemoveAll();
	m_mapWallInfoData.RemoveAll();

	elem_num = gm->m_EKeyListActive.GetSize();
	for(i=0;i<elem_num;i++) 
	{
		elem_key = gm->m_EKeyListActive[i];
		m_pDoc->m_pAttrCtrl->GetElem(elem_key, elem_data);
		if (!m_pDoc->m_pAttrCtrl->IsWall(elem_data.eltyp))continue;

		m_pDoc->m_pPostCtrl->GetInternalWallId(elem_key, wall_id);
		m_pDoc->m_pPostCtrl->GetWallKey(wall_id, wall_key);

		// 1. DB로 부터 해당 Element의 Wall Information 및 Wall Force 데이터를 얻고
		switch (gm->m_LoadMinMaxType) 
		{
		case LOADTYPE_NORMAL:
		case LOADTYPE_MAX:
			if(!m_pDoc->m_pPostCtrl->GetStrwNew(wall_id, &wforc, NULL,NULL))continue;
			break;
		case LOADTYPE_MIN:
			if(!m_pDoc->m_pPostCtrl->GetStrwNew(wall_id, NULL, &wforc, NULL))continue;
			break;
		case LOADTYPE_ALL:
			if (!m_pDoc->m_pPostCtrl->GetStrwNew(wall_id, NULL,NULL,&wforc))continue;
			break;
		}

		if(!m_pDoc->m_pPostCtrl->GetWallData(wall_key, winfo))continue;
		has_content = TRUE;

		// 2. Wall Force에 대한 최대/최소값을 갱신하고
		switch (m_WForcComponent) 
		{
		case WFORC_COMPONENT_FYZ:
			len = CalcWForcValue(wforc, WFORC_COMPONENT_FY, WALL_TOP);
			if (len > max_wforc){ max_wforc = len; gm->m_nLgdMaxValKey = elem_key; }
			if (len < min_wforc){	min_wforc = len; gm->m_nLgdMinValKey = elem_key; }

			len = CalcWForcValue(wforc, WFORC_COMPONENT_FY, WALL_BOTTOM);
			if (len > max_wforc){	max_wforc = len; gm->m_nLgdMaxValKey = elem_key; }
			if (len < min_wforc){	min_wforc = len; gm->m_nLgdMinValKey = elem_key; }

			len = CalcWForcValue(wforc, WFORC_COMPONENT_FZ, WALL_TOP);
			if (len > max_wforc){	max_wforc = len; gm->m_nLgdMaxValKey = elem_key; }
			if (len < min_wforc){	min_wforc = len; gm->m_nLgdMinValKey = elem_key; }

			len = CalcWForcValue(wforc, WFORC_COMPONENT_FZ, WALL_BOTTOM);
			if (len > max_wforc){	max_wforc = len; gm->m_nLgdMaxValKey = elem_key; }
			if (len < min_wforc){	min_wforc = len; gm->m_nLgdMinValKey = elem_key; }
			break;
		case WFORC_COMPONENT_MYZ:
			len = CalcWForcValue(wforc, WFORC_COMPONENT_MY, WALL_TOP);
			if (len > max_wforc){	max_wforc = len; gm->m_nLgdMaxValKey = elem_key; }
			if (len < min_wforc){	min_wforc = len; gm->m_nLgdMinValKey = elem_key; }

			len = CalcWForcValue(wforc, WFORC_COMPONENT_MY, WALL_BOTTOM);
			if (len > max_wforc){	max_wforc = len; gm->m_nLgdMaxValKey = elem_key; }
			if (len < min_wforc){	min_wforc = len; gm->m_nLgdMinValKey = elem_key; }

			len = CalcWForcValue(wforc, WFORC_COMPONENT_MZ, WALL_TOP);
			if (len > max_wforc){	max_wforc = len; gm->m_nLgdMaxValKey = elem_key; }
			if (len < min_wforc){	min_wforc = len; gm->m_nLgdMinValKey = elem_key; }

			len = CalcWForcValue(wforc, WFORC_COMPONENT_MZ, WALL_BOTTOM);
			if (len > max_wforc){	max_wforc = len; gm->m_nLgdMaxValKey = elem_key; }
			if (len < min_wforc){	min_wforc = len; gm->m_nLgdMinValKey = elem_key; }

			break;
		default:
			len = CalcWForcValue(wforc, WALL_TOP);
			if (len > max_wforc){	max_wforc = len; gm->m_nLgdMaxValKey = elem_key; }
			if (len < min_wforc){	min_wforc = len; gm->m_nLgdMinValKey = elem_key; }

			len = CalcWForcValue(wforc, WALL_BOTTOM);
			if (len > max_wforc){	max_wforc = len; gm->m_nLgdMaxValKey = elem_key; }
			if (len < min_wforc){	min_wforc = len; gm->m_nLgdMinValKey = elem_key; }
			break;
		}

		// 3. Wall Information, Wall Force 및 해당 Element번호를 CArray에 저장
		m_WallKeyList.Add(elem_key);
		m_mapWForcData.SetAt(elem_key,wforc);
		m_mapWallInfoData.SetAt(elem_key,winfo);
	}

	if (!has_content) 
	{
		min_wforc = max_wforc = 0.0;
		gm->m_nLgdMaxValKey = 0;
		gm->m_nLgdMinValKey = 0;
	}

	m_dMaxValue = max_wforc;
	m_dMinValue = min_wforc;

	if(fabs(max_wforc) < fabs(min_wforc))
		InitWSfdBmdAdjustFactor(min_wforc);
	else
		InitWSfdBmdAdjustFactor(max_wforc);

	if (m_pContourEngine == NULL)
		m_pContourEngine = new CContourEngine(min_wforc, max_wforc);
	else
		m_pContourEngine->MakeRankMap(min_wforc, max_wforc);

	gm->m_pMyView->EndWaitCursor();

	m_bWForcDataSet = TRUE;
}

BOOL CForceEngine::GetWForcRangeDataList(double& dMaxRange, double& dMinRange, CArray<UINT,UINT>& aElemKeyList)
{
	aElemKeyList.RemoveAll();

	if (CTestEnvMgr::IsTestEnvST(_LSX(ProfilingSTL), _LSX(yes)))
	{
		M_PROFILE('GetWForcRangeDataList()');
	}

	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;

	int				i, elem_num;
	T_ELEM_K		elem_key;
	T_ELEM_D		elem_data;
	unsigned int	wall_id;
	T_WALL_KEY		wall_key;
	T_STRW_D		wforc;
	T_WALL_D		winfo;
	
	gm->m_pMyView->BeginWaitCursor();

	elem_num = gm->m_EKeyListActive.GetSize();
	for(i=0;i<elem_num;i++) 
	{
		elem_key = gm->m_EKeyListActive[i];
		m_pDoc->m_pAttrCtrl->GetElem(elem_key, elem_data);
		if (!m_pDoc->m_pAttrCtrl->IsWall(elem_data.eltyp))continue;

		m_pDoc->m_pPostCtrl->GetInternalWallId(elem_key, wall_id);
		m_pDoc->m_pPostCtrl->GetWallKey(wall_id, wall_key);

		// 1. DB로 부터 해당 Element의 Wall Information 및 Wall Force 데이터를 얻고
		switch (gm->m_LoadMinMaxType) 
		{
		case LOADTYPE_NORMAL:
		case LOADTYPE_MAX:
			if(!m_pDoc->m_pPostCtrl->GetStrwNew(wall_id, &wforc, NULL,NULL))continue;
			break;
		case LOADTYPE_MIN:
			if(!m_pDoc->m_pPostCtrl->GetStrwNew(wall_id, NULL, &wforc, NULL))continue;
			break;
		case LOADTYPE_ALL:
			if (!m_pDoc->m_pPostCtrl->GetStrwNew(wall_id, NULL,NULL,&wforc))continue;
			break;
		}

		if(!m_pDoc->m_pPostCtrl->GetWallData(wall_key, winfo))continue;
		
		if(!IsWithinRangeElemWForc(wforc, dMaxRange, dMinRange)) continue;
		
		aElemKeyList.Add(elem_key);
	}

	gm->m_pMyView->EndWaitCursor();

	return TRUE;
}

void CForceEngine::DrawWForcContour(CDC *pDC)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	T_MIRE_K mkey;
	int			i, elem_num;
	T_ELEM_D	elem_d;
	CPen		elem_pen, *old_pen;
	CArray <int, int>				type_list;
	CArray <GRE_Atom, GRE_Atom&>		atom_list;
	BOOL bEscapePressed = FALSE;

	if (!gm->m_bContour) {
		gm->GPSDrawOriginal(pDC);
		return;
	}

	if (m_bDeformedShapeContour) {
		if (gm->m_pDeformEngine == NULL) {
			return;
		}
		type_list.Add(gm->m_MinOTID + OBJECT_TYPE_DEFORMED);
	}
	else {
		type_list.Add(gm->m_MinOTID + OBJECT_TYPE_ORIGINAL);
	}

	//elem_pen.CreatePen(PS_SOLID, gm->m_nLineWidth, m_pContourEngine->m_ElemColor);
	//elem_pen.CreatePen(PS_SOLID, gm->m_LnWd.nElemHddn, m_pContourEngine->m_ElemColor);
	elem_pen.CreatePen(PS_SOLID, gm->m_DOPT.DR.nElemHddn, m_pContourEngine->m_ElemColor);
	old_pen = (CPen *) pDC->SelectObject(&elem_pen);

	gm->m_pGPSCtrl->GetZSortedList(type_list, gm->m_EKeyListVisible_Mirror, atom_list);
	elem_num = atom_list.GetSize();
	for (i=0;i<elem_num;i++) 
	{
		//if(gm->m_pGPSCtrl->WatchEscKeyPress()) bEscapePressed = TRUE;
		if(gm->m_pGPSCtrl->WatchEscKeyPress()) return;
		if (gm->m_pGPSCtrl->IsZoomAllState() ||
			gm->m_pGPSCtrl->IsObjectInClientWindow(atom_list[i].m_OType, atom_list[i].m_OKey)) {
				mkey.keymap = atom_list[i].m_OKey;
				m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d);
				if (m_pDoc->m_pAttrCtrl->IsWall(elem_d.eltyp) && (gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey)) && !bEscapePressed) 
					DoWForcElementContour(pDC, atom_list[i].m_OKey);
				else
				{
					if(m_bDeformedShapeContour)
						gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, atom_list[i].m_OKey);
					else
						gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
				}
		}
	}

	// 변형된 그림에 Undeformed Shape을 같이 그릴 경우.
	// Contour를 그릴 경우는 Hidden이 default
	// 따라서 Undeformed Shape은 무조건 나중에 그린다...
	if (m_bDeformedShapeContour && gm->m_DOPT.DR.m_bDrawInactive && !bEscapePressed) {
		gm->GPSDrawOriginal(pDC, TRUE);
	}

	pDC->SelectObject(old_pen);
	elem_pen.DeleteObject();
}

// 주어진 요소의 Wall Force Contour를 그린다.
// 1. 요소의 형상정보를 얻는다.
// 2. 요소의 형상을 이루는 polygon들의 각 Vertex에 해당 Wall Force값을 부여한다.
// 3. polygon별로 Contour를 실시하여 Wall Force값에 따라 나뉘어진 sub-polygon list를 얻는다.
// 4. sub-polygon들을 그린다.
void CForceEngine::DoWForcElementContour(CDC *pDC, unsigned int ekey)
{
	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;
	T_MIRE_K mkey;
	mkey.keymap = ekey;

	int				i, j, poly_num, vtx_num, node_in_elem, order;
	double			wforc_val[4];
	BOOL			ef[4];
	T_ELEM_D		elem_d;
	T_STRW_D		wforc;

	CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray <CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					edge_list;
	CArray <CArray <T_NODE_K, T_NODE_K> *, CArray <T_NODE_K, T_NODE_K> *>	VertexNode;

	if ((gm->m_pDeformEngine==NULL) ||
		(m_pContourEngine==NULL) ||
		(!GetWallData(mkey.key.elem_k, wforc))) {
			return;
	}

	m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d);
	node_in_elem = m_pDoc->m_pAttrCtrl->GetNumNode(elem_d.eltyp, elem_d.elnod);
	// 요소의 형상정보를 얻는다.
	if (m_bDeformedShapeContour) {		// 변형된 형상
		gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list, &VertexNode);
	}
	else {
		gm->GetShapeElement(ekey, polygon_list, &edge_list, NULL, &VertexNode);
	}

	gm->GPS_XGL_Begin_Elem(mkey.key.elem_k,elem_d);
	poly_num = polygon_list.GetSize();
	for (i=0;i<poly_num;i++) {
		vtx_num = polygon_list[i]->GetCount();
		if (vtx_num == 2) 
			continue;
		if(poly_num>1 && !gm->m_DOPT.DR.m_bFrameLine &&  gm->m_DOPT.DR.m_bPlaneThick && !gm->IsVisibleFace(polygon_list[i],vtx_num))
			continue;


		// 2. 요소의 형상을 이루는 polygon들의 각 Vertex에 해당 Wall Force값을 부여한다.
		for (j=0;j<vtx_num;j++) {
			order = GetNodeOrder(VertexNode[i]->GetAt(j), elem_d, node_in_elem);
			if ((order==0) || (order==1))		// Bottom에 해당하는 노드
				wforc_val[j] = CalcWForcValue(wforc, WALL_BOTTOM);
			else								// Top에 해당하는 노드
				wforc_val[j] = CalcWForcValue(wforc, WALL_TOP);
			if (gm->m_AnimEngine.m_bAnimateContour)
				wforc_val[j] = m_pContourEngine->GetSubFrameValue(wforc_val[j], gm->m_AnimEngine.GetAnimationFactor(TRUE));
			ef[j] = edge_list[i]->GetAt(j);
		}
		// 3. polygon별로 Contour를 실시하여 Wall Force값에 따라 나뉘어진 sub-polygon list를 얻는다.
		// 4. sub-polygon들을 그린다.
		DoSubPolyContour(pDC, wforc_val, polygon_list[i], ef, TRUE);

		// Fill+Outline의 경우 Contour를 수행하기 전의 Polygon의 Outline을 그림.
		//if (gm->m_RenderFlag == 3 || gm->m_RenderFlag == 2)
		if (gm->m_DOPT.DR.m_RenderFlag == 3 || gm->m_DOPT.DR.m_RenderFlag == 2)
			gm->GPSDrawPolygonEdge(pDC, polygon_list[i], edge_list[i]);
	}
	gm->GPS_XGL_End_Elem();
	FreeMemoryPolyList(&polygon_list,&edge_list,&VertexNode); 
	/*
	for (i=0;i<poly_num;i++) {
	polygon_list[i]->RemoveAll();
	delete polygon_list[i];
	edge_list[i]->RemoveAll();
	delete edge_list[i];
	VertexNode[i]->RemoveAll();
	delete VertexNode[i];
	}
	polygon_list.RemoveAll();
	edge_list.RemoveAll();
	VertexNode.RemoveAll();
	*/
}

void CForceEngine::DrawWallSfdBmd(CDC *pDC)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	T_MIRE_K mkey;
	int			i, elem_num;
	BOOL		fl_bak=gm->m_DOPT.DR.m_bFrameLine;
	T_ELEM_D	elem_d;
	CArray <int, int>				type_list;
	CArray <GRE_Atom, GRE_Atom&>		atom_list;
	BOOL bEscapePressed = FALSE;

	gm->m_DOPT.DR.m_bFrameLine = TRUE;

	if (m_bDeformedShapeContour) {
		if (gm->m_pDeformEngine == NULL) {
			gm->m_DOPT.DR.m_bFrameLine = fl_bak;
			return;
		}
		type_list.Add(gm->m_MinOTID + OBJECT_TYPE_DEFORMED);

		// 변형된 형상에 Undeformed Shape을 그리는 경우
		if (gm->m_DOPT.DR.m_bDrawInactive && m_bWSfdBmdLineOnly) {
			gm->GPSDrawOriginal(pDC, TRUE);
		}
	}
	else {
		type_list.Add(gm->m_MinOTID + OBJECT_TYPE_ORIGINAL);
	}

	gm->m_pGPSCtrl->GetZSortedList(type_list, gm->m_EKeyListVisible_Mirror, atom_list);
	elem_num = atom_list.GetSize();
	for (i=0;i<elem_num;i++) 
	{
		//if(gm->m_pGPSCtrl->WatchEscKeyPress()) bEscapePressed = TRUE;
		if(gm->m_pGPSCtrl->WatchEscKeyPress()) return;
		if(gm->m_pGPSCtrl->IsZoomAllState() ||
			gm->m_pGPSCtrl->IsObjectInClientWindow(atom_list[i].m_OType, atom_list[i].m_OKey)) {
				mkey.keymap = atom_list[i].m_OKey;
				if(!m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d))
					continue;
				if (m_bDeformedShapeContour)
					gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, atom_list[i].m_OKey);
				else
					gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);

				if (m_pDoc->m_pAttrCtrl->IsWall(elem_d.eltyp) && (gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey)) && !bEscapePressed) {
					DoWallElementSfdBmd(pDC, atom_list[i].m_OKey);
				}
		}
	}

	// 변형된 형상에 Undeformed Shape을 그리는 경우
	if (m_bDeformedShapeContour && gm->m_DOPT.DR.m_bDrawInactive && !m_bWSfdBmdLineOnly && !bEscapePressed) {
		gm->GPSDrawOriginal(pDC, TRUE);
	}

	gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}

void CForceEngine::DoWallElementSfdBmd(CDC *pDC, unsigned int ekey)
{
	I_GPSModel						*gm=(I_GPSModel *) m_pGPSModel;
	T_MIRE_K mkey;
	mkey.keymap = ekey;

	int								  poly_num, order;
	double							local_vector[2][3];
	T_ELEM_D						edata;
	T_STRW_D						wforc;
	T_WALL_D						winfo;
	POSITION						pos;
	C3DPoint						bottom, top, *txt_pnt=NULL;
	CArray <C3DPoint, C3DPoint &>	vtx_list;
	CArray <double, double &>		val_list;
	CArray <BOOL, BOOL>				ef_list;
	CArray <BOOL, BOOL>				rect_flag;
	CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray <CArray <T_NODE_K, T_NODE_K> *, CArray <T_NODE_K, T_NODE_K> *>	VertexNode;

	if ((gm->m_pDeformEngine==NULL) ||
		(m_pContourEngine==NULL)) {
			return;
	}

	if (!GetWallData(mkey.key.elem_k, wforc) || !GetWallInfo(mkey.key.elem_k, winfo)) {
		return;
	}

	m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, edata);

	// local_vector[0] => y축 
	// local_vector[1] => z축 
	// x축은 Global Z축임 
	local_vector[0][0] = local_vector[1][0] = winfo.ux;
	local_vector[0][1] = local_vector[1][1] = winfo.uy;
	local_vector[0][2] = local_vector[1][2] = 0.0;
	CMathFunc::mathRotateZ(90.0, local_vector[0][0], local_vector[0][1], local_vector[0][2]);

	bottom.x = top.x = winfo.xc;
	bottom.y = top.y = winfo.yc;

	if (m_bDeformedShapeContour) {
		gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, NULL, &VertexNode);
	}
	else {
		gm->GetShapeElement(ekey, polygon_list, NULL, NULL, &VertexNode);
	}

	poly_num = polygon_list.GetSize();

	if ((poly_num!=1) || (polygon_list[0]->GetCount()!=4))
		return;

	if (gm->m_DOPT.TX.m_bOutputNumber)
		txt_pnt = new C3DPoint[2];

	order = GetNodeOrder(VertexNode[0]->GetAt(0), edata, 4);

	pos = polygon_list[0]->GetHeadPosition();
	if ((order==0) || (order==1)) {
		bottom.z = polygon_list[0]->GetNext(pos).z;
		polygon_list[0]->GetNext(pos);
		top.z = polygon_list[0]->GetNext(pos).z;
	}
	else {
		top.z = polygon_list[0]->GetNext(pos).z;
		polygon_list[0]->GetNext(pos);
		bottom.z = polygon_list[0]->GetNext(pos).z;
	}

	switch (m_WForcComponent) {
	case WFORC_COMPONENT_FX:
	case WFORC_COMPONENT_MX:	
	case WFORC_COMPONENT_FY:
	case WFORC_COMPONENT_FZ:
	case WFORC_COMPONENT_MY:
	case WFORC_COMPONENT_MZ:
		WSfdBmdMakePolygon(wforc, m_WForcComponent, local_vector,
			bottom, top, vtx_list, val_list, ef_list, rect_flag, txt_pnt);
		break;
	case WFORC_COMPONENT_FYZ:
		if (IsFar(local_vector[0], local_vector[1])) {
			WSfdBmdMakePolygon(wforc, WFORC_COMPONENT_FY, local_vector,
				bottom, top, vtx_list, val_list, ef_list, rect_flag, NULL);
			WSfdBmdMakePolygon(wforc, WFORC_COMPONENT_FZ, local_vector,
				bottom, top, vtx_list, val_list, ef_list, rect_flag, txt_pnt);
		}
		else {
			WSfdBmdMakePolygon(wforc, WFORC_COMPONENT_FZ, local_vector,
				bottom, top, vtx_list, val_list, ef_list, rect_flag, txt_pnt);
			WSfdBmdMakePolygon(wforc, WFORC_COMPONENT_FY, local_vector,
				bottom, top, vtx_list, val_list, ef_list, rect_flag, NULL);
		}
		break;
	case WFORC_COMPONENT_MYZ:
		if (IsFar(local_vector[1], local_vector[0])) {
			WSfdBmdMakePolygon(wforc, WFORC_COMPONENT_MY, local_vector,
				bottom, top, vtx_list, val_list, ef_list, rect_flag, NULL);
			WSfdBmdMakePolygon(wforc, WFORC_COMPONENT_MZ, local_vector,
				bottom, top, vtx_list, val_list, ef_list, rect_flag, txt_pnt);
		}
		else {
			WSfdBmdMakePolygon(wforc, WFORC_COMPONENT_MZ, local_vector,
				bottom, top, vtx_list, val_list, ef_list, rect_flag, txt_pnt);
			WSfdBmdMakePolygon(wforc, WFORC_COMPONENT_MY, local_vector,
				bottom, top, vtx_list, val_list, ef_list, rect_flag, NULL);
		}
		break;
	}

	gm->GPS_XGL_Begin_Diagram(mkey.key.elem_k);
	DoBSfdBmdContour(pDC, vtx_list, val_list, ef_list, rect_flag);
	gm->GPS_XGL_End_Elem();

	vtx_list.RemoveAll();
	val_list.RemoveAll();
	ef_list.RemoveAll();
	rect_flag.RemoveAll();

	FreeMemoryPolyList(&polygon_list,NULL,&VertexNode); 

	/*
	for (i=0;i<poly_num;i++) {
	polygon_list[i]->RemoveAll();
	delete polygon_list[i];
	VertexNode[i]->RemoveAll();
	delete VertexNode[i];
	}
	polygon_list.RemoveAll();
	VertexNode.RemoveAll();
	*/

	if (txt_pnt)
		delete []txt_pnt;

}

void CForceEngine::WSfdBmdMakePolygon(T_STRW_D &wforc_d, int component, double local_vector[][3],
																			C3DPoint &bottom, C3DPoint &top,
																			CArray <C3DPoint, C3DPoint &> &vtx_list,
																			CArray <double, double &> &val_list,
																			CArray <BOOL, BOOL> &ef_list,
																			CArray <BOOL, BOOL> &rect_flag,
																			C3DPoint *txt_pnt)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	int			j, sl_num;
	double  val_b, val_t, sub_bval, sub_tval, sub_mval;
	double  ulen, udist, uval, ldist, vdist;
	C3DPoint	pb, pbb, pt, ptt;
	C3DPoint	sub_pb, sub_pbb, sub_pt, sub_ptt, pm;

	CDC	*pdc=gm->m_pMyView->GetDC();
	ulen = fabs(gm->m_pGPSCtrl->GetWorldLength(((double) pdc->GetDeviceCaps(LOGPIXELSX))/6.0));
	gm->m_pMyView->ReleaseDC(pdc);

	// SFD,BMD Inverse 
	double SFDvector[3],BMDvector[3];
	int nBMDSign = (gm->m_DOPT.DR.m_bInverseBMD == TRUE)? -1:1; 
	int nSFDSign = (gm->m_DOPT.DR.m_bInverseSFD == TRUE)? -1:1;

	pb = bottom;
	pt = top;

	val_b = CalcWForcValue(wforc_d, component, WALL_BOTTOM);
	val_t = CalcWForcValue(wforc_d, component, WALL_TOP);

	if(gm->m_AnimEngine.m_bAnimateContour) 
	{
		val_b = val_b*fabs(gm->m_AnimEngine.GetAnimationFactor(TRUE));
		val_t = val_t*fabs(gm->m_AnimEngine.GetAnimationFactor(TRUE));
	}

	switch(component) 
	{
	case WFORC_COMPONENT_FX:
	case WFORC_COMPONENT_FZ:
		for(j=0; j<3; j++)
			SFDvector[j] = local_vector[1][j]*nSFDSign;
		CUtilFuncs::GetVectorDirectionPoint(SFDvector, val_b, m_WSfdBmdAdjustFactor*m_WSfdBmdScFactor, pb, pbb);
		CUtilFuncs::GetVectorDirectionPoint(SFDvector, val_t, m_WSfdBmdAdjustFactor*m_WSfdBmdScFactor, pt, ptt);
		break;
	case WFORC_COMPONENT_FY:
		for(j=0; j<3; j++)
			SFDvector[j] = local_vector[0][j]*nSFDSign;
		CUtilFuncs::GetVectorDirectionPoint(SFDvector, val_b, m_WSfdBmdAdjustFactor*m_WSfdBmdScFactor, pb, pbb);
		CUtilFuncs::GetVectorDirectionPoint(SFDvector, val_t, m_WSfdBmdAdjustFactor*m_WSfdBmdScFactor, pt, ptt);
		break;

	case WFORC_COMPONENT_MX:
	case WFORC_COMPONENT_MY:
		for(j=0; j<3; j++)
			BMDvector[j] = local_vector[1][j]*nBMDSign;
		CUtilFuncs::GetVectorDirectionPoint(BMDvector, val_b, -m_WSfdBmdAdjustFactor*m_WSfdBmdScFactor, pb, pbb);
		CUtilFuncs::GetVectorDirectionPoint(BMDvector, val_t, -m_WSfdBmdAdjustFactor*m_WSfdBmdScFactor, pt, ptt);
		break;
	case WFORC_COMPONENT_MZ:
		for(j=0; j<3; j++)
			BMDvector[j] = local_vector[0][j]*-nBMDSign;  // MQC:2053-JHYUN-20080816
		CUtilFuncs::GetVectorDirectionPoint(BMDvector, val_b, -m_WSfdBmdAdjustFactor*m_WSfdBmdScFactor, pb, pbb);
		CUtilFuncs::GetVectorDirectionPoint(BMDvector, val_t, -m_WSfdBmdAdjustFactor*m_WSfdBmdScFactor, pt, ptt);
		break;
	default:
		return;
	}

	if(txt_pnt) 
	{
		txt_pnt[0] = pbb;
		txt_pnt[1] = ptt;
	}

	ldist   = sqrt((pt.x-pb.x)*(pt.x-pb.x)+(pt.y-pb.y)*(pt.y-pb.y)+(pt.z-pb.z)*(pt.z-pb.z));
	sl_num  = (int) (ldist/ulen);
	if(((double) sl_num)*ulen == ldist)sl_num--;
	udist = ldist/((double) (sl_num+1));
	vdist = val_t - val_b;
	uval  = vdist*udist/ldist;

	sub_tval = val_b;
	sub_pt = pb;
	sub_ptt = pbb;
	for(j=0;j<=sl_num;j++) 
	{
		sub_bval = sub_tval;
		sub_pb = sub_pt;
		sub_pbb = sub_ptt;
		if(j == sl_num) 
		{
			sub_tval = val_t;
			sub_pt = pt;
			sub_ptt = ptt;
		}
		else 
		{
			sub_tval = val_b + uval*(j+1);
			CUtilFuncs::GetInnerLinePoint(fabs(udist*(j+1)), fabs(fabs(ldist)-fabs(udist*(j+1))), pb, pt, sub_pt);
			CUtilFuncs::GetInnerLinePoint(fabs(udist*(j+1)), fabs(fabs(ldist)-fabs(udist*(j+1))), pbb, ptt, sub_ptt);
		}

		if((sub_bval==0) && (sub_tval==0)) 
		{
			continue;
		}
		else if(sub_bval == 0) 
		{
			ef_list.Add(TRUE);	vtx_list.Add(sub_pb);	val_list.Add(sub_bval);
			ef_list.Add(TRUE);	vtx_list.Add(sub_ptt);	val_list.Add(sub_tval);
			ef_list.Add(TRUE);	vtx_list.Add(sub_pt);	val_list.Add(sub_tval);
			rect_flag.Add(FALSE);
		}
		else if(sub_tval == 0) 
		{
			ef_list.Add(TRUE);	vtx_list.Add(sub_pb);	val_list.Add(sub_bval);
			ef_list.Add(TRUE);	vtx_list.Add(sub_pbb);	val_list.Add(sub_bval);
			ef_list.Add(TRUE);	vtx_list.Add(sub_pt);	val_list.Add(sub_tval);
			rect_flag.Add(FALSE);
		}
		else if((sub_bval*sub_tval) < 0) 
		{
			sub_mval = 0.0;
			CUtilFuncs::GetInnerLinePoint(fabs(sub_bval), fabs(sub_tval), sub_pb, sub_pt, pm);
			ef_list.Add(TRUE);	vtx_list.Add(sub_pb);	val_list.Add(sub_bval);
			ef_list.Add(TRUE);	vtx_list.Add(sub_pbb);	val_list.Add(sub_bval);
			ef_list.Add(TRUE);	vtx_list.Add(pm);		val_list.Add(sub_mval);
			rect_flag.Add(FALSE);
			ef_list.Add(TRUE);	vtx_list.Add(pm);		val_list.Add(sub_mval);
			ef_list.Add(TRUE);	vtx_list.Add(sub_ptt);	val_list.Add(sub_tval);
			ef_list.Add(TRUE);	vtx_list.Add(sub_pt);	val_list.Add(sub_tval);
			rect_flag.Add(FALSE);
		}
		else 
		{
			ef_list.Add(TRUE);	vtx_list.Add(sub_pb);	val_list.Add(sub_bval);
			ef_list.Add(TRUE);	vtx_list.Add(sub_pbb);	val_list.Add(sub_bval);
			ef_list.Add(TRUE);	vtx_list.Add(sub_ptt);	val_list.Add(sub_tval);
			ef_list.Add(TRUE);	vtx_list.Add(sub_pt);	val_list.Add(sub_tval);
			rect_flag.Add(TRUE);
		}
	}
}

void CForceEngine::WSfdBmdMakePolygonForMDgrm(T_STRW_D &wforc_d, int component, double local_vector[][3],
																							C3DPoint &bottom, C3DPoint &top,
																							CArray <C3DPoint, C3DPoint &> &vtx_list,
																							CArray <double, double &> &val_list,
																							CArray <BOOL, BOOL> &ef_list,
																							CArray <BOOL, BOOL> &rect_flag,
																							C3DPoint *txt_pnt)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	int			j, sl_num;
	double  val_b, val_t, sub_bval, sub_tval, sub_mval;
	double  ulen, udist, uval, ldist, vdist;
	C3DPoint	pb, pbb, pt, ptt;
	C3DPoint	sub_pb, sub_pbb, sub_pt, sub_ptt, pm;

	CDC	*pdc=gm->m_pMyView->GetDC();
	ulen = fabs(gm->m_pGPSCtrl->GetWorldLength(((double) pdc->GetDeviceCaps(LOGPIXELSX))/6.0));
	gm->m_pMyView->ReleaseDC(pdc);

	// SFD,BMD Inverse 
	double SFDvector[3],BMDvector[3];
	int nBMDSign = (gm->m_DOPT.DR.m_bInverseBMD == TRUE)? -1:1;
	int nSFDSign = (gm->m_DOPT.DR.m_bInverseSFD == TRUE)? -1:1;

	pb = bottom;
	pt = top;

	val_b = CalcWForcValue(wforc_d, component, WALL_BOTTOM);
	val_t = CalcWForcValue(wforc_d, component, WALL_TOP);

	if(gm->m_AnimEngine.m_bAnimateContour) 
	{
		val_b = val_b*fabs(gm->m_AnimEngine.GetAnimationFactor(TRUE));
		val_t = val_t*fabs(gm->m_AnimEngine.GetAnimationFactor(TRUE));
	}

	switch(component) 
	{
	case WFORC_COMPONENT_FX:
	case WFORC_COMPONENT_FZ:
		for(j=0; j<3; j++)
			SFDvector[j] = local_vector[1][j]*nSFDSign;
		CUtilFuncs::GetVectorDirectionPoint(SFDvector, val_b, m_WSfdBmdAdjustFactor*m_WSfdBmdScFactor, pb, pbb);
		CUtilFuncs::GetVectorDirectionPoint(SFDvector, val_t, m_WSfdBmdAdjustFactor*m_WSfdBmdScFactor, pt, ptt);
		break;
	case WFORC_COMPONENT_FY:
		for(j=0; j<3; j++)
			SFDvector[j] = local_vector[0][j]*nSFDSign;
		CUtilFuncs::GetVectorDirectionPoint(SFDvector, val_b, m_WSfdBmdAdjustFactor*m_WSfdBmdScFactor, pb, pbb);
		CUtilFuncs::GetVectorDirectionPoint(SFDvector, val_t, m_WSfdBmdAdjustFactor*m_WSfdBmdScFactor, pt, ptt);
		break;

	case WFORC_COMPONENT_MX:
	case WFORC_COMPONENT_MY:
		for(j=0; j<3; j++)
			BMDvector[j] = local_vector[1][j]*nBMDSign;
		CUtilFuncs::GetVectorDirectionPoint(BMDvector, val_b, -m_WSfdBmdAdjustFactor*m_WSfdBmdScFactor, pb, pbb);
		CUtilFuncs::GetVectorDirectionPoint(BMDvector, val_t, -m_WSfdBmdAdjustFactor*m_WSfdBmdScFactor, pt, ptt);
		break;
	case WFORC_COMPONENT_MZ:
		for(j=0; j<3; j++)
			BMDvector[j] = local_vector[0][j]*nBMDSign;
		CUtilFuncs::GetVectorDirectionPoint(BMDvector, val_b, -m_WSfdBmdAdjustFactor*m_WSfdBmdScFactor, pb, pbb);
		CUtilFuncs::GetVectorDirectionPoint(BMDvector, val_t, -m_WSfdBmdAdjustFactor*m_WSfdBmdScFactor, pt, ptt);
		break;
	default:
		return;
	}

	if(txt_pnt) 
	{
		txt_pnt[0] = pbb;
		txt_pnt[1] = ptt;
	}

	ldist   = sqrt((pt.x-pb.x)*(pt.x-pb.x)+(pt.y-pb.y)*(pt.y-pb.y)+(pt.z-pb.z)*(pt.z-pb.z));
	sl_num  = (int) (ldist/ulen);
	if(((double) sl_num)*ulen == ldist)sl_num--;
	udist = ldist/((double) (sl_num+1));
	vdist = val_t - val_b;
	uval  = vdist*udist/ldist;

	sub_tval = val_b;
	sub_pt = pb;
	sub_ptt = pbb;
	for(j=0;j<=sl_num;j++) 
	{
		sub_bval = sub_tval;
		sub_pb = sub_pt;
		sub_pbb = sub_ptt;
		if(j == sl_num) 
		{
			sub_tval = val_t;
			sub_pt = pt;
			sub_ptt = ptt;
		}
		else 
		{
			sub_tval = val_b + uval*(j+1);
			CUtilFuncs::GetInnerLinePoint(fabs(udist*(j+1)), fabs(fabs(ldist)-fabs(udist*(j+1))), pb, pt, sub_pt);
			CUtilFuncs::GetInnerLinePoint(fabs(udist*(j+1)), fabs(fabs(ldist)-fabs(udist*(j+1))), pbb, ptt, sub_ptt);
		}

		BOOL bIsStart     = j==0?       TRUE:FALSE;
		BOOL bIsEnd       = j==sl_num?  TRUE:FALSE;
		BOOL bAnyFill = m_bVerticalLineFill; // No Fill Option일 경우만 FALSE이다.
		if(m_bBSfdBmdLineOnly == FALSE && m_bVerticalLineFill == TRUE && gm->m_bGradient) bAnyFill = FALSE; // Gradient Fill시 외곽선을 없앤다.

		if((sub_bval==0) && (sub_tval==0)) 
		{
			continue;
		}
		else if(sub_bval == 0) 
		{
			ef_list.Add(TRUE);	vtx_list.Add(sub_pb);	val_list.Add(sub_bval);
			ef_list.Add(bAnyFill || bIsEnd);	vtx_list.Add(sub_ptt);	val_list.Add(sub_tval);
			ef_list.Add(TRUE);	vtx_list.Add(sub_pt);	val_list.Add(sub_tval);
			rect_flag.Add(FALSE);
		}
		else if(sub_tval == 0) 
		{
			ef_list.Add(bAnyFill || bIsStart);	vtx_list.Add(sub_pb);	val_list.Add(sub_bval);
			ef_list.Add(TRUE);	vtx_list.Add(sub_pbb);	val_list.Add(sub_bval);
			ef_list.Add(TRUE);	vtx_list.Add(sub_pt);	val_list.Add(sub_tval);
			rect_flag.Add(FALSE);
		}
		else if((sub_bval*sub_tval) < 0) 
		{
			sub_mval = 0.0;
			CUtilFuncs::GetInnerLinePoint(fabs(sub_bval), fabs(sub_tval), sub_pb, sub_pt, pm);
			ef_list.Add(bAnyFill || bIsStart);	vtx_list.Add(sub_pb);	val_list.Add(sub_bval);
			ef_list.Add(TRUE);	vtx_list.Add(sub_pbb);	val_list.Add(sub_bval);
			ef_list.Add(TRUE);	vtx_list.Add(pm);		val_list.Add(sub_mval);
			rect_flag.Add(FALSE);
			ef_list.Add(TRUE);	vtx_list.Add(pm);		val_list.Add(sub_mval);
			ef_list.Add(bAnyFill || bIsEnd);	vtx_list.Add(sub_ptt);	val_list.Add(sub_tval);
			ef_list.Add(TRUE);	vtx_list.Add(sub_pt);	val_list.Add(sub_tval);
			rect_flag.Add(FALSE);
		}
		else 
		{
			ef_list.Add(bAnyFill || bIsStart);	vtx_list.Add(sub_pb);	val_list.Add(sub_bval);
			ef_list.Add(TRUE);	vtx_list.Add(sub_pbb);	val_list.Add(sub_bval);
			ef_list.Add(bAnyFill || bIsEnd);	  vtx_list.Add(sub_ptt);	val_list.Add(sub_tval);
			ef_list.Add(TRUE);	vtx_list.Add(sub_pt);	val_list.Add(sub_tval);
			rect_flag.Add(TRUE);
		}
	}
}

void CForceEngine::OutputWForcNumbers(CDC *pDC)
{
	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;

	int				i, j, elem_num, slopeb, slopet, order1, order2;
	T_ELEM_K		ekey;
	T_ELEM_D		edata;
	T_STRW_D		wforc_d;
	C3DPoint		bi_3D, bj_3D, ti_3D, tj_3D,DrawPoint;
	CPoint			text_p,bi, bj, ti, tj;
	TCHAR			fmt_str[10], text_str[512];
	CFont			ft, *old_ft;
	BOOL			fl_bak=gm->m_DOPT.DR.m_bFrameLine, is_inverse;

	POSITION		pos;
	CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		polygon_list;
	CArray <CArray <BOOL, BOOL> *, CArray <BOOL, BOOL> *>					edge_list;
	CArray <CArray <T_NODE_K, T_NODE_K> *, CArray <T_NODE_K, T_NODE_K> *>	VertexNode;

	if (!m_bWForcDataSet)
		return;

	if (gm->m_DOPT.TX.m_bNumberOpaque)
		pDC->SetBkMode(OPAQUE);
	else
		pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
	pDC->SetBkColor(gm->m_DOPT.TX.m_NumberBackCol);

	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T("%s%de"), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T("%s%df"), _T("%."), gm->m_NumberDecimalPoint);

	gm->m_DOPT.DR.m_bFrameLine = TRUE;

	BOOL bGrpFltMode=gm->m_pGPSCtrl->IsGroupFilterMode();
	if(!bGrpFltMode)elem_num = gm->m_EKeyListActive.GetSize();
	else            elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize(); 

	CDBDoc* pDoc = CDBDoc::GetDocPoint();
	//CStoryData StoryData(pDoc);
	//StoryData.MakeStoryData(1);
	CStoryData* pStoryData = pDoc->GetStoryData();

	for (i=0;i<elem_num;i++) 
	{
		//ekey = gm->m_EKeyListActive[i];
		if(!bGrpFltMode)ekey = gm->m_EKeyListActive[i];
		else            ekey = gm->m_pDispFilter->m_aGrpEKey[i]; 

		if(!gm->m_pGPSCtrl->IsActiveElem(ekey))
			continue;

		m_pDoc->m_pAttrCtrl->GetElem(ekey, edata);

		if (!m_pDoc->m_pAttrCtrl->IsWall(edata.eltyp))
			continue;

		T_WALL_KEY KeyWall;
		T_WALL_D DataWall;
		UINT nInternalWallID;
		if(!m_pDoc->m_pPostCtrl->GetInternalWallId(ekey, nInternalWallID))  continue;
		if(!m_pDoc->m_pPostCtrl->GetWallKey(nInternalWallID, KeyWall))      continue;
		if(!m_pDoc->m_pPostCtrl->GetWallData(KeyWall, DataWall))            continue;    
		
		CArray<T_ELEM_K,T_ELEM_K> ElemKeyList;
		T_ELEM_K RootKey,FirstElem,LastElem;
		m_pDoc->m_pAttrCtrl->GetKeyListBy_WallID_ByStor(ElemKeyList, ekey, NULL, pStoryData);
		m_pDoc->m_pAttrCtrl->GetRootWallElemKey(ElemKeyList, RootKey);

		if(RootKey != ekey) continue;

		C3DPoint		start_bi_3D, start_bj_3D, start_ti_3D, start_tj_3D;
		C3DPoint		end_bi_3D, end_bj_3D, end_ti_3D, end_tj_3D;

		CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		start_polygon_list;
		CArray <CList <C3DPoint, C3DPoint> *, CList <C3DPoint, C3DPoint> *>		end_polygon_list;

		m_pDoc->m_pAttrCtrl->GetWallIDFirstLastElem(ElemKeyList,FirstElem,LastElem,FALSE);

		if (m_bDeformedShapeContour) 
		{
			//gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list, &VertexNode);
			gm->m_pDeformEngine->GetDeformedShapeElement(FirstElem, &start_polygon_list, &edge_list, &VertexNode);
			gm->m_pDeformEngine->GetDeformedShapeElement(LastElem, &end_polygon_list, &edge_list, &VertexNode);
		}
		else 
		{
			//gm->GetShapeElement(ekey, polygon_list, &edge_list, NULL, &VertexNode);
			gm->GetShapeElement(FirstElem, start_polygon_list, &edge_list, NULL, &VertexNode);
			gm->GetShapeElement(LastElem, end_polygon_list, &edge_list, NULL, &VertexNode);
		}

		order1 = GetNodeOrder(VertexNode[0]->GetAt(0), edata, 4);
		order2 = GetNodeOrder(VertexNode[0]->GetAt(1), edata, 4);

		pos = start_polygon_list[0]->GetHeadPosition();
		start_bi_3D = start_polygon_list[0]->GetNext(pos);
		start_bj_3D = start_polygon_list[0]->GetNext(pos);
		start_tj_3D = start_polygon_list[0]->GetNext(pos);
		start_ti_3D = start_polygon_list[0]->GetNext(pos);

		pos = end_polygon_list[0]->GetHeadPosition();
		end_bi_3D = end_polygon_list[0]->GetNext(pos);
		end_bj_3D = end_polygon_list[0]->GetNext(pos);
		end_tj_3D = end_polygon_list[0]->GetNext(pos);
		end_ti_3D = end_polygon_list[0]->GetNext(pos);

		bi_3D = start_bi_3D + end_bi_3D;
		bj_3D = start_bj_3D + end_bj_3D;
		ti_3D = start_ti_3D + end_ti_3D;
		tj_3D = start_tj_3D + end_tj_3D;

		bi_3D.x = bi_3D.x / 2; bi_3D.y = bi_3D.y / 2; bi_3D.z = bi_3D.z / 2;
		bj_3D.x = bj_3D.x / 2; bj_3D.y = bj_3D.y / 2; bj_3D.z = bj_3D.z / 2; 
		ti_3D.x = ti_3D.x / 2; ti_3D.y = ti_3D.y / 2; ti_3D.z = ti_3D.z / 2;
		tj_3D.x = tj_3D.x / 2; tj_3D.y = tj_3D.y / 2; tj_3D.z = tj_3D.z / 2;

 
		// MQC:1527 20080121 mylee - Wall Force 요소별 아닌 한곳에 출력하도록
		T_WALL_D winfo;
		if (!GetWallInfo(ekey, winfo)) continue;

		if (gm->m_bVirtualMode) 
		{
			double dWallCoordX = DataWall.xc; double dWallCoordY = DataWall.yc;

			bi_3D.x = dWallCoordX; 
			bj_3D.x = dWallCoordX; 
			ti_3D.x = dWallCoordX; 
			tj_3D.x = dWallCoordX;

			bi_3D.y = dWallCoordY; 
			bj_3D.y = dWallCoordY; 
			ti_3D.y = dWallCoordY; 
			tj_3D.y = dWallCoordY;

			bi = gm->m_pGPSCtrl->GetWorldToWindowP2D(bi_3D);
			bj = gm->m_pGPSCtrl->GetWorldToWindowP2D(bj_3D);
			ti = gm->m_pGPSCtrl->GetWorldToWindowP2D(ti_3D);
			tj = gm->m_pGPSCtrl->GetWorldToWindowP2D(tj_3D);
		}
		else
		{
			double dWallCoordX = DataWall.xc; double dWallCoordY = DataWall.yc;
			
			bi_3D.x = dWallCoordX; 
			bj_3D.x = dWallCoordX; 
			ti_3D.x = dWallCoordX; 
			tj_3D.x = dWallCoordX;

			bi_3D.y = dWallCoordY; 
			bj_3D.y = dWallCoordY; 
			ti_3D.y = dWallCoordY; 
			tj_3D.y = dWallCoordY;

			bi = gm->m_pGPSCtrl->GetWorldToMemDCP2D(bi_3D);
			bj = gm->m_pGPSCtrl->GetWorldToMemDCP2D(bj_3D);
			ti = gm->m_pGPSCtrl->GetWorldToMemDCP2D(ti_3D);
			tj = gm->m_pGPSCtrl->GetWorldToMemDCP2D(tj_3D);
		}

		if((bi.x >=0 && bi.y >= 0) &&
			(bj.x >=0 && bj.y >= 0) &&
			(ti.x >=0 && ti.y >= 0) &&
			(tj.x >=0 && tj.y >= 0) )
		{

			slopeb = (int) (atan2(bi.y-bj.y, bj.x-bi.x)*1800.0/3.14159);
			slopeb = (slopeb+3600)%3600;
			slopet = (int) (atan2(ti.y-tj.y, tj.x-ti.x)*1800.0/3.14159);
			slopet = (slopet+3600)%3600;

			if ((900<slopeb) && (slopeb<=2700)) {
				slopeb = (slopeb+1800)%3600;
			}
			if ((900<slopet) && (slopet<=2700)) {
				slopet = (slopet+1800)%3600;
			}

			if (ti.y > bi.y)
				is_inverse = TRUE;
			else
				is_inverse = FALSE;

			GetWallData(ekey, wforc_d);
			double dWTopValue = CalcWForcValue(wforc_d, WALL_TOP);
			double dWBotValue = CalcWForcValue(wforc_d, WALL_BOTTOM);
			double dWMaxValue = (fabs(dWTopValue) > fabs(dWBotValue))? dWTopValue:dWBotValue;

			if(gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
			{
				double dLimit = (m_dMaxValue-m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;
				double dWValue;

				for(int n=0; n<2; n++)
				{
					if(n==0) // TOP 또는 MAX
					{
						if (m_WForcOutputLocation == WFORC_OUTPUT_BOT) continue;

						if (m_WForcOutputLocation == WFORC_OUTPUT_TOP || m_WForcOutputLocation == WFORC_OUTPUT_ALL) 
						{
							// Top ////////////////////////////////////////////////////////////////////////
							gm->SetNumberFontOrientation(slopet);
							ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
							old_ft = (CFont *) pDC->SelectObject(&ft);

							DrawPoint.x = (ti_3D.x + tj_3D.x)/2.0;
							DrawPoint.y = (ti_3D.y + tj_3D.y)/2.0;
							DrawPoint.z = (ti_3D.z + tj_3D.z)/2.0;

							if (is_inverse)
								pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);
							else
								pDC->SetTextAlign(TA_CENTER|TA_TOP);

							dWValue = dWTopValue;

						}
						else if (m_WForcOutputLocation == WFORC_OUTPUT_MAX) 
						{
							// MAX ////////////////////////////////////////////////////////////////////////
							gm->SetNumberFontOrientation(slopet);
							ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
							old_ft = (CFont *) pDC->SelectObject(&ft);

							DrawPoint.x = (ti_3D.x + tj_3D.x + bi_3D.x + bj_3D.x)/4.0;
							DrawPoint.y = (ti_3D.y + tj_3D.y + bi_3D.y + bj_3D.y)/4.0;
							DrawPoint.z = (ti_3D.z + tj_3D.z + bi_3D.z + bj_3D.z)/4.0;

							if (is_inverse)
								pDC->SetTextAlign(TA_CENTER|TA_TOP);
							else
								pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);

							dWValue = dWMaxValue;
						}
					}
					else // Bottom
					{			  
						if (m_WForcOutputLocation == WFORC_OUTPUT_TOP || m_WForcOutputLocation == WFORC_OUTPUT_MAX ) continue;
						// Bot ////////////////////////////////////////////////////////////////////////
						gm->SetNumberFontOrientation(slopet);
						ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
						old_ft = (CFont *) pDC->SelectObject(&ft);

						DrawPoint.x = (bi_3D.x + bj_3D.x)/2.0;
						DrawPoint.y = (bi_3D.y + bj_3D.y)/2.0;
						DrawPoint.z = (bi_3D.z + bj_3D.z)/2.0;

						if (is_inverse)
							pDC->SetTextAlign(TA_CENTER|TA_TOP);
						else
							pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);

						dWValue = dWBotValue;
					}

					switch(gm->m_DOPT.TX.m_nOutputMinMaxType)
					{
					case 0: // Min & Max
						if((m_dMaxValue-dWValue) <= dLimit)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,dWValue);
						else if((dWValue-m_dMinValue) <= dLimit)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,dWValue);
						break;
					case 1: // Abs Max
						if(fabs(m_dMaxValue) >= fabs(m_dMinValue))
						{
							if( fabs(m_dMaxValue)-fabs(dWValue) <= dLimit)
								DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dWValue);
						}
						else
						{
							if( fabs(m_dMinValue)-fabs(dWValue) <= dLimit)
								DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dWValue);
						}
						break;
					case 2: // Max
						if((m_dMaxValue-dWValue) <= dLimit)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,dWValue);
						break;
					case 3: // Min
						if((dWValue-m_dMinValue) <= dLimit)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,dWValue);
						break;
					}

					pDC->SelectObject(old_ft);
					ft.DeleteObject();
				}
				//////////////////////////////////////////////////////////////////////////////////////
			}      
			else      
			{
				if(m_WForcOutputLocation == WFORC_OUTPUT_ALL || m_WForcOutputLocation == WFORC_OUTPUT_BOT)
				{
					// Bottom ////////////////////////////////////////////////////////////////////
					gm->SetNumberFontOrientation(slopeb);
					ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
					old_ft = (CFont *) pDC->SelectObject(&ft);

					text_p.x = (int) ((bi.x+bj.x)/2.0);
					text_p.y = (int) ((bi.y+bj.y)/2.0);
					_stprintf(text_str, fmt_str, dWBotValue);
					if (is_inverse)
						pDC->SetTextAlign(TA_CENTER|TA_TOP);
					else
						pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);
					pDC->TextOut(text_p.x, text_p.y, text_str);

					pDC->SelectObject(old_ft);
					ft.DeleteObject();
				}

				if(m_WForcOutputLocation == WFORC_OUTPUT_ALL || m_WForcOutputLocation == WFORC_OUTPUT_TOP)
				{
					// Top ////////////////////////////////////////////////////////////////////////
					gm->SetNumberFontOrientation(slopet);
					ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
					old_ft = (CFont *) pDC->SelectObject(&ft);

					text_p.x = (int) ((ti.x+tj.x)/2.0);
					text_p.y = (int) ((ti.y+tj.y)/2.0);
					_stprintf(text_str, fmt_str, dWTopValue);

					if (is_inverse)
						pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);
					else
						pDC->SetTextAlign(TA_CENTER|TA_TOP);
					pDC->TextOut(text_p.x, text_p.y, text_str);

					pDC->SelectObject(old_ft);
					ft.DeleteObject();
				}

				if(m_WForcOutputLocation == WFORC_OUTPUT_MAX)
				{
					// Max ////////////////////////////////////////////////////////////////////////
					gm->SetNumberFontOrientation((slopet+ slopeb)/2.0);
					ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
					old_ft = (CFont *) pDC->SelectObject(&ft);

					text_p.x = (int) ((ti.x+tj.x+bi.x+bj.x)/4.0);
					text_p.y = (int) ((ti.y+tj.y+bi.y+bj.y)/4.0);
					_stprintf(text_str, fmt_str,dWMaxValue);

					if (is_inverse)
						pDC->SetTextAlign(TA_CENTER|TA_TOP);
					else
						pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);
					pDC->TextOut(text_p.x, text_p.y, text_str);

					pDC->SelectObject(old_ft);
					ft.DeleteObject();
				}
			}

		}


		/////////////////////////////////////////////////////////////////////////////////

		for (j=0;j<polygon_list.GetSize();j++) {
			polygon_list[j]->RemoveAll();
			delete polygon_list[j];
			VertexNode[j]->RemoveAll();
			delete VertexNode[j];
			edge_list[j]->RemoveAll();
			delete edge_list[j];
		}
		polygon_list.RemoveAll();
		VertexNode.RemoveAll();
		edge_list.RemoveAll();
	}

	gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}

BOOL CForceEngine::GetNodalValueforCutting(T_ELEM_K PlateKey,double& NodalVal1,int i, double& NodalVal2, int j)
{
	T_STRP_DL		pforc_d;

	if(m_PForcComponent == PFORC_COMPONENT_MOMENT_COMB)
	{
		T_SLAB_FORCE_COMPACT SlabForce;

		if(m_bAverage)
		{
			if(!IsSubDomainElem(PlateKey))
			{
				return FALSE;
			}
		}
		else
		{
			if(!m_mapSlabForce.Lookup(PlateKey, SlabForce))
			{
				return FALSE;
			}
		}

		NodalVal1 = CalcPForcWoodArmer(PlateKey, i);
		NodalVal2 = CalcPForcWoodArmer(PlateKey, j);
	}
	else
	{
		if(!GetPlateForce(PlateKey, pforc_d)) return FALSE;    
		NodalVal1 = CalcPForcValue(pforc_d, i+1); // i:0= Center
		NodalVal2 = CalcPForcValue(pforc_d, j+1);     
	}		
	return TRUE; 
}

// DATE : 2002.9.17 by KYE-HONG
// FUNC : Cutting Line을 위해 새롭게 만들었음 
BOOL CForceEngine::GetNodalValueforCutting(T_STRP_DL& PForc,double& NodalVal1,int i, double& NodalVal2, int j)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	int nBackComp = m_PForcComponent;

	//if(gm->m_pBDT->PFUD.nComp>2) m_PForcComponent=gm->m_pBDT->PFUD.nComp+3;
	//else m_PForcComponent=gm->m_pBDT->PFUD.nComp;

	NodalVal1 = CalcPForcValue(PForc, i+1); // i:0= Center
	NodalVal2 = CalcPForcValue(PForc, j+1); 

	m_PForcComponent = nBackComp; 
	return TRUE; 
}

void CForceEngine::DrawSFDBMDContourList_mono(CDC *pDC, CArray <int, int> &vnum_list, CArray <VtxInfo, VtxInfo> &vtx_list)								
{
	int							i, j, k, poly_num=vnum_list.GetSize();
	I_GPSModel					*gm=(I_GPSModel *) m_pGPSModel;
	CList <C3DPoint, C3DPoint>	vlist;

	CClientDC		ClientDC(((I_GPSModel*)m_pGPSModel)->m_pMyView);

	if (m_pContourEngine == NULL) {
		return;
	}

	k = 0;

	for (i=0;i<poly_num;i++) {
		for (j=0;j<vnum_list[i];j++) {
			vlist.AddTail(vtx_list[k+j].vtx);
		}

		//COLORREF color =gm->m_BeamDiagramColor;
		COLORREF color =gm->m_DOPT.CL.m_BeamDiagramColor;

		if (gm->m_bVirtualMode)
			gm->m_pGPSCtrl->DrawPolygon3DFillOnClientWindow(pDC, vlist, color);
		else
		{
			if (!gm->m_bAnimation)
				gm->m_pGPSCtrl->DrawPolygon3DFillOnClientWindow(&ClientDC, vlist, color);
			gm->m_pGPSCtrl->DrawPolygon3DFill(pDC, vlist, color);
		}
		vlist.RemoveAll();
		k += vnum_list[i];
	}

}

void CForceEngine::ResetEngine()
{
	CEngineBase::ResetEngine();
	// Truss Member
	m_bTForcDataSet				= FALSE;
	m_TForcPart					  = I_NODE;
	m_TForcComponent			= TFORC_COMPONENT_ALL;
	m_TForcOutputSection	= TFORC_OUTPUT_ALL;

	// Beam Member
	m_bBForcDataSet				= FALSE;

	// For Beam Member Force/Moment Operation
	m_BForcPart					  = PART_I;
	m_BForcComponent			= BFORC_COMPONENT_MY;
	m_nBForcPscPart       = 0;   // Total
	m_BForcOutputSection	= BFORC_OUTPUT_MAX;
	m_bBForcOutputMax			= TRUE;
	m_bBForcOutputMinMax  = FALSE; 
	m_bBForcOutputAll			= FALSE;
	m_bBForcOutputI				= FALSE;
	m_bBForcOutputC				= FALSE;
	m_bBForcOutputJ				= FALSE;
	m_bBForcOutputByMember= FALSE;
	m_bBsfdBmdByMember    = FALSE;

	m_bBInflIclImpFct     = FALSE; 
	m_bTInflIclImpFct     = FALSE; 
	m_bPInflIclImpFct     = FALSE; 

	// For Drawing Beam Member Shear Force/Bending Moment Diagram
	m_BSfdBmdAdjustFactor		 = 1.0;
	m_BSfdBmdScFactor				 = 1.0;
	m_bBSfdBmdExact					 = FALSE;
	m_bBSfdBmdLineOnly			 = TRUE;
	m_bVerticalLineFill      = TRUE;

	// Wall Member
	m_bWForcDataSet				= FALSE;
	m_WForcComponent			= WFORC_COMPONENT_MY;
	m_WSfdBmdAdjustFactor		= 1.0;
	m_WSfdBmdScFactor			= 1.0;
	m_bWSfdBmdLineOnly			= TRUE;

	// Plate Member
	m_bPForcDataSet				  = FALSE;
	m_PForcComponent			  = PFORC_COMPONENT_MXX;
	m_MVLTRCPForcComponent  = MVLTRC_PFORC_COMPONENT_MXX;
	m_PForcPart					    = PLATE_PART_CENT;
	m_PForcVtAdjustFactor		= 1.0;
	m_PForcVtScaleFactor		= 1.0;
	m_bAverage					    = FALSE;
	m_bAverageNodalActiveOnly = FALSE;
	m_nPlateForceLocalGlobal = 1; // local
	m_bStripOutput = FALSE;

	m_BeamKeyList.RemoveAll();
	m_BeamReverseFg.RemoveAll();
	m_BForcDataList.RemoveAll();
	m_PForcDataList.RemoveAll();
	m_PlateReverseFg.RemoveAll(); //KYE-HONG-20020204
	m_mapBForcData.RemoveAll();
	m_mapBForcDataMin.RemoveAll();
	m_mapPForcData.RemoveAll();
	m_mapPForcData_G.RemoveAll();
	m_mapResultantForceData.RemoveAll();
	m_mapResultantForceDataMxMn.RemoveAll();
	m_mapTForcData.RemoveAll();
	m_mapSFDBMDMax.RemoveAll();
	m_mapWallInfoData.RemoveAll();
	m_mapWForcData.RemoveAll();
	m_TForcDataList.RemoveAll();
	m_TrussKeyList.RemoveAll();
	m_TrussReverseFg.RemoveAll();
	m_WallKeyList.RemoveAll();
	for(int ii=0; ii<3; ii++)m_arTrussEccen[ii].RemoveAll();//KYE-HONG-20020208

	//m_arEleDivNum.RemoveAll();

	m_bSSFRDataSet=FALSE; 
	m_nSSFRDir=0;
	m_nSSFROutType=0;
	m_dSSFRAngle=0.0;
	m_mapSSFRData.RemoveAll();

	// Member Diagram
	m_bMbDgramDataSet=FALSE; 
	m_nMbDgrmNPlanK=0; // Named Plan Key
	m_nMbDgrmSelectMode = 0;
	m_nMbDgrmStorK      = 0;  //  0:Named Plane, 1:Story

	m_arMbDgrmNPlanK.RemoveAll();
	m_bMbDgrmBeamChk=TRUE;
	m_bMbDgrmBrceChk=TRUE;
	m_bMbDgrmColmChk=TRUE;
	m_bMbDgrmWallChk=TRUE;
	m_nMbDgrmDeciPt=2;
	m_bMbDgrmExpChk=FALSE;
	m_bMbDgrmShowDgrm=TRUE;
	m_mapMbDgrmD.RemoveAll();
	m_MSfdBmdAdjustFactor = 1.0;
	m_nMbdgrmDgrmComp = 2; 
	m_nMbDgrmOutType  = 0; 
	m_nMbDgrmDgrmType=0;
	m_dMbDgrmScFt=0.5;
	m_bMbDgrmValAxial = TRUE;
	m_bMbDgrmValShear = TRUE;
	m_bMbDgrmValMoment= TRUE;
	m_bPrintUCSAxis   = TRUE; 
	memset(m_dMbDgrmLocalVec,0,sizeof(m_dMbDgrmLocalVec));
	for(int i=0; i<3; i++)
	{
		m_dMbDgrmMaxVal[i]=0.0;
		m_nMbDgrmMaxKey[i]=0;
	}

	m_NlnkPart = NLNK_PART_I; 
	m_NlnkComp = NLNK_COMPONENT_MYY; 
	m_ElnkPart = ELNK_PART_I; 
	m_ElnkComp = NLNK_COMPONENT_MYY; 
	m_dNlnkScFc = 1.0;
	m_dElnkScFc = 1.0;

	m_dThisTimeStep   = 0.0;
	m_nThisTimeIndex  = 0;
	m_bThisFunction   = 0;   
	m_nFunctionKey    = 0;    //  m_nThisCaseOrFunc = 1일때 Function Key
	m_bThisFunction   = FALSE; 
	m_mapNForcData.RemoveAll();

	m_bMaxMinDgrm  = TRUE;
	m_bBForcWithTForc = FALSE;
	m_bBForcOnlyTForc = FALSE; 

	m_dMxxCoeff = 1.0;
	m_dMyyCoeff = 1.0;
	m_nMxxMyyMode = 0;  
	m_dMxyCoeff   = 1.0;

	m_nWoodArmerTopBot = 0;
	m_dWoodArmerAngle  = 0.0;
	m_mapSlabForce.RemoveAll();

	m_bEnvelopeLC = FALSE;
	m_Mldt = 0;
	m_bRFrcdTopAlignment = TRUE;
	m_nRfrcdOutputPos = 2; // 0:I, 1:J, 2:All
	m_ResultantForceComponent = 4; // My

	m_mapYeildPointIdx.clear();
	m_bYieldPoint = FALSE;
}

void CForceEngine::GetUCSVector(T_NUCS_D &NUCS, double UCSV[][3])
{
	double dVz[3];

	CMathFunc::mathCross(NUCS.dVx,NUCS.dVy,dVz);

	UCSV[0][0] = NUCS.dVx[0];
	UCSV[0][1] = NUCS.dVx[1];
	UCSV[0][2] = NUCS.dVx[2];
	UCSV[1][0] = NUCS.dVy[0];
	UCSV[1][1] = NUCS.dVy[1];
	UCSV[1][2] = NUCS.dVy[2];
	UCSV[2][0] = dVz[0];
	UCSV[2][1] = dVz[1];
	UCSV[2][2] = dVz[2];
	CMathFunc::mathNormalize(UCSV[0],UCSV[0]);
	CMathFunc::mathNormalize(UCSV[1],UCSV[1]);
	CMathFunc::mathNormalize(UCSV[2],UCSV[2]);
}


void CForceEngine::ExportPlateData()
{

	CFile file;
	CString sFileName;
	CGPS_PLATE_RESULT PlateElem;
	T_GNODE_D gNode;

	CFileDialog fd(FALSE, _T(".gps"), NULL, OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_LONGNAMES,
		_T("MIDAS GPS Output File (*.gps)|*.gps|All File(*.*)|*.*||"), NULL);
	if (fd.DoModal() == IDOK)
		sFileName = fd.GetFileName();
	else
		return; 

	InitEngine();
	file.Open(sFileName,CFile::modeCreate|CFile::modeWrite);
	CArchive ar(&file, CArchive::store);

	int			nElemCount,nNodeCount;
	CArray<T_NODE_K,T_NODE_K> arNodeKey;
	m_pDoc->m_pAttrCtrl->GetNodeKeyList(arNodeKey);
	CMap<T_NODE_K,T_NODE_K,BOOL,BOOL> mapNode;
	T_NODE_D node;

	T_ELEM_D elem;
	int nie;
	nElemCount = m_PlateKeyList.GetSize();
	for(int i=0; i<nElemCount; i++)
	{
		m_pDoc->m_pAttrCtrl->GetElem(m_PlateKeyList[i],elem);
		nie = m_pDoc->m_pAttrCtrl->GetNumNode(elem.eltyp, elem.elnod);
		for(int j=0; j<nie; j++)
			mapNode.SetAt(elem.elnod[j],TRUE);
	}

	nNodeCount=arNodeKey.GetSize();
	ar<<mapNode.GetCount();
	BOOL bExist;
	T_DISP_D disp;
	for(int i=0; i<nNodeCount; i++)
	{
		if(!mapNode.Lookup(arNodeKey[i],bExist)) continue;
		gNode.node_k = arNodeKey[i];
		m_pDoc->m_pAttrCtrl->GetNode(arNodeKey[i],node);
		gNode.x = node.x;
		gNode.y = node.y;
		gNode.z = node.z;

		if(!m_pDoc->m_pPostCtrl->GetDispNew(arNodeKey[i], &disp,NULL,NULL)) continue;
		for(int j=0; j<6; j++)
			gNode.disp[j] = disp.dblDisp[j];

		gNode.Serialize(ar);
	}


	T_STRP_DL pforc;
	ar<<nElemCount;// the number of elements
	for(int i=0; i<nElemCount; i++)
	{
		PlateElem.aNodes.RemoveAll();
		m_pDoc->m_pAttrCtrl->GetElem(m_PlateKeyList[i],elem);
		nie = m_pDoc->m_pAttrCtrl->GetNumNode(elem.eltyp, elem.elnod);

		PlateElem.nDataType = 0; //Force
		for(int j=0; j<nie; j++)
			PlateElem.aNodes.Add(elem.elnod[j]);

		m_mapPForcData.Lookup(m_PlateKeyList[i],pforc);
		memcpy(PlateElem.dblForce,pforc.dblForce,sizeof(PlateElem.dblForce));
		memcpy(PlateElem.dblStress,pforc.dblStress,sizeof(PlateElem.dblStress));

		ar<<GPS_PLATE; // ElemType
		PlateElem.Serialize(ar);		
	}

	ar.Close();
	file.Close();

}

BOOL CForceEngine::IsPossibleExactSfdBmdMode(void)
{
	if(!m_bBSfdBmdExact)return FALSE; 

	T_PDEL_D PdelD;
	BOOL bPDelLdc=FALSE;
	BOOL bIsPossible; 
	BOOL bMoment;
	I_GPSModel		*gm=(I_GPSModel *) m_pGPSModel;

	if(m_pDoc->m_pAttrCtrl->GetPdel(PdelD))
		for(int i=0; i<D_PDEL_NUMPDEL; i++)
		{
			if(PdelD.PdelCase[i].LoadCaseKey==gm->m_LoadCaseKey)
			{
				bPDelLdc=TRUE; 
				break; 
			}
		}
		bMoment =((m_BForcComponent==BFORC_COMPONENT_MX)||(m_BForcComponent==BFORC_COMPONENT_MY)|| 
			(m_BForcComponent==BFORC_COMPONENT_MZ)||(m_BForcComponent==BFORC_COMPONENT_MYZ) ||
			(m_BForcComponent==BFORC_COMPONENT_W) || (m_BForcComponent==BFORC_COMPONENT_MT) || (m_BForcComponent==BFORC_COMPONENT_MW));

		if(m_bBSfdBmdExact)
		{
			if(bMoment && bPDelLdc) bIsPossible=FALSE; 
			else  bIsPossible=TRUE; 
		}
		else
		{
			bIsPossible=FALSE; 
		}

		return bIsPossible; 
}

void CForceEngine::ResetDrawCLWPData(void)
{
	m_arDrawCLWPMnMx.RemoveAll();
	for(int i=0; i<m_parDrawCLWP.GetSize(); i++)
	{
		if(m_parDrawCLWP[i])
		{
			if(m_parDrawCLWP[i]->GetSize())m_parDrawCLWP[i]->RemoveAll();
			delete m_parDrawCLWP[i];
			m_parDrawCLWP[i]=NULL; 
		}
	}
	m_parDrawCLWP.RemoveAll(); 
}

/*---------------------------------------------------------------------------------------------------
* DATE : 2003.1.23. by KYE-HONG
* FUNC : Story Shear Force Ratio Contour를 그리기 위한 
데이터 생성 
---------------------------------------------------------------------------------------------------*/
BOOL  CForceEngine::MakeSSFRData(void)
{
	I_GPSModel *gm=(I_GPSModel *) m_pGPSModel;

	int		    i,nElemNum;
	double	  MxVal=-DBL_MAX, MnVal=DBL_MAX;
	BOOL		  has_content=FALSE;
	T_ELEM_K	ElemK;
	T_ELEM_D	ElemD;
	T_SSRT_K  SsrtK;
	T_SSRT_D  SsrtD;

	if(!gm->m_bLoadDataSet)return FALSE;
	UINT nLKey=gm->m_LoadCaseKey;
	UINT nLTyp=gm->m_LoadCaseType;

	gm->m_pMyView->BeginWaitCursor();

	// Output Type Ratio인 경우는 각층의 
	// Shear Force의 합이 필요하다. 
	// Map으로 구성한후 나중에 사용함 
	CMap<T_STOR_K,T_STOR_K,T_SSRT_D,T_SSRT_D&> mapStorySSRT;
	if(m_nSSFROutType==1)
	{
		CArray<T_STOR_K,T_STOR_K> arStorK; 
		m_pDoc->m_pAttrCtrl->GetStorKeyList(arStorK); 
		SsrtK.key.type = 3;
		for(i=0; i<arStorK.GetSize(); i++)
		{
			SsrtK.key.entity  = arStorK[i];
			m_pDoc->m_pPostCtrl->GetStoryShearRatio(SsrtK, nLTyp, nLKey, 0, m_dSSFRAngle, SsrtD, TRUE);
			mapStorySSRT.SetAt(arStorK[i],SsrtD); 
		}
	}

	UINT WallId;
	m_mapSSFRData.RemoveAll(); 
	nElemNum = gm->m_EKeyListActive.GetSize();

	for(i=0;i<nElemNum;i++) 
	{
		ElemK = gm->m_EKeyListActive[i];
		m_pDoc->m_pAttrCtrl->GetElem(ElemK, ElemD);

		if(m_pDoc->m_pAttrCtrl->IsWall(ElemD.eltyp))
		{
			m_pDoc->m_pPostCtrl->GetInternalWallId(ElemK, WallId);     
			SsrtK.key.type    = 2;
			SsrtK.key.entity  = WallId;
		}
		// Plnar Type
		else if(m_pDoc->m_pAttrCtrl->IsPlaneType(ElemD.eltyp))
		{
			SsrtK.key.type    = 7;
			SsrtK.key.entity  = ElemK;
		}
		// Solid Type
		else if(m_pDoc->m_pAttrCtrl->IsSolidType(ElemD.eltyp))
		{
			SsrtK.key.type    = 8;
			SsrtK.key.entity  = ElemK;
		}
		
		//Truss Type
		else if(m_pDoc->m_pAttrCtrl->IsTruss(ElemD.eltyp))
		{
			SsrtK.key.type    = 11;
			SsrtK.key.entity  = ElemK;
		}

		else
		{
			SsrtK.key.type    = 1;
			SsrtK.key.entity  = ElemK;
		}
		if(!m_pDoc->m_pPostCtrl->GetStoryShearRatio(SsrtK,nLTyp,nLKey, 0, m_dSSFRAngle,SsrtD, TRUE))continue;// 요소 Type에 따라 Key를 구분 


		// 하중 Type에 따라 전단력 성분 분류 
		double dValue=0.0; 
		//TEST dValue=i; 
		switch(nLTyp)
		{
		case D_LOADCASE_STATIC:
			dValue = SsrtD.dShearX; 
			break; 
		case D_LOADCASE_SPECTRUM:
		case D_LOADCASE_SPECTRUM_ND:
			if(m_nSSFRDir==0) dValue = SsrtD.dShearX; // Angle방향 
			else              dValue = SsrtD.dShearY; // Angle방향의 수직  
			break; 
		default:
			ASSERT(FALSE);
			continue;
		}

		// Ratio출력의 경우 StoryRatio Map에서 
		// 값을 구한후 이를 나누어 저장.. 
		if(m_nSSFROutType==1)
		{
			double dSumValNewton;
			T_SSRT_D    SsrtDTmp;
			T_SSRT_UNIT SsrtUnit;
			if(!mapStorySSRT.Lookup(SsrtD.StorKey,SsrtDTmp)){ ASSERT(FALSE); continue; }

			switch(nLTyp)
			{
			case D_LOADCASE_STATIC:
				dSumValNewton = m_pDoc->m_pUnitCtrl->ConvertUnitDataIn(SsrtUnit.dShearX,SsrtDTmp.dShearX);
				if(fabs(dSumValNewton)<1.0){ continue; } //1N 보다 작으면 취급안함 
				dValue/=SsrtDTmp.dShearX; 
				break; 
			case D_LOADCASE_SPECTRUM:
			case D_LOADCASE_SPECTRUM_ND:
				if(m_nSSFRDir==0) 
				{
					dSumValNewton = m_pDoc->m_pUnitCtrl->ConvertUnitDataIn(SsrtUnit.dShearX,SsrtDTmp.dShearX);
					if(fabs(dSumValNewton)<1.0){ continue; } //1N 보다 작으면 취급안함 
					dValue /= SsrtDTmp.dShearX; // Angle방향 
				}
				else              
				{
					dSumValNewton = m_pDoc->m_pUnitCtrl->ConvertUnitDataIn(SsrtUnit.dShearY,SsrtDTmp.dShearY);
					if(fabs(dSumValNewton)<1.0){ continue; } //1N 보다 작으면 취급안함 
					dValue /= SsrtDTmp.dShearY; // Angle방향의 수직  
				}
				break; 
			} 
		}

		has_content = TRUE;

		if(dValue>MxVal) {  MxVal = dValue; gm->m_nLgdMaxValKey = ElemK;}
		if(dValue<MnVal) {  MnVal = dValue; gm->m_nLgdMinValKey = ElemK;}
		m_mapSSFRData.SetAt(ElemK,dValue);
	}

	if(!has_content) 
	{
		MxVal=MnVal=0.0;
		gm->m_nLgdMaxValKey = 0;
		gm->m_nLgdMinValKey = 0;
	}

	m_dMaxValue = MxVal;
	m_dMinValue = MnVal;

	if(m_pContourEngine==NULL)m_pContourEngine = new CContourEngine(MnVal, MxVal);
	else                      m_pContourEngine->MakeRankMap(MnVal, MxVal);

	gm->m_pMyView->EndWaitCursor();

	m_bSSFRDataSet = TRUE;
	return TRUE;
}

void  CForceEngine::DrawSSFRData(CDC *pDC)
{
	I_GPSModel *gm=(I_GPSModel*)m_pGPSModel;

	T_MIRE_K mkey;
	int			i,nElemNum;
	T_ELEM_D	ElemD;
	CArray<int,int>	type_list;
	CArray<GRE_Atom,GRE_Atom&>atom_list;
	BOOL bEscapePressed = FALSE;

	type_list.Add(gm->m_MinOTID + OBJECT_TYPE_ORIGINAL);
	gm->m_pGPSCtrl->GetZSortedList(type_list, gm->m_EKeyListVisible_Mirror, atom_list);
	nElemNum =atom_list.GetSize();

	double dValue; 
	for(i=0; i<nElemNum; i++) 
	{
		if(gm->m_pGPSCtrl->WatchEscKeyPress()) return;
		if(gm->m_pGPSCtrl->IsZoomAllState() ||
			gm->m_pGPSCtrl->IsObjectInClientWindow(atom_list[i].m_OType, atom_list[i].m_OKey)) 
		{
			mkey.keymap = atom_list[i].m_OKey;
			m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, ElemD);

			if(gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey) && !bEscapePressed ) 
			{ 
				if(!m_mapSSFRData.Lookup(atom_list[i].m_OKey,dValue))
				{
					gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
				}
				else
				{
					if(m_pDoc->m_pAttrCtrl->IsFrameType(ElemD.eltyp))
						DoFrameTypeSSFR(atom_list[i].m_OKey,pDC);
					else if(m_pDoc->m_pAttrCtrl->IsPlaneType(ElemD.eltyp))
						DoPlaneTypeSSFR(atom_list[i].m_OKey,pDC); 
					else if(m_pDoc->m_pAttrCtrl->IsSolidType(ElemD.eltyp))
						DoSolidTypeSSFR(atom_list[i].m_OKey,pDC);
					else
					{
						ASSERT(FALSE);
						gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
					}
				}
			}
			else
			{
				gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
			}
		}
	}
}

void  CForceEngine::DoFrameTypeSSFR(T_ELEM_K ElemK,CDC *pDC)
{
	double dValue;
	I_GPSModel  *gm=(I_GPSModel *)m_pGPSModel;

	if(!m_mapSSFRData.Lookup(ElemK,dValue))return; 

	T_MIRE_K mkey;
	mkey.keymap = ElemK;

	int				i, j,poly_num, vtx_num;
	POSITION  nPos;
	T_ELEM_D  elem_d;

	GPS_3DPT_ARRY rvtx_list;
	GPS_DUBL_ARRY	rval_list;
	CArray<GPS_3DPT_LISTP, GPS_3DPT_LISTP>	polygon_list;
	CArray<GPS_BOOL_ARRYP, GPS_BOOL_ARRYP>  edge_list;
	CArray<GPS_UINT_ARRYP, GPS_UINT_ARRYP>	VertexNode;

	if(m_pContourEngine==NULL) return;

	// 요소의 형상정보를 얻음
	m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d);
	gm->GetShapeElement(ElemK, polygon_list, &edge_list, NULL, &VertexNode);

	T_SECT_D SectD;
	if(gm->m_DOPT.DR.m_bFrameThick)
		m_pDoc->m_pAttrCtrl->GetSect(elem_d.elpro,SectD);

	gm->GPS_XGL_Begin_Elem(mkey.key.elem_k,elem_d);

	poly_num = polygon_list.GetSize();
	for (i=0;i<poly_num;i++) 
	{
		vtx_num = polygon_list[i]->GetCount();

		// Contour를 실시
		if(vtx_num == 2) 
		{
			rvtx_list.RemoveAll();
			rval_list.RemoveAll(); 
			nPos=polygon_list[i]->GetHeadPosition();
			rvtx_list.Add(polygon_list[i]->GetNext(nPos));
			rvtx_list.Add(polygon_list[i]->GetNext(nPos));
			rval_list.Add(dValue);
			rval_list.Add(dValue);
			DrawContourLine(pDC, rvtx_list, rval_list, gm->m_DOPT.DR.nElemWire);
		}
		else 
		{
			if(!gm->IsPossibleDrawingPolyFrame(ElemK,&elem_d,&SectD,poly_num,polygon_list[i]))continue;
			//if(poly_num>1 && gm->m_DOPT.DR.m_bFrameThick && !gm->IsVisibleFace(polygon_list[i],vtx_num))
			//continue;

			if(vtx_num != 4)continue;
			double arVal[4];
			for(j=0;j<4;j++)arVal[j]=dValue;
			DoSubPolyContour(pDC, arVal, polygon_list[i], edge_list[i]->GetData(), TRUE);

			// Fill+Outline의 경우 Contour를 수행하기 전의 Polygon의 Outline을 그림.
			if(gm->m_DOPT.DR.m_RenderFlag == 3 || gm->m_DOPT.DR.m_RenderFlag == 2)
				gm->GPSDrawPolygonEdge(pDC, polygon_list[i], edge_list[i]);
		}
	}
	gm->GPS_XGL_End_Elem();

	FreeMemoryPolyList(&polygon_list,&edge_list,&VertexNode); 
}

void  CForceEngine::DoPlaneTypeSSFR(T_ELEM_K ElemK,CDC *pDC)
{
	double dValue;
	if(!m_mapSSFRData.Lookup(ElemK,dValue))return; 

	T_MIRE_K mkey;
	mkey.keymap = ElemK;
	I_GPSModel *gm=(I_GPSModel *) m_pGPSModel;

	int				i, j, poly_num, vtx_num;
	double		dVal[4];
	BOOL			bEf[4];

	CArray<GPS_3DPT_LISTP, GPS_3DPT_LISTP>	polygon_list;
	CArray<GPS_BOOL_ARRYP, GPS_BOOL_ARRYP>  edge_list;
	CArray<GPS_UINT_ARRYP, GPS_UINT_ARRYP>	VertexNode;

	T_ELEM_D elem_d;
	m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d);
	if(m_pContourEngine==NULL)return;
	gm->GetShapeElement(ElemK, polygon_list, &edge_list, NULL, &VertexNode);

	gm->GPS_XGL_Begin_Elem(mkey.key.elem_k,elem_d);

	poly_num = polygon_list.GetSize();
	for(i=0;i<poly_num;i++) 
	{
		vtx_num=polygon_list[i]->GetCount();
		if(vtx_num==2)continue;

		if(poly_num>1 && !gm->m_DOPT.DR.m_bFrameLine &&  gm->m_DOPT.DR.m_bPlaneThick && !gm->IsVisibleFace(polygon_list[i],vtx_num))
			continue;

		// Fill+Outline의 경우 Contour를 수행하기 전의 Polygon의 Outline을 그림.// Line Only 일경우는 먼저그린다.
		if((gm->m_DOPT.DR.m_RenderFlag == 3 || 
			gm->m_DOPT.DR.m_RenderFlag == 2) && 
			m_pContourEngine->m_nContourFill ==1)
		{
			gm->DrawPolygon3DFill(pDC, *(polygon_list[i]), *(edge_list[i]), gm->m_DOPT.CL.m_ClientBackColor);
			gm->GPSDrawPolygonEdge(pDC, polygon_list[i], edge_list[i]);
		}

		for (j=0;j<vtx_num;j++) 
		{
			dVal[j] = dValue;
			bEf[j]  = edge_list[i]->GetAt(j);
		}
		DoSubPolyContour(pDC, dVal, polygon_list[i], bEf, FALSE);

		// Fill+Outline의 경우 Contour를 수행하기 전의 Polygon의 Outline을 그림. Fill Type
		if((gm->m_DOPT.DR.m_RenderFlag == 3   || 
			gm->m_DOPT.DR.m_RenderFlag == 2)  && 
			m_pContourEngine->m_nContourFill ==0)
			gm->GPSDrawPolygonEdge(pDC, polygon_list[i], edge_list[i]);
	}
	gm->GPS_XGL_End_Elem();

	FreeMemoryPolyList(&polygon_list,&edge_list,&VertexNode); 
}

void  CForceEngine::DoSolidTypeSSFR(T_ELEM_K ElemK,CDC *pDC)
{
	double dValue;
	if(!m_mapSSFRData.Lookup(ElemK,dValue))return; 

	T_MIRE_K mkey;
	mkey.keymap = ElemK;
	I_GPSModel*gm=(I_GPSModel *) m_pGPSModel;

	int				i, j, poly_num, vtx_num;
	double		dVal[4];
	BOOL			bEf[4];

	CArray<GPS_3DPT_LISTP, GPS_3DPT_LISTP>	polygon_list;
	CArray<GPS_BOOL_ARRYP, GPS_BOOL_ARRYP>  edge_list;
	CArray<GPS_UINT_ARRYP, GPS_UINT_ARRYP>	VertexNode;

	T_ELEM_D elem_d;
	m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d);

	if(m_pContourEngine==NULL)return;
	gm->GetShapeElement(ElemK, polygon_list, &edge_list, NULL, &VertexNode,NULL,NULL);

	gm->GPS_XGL_Begin_Elem(mkey.key.elem_k,elem_d);

	poly_num = polygon_list.GetSize();
	for(i=0;i<poly_num;i++) 
	{
		vtx_num = polygon_list[i]->GetCount();
		if(vtx_num==2)continue;

		if(poly_num>1 && !gm->IsVisibleFace(polygon_list[i],vtx_num))continue;

		// Fill+Outline의 경우 Contour를 수행하기 전의 Polygon의 Outline을 그림.// Line Only 일경우는 먼저그린다.
		if((gm->m_DOPT.DR.m_RenderFlag == 3 || 
			gm->m_DOPT.DR.m_RenderFlag == 2) && 
			m_pContourEngine->m_nContourFill ==1)
		{
			gm->DrawPolygon3DFill(pDC, *(polygon_list[i]), *(edge_list[i]), gm->m_DOPT.CL.m_ClientBackColor);
			gm->GPSDrawPolygonEdge(pDC, polygon_list[i], edge_list[i]);
		}

		for(j=0;j<vtx_num;j++) 
		{
			dVal[j] = dValue;
			bEf[j]  = edge_list[i]->GetAt(j);
		}

		// 3. polygon별로 Contour를 실시하여 Solid Stress값에 따라 나뉘어진 sub-polygon list를 얻는다.
		// 4. sub-polygon들을 그린다.
		DoSubPolyContour(pDC, dVal, polygon_list[i], bEf, FALSE);

		// Fill+Outline의 경우 Contour를 수행하기 전의 Polygon의 Outline을 그림.
		if((gm->m_DOPT.DR.m_RenderFlag == 3 || 
			gm->m_DOPT.DR.m_RenderFlag == 2) && 
			m_pContourEngine->m_nContourFill ==0)
			gm->GPSDrawPolygonEdge(pDC, polygon_list[i], edge_list[i]);

	}
	gm->GPS_XGL_End_Elem();
	FreeMemoryPolyList(&polygon_list,&edge_list,&VertexNode); 
}

void  CForceEngine::OutputSSFRData(CDC *pDC)
{
	CGPSResultLabelBase Label;

	I_GPSModel  *gm=(I_GPSModel *) m_pGPSModel;

	int				i, j, elem_num, nSlope;
	T_ELEM_K	ekey;
	T_ELEM_D	edata;
	BOOL			fl_bak;

	if(!m_bSSFRDataSet)return;

	Label.SetDC(pDC);
	Label.SetEng((CEngineBase *)this);
	Label.SetFont(&(gm->m_NumberFont));
	Label.SetColor(gm->m_DOPT.TX.m_NumberTextColorC,gm->m_DOPT.TX.m_NumberBackCol);
	Label.SetDcmPnt(gm->m_NumberDecimalPoint);
	Label.SetExpnt(gm->m_DOPT.TX.m_bNumberExponent);
	Label.SetOpaque(gm->m_DOPT.TX.m_bNumberOpaque);
	Label.BgnLabel();

	fl_bak = gm->m_DOPT.DR.m_bFrameLine;
	gm->m_DOPT.DR.m_bFrameLine = TRUE;

	BOOL bGrpFltMode=gm->m_pGPSCtrl->IsGroupFilterMode();
	if(!bGrpFltMode)elem_num = gm->m_EKeyListActive.GetSize();
	else            elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize(); 

	double dValue; 
	C3DPoint  Center3D;
	CPoint    Center2D;
	CArray<CPoint,CPoint&>arNode2DPt;
	for (i=0;i<elem_num;i++) 
	{
		if(!bGrpFltMode)ekey = gm->m_EKeyListActive[i];
		else            ekey = gm->m_pDispFilter->m_aGrpEKey[i]; 

		if(!gm->m_pGPSCtrl->IsActiveElem(ekey))
			continue; // Label Hidden 처리를 위해서 추가 됨.


		m_pDoc->m_pAttrCtrl->GetElem(ekey, edata);
		if(!m_mapSSFRData.Lookup(ekey,dValue))continue; 

		arNode2DPt.RemoveAll(); 
		if(!GetTextPoint(edata,Center3D,Center2D,arNode2DPt))continue; 

		BOOL bContinue=FALSE; 
		for(j=0; j<arNode2DPt.GetSize(); j++)
			if(arNode2DPt[j].x<0||arNode2DPt[j].y<0)
			{
				bContinue=TRUE; 
				break; 
			}
			if(bContinue)continue; 

			nSlope=0; 
			if(m_pDoc->m_pAttrCtrl->IsFrameType(edata.eltyp))
			{
				nSlope = (int) (atan2(arNode2DPt[0].y-arNode2DPt[1].y, arNode2DPt[1].x-arNode2DPt[0].x)*1800.0/3.14159);
				nSlope = (nSlope+3600)%3600;

				if((900<nSlope) && (nSlope<=2700)) 
				{
					nSlope=(nSlope+1800)%3600;
				}
			}

			if(gm->m_DOPT.TX.m_bOutputMinMaxValueOnly)
			{
				double dLimit = (m_dMaxValue-m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;

				switch(gm->m_DOPT.TX.m_nOutputMinMaxType)
				{
				case 0: // Min & Max
					if((m_dMaxValue-dValue) <= dLimit)
						Label.DoMnMxLabel(Center3D, dValue,0,&nSlope);
					else if((dValue-m_dMinValue) <= dLimit)
						Label.DoMnMxLabel(Center3D, dValue,1,&nSlope);
					break;
				case 1: // Abs Max
					if(fabs(m_dMaxValue) >= fabs(m_dMinValue))
					{
						if( fabs(m_dMaxValue)-fabs(dValue) <= dLimit)
							Label.DoMnMxLabel(Center3D, dValue,2,&nSlope);
					}
					else
					{
						if( fabs(m_dMinValue)-fabs(dValue) <= dLimit)
							Label.DoMnMxLabel(Center3D, dValue,2,&nSlope);
					}
					break;
				case 2: // Max
					if((m_dMaxValue-dValue) <= dLimit)
						Label.DoMnMxLabel(Center3D, dValue,0,&nSlope);
					break;
				case 3: // Min
					if((dValue-m_dMinValue) <= dLimit)
						Label.DoMnMxLabel(Center3D, dValue,1,&nSlope);
					break;
				}
				//////////////////////////////////////////////////////////////////////////////////////
			}      
			else      
			{
				Label.DoLabel(Center2D,dValue,&nSlope,&(gm->m_DOPT.TX.m_NumberTextColorC));  		  
			}
	}
	gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}

BOOL  CForceEngine::GetTextPoint(T_ELEM_D &ElemD,C3DPoint &Center3D,
																 CPoint &Center2D,CArray<CPoint,CPoint&> &arNode2DPt)
{
	I_GPSModel  *gm=(I_GPSModel *) m_pGPSModel;

	int i; 
	T_NODE_D  NodeD; 
	CPoint    Node2DPt;
	C3DPoint  Node3DPt;
	CArray<C3DPoint,C3DPoint> arNode3DPt;
	int nNodeNum=m_pDoc->m_pAttrCtrl->GetNumNode(ElemD.eltyp, ElemD.elnod);

	if(!nNodeNum)return FALSE; 
	for(i=0; i<nNodeNum; i++)
	{
		m_pDoc->m_pAttrCtrl->GetNode(ElemD.elnod[i],NodeD);
		Node3DPt.x = NodeD.x;
		Node3DPt.y = NodeD.y;
		Node3DPt.z = NodeD.z;
		arNode3DPt.Add(Node3DPt); 
	}

	Center3D.Init();
	Center2D.x = 0;
	Center2D.y = 0;
	arNode2DPt.RemoveAll(); 

	for(i=0; i<nNodeNum; i++)
	{
		if(gm->m_bVirtualMode) 
			Node2DPt = gm->m_pGPSCtrl->GetWorldToWindowP2D(arNode3DPt[i]);
		else
			Node2DPt = gm->m_pGPSCtrl->GetWorldToMemDCP2D(arNode3DPt[i]);

		Center2D.x += Node2DPt.x;
		Center2D.y += Node2DPt.y;
		arNode2DPt.Add(Node2DPt); 
		Center3D.x += arNode3DPt[i].x;
		Center3D.y += arNode3DPt[i].y;
		Center3D.z += arNode3DPt[i].z;
	}

	Center2D.x /= nNodeNum; 
	Center2D.y /= nNodeNum; 
	Center3D.x /= ((double)nNodeNum); 
	Center3D.y /= ((double)nNodeNum); 
	Center3D.z /= ((double)nNodeNum); 

	return TRUE;
}

#if defined(__OLD_OUTPUT_VALUE)
void CForceEngine::OutputSfdBmdNumber(CDC *pDC, T_ELEM_K ekey, T_STRB_D bforc_d, 
																			C3DPoint *txt_pnt,int nComp,double *pMnMxVal)
{
	DECLARE_GPSMD();
	DECLARE_DPTTX();
	DECLARE_DPTDR();

	if(!gm->m_pGPSCtrl->IsActiveElem(ekey))
		return; // Label Hidden 처리를 위해 추가되었음. 

	int			  j, slope;
	TCHAR			fmt_str[10], text_str[512];
	BOOL			fl_bak, is_inverse;
	C3DPoint	node3D_i, node3D_j,DrawPoint;
	CPoint		text_p,node_2d_i, node_2d_j;
	CFont			ft, *old_ft;
	T_ELEM_D	edata;

	POSITION	pos;
	CArray<GPS_3DPT_LISTP, GPS_3DPT_LISTP>  polygon_list, polygon_list_Last;
	CArray<GPS_BOOL_ARRYP, GPS_BOOL_ARRYP>	edge_list, edge_list_Last;

	BOOL bIsMemberAssigend = FALSE;

	if(pTX->m_bNumberOpaque)pDC->SetBkMode(OPAQUE);
	else		                pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(pTX->m_NumberTextColorC);
	pDC->SetBkColor(pTX->m_NumberBackCol);
	pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);

	if(pTX->m_bNumberExponent)_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else		                  _stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);

	m_pDoc->m_pAttrCtrl->GetElem(ekey, edata);
	if(!m_pDoc->m_pAttrCtrl->IsBeam(edata.eltyp) && 
		!m_pDoc->m_pAttrCtrl->IsTruss(edata.eltyp) &&
		!m_pDoc->m_pAttrCtrl->IsWall(edata.eltyp)) return;

	fl_bak = pDR->m_bFrameLine;
	gm->m_DOPT.DR.m_bFrameLine = TRUE;

	if(m_bDeformedShapeContour) gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list);
	else                        gm->GetShapeElement(ekey, polygon_list, &edge_list);

	pos = polygon_list[0]->GetHeadPosition();
	node3D_i = polygon_list[0]->GetNext(pos);
	node3D_j = polygon_list[0]->GetNext(pos);

	// 멤버별 출력시 J의 위치를 재조정해주기 위한 조건문
	if(m_bBsfdBmdByMember)
	{
		T_MEMB_K MembK; T_ELEM_K ekey_Last=0;
		if(m_pDoc->m_pAttrCtrl->GetMembAssigned(ekey, MembK))
		{
			bIsMemberAssigend = TRUE;
			ekey_Last = CMembCtrl::GetMembCtrl()->GetLastElemKeyOfMemb(MembK);
			if(m_bDeformedShapeContour) gm->m_pDeformEngine->GetDeformedShapeElement(ekey_Last, &polygon_list_Last, &edge_list_Last);
			else                        gm->GetShapeElement(ekey_Last, polygon_list_Last, &edge_list_Last);
			pos = polygon_list_Last[0]->GetHeadPosition();
			polygon_list_Last[0]->GetNext(pos);
			node3D_j = polygon_list_Last[0]->GetNext(pos);
		}
	}

	//XGLRenderer
	BOOL bSaveTextOutput = FALSE;
	if(gm->m_pGPSCtrl->IsGLRenderer() && gm->m_pGPSCtrl->IsXGRMode() && 
		!gm->m_pGPSCtrl->IsMakeEMFMode() )
	{
		bSaveTextOutput = TRUE;
	}


	if(gm->m_bVirtualMode) 
	{
		node_2d_i = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_i);
		node_2d_j = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_j);
	}
	else 
	{
		node_2d_i = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_i);
		node_2d_j = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_j);
	}

	//XGLRenderer 
	if(bSaveTextOutput == FALSE) //저장 모드에서는 현재 화면 상태와 관계된 Filtering처리를 하지 않는다. 
	{
		if(node_2d_i.x < 0 ||node_2d_i.y < 0 ) return;
		if(node_2d_j.x < 0 ||node_2d_j.y < 0 ) return;
	}

	slope = (int) (atan2(node_2d_i.y-node_2d_j.y, node_2d_j.x-node_2d_i.x)*1800.0/3.14159);
	slope = (slope+3600)%3600;
	if ((900<slope) && (slope<=2700)) 
	{
		slope = (slope+1800)%3600;
		is_inverse = TRUE;
	}
	else 
	{
		is_inverse = FALSE;
	}

	gm->SetNumberFontOrientation(slope);
	ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
	old_ft = (CFont *) pDC->SelectObject(&ft);

	if(pTX->m_bOutputMinMaxValueOnly)
	{
		double dLimit = (m_dMaxValue-m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;
		double dBValue;

		for(int n=0; n<3; n++)
		{
			if(m_bBForcOutputMinMax)
			{
				// Min
				if(n==0)
				{
					pDC->SetTextAlign(TA_CENTER|TA_TOP);
					DrawPoint = txt_pnt[0];  
					dBValue   = pMnMxVal[0];
				}
				else if(n==1)
				{
					pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);
					DrawPoint = txt_pnt[1];  
					dBValue   = pMnMxVal[1];
				}
				else continue; 
			}
			else if(n==0) // I단 
			{
				if (!m_bBForcOutputI) continue;

				if(is_inverse) pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
				else					 pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
				DrawPoint = txt_pnt[0];
				//dBValue = CalcBForcValue(bforc_d, 0, I_NODE);
				dBValue = CalcBForcValue(bforc_d, nComp, 0, I_NODE);

			}
			else if(n==1)// CNT or MAX
			{			  
				if (!(m_bBForcOutputC||m_bBForcOutputMax)) continue;

				pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);
				DrawPoint= txt_pnt[1];

				if (m_bBForcOutputMax) 
				{
					dBValue = pMnMxVal[1];
				}
				else
				{
					dBValue = CalcBForcValue(bforc_d, nComp, 1, J_NODE);
				}

			}
			else if(n==2)// J단 
			{			  
				if(!m_bBForcOutputJ) continue;
				if(is_inverse)pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
				else					pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
				DrawPoint = txt_pnt[2];
				//dBValue = CalcBForcValue(bforc_d, 3, J_NODE);
				dBValue = CalcBForcValue(bforc_d, nComp, 3, J_NODE);
			}

			switch(gm->m_DOPT.TX.m_nOutputMinMaxType)
			{
			case 0: // Min & Max
				if(bSaveTextOutput)
				{
					double Pos6[6];
					Pos6[0] = node3D_i.x;Pos6[1] = node3D_i.y;Pos6[2] = node3D_i.z;
					Pos6[3] = node3D_j.x;Pos6[4] = node3D_j.y;Pos6[5] = node3D_j.z;
					if((m_dMaxValue-dBValue) <= dLimit)
						gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(DrawPoint.x),Pos6, 0,dBValue);
					else if((dBValue-m_dMinValue) <= dLimit)
						gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(DrawPoint.x),Pos6, 1,dBValue);
				}
				else
				{
					if((m_dMaxValue-dBValue) <= dLimit)
						DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,dBValue);
					else if((dBValue-m_dMinValue) <= dLimit)
						DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,dBValue);
				}
				break;
			case 1: // Abs Max
				if(bSaveTextOutput)
				{
					double Pos6[6];
					Pos6[0] = node3D_i.x;Pos6[1] = node3D_i.y;Pos6[2] = node3D_i.z;
					Pos6[3] = node3D_j.x;Pos6[4] = node3D_j.y;Pos6[5] = node3D_j.z;
					if(fabs(m_dMaxValue) >= fabs(m_dMinValue))
					{
						if( fabs(m_dMaxValue)-fabs(dBValue) <= dLimit)
							gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(DrawPoint.x),Pos6, 2,dBValue);
					}
					else
					{
						if( fabs(m_dMinValue)-fabs(dBValue) <= dLimit)
							gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(DrawPoint.x),Pos6, 2,dBValue);
					}
				}
				else
				{
					if(fabs(m_dMaxValue) >= fabs(m_dMinValue))
					{
						if( fabs(m_dMaxValue)-fabs(dBValue) <= dLimit)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dBValue);
					}
					else
					{
						if( fabs(m_dMinValue)-fabs(dBValue) <= dLimit)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dBValue);
					}
				}
				break;
			case 2: // Max
				if(bSaveTextOutput)
				{
					double Pos6[6];
					Pos6[0] = node3D_i.x;Pos6[1] = node3D_i.y;Pos6[2] = node3D_i.z;
					Pos6[3] = node3D_j.x;Pos6[4] = node3D_j.y;Pos6[5] = node3D_j.z;
					if((m_dMaxValue-dBValue) <= dLimit)
						gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(DrawPoint.x),Pos6, 0,dBValue);
				}
				else
				{
					if((m_dMaxValue-dBValue) <= dLimit)
						DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,dBValue);
				}
				break;
			case 3: // Min
				if(bSaveTextOutput)
				{
					double Pos6[6];
					Pos6[0] = node3D_i.x;Pos6[1] = node3D_i.y;Pos6[2] = node3D_i.z;
					Pos6[3] = node3D_j.x;Pos6[4] = node3D_j.y;Pos6[5] = node3D_j.z;
					if((dBValue-m_dMinValue) <= dLimit)
						gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(DrawPoint.x),Pos6, 1,dBValue);
				}
				else
				{
					if((dBValue-m_dMinValue) <= dLimit)
						DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,dBValue);
				}
				break;
			}
		}
		//////////////////////////////////////////////////////////////////////////////////////
	}      
	else      
	{
		// Min/Max
		if(m_bBForcOutputMinMax)      
		{

			if(bSaveTextOutput)
			{
				double Pos6[6];
				Pos6[0] = node3D_i.x;Pos6[1] = node3D_i.y;Pos6[2] = node3D_i.z;
				Pos6[3] = node3D_j.x;Pos6[4] = node3D_j.y;Pos6[5] = node3D_j.z;
				if(m_bBsfdBmdByMember && bIsMemberAssigend) 
				{
					gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[0].x), Pos6, 3, pMnMxVal[0]);
					gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[1].x), Pos6, 4, pMnMxVal[1]);
				}
				else 
				{
					gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[0].x),Pos6, 3, pMnMxVal[0]);
					gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[1].x),Pos6, 4, pMnMxVal[1]);
				}
			}
			else
			{
				// Min Val
				pDC->SetTextAlign(TA_CENTER|TA_TOP);
				if(gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[0]);
				else                  text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[0]);
				_stprintf(text_str, fmt_str, pMnMxVal[0]);
				if(text_p.x >= 0 && text_p.y>=0)pDC->TextOut(text_p.x, text_p.y, text_str);  

				// Max Val
				pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);
				if(gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[1]);
				else                  text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[1]);
				_stprintf(text_str, fmt_str, pMnMxVal[1]);
				if(text_p.x >= 0 && text_p.y>=0)pDC->TextOut(text_p.x, text_p.y, text_str);  
			}
		}
		// Abs Max
		else if(m_bBForcOutputMax) 
		{
			double dAbsMax;
			if(fabs(pMnMxVal[0]) > fabs(pMnMxVal[1])) 
				dAbsMax = pMnMxVal[0];
			else 
				dAbsMax = pMnMxVal[1];

			if(bSaveTextOutput)
			{
				double Pos6[6];
				Pos6[0] = node3D_i.x;Pos6[1] = node3D_i.y;Pos6[2] = node3D_i.z;
				Pos6[3] = node3D_j.x;Pos6[4] = node3D_j.y;Pos6[5] = node3D_j.z;

				gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[1].x),Pos6, 5, dAbsMax);
			}
			else
			{
				if(gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[1]);
				else                  text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[1]);
				_stprintf(text_str, fmt_str, dAbsMax);
				if(text_p.x >= 0 && text_p.y>=0) pDC->TextOut(text_p.x, text_p.y, text_str);
			}
		}
		else 
		{
			if(bSaveTextOutput) 
			{
				double Pos6[6];

				Pos6[0] = node3D_i.x;Pos6[1] = node3D_i.y;Pos6[2] = node3D_i.z;
				Pos6[3] = node3D_j.x;Pos6[4] = node3D_j.y;Pos6[5] = node3D_j.z;

				if(m_bBForcOutputI) 
				{
					gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[0].x),Pos6, 6, CalcBForcValue(bforc_d, nComp, 0, I_NODE));
				}
				if (m_bBForcOutputJ) 
				{
					gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[2].x),Pos6, 7, CalcBForcValue(bforc_d, nComp, 3, J_NODE));
				}
				if(m_bBForcOutputC) 
				{				
					// 멤버별 출력시 : Mid값, 요소별 출력시 : 가운데 BForc값
					if(m_bBsfdBmdByMember)
					{
						double dMidVal;
						if(bIsMemberAssigend) dMidVal = CalcBForcValue(bforc_d, nComp, 0, J_NODE);
						else                  dMidVal = GetMidElemBForc(bforc_d, FALSE, FALSE);
						gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[1].x),Pos6, 8, dMidVal);
					}
					else
					{
						gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[1].x),Pos6, 8, CalcBForcValue(bforc_d, nComp, 1, J_NODE));
					}
				}
			}
			else 
			{
				if(m_bBForcOutputI) 
				{
					pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorI);
					if(is_inverse)pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
					else				  pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
					if (gm->m_bVirtualMode) text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[0]);
					else                    text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[0]);
					_stprintf(text_str, fmt_str, CalcBForcValue(bforc_d, nComp, 0, I_NODE));
					if(text_p.x >= 0 && text_p.y>=0)pDC->TextOut(text_p.x, text_p.y, text_str);
				}
				if (m_bBForcOutputJ) 
				{
					pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorJ);
					if(is_inverse)pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
					else				  pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
					if (gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[2]);
					else                   text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[2]);
					_stprintf(text_str, fmt_str, CalcBForcValue(bforc_d, nComp, 3, J_NODE));
					if(text_p.x >= 0 && text_p.y>=0) pDC->TextOut(text_p.x, text_p.y, text_str);
				}
				if(m_bBForcOutputC) 
				{
					double dCenterValue;
					if(m_bBsfdBmdByMember) 
					{
						if(bIsMemberAssigend) dCenterValue = CalcBForcValue(bforc_d, nComp, 0, J_NODE);
						else                  dCenterValue = GetMidElemBForc(bforc_d, FALSE, FALSE);
					}        
					else
					{
						dCenterValue= CalcBForcValue(bforc_d, nComp, 1, J_NODE);
					}

					pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
					pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);
					if(gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[1]);
					else 				          text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[1]);

					_stprintf(text_str, fmt_str, dCenterValue);
					if(text_p.x >= 0 && text_p.y>=0) pDC->TextOut(text_p.x, text_p.y, text_str);
				}
			}
		}
	}

	pDC->SelectObject(old_ft);
	ft.DeleteObject();

	for(j=0;j<polygon_list.GetSize();j++) 
	{
		polygon_list[j]->RemoveAll();
		delete polygon_list[j];
		edge_list[j]->RemoveAll();
		delete edge_list[j];
	}
	for(j=0;j<polygon_list_Last.GetSize();j++) 
	{
		polygon_list_Last[j]->RemoveAll();
		delete polygon_list_Last[j];
		edge_list_Last[j]->RemoveAll();
		delete edge_list_Last[j];
	}
	polygon_list.RemoveAll(); polygon_list_Last.RemoveAll();
	edge_list.RemoveAll();    edge_list_Last.RemoveAll();

	gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}
#else
void CForceEngine::OutputSfdBmdNumber(CDC *pDC, T_ELEM_K ekey, T_STRB_D bforc_d,
	C3DPoint *txt_pnt, int nComp, double *pMnMxVal)
{
	DECLARE_GPSMD();
	DECLARE_DPTTX();
	DECLARE_DPTDR();

	if (!gm->m_pGPSCtrl->IsActiveElem(ekey))
		return; // Label Hidden 처리를 위해 추가되었음. 

	int			  j, slope;
	TCHAR			fmt_str[10], text_str[512];
	BOOL			fl_bak, is_inverse;
	C3DPoint	node3D_i, node3D_j, DrawPoint;
	CPoint		text_p, node_2d_i, node_2d_j;
	CFont			ft, *old_ft;
	T_ELEM_D	edata;

	POSITION	pos;
	CArray<GPS_3DPT_LISTP, GPS_3DPT_LISTP>  polygon_list, polygon_list_Last;
	CArray<GPS_BOOL_ARRYP, GPS_BOOL_ARRYP>	edge_list, edge_list_Last;

	BOOL bIsMemberAssigend = FALSE;

	GPostTextOut TextOutModel;
	TextOutModel.StartBmdForceVal();
	TextOutModel.SetDC(pDC);
	TextOutModel.SettingBmdForce(gm);

	if (pTX->m_bNumberExponent)_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else		                  _stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);

	m_pDoc->m_pAttrCtrl->GetElem(ekey, edata);
	if (!m_pDoc->m_pAttrCtrl->IsBeam(edata.eltyp) &&
		!m_pDoc->m_pAttrCtrl->IsTruss(edata.eltyp) &&
		!m_pDoc->m_pAttrCtrl->IsWall(edata.eltyp)) return;

	fl_bak = pDR->m_bFrameLine;
	gm->m_DOPT.DR.m_bFrameLine = TRUE;

	if (m_bDeformedShapeContour) gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list);
	else                        gm->GetShapeElement(ekey, polygon_list, &edge_list);

	pos = polygon_list[0]->GetHeadPosition();
	node3D_i = polygon_list[0]->GetNext(pos);
	node3D_j = polygon_list[0]->GetNext(pos);

	// 멤버별 출력시 J의 위치를 재조정해주기 위한 조건문
	if (m_bBsfdBmdByMember)
	{
		T_MEMB_K MembK; T_ELEM_K ekey_Last = 0;
		if (m_pDoc->m_pAttrCtrl->GetMembAssigned(ekey, MembK))
		{
			bIsMemberAssigend = TRUE;
			ekey_Last = CMembCtrl::GetMembCtrl()->GetLastElemKeyOfMemb(MembK);
			if (m_bDeformedShapeContour) gm->m_pDeformEngine->GetDeformedShapeElement(ekey_Last, &polygon_list_Last, &edge_list_Last);
			else                        gm->GetShapeElement(ekey_Last, polygon_list_Last, &edge_list_Last);
			pos = polygon_list_Last[0]->GetHeadPosition();
			polygon_list_Last[0]->GetNext(pos);
			node3D_j = polygon_list_Last[0]->GetNext(pos);
		}
	}

	//XGLRenderer
	BOOL bSaveTextOutput = FALSE;
	if (gm->m_pGPSCtrl->IsGLRenderer() && gm->m_pGPSCtrl->IsXGRMode() &&
		!gm->m_pGPSCtrl->IsMakeEMFMode())
	{
		bSaveTextOutput = TRUE;
	}


	if (gm->m_bVirtualMode)
	{
		node_2d_i = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_i);
		node_2d_j = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_j);
	}
	else
	{
		node_2d_i = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_i);
		node_2d_j = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_j);
	}

	//XGLRenderer 
	if (bSaveTextOutput == FALSE) //저장 모드에서는 현재 화면 상태와 관계된 Filtering처리를 하지 않는다. 
	{
		if (node_2d_i.x < 0 || node_2d_i.y < 0) return;
		if (node_2d_j.x < 0 || node_2d_j.y < 0) return;
	}

	slope = (int)(atan2(node_2d_i.y - node_2d_j.y, node_2d_j.x - node_2d_i.x)*1800.0 / 3.14159);
	slope = (slope + 3600) % 3600;
	if ((900 < slope) && (slope <= 2700))
	{
		slope = (slope + 1800) % 3600;
		is_inverse = TRUE;
	}
	else
	{
		is_inverse = FALSE;
	}

	TextOutModel.Font4BmdForce(gm, slope);

	if (pTX->m_bOutputMinMaxValueOnly)
	{
		double dLimit = (m_dMaxValue - m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;
		double dBValue;

		for (int n = 0; n < 3; n++)
		{
			if (m_bBForcOutputMinMax)
			{
				// Min
				if (n == 0)
				{
					TextOutModel.AlignTextTop(TA_CENTER);
					pDC->SetTextAlign(TA_CENTER | TA_TOP);
					DrawPoint = txt_pnt[0];
					dBValue = pMnMxVal[0];
				}
				else if (n == 1)
				{
					TextOutModel.AlignTextBot(TA_CENTER);
					DrawPoint = txt_pnt[1];
					dBValue = pMnMxVal[1];
				}
				else continue;
			}
			else if (n == 0) // I단 
			{
				if (!m_bBForcOutputI) continue;

				if (is_inverse) TextOutModel.AlignTextBot(TA_RIGHT);
				else					 TextOutModel.AlignTextBot(TA_LEFT);
				DrawPoint = txt_pnt[0];
				//dBValue = CalcBForcValue(bforc_d, 0, I_NODE);
				dBValue = CalcBForcValue(bforc_d, nComp, 0, I_NODE);

			}
			else if (n == 1)// CNT or MAX
			{
				if (!(m_bBForcOutputC || m_bBForcOutputMax)) continue;

				TextOutModel.AlignTextBot(TA_CENTER);
				DrawPoint = txt_pnt[1];

				if (m_bBForcOutputMax)
				{
					dBValue = pMnMxVal[1];
				}
				else
				{
					dBValue = CalcBForcValue(bforc_d, nComp, 1, J_NODE);
				}

			}
			else if (n == 2)// J단 
			{
				if (!m_bBForcOutputJ) continue;
				if (is_inverse) TextOutModel.AlignTextBot(TA_LEFT);
				else					TextOutModel.AlignTextBot(TA_RIGHT);
				DrawPoint = txt_pnt[2];
				//dBValue = CalcBForcValue(bforc_d, 3, J_NODE);
				dBValue = CalcBForcValue(bforc_d, nComp, 3, J_NODE);
			}

			switch (gm->m_DOPT.TX.m_nOutputMinMaxType)
			{
			case 0: // Min & Max
				if (bSaveTextOutput)
				{
					double Pos6[6];
					Pos6[0] = node3D_i.x; Pos6[1] = node3D_i.y; Pos6[2] = node3D_i.z;
					Pos6[3] = node3D_j.x; Pos6[4] = node3D_j.y; Pos6[5] = node3D_j.z;
					if ((m_dMaxValue - dBValue) <= dLimit)
						gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(DrawPoint.x), Pos6, 0, dBValue);
					else if ((dBValue - m_dMinValue) <= dLimit)
						gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(DrawPoint.x), Pos6, 1, dBValue);
				}
				else
				{
					if ((m_dMaxValue - dBValue) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, dBValue);
					else if ((dBValue - m_dMinValue) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, dBValue);
				}
				break;
			case 1: // Abs Max
				if (bSaveTextOutput)
				{
					double Pos6[6];
					Pos6[0] = node3D_i.x; Pos6[1] = node3D_i.y; Pos6[2] = node3D_i.z;
					Pos6[3] = node3D_j.x; Pos6[4] = node3D_j.y; Pos6[5] = node3D_j.z;
					if (fabs(m_dMaxValue) >= fabs(m_dMinValue))
					{
						if (fabs(m_dMaxValue) - fabs(dBValue) <= dLimit)
							gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(DrawPoint.x), Pos6, 2, dBValue);
					}
					else
					{
						if (fabs(m_dMinValue) - fabs(dBValue) <= dLimit)
							gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(DrawPoint.x), Pos6, 2, dBValue);
					}
				}
				else
				{
					if (fabs(m_dMaxValue) >= fabs(m_dMinValue))
					{
						if (fabs(m_dMaxValue) - fabs(dBValue) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, dBValue);
					}
					else
					{
						if (fabs(m_dMinValue) - fabs(dBValue) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, dBValue);
					}
				}
				break;
			case 2: // Max
				if (bSaveTextOutput)
				{
					double Pos6[6];
					Pos6[0] = node3D_i.x; Pos6[1] = node3D_i.y; Pos6[2] = node3D_i.z;
					Pos6[3] = node3D_j.x; Pos6[4] = node3D_j.y; Pos6[5] = node3D_j.z;
					if ((m_dMaxValue - dBValue) <= dLimit)
						gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(DrawPoint.x), Pos6, 0, dBValue);
				}
				else
				{
					if ((m_dMaxValue - dBValue) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, dBValue);
				}
				break;
			case 3: // Min
				if (bSaveTextOutput)
				{
					double Pos6[6];
					Pos6[0] = node3D_i.x; Pos6[1] = node3D_i.y; Pos6[2] = node3D_i.z;
					Pos6[3] = node3D_j.x; Pos6[4] = node3D_j.y; Pos6[5] = node3D_j.z;
					if ((dBValue - m_dMinValue) <= dLimit)
						gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(DrawPoint.x), Pos6, 1, dBValue);
				}
				else
				{
					if ((dBValue - m_dMinValue) <= dLimit)
						DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, dBValue);
				}
				break;
			}
		}
		//////////////////////////////////////////////////////////////////////////////////////
	}
	else
	{
		// Min/Max
		if (m_bBForcOutputMinMax)
		{

			if (bSaveTextOutput)
			{
				double Pos6[6];
				Pos6[0] = node3D_i.x; Pos6[1] = node3D_i.y; Pos6[2] = node3D_i.z;
				Pos6[3] = node3D_j.x; Pos6[4] = node3D_j.y; Pos6[5] = node3D_j.z;
				if (m_bBsfdBmdByMember && bIsMemberAssigend)
				{
					gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[0].x), Pos6, 3, pMnMxVal[0]);
					gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[1].x), Pos6, 4, pMnMxVal[1]);
				}
				else
				{
					gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[0].x), Pos6, 3, pMnMxVal[0]);
					gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[1].x), Pos6, 4, pMnMxVal[1]);
				}
			}
			else
			{
				// Min Val
				TextOutModel.AlignTextTop(TA_CENTER);
				if (gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[0]);
				else                  text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[0]);
				_stprintf(text_str, fmt_str, pMnMxVal[0]);
				if (text_p.x >= 0 && text_p.y >= 0)	TextOutModel.TextOutBmdForce(text_p.x, text_p.y, text_str);

				// Max Val
				TextOutModel.AlignTextBot(TA_CENTER);
				if (gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[1]);
				else                  text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[1]);
				_stprintf(text_str, fmt_str, pMnMxVal[1]);
				if (text_p.x >= 0 && text_p.y >= 0)	TextOutModel.TextOutBmdForce(text_p.x, text_p.y, text_str);
			}
		}
		// Abs Max
		else if (m_bBForcOutputMax)
		{
			double dAbsMax;
			if (fabs(pMnMxVal[0]) > fabs(pMnMxVal[1]))
				dAbsMax = pMnMxVal[0];
			else
				dAbsMax = pMnMxVal[1];

			if (bSaveTextOutput)
			{
				double Pos6[6];
				Pos6[0] = node3D_i.x; Pos6[1] = node3D_i.y; Pos6[2] = node3D_i.z;
				Pos6[3] = node3D_j.x; Pos6[4] = node3D_j.y; Pos6[5] = node3D_j.z;

				gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[1].x), Pos6, 5, dAbsMax);
			}
			else
			{
				if (gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[1]);
				else                  text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[1]);
				_stprintf(text_str, fmt_str, dAbsMax);
				if (text_p.x >= 0 && text_p.y >= 0) TextOutModel.TextOutBmdForce(text_p.x, text_p.y, text_str);
			}
		}
		else
		{
			if (bSaveTextOutput)
			{
				double Pos6[6];

				Pos6[0] = node3D_i.x; Pos6[1] = node3D_i.y; Pos6[2] = node3D_i.z;
				Pos6[3] = node3D_j.x; Pos6[4] = node3D_j.y; Pos6[5] = node3D_j.z;

				if (m_bBForcOutputI)
				{
					gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[0].x), Pos6, 6, CalcBForcValue(bforc_d, nComp, 0, I_NODE));
				}
				if (m_bBForcOutputJ)
				{
					gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[2].x), Pos6, 7, CalcBForcValue(bforc_d, nComp, 3, J_NODE));
				}
				if (m_bBForcOutputC)
				{
					// 멤버별 출력시 : Mid값, 요소별 출력시 : 가운데 BForc값
					if (m_bBsfdBmdByMember)
					{
						double dMidVal;
						if (bIsMemberAssigend) dMidVal = CalcBForcValue(bforc_d, nComp, 0, J_NODE);
						else                  dMidVal = GetMidElemBForc(bforc_d, FALSE, FALSE);
						gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[1].x), Pos6, 8, dMidVal);
					}
					else
					{
						gm->m_pXGR_GPSDrawMgr->m_OutputSfdBmdNumber.Add_OutputSfdBmdNumber(&(txt_pnt[1].x), Pos6, 8, CalcBForcValue(bforc_d, nComp, 1, J_NODE));
					}
				}
			}
			else
			{
				if (m_bBForcOutputI)
				{
					if (gm->m_bVirtualMode) text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[0]);
					else                    text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[0]);
					_stprintf(text_str, fmt_str, CalcBForcValue(bforc_d, nComp, 0, I_NODE));
					if (text_p.x >= 0 && text_p.y >= 0)
					{
						if (is_inverse) TextOutModel.TextOutBmdForce(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorI, TA_RIGHT);
						else				  TextOutModel.TextOutBmdForce(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorI, TA_LEFT);
					}
				}
				if (m_bBForcOutputJ)
				{
					if (gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[2]);
					else                   text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[2]);
					_stprintf(text_str, fmt_str, CalcBForcValue(bforc_d, nComp, 3, J_NODE));
					if (text_p.x >= 0 && text_p.y >= 0)
					{
						if (is_inverse)	TextOutModel.TextOutBmdForce(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorJ, TA_LEFT);
						else				  TextOutModel.TextOutBmdForce(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorJ, TA_RIGHT);
					}
				}
				if (m_bBForcOutputC)
				{
					double dCenterValue;
					if (m_bBsfdBmdByMember)
					{
						if (bIsMemberAssigend) dCenterValue = CalcBForcValue(bforc_d, nComp, 0, J_NODE);
						else                  dCenterValue = GetMidElemBForc(bforc_d, FALSE, FALSE);
					}
					else
					{
						dCenterValue = CalcBForcValue(bforc_d, nComp, 1, J_NODE);
					}

					if (gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[1]);
					else 				          text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[1]);

					_stprintf(text_str, fmt_str, dCenterValue);
					if (text_p.x >= 0 && text_p.y >= 0)
					{
						TextOutModel.TextOutBmdForce(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorC, TA_CENTER);
					}
				}
			}
		}
	}

	TextOutModel.DeleteFont();

	for (j = 0; j < polygon_list.GetSize(); j++)
	{
		polygon_list[j]->RemoveAll();
		delete polygon_list[j];
		edge_list[j]->RemoveAll();
		delete edge_list[j];
	}
	for (j = 0; j < polygon_list_Last.GetSize(); j++)
	{
		polygon_list_Last[j]->RemoveAll();
		delete polygon_list_Last[j];
		edge_list_Last[j]->RemoveAll();
		delete edge_list_Last[j];
	}
	polygon_list.RemoveAll(); polygon_list_Last.RemoveAll();
	edge_list.RemoveAll();    edge_list_Last.RemoveAll();

	gm->m_DOPT.DR.m_bFrameLine = fl_bak;
	TextOutModel.EndBmdForceVal();
}
#endif

BOOL CForceEngine::MakeBForcTimeHist()
{
	if (CTestEnvMgr::IsTestEnvST(_LSX(ProfilingSTL), _LSX(yes)))
	{
		M_PROFILE('MakeBForcTimeHist()');
	}

	DECLARE_GPSMD();
	DECLARE_DBDOC();

	if(!gm->m_bLoadDataSet)return FALSE;
	pDoc->m_pPostCtrl->SelectThis(gm->m_LoadCaseKey);
	return MakeBForcTimeHistByIndex(m_nThisTimeIndex);
}

BOOL CForceEngine::MakeBForcTimeHistByIndex(int nTimeIndex)
{
	BOOL  bDesignatedDOF = FALSE;
	T_THRD_D ThrdD;
	if(m_bThisFunction && CGPSPostCtrl::IsDesignatedDOFFunction(m_nFunctionKey,&ThrdD))
	{
		// Designated D.O.F
		if(!MakeBForcTimeHistByIndexSubByElem(ThrdD)) return FALSE;
	}
	else
	{
		// Designated Step
		if(!MakeBForcTimeHistByIndexSubByElemList(nTimeIndex, ThrdD)) return FALSE;
	}

	if(fabs(m_dMaxValue)<fabs(m_dMinValue))	InitBSfdBmdAdjustFactor(m_dMinValue);
	else									InitBSfdBmdAdjustFactor(m_dMaxValue);

	if (m_pContourEngine == NULL)	m_pContourEngine = new CContourEngine(m_dMinValue, m_dMaxValue);
	else							m_pContourEngine->MakeRankMap(m_dMinValue, m_dMaxValue);

	DECLARE_GPSMD();
	gm->m_pMyView->EndWaitCursor();

	m_bBForcDataSet = TRUE;
	m_bWForcDataSet = TRUE;

	return TRUE;
}

BOOL CForceEngine::MakeBForcTimeHistByIndexSubByElem(T_THRD_D& ThrdD)
{
	DECLARE_GPSMD();
	if(!gm->m_bLoadDataSet) return FALSE;
	
	double		dMaxForc=-DBL_MAX;
	double		dMinForc=DBL_MAX;
	double		dLen = 0.0;
	BOOL		bHasContent=FALSE;
	T_ELEM_K	ElemK = 0;
	T_ELEM_D	ElemD;
	T_STRB_D	StrbD;
	T_STRW_D	StrwD;
	T_STRT_D	StrtD;	

	gm->m_pMyView->BeginWaitCursor();
	m_BeamKeyList.RemoveAll();
	m_WallKeyList.RemoveAll(); 
	m_TrussKeyList.RemoveAll(); 
	m_mapBForcData.RemoveAll();
	m_mapWForcData.RemoveAll();
	m_mapWallInfoData.RemoveAll();
	m_mapTForcData.RemoveAll();
	m_mapNForcData.RemoveAll();

	//--------------------------------------------------------------------------------
	// Element Result
	//--------------------------------------------------------------------------------
	int nElemNum = gm->m_EKeyListActive.GetSize();
	for (int i=0; i<nElemNum; i++) 
	{
		ElemK = gm->m_EKeyListActive[i];
		if(!m_pDoc->m_pAttrCtrl->GetElem(ElemK, ElemD)) { ASSERT(0); continue; }
		
		if(m_pDoc->m_pAttrCtrl->IsBeam(ElemD.eltyp))
		{
			// Beam Result
			int nStrbTimeIndex = 0;
			ThrdD.nEntity       = ElemK;
			ThrdD.nStepFunction = 4; //Beam Force/Stress
			ThrdD.nSubType      = 1; //Force
			if(!CGPSPostCtrl::GetTimeStepIndexByFuncCondition(ThrdD,nStrbTimeIndex)) nStrbTimeIndex = 0;

			if(!m_pDoc->m_pPostCtrl->GetStrbHistory(nStrbTimeIndex,ElemK,StrbD)){ continue;  }
			MinMaxElemBForc(ElemK,StrbD,dMaxForc,dMinForc,TRUE);
			m_BeamKeyList.Add(ElemK);
			m_mapBForcData.SetAt(ElemK,StrbD);
			bHasContent = TRUE;
		}
		else if(m_pDoc->m_pAttrCtrl->IsWall(ElemD.eltyp))
		{
			// Wall Result
			//----------------------------------------------------------------------
			// Beam Force 대화상자를 가지고 Wall도 함께 쓰기 때문에 Beam을 참고로 Wall도 아래와 같이 세팅 
			switch (m_BForcComponent)
			{
			case BFORC_COMPONENT_FX:  m_WForcComponent = WFORC_COMPONENT_FX;  break;
			case BFORC_COMPONENT_FY:  m_WForcComponent = WFORC_COMPONENT_FY;  break;
			case BFORC_COMPONENT_FZ:  m_WForcComponent = WFORC_COMPONENT_FZ;  break;
			case BFORC_COMPONENT_MX:  m_WForcComponent = WFORC_COMPONENT_MX;  break;
			case BFORC_COMPONENT_MY:  m_WForcComponent = WFORC_COMPONENT_MY;  break;
			case BFORC_COMPONENT_MZ:  m_WForcComponent = WFORC_COMPONENT_MZ;  break;
			default:
				ASSERT(0);
				m_WForcComponent = WFORC_COMPONENT_MY;  break;
				break;
			}
			m_WForcOutputLocation = WFORC_OUTPUT_ALL;   // Time History 결과에서는 요소 결과가 하나이므로 그냥 ALL position에 찍도록 처리함.
			//----------------------------------------------------------------------

			int nStrwTimeIndex = 0;
			ThrdD.nEntity       = ElemK;
			ThrdD.nStepFunction = 7; //Wall Force
			ThrdD.nSubType      = 1; //Force
			if(!CGPSPostCtrl::GetTimeStepIndexByFuncCondition(ThrdD,nStrwTimeIndex)) nStrwTimeIndex = 0;

			unsigned int iInternalWallID=0;
			m_pDoc->m_pPostCtrl->GetInternalWallId(ElemK, iInternalWallID);
			if(!m_pDoc->m_pPostCtrl->GetStrwHistory(nStrwTimeIndex,iInternalWallID,StrwD)){ continue;  }

			T_WALL_KEY		wall_key;
			if (!m_pDoc->m_pPostCtrl->GetWallKey(iInternalWallID, wall_key))  { ASSERT(0);  continue; }
			T_WALL_D		winfo;
			if(!m_pDoc->m_pPostCtrl->GetWallData(wall_key, winfo))  { ASSERT(0);  continue; }

			dLen=GetMaxWallForc(StrwD);  if(dLen>dMaxForc){ dMaxForc = dLen; gm->m_nLgdMaxValKey = ElemK; }   // ElemK가 맞나? 아니면 iInternalWallID로 바꿔줘야 하는데, iInternalWallID는 사용자가 모르는 번호임.
			dLen=GetMinWallForc(StrwD);  if(dLen<dMinForc){ dMinForc = dLen; gm->m_nLgdMinValKey = ElemK; }   // ElemK가 맞나? 아니면 iInternalWallID로 바꿔줘야 하는데, iInternalWallID는 사용자가 모르는 번호임.

			m_WallKeyList.Add(ElemK);  //m_WallKeyList.Add(iInternalWallID);
			m_mapWForcData.SetAt(ElemK,StrwD);  //m_mapWForcData.SetAt(iInternalWallID,StrwD);
			m_mapWallInfoData.SetAt(ElemK,winfo);
			bHasContent = TRUE;
		}
		else if(m_BForcComponent==BFORC_COMPONENT_FX && m_pDoc->m_pAttrCtrl->IsTruss(ElemD.eltyp))
		{
			// Truss Result
			int nStrtTimeIndex = 0;
			if(ThrdD.nPosition>2)   continue; // Middle
			if(ThrdD.nComponent!=1) continue; // Fx

			ThrdD.nEntity = ElemK;
			ThrdD.nStepFunction = 3; //Truss Force/Stress
			ThrdD.nSubType      = 1; //Force
			if(!CGPSPostCtrl::GetTimeStepIndexByFuncCondition(ThrdD,nStrtTimeIndex)) nStrtTimeIndex = 0;

			if(!m_pDoc->m_pPostCtrl->GetStrtHistory(nStrtTimeIndex,ElemK,StrtD)){ continue;  }
			dLen=GetMaxElemTForc(StrtD);  if(dLen>dMaxForc){ dMaxForc = dLen; gm->m_nLgdMaxValKey = ElemK; }
			dLen=GetMinElemTForc(StrtD);  if(dLen<dMinForc){ dMinForc = dLen; gm->m_nLgdMinValKey = ElemK; }

			m_TrussKeyList.Add(ElemK);
			m_mapTForcData.SetAt(ElemK,StrtD);
			bHasContent = TRUE; 
		}
	}

	//--------------------------------------------------------------------------------
	// General Link Result
	//--------------------------------------------------------------------------------
	T_STEK_D StekD;
	T_NLNK_D NlnkD;
	CArray<T_NLNK_K,T_NLNK_K> arNlnkK;
	m_pDoc->m_pAttrCtrl->GetNlnkKeyList(arNlnkK);

	for(int i=0;i<arNlnkK.GetSize();i++)
	{
		if(!m_pDoc->m_pAttrCtrl->GetNlnk(arNlnkK[i],NlnkD)) { ASSERT(0); continue; }
		if(!gm->m_pGPSCtrl->IsActiveNode(NlnkD.Node1))continue;
		if(!gm->m_pGPSCtrl->IsActiveNode(NlnkD.Node2))continue;

		int nNlnkTimeIndex = 0;
		if(ThrdD.nPosition>2)   continue; // Middle
		ThrdD.nEntity = arNlnkK[i];
		ThrdD.nStepFunction = 6; //Genral Link Force
		if(!CGPSPostCtrl::GetTimeStepIndexByFuncCondition(ThrdD, nNlnkTimeIndex)) nNlnkTimeIndex = 0;

		if(!m_pDoc->m_pPostCtrl->GetNlfcHistory(nNlnkTimeIndex,arNlnkK[i],StekD)){ continue;  }	

		dLen=GetMaxNlnkForc(StekD);  if(dLen>dMaxForc){ dMaxForc = dLen; gm->m_nLgdMaxValKey = 0; }
		dLen=GetMinNlnkForc(StekD);  if(dLen<dMinForc){ dMinForc = dLen; gm->m_nLgdMinValKey = 0; }
		m_mapNForcData.SetAt(arNlnkK[i],StekD);
		bHasContent = TRUE; 
	}

	if(!bHasContent) 
	{
		dMaxForc = dMinForc = 0.0;
		gm->m_nLgdMaxValKey=0;
		gm->m_nLgdMinValKey=0;
	}
	m_dMaxValue = dMaxForc;
	m_dMinValue = dMinForc;

	return TRUE; 
}

BOOL CForceEngine::MakeBForcTimeHistByIndexSubByElemList(int nTimeIndex, T_THRD_D& ThrdD)
{
	DECLARE_GPSMD();
	if(!gm->m_bLoadDataSet) return FALSE;

	double		dMaxForc=-DBL_MAX;
	double		dMinForc=DBL_MAX;
	double		dLen = 0.0;
	BOOL		bHasContent=FALSE;
	T_ELEM_K	ElemK = 0;
	T_ELEM_D	ElemD;
	T_STRB_D	StrbD;
	T_STRW_D	StrwD;
	T_STRT_D	StrtD;

	//--------------------------------------------------------------------------------
	// Element Result
	//--------------------------------------------------------------------------------
	CArray<T_ELEM_K, T_ELEM_K> aBeamElemK;
	CArray<T_ELEM_K, T_ELEM_K> aWallElemK;
	CArray<T_ELEM_K, T_ELEM_K> aTrussElemK;
	int nElemNum = gm->m_EKeyListActive.GetSize();
	for (int i=0;i<nElemNum;i++) 
	{
		ElemK = gm->m_EKeyListActive[i];
		if(!m_pDoc->m_pAttrCtrl->GetElem(ElemK, ElemD)) { ASSERT(0); continue; }
		
		if(m_pDoc->m_pAttrCtrl->IsBeam(ElemD.eltyp))
		{
			aBeamElemK.Add(ElemK);
		}
		else if(m_pDoc->m_pAttrCtrl->IsWall(ElemD.eltyp))
		{
			aWallElemK.Add(ElemK);
		}
		else if(m_BForcComponent==BFORC_COMPONENT_FX && m_pDoc->m_pAttrCtrl->IsTruss(ElemD.eltyp))
		{
			aTrussElemK.Add(ElemK);
		}
	}

	nElemNum = aBeamElemK.GetSize();
	if(nElemNum > 0)
	{
		// Beam Result
		CArray<T_STRB_D, T_STRB_D&> aStrbD;
		if(m_pDoc->m_pPostCtrl->GetStrbHistory(nTimeIndex, aBeamElemK, aStrbD))
		{
			for(int i=0; i<nElemNum; i++)
			{
				ElemK = aBeamElemK[i];
				StrbD = aStrbD[i];

				MinMaxElemBForc(ElemK,StrbD,dMaxForc,dMinForc,TRUE);

				m_BeamKeyList.Add(ElemK);
				m_mapBForcData.SetAt(ElemK,StrbD);
				bHasContent = TRUE;
			}
		}
	}
	
	nElemNum = aWallElemK.GetSize();
	if(nElemNum > 0)
	{
		// Wall Result
		//----------------------------------------------------------------------
		// Beam Force 대화상자를 가지고 Wall도 함께 쓰기 때문에 Beam을 참고로 Wall도 아래와 같이 세팅 
		switch (m_BForcComponent)
		{
		case BFORC_COMPONENT_FX:  m_WForcComponent = WFORC_COMPONENT_FX;  break;
		case BFORC_COMPONENT_FY:  m_WForcComponent = WFORC_COMPONENT_FY;  break;
		case BFORC_COMPONENT_FZ:  m_WForcComponent = WFORC_COMPONENT_FZ;  break;
		case BFORC_COMPONENT_MX:  m_WForcComponent = WFORC_COMPONENT_MX;  break;
		case BFORC_COMPONENT_MY:  m_WForcComponent = WFORC_COMPONENT_MY;  break;
		case BFORC_COMPONENT_MZ:  m_WForcComponent = WFORC_COMPONENT_MZ;  break;
		default:
			ASSERT(0);
			m_WForcComponent = WFORC_COMPONENT_MY;  break;
			break;
		}
		m_WForcOutputLocation = WFORC_OUTPUT_ALL;   // Time History 결과에서는 요소 결과가 하나이므로 그냥 ALL position에 찍도록 처리함.
		//----------------------------------------------------------------------

		T_WALL_KEY	wall_key;
		T_WALL_D	winfo;
		unsigned int nInternalWallID = 0;
		for(int i=0; i<nElemNum; i++)
		{
			ElemK = aWallElemK[i];
			if(!m_pDoc->m_pPostCtrl->GetInternalWallId(ElemK, nInternalWallID)) { ASSERT(0); continue; }
			if(!m_pDoc->m_pPostCtrl->GetStrwHistory(nTimeIndex, nInternalWallID, StrwD)){ continue;  }
			if (!m_pDoc->m_pPostCtrl->GetWallKey(nInternalWallID, wall_key)) { ASSERT(0); continue; }
			if(!m_pDoc->m_pPostCtrl->GetWallData(wall_key, winfo)) { ASSERT(0); continue; }

			dLen=GetMaxWallForc(StrwD);  if(dLen>dMaxForc){ dMaxForc = dLen; gm->m_nLgdMaxValKey = ElemK; }   // ElemK가 맞나? 아니면 iInternalWallID로 바꿔줘야 하는데, iInternalWallID는 사용자가 모르는 번호임.
			dLen=GetMinWallForc(StrwD);  if(dLen<dMinForc){ dMinForc = dLen; gm->m_nLgdMinValKey = ElemK; }   // ElemK가 맞나? 아니면 iInternalWallID로 바꿔줘야 하는데, iInternalWallID는 사용자가 모르는 번호임.

			m_WallKeyList.Add(ElemK);
			m_mapWForcData.SetAt(ElemK,StrwD);
			m_mapWallInfoData.SetAt(ElemK,winfo);
			bHasContent = TRUE;
		}
	}
	
	nElemNum = aTrussElemK.GetSize();
	if(nElemNum > 0)
	{
		// Truss Result
		CArray<T_STRT_D, T_STRT_D&> aStrtD;
		if(m_pDoc->m_pPostCtrl->GetStrtHistory(nTimeIndex, aTrussElemK, aStrtD))
		{
			for(int i=0; i<nElemNum; i++)
			{
				ElemK = aTrussElemK[i];
				StrtD = aStrtD[i];

				dLen=GetMaxElemTForc(StrtD);  if(dLen>dMaxForc){ dMaxForc = dLen; gm->m_nLgdMaxValKey = ElemK; }
				dLen=GetMinElemTForc(StrtD);  if(dLen<dMinForc){ dMinForc = dLen; gm->m_nLgdMinValKey = ElemK; }

				m_TrussKeyList.Add(ElemK);
				m_mapTForcData.SetAt(ElemK,StrtD);
				bHasContent = TRUE; 
			}
		}
	}

	//--------------------------------------------------------------------------------
	// General Link Result
	//--------------------------------------------------------------------------------
	T_STEK_D StekD;
	T_NLNK_D NlnkD;
	CArray<T_NLNK_K,T_NLNK_K> arNlnkK;
	m_pDoc->m_pAttrCtrl->GetNlnkKeyList(arNlnkK);

	for(int i=0;i<arNlnkK.GetSize();i++)
	{
		m_pDoc->m_pAttrCtrl->GetNlnk(arNlnkK[i],NlnkD);
		if(!gm->m_pGPSCtrl->IsActiveNode(NlnkD.Node1))continue;
		if(!gm->m_pGPSCtrl->IsActiveNode(NlnkD.Node2))continue;

		if(!m_pDoc->m_pPostCtrl->GetNlfcHistory(nTimeIndex,arNlnkK[i],StekD)){ continue;  }	

		dLen=GetMaxNlnkForc(StekD);  if(dLen>dMaxForc){ dMaxForc = dLen; gm->m_nLgdMaxValKey = 0; }
		dLen=GetMinNlnkForc(StekD);  if(dLen<dMinForc){ dMinForc = dLen; gm->m_nLgdMinValKey = 0; }
		m_mapNForcData.SetAt(arNlnkK[i],StekD);
		bHasContent = TRUE; 
	}

	if(!bHasContent) 
	{
		dMaxForc = dMinForc = 0.0;
		gm->m_nLgdMaxValKey=0;
		gm->m_nLgdMinValKey=0;
	}
	m_dMaxValue = dMaxForc;
	m_dMinValue = dMinForc;

	return TRUE; 
}

BOOL CForceEngine::GetBForcTimeHistRangeDataList(double& dMaxRange, double& dMinRange, CArray<UINT,UINT>& aElemKeyList)
{
	aElemKeyList.RemoveAll();

	DECLARE_GPSMD();

	int			  i;
	T_ELEM_K	ElemK;
	T_ELEM_D	ElemD;
	T_STRB_D	StrbD;
	T_STRW_D	StrwD;
	T_STRT_D	StrtD;
	T_WALL_KEY	wall_key;
	T_WALL_D		winfo;

	gm->m_pMyView->BeginWaitCursor();

	BOOL  bDesignatedDOF = FALSE;
	T_THRD_D ThrdD;
	if(m_bThisFunction)
	{
		bDesignatedDOF = CGPSPostCtrl::IsDesignatedDOFFunction(m_nFunctionKey,&ThrdD);
	}

	//--------------------------------------------------------------------------------
	// Element Result
	//--------------------------------------------------------------------------------
	int ElemNum = gm->m_EKeyListActive.GetSize();
	for (i=0;i<ElemNum;i++) 
	{
		ElemK = gm->m_EKeyListActive[i];
		m_pDoc->m_pAttrCtrl->GetElem(ElemK, ElemD);

		// Beam Result
		if(m_pDoc->m_pAttrCtrl->IsBeam(ElemD.eltyp))
		{
			int nStrbTimeIndex = m_nThisTimeIndex;
			if(bDesignatedDOF)
			{
				// Designated D.O.F
				ThrdD.nEntity       = ElemK;
				ThrdD.nStepFunction = 4; //Beam Force/Stress
				ThrdD.nSubType      = 1; //Force
				if(!CGPSPostCtrl::GetTimeStepIndexByFuncCondition(ThrdD,nStrbTimeIndex)) nStrbTimeIndex = 0;
			}

			if(!m_pDoc->m_pPostCtrl->GetStrbHistory(nStrbTimeIndex,ElemK,StrbD)){ continue;  }

			if(!IsWithinRangeElemBForc(ElemK,StrbD,dMaxRange,dMinRange,FALSE)) continue;

			aElemKeyList.Add(ElemK);
		}

		// Wall Result
		else if(m_pDoc->m_pAttrCtrl->IsWall(ElemD.eltyp))
		{
			int nStrwTimeIndex = m_nThisTimeIndex;
			if(bDesignatedDOF)
			{
				// Designated D.O.F
				ThrdD.nEntity       = ElemK;
				ThrdD.nStepFunction = 7; //Wall Force
				ThrdD.nSubType      = 1; //Force
				if(!CGPSPostCtrl::GetTimeStepIndexByFuncCondition(ThrdD,nStrwTimeIndex)) nStrwTimeIndex = 0;
			}

			unsigned int iInternalWallID=0;
			m_pDoc->m_pPostCtrl->GetInternalWallId(ElemK, iInternalWallID);
			if(!m_pDoc->m_pPostCtrl->GetStrwHistory(nStrwTimeIndex,iInternalWallID,StrwD)){ continue;  }
			if (!m_pDoc->m_pPostCtrl->GetWallKey(iInternalWallID, wall_key))  { ASSERT(0);  continue; }
			if(!m_pDoc->m_pPostCtrl->GetWallData(wall_key, winfo)) continue;

			if(!IsWithinRangeElemWForc(StrwD, dMaxRange, dMinRange)) continue;

			aElemKeyList.Add(ElemK);
		}

		// Truss Result
		else if(m_BForcComponent==BFORC_COMPONENT_FX && m_pDoc->m_pAttrCtrl->IsTruss(ElemD.eltyp))
		{
			int nStrtTimeIndex = m_nThisTimeIndex;
			if(bDesignatedDOF)
			{
				// Designated D.O.F
				if(ThrdD.nPosition>2)   continue; // Middle
				if(ThrdD.nComponent!=1) continue; // Fx

				ThrdD.nEntity = ElemK;
				ThrdD.nStepFunction = 3; //Truss Force/Stress
				ThrdD.nSubType      = 1; //Force
				if(!CGPSPostCtrl::GetTimeStepIndexByFuncCondition(ThrdD,nStrtTimeIndex)) nStrtTimeIndex = 0;
			}

			if(!m_pDoc->m_pPostCtrl->GetStrtHistory(nStrtTimeIndex,ElemK,StrtD)){ continue;  }

			if(!IsWithinRangeElemTForc(StrtD,dMaxRange,dMinRange)) continue;

			aElemKeyList.Add(ElemK);
		}
	}

	//--------------------------------------------------------------------------------
	// General Link Result
	//--------------------------------------------------------------------------------
	T_STEK_D StekD;
	T_NLNK_D NlnkD;
	CArray<T_NLNK_K,T_NLNK_K> arNlnkK;
	m_pDoc->m_pAttrCtrl->GetNlnkKeyList(arNlnkK);
	for(i=0;i<arNlnkK.GetSize();i++) 
	{
		m_pDoc->m_pAttrCtrl->GetNlnk(arNlnkK[i],NlnkD);
		if(!gm->m_pGPSCtrl->IsActiveNode(NlnkD.Node1))continue;
		if(!gm->m_pGPSCtrl->IsActiveNode(NlnkD.Node2))continue;
		int nNlnkTimeIndex = m_nThisTimeIndex;
		if(bDesignatedDOF)
		{
			// Designated D.O.F
			if(ThrdD.nPosition>2)   continue; // Middle
			ThrdD.nEntity = arNlnkK[i];
			ThrdD.nStepFunction = 6; //Genral Link Force
			if(!CGPSPostCtrl::GetTimeStepIndexByFuncCondition(ThrdD,nNlnkTimeIndex))nNlnkTimeIndex = 0;
		}

		if(!m_pDoc->m_pPostCtrl->GetNlfcHistory(nNlnkTimeIndex,arNlnkK[i],StekD)){ continue;  }	

		if(!IsWithinRangeNlnkForc(StekD,dMaxRange,dMinRange)) continue;

		aElemKeyList.Add(ElemK);
	}

	gm->m_pMyView->EndWaitCursor();

	return TRUE; 
}

void CForceEngine::DrawBForcTimeHist(CDC *pDC)
{
	DECLARE_GPSMD();
	DECLARE_DBDOC();

	int			  i,ElemNum;
	T_ELEM_D	ElemD;
	CPen		  ElemPen, *pOldPen;
	CArray<int, int>  TypeList;
	CArray<GRE_Atom, GRE_Atom&> AtomList;

	BOOL bEscapePressed = FALSE;
	T_MIRE_K mkey;

	if(!gm->m_bContour){ gm->GPSDrawOriginal(pDC); return; }

	if(m_bDeformedShapeContour) 
	{
		if(gm->m_pDeformEngine == NULL)return;
		TypeList.Add(gm->m_MinOTID + OBJECT_TYPE_DEFORMED);
	}
	else
		TypeList.Add(gm->m_MinOTID + OBJECT_TYPE_ORIGINAL);

	if(gm->m_DOPT.DR.m_bFrameLine) // wire frame
		ElemPen.CreatePen(PS_SOLID, gm->m_DOPT.DR.nElemWire*1.7, m_pContourEngine->m_ElemColor);
	else 
		ElemPen.CreatePen(PS_SOLID, gm->m_DOPT.DR.nElemHddn, m_pContourEngine->m_ElemColor);

	pOldPen = (CPen *) pDC->SelectObject(&ElemPen);

	gm->m_pGPSCtrl->GetZSortedList(TypeList, gm->m_EKeyListVisible_Mirror, AtomList);
	ElemNum = AtomList.GetSize();


	//-----------------------------------------------------------------------------------
	// 요소에 대한 결과출력
	//-----------------------------------------------------------------------------------
	BOOL bExit = FALSE; 
	for (i=0;i<ElemNum;i++) 
	{
		if(gm->m_pGPSCtrl->WatchEscKeyPress()) 
		{
			bExit = TRUE; 
			break; 
		}

		if(gm->m_pGPSCtrl->IsZoomAllState() ||
			gm->m_pGPSCtrl->IsObjectInClientWindow(AtomList[i].m_OType, AtomList[i].m_OKey)) 
		{
			mkey.keymap = AtomList[i].m_OKey;
			if(!m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, ElemD)) continue;

			if(m_pDoc->m_pAttrCtrl->IsBeam(ElemD.eltyp) && !bEscapePressed) 
			{
				if(gm->m_pGPSCtrl->IsActiveElem(AtomList[i].m_OKey))
					DoBForcElementContour(pDC, AtomList[i].m_OKey);
				else
				{
					if(m_bDeformedShapeContour)gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, AtomList[i].m_OKey);
					else                       gm->GPSDrawInactiveElement(pDC, AtomList[i].m_OKey);
				}
			}
			else if(m_pDoc->m_pAttrCtrl->IsTruss(ElemD.eltyp)) 
			{
				if(gm->m_pGPSCtrl->IsActiveElem(AtomList[i].m_OKey) && !bEscapePressed)  
				{
					DoTForcElementContour(pDC, AtomList[i].m_OKey);
				}
				else
				{
					if(m_bDeformedShapeContour) gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, AtomList[i].m_OKey);
					else                        gm->GPSDrawInactiveElement(pDC, AtomList[i].m_OKey);
				}       
			}
			else if (m_pDoc->m_pAttrCtrl->IsWall(ElemD.eltyp))
			{
				if(gm->m_pGPSCtrl->IsActiveElem(AtomList[i].m_OKey) && !bEscapePressed)  
				{
					DoWForcElementContour(pDC, AtomList[i].m_OKey);
				}
				else
				{
					if(m_bDeformedShapeContour) gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, AtomList[i].m_OKey);
					else                        gm->GPSDrawInactiveElement(pDC, AtomList[i].m_OKey);
				}       
			}
			else 
			{
				if(m_bDeformedShapeContour)
					gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, AtomList[i].m_OKey);
				else
					gm->GPSDrawInactiveElement(pDC, AtomList[i].m_OKey);
			}
		}
	}

	pDC->SelectObject(pOldPen);
	ElemPen.DeleteObject();

	//-----------------------------------------------------------------------------------
	// Link에 대한 결과 출력 
	//-----------------------------------------------------------------------------------
	T_NLNK_D  NlnkD;
	CArray<T_NLNK_K,T_NLNK_K>arNllk;
	pDoc->m_pAttrCtrl->GetNlnkKeyList(arNllk);

	for (i=0; i<arNllk.GetSize();i++) 
	{
		if(gm->m_pGPSCtrl->WatchEscKeyPress()){bExit=TRUE;  break; }

		pDoc->m_pAttrCtrl->GetNlnk(arNllk[i],NlnkD);
		if(!gm->m_pGPSCtrl->IsActiveNode(NlnkD.Node1))continue;
		if(!gm->m_pGPSCtrl->IsActiveNode(NlnkD.Node2))continue;

		T_STEK_D StekD;
		if(!m_mapNForcData.Lookup(arNllk[i],StekD))continue; 
		DrawNForcTimeHist(pDC,arNllk[i],NlnkD,StekD);
	}


	if(bExit)return; 

	// 변형된 그림에 Undeformed Shape을 같이 그릴 경우.
	// Contour를 그릴 경우는 Hidden이 default
	// 따라서 Undeformed Shape은 무조건 나중에 그린다...
	if (m_bDeformedShapeContour && gm->m_DOPT.DR.m_bDrawInactive && !bEscapePressed) 
	{
		int	rf_bak=gm->m_DOPT.DR.m_RenderFlag;
		gm->m_DOPT.DR.m_RenderFlag = 2;
		gm->GPSDrawOriginal(pDC, TRUE);
		gm->m_DOPT.DR.m_RenderFlag = rf_bak;
	}
}

void CForceEngine::DrawNForcTimeHist(CDC *pDC,T_NLNK_K NlnkK,T_NLNK_D NlnkD,T_STEK_D &StekD)
{
	DECLARE_DBDOC();
	DECLARE_GPSMD();
	DECLARE_DPTDR();
	DECLARE_DPTCL();

	C3DPoint Point1,Point2;
	CArray<BOOL,BOOL> EdgeList;
	CList<C3DPoint,C3DPoint> PolyList;

	BOOL m_bDSCont = m_bDeformedShapeContour;
	T_NODE_D NodeD;
	pDoc->m_pAttrCtrl->GetNode(NlnkD.Node1,NodeD);
	Point1.Set(NodeD.x,NodeD.y,NodeD.z);
	pDoc->m_pAttrCtrl->GetNode(NlnkD.Node2,NodeD);
	Point2.Set(NodeD.x,NodeD.y,NodeD.z);

	if(m_bDeformedShapeContour) 
	{
		Point1 = gm->m_pDeformEngine->GetDisplacedPoint(NlnkD.Node1,Point1);
		Point2 = gm->m_pDeformEngine->GetDisplacedPoint(NlnkD.Node2,Point2);
	}

	PolyList.AddTail(Point1);
	PolyList.AddTail(Point2);
	EdgeList.SetSize(2);
	EdgeList[0] = TRUE;
	EdgeList[1] = FALSE;

	// Nlnk를 그린다 
	CPen		pen, *old_pen;
	pen.CreatePen(PS_SOLID, gm->m_DOPT.DR.nElemWire, pCL->m_NlnkColor);
	old_pen = (CPen *)pDC->SelectObject(&pen);

	gm->GPSDrawPolygonEdge(pDC, &PolyList, &EdgeList,FALSE);

	pDC->SelectObject(old_pen);
	pen.DeleteObject();

	CBrush RankBrush,*pOldBrush;
	C3DPoint IPos,JPos;

	double dUnitSize = pDC->GetDeviceCaps(LOGPIXELSX)*0.12;

	IPos.x = Point1.x+(Point2.x-Point1.x)*0.1; 
	IPos.y = Point1.y+(Point2.y-Point1.y)*0.1; 
	IPos.z = Point1.z+(Point2.z-Point1.z)*0.1; 

	JPos.x = Point1.x+(Point2.x-Point1.x)*0.9; 
	JPos.y = Point1.y+(Point2.y-Point1.y)*0.9; 
	JPos.z = Point1.z+(Point2.z-Point1.z)*0.9; 

	double dIValue = this->CalcNForcValue(StekD,0);
	double dJValue = this->CalcNForcValue(StekD,1);

	RankBrush.CreateSolidBrush(m_pContourEngine->GetValueColor(dIValue));
	pOldBrush = (CBrush *)pDC->SelectObject(&RankBrush);
	DrawPoint(pDC,IPos,dUnitSize); 
	pDC->SelectObject(pOldBrush);
	RankBrush.DeleteObject(); 

	RankBrush.CreateSolidBrush(m_pContourEngine->GetValueColor(dJValue));
	pOldBrush = (CBrush *)pDC->SelectObject(&RankBrush);
	DrawPoint(pDC,JPos,dUnitSize); 
	pDC->SelectObject(pOldBrush);
	RankBrush.DeleteObject(); 

}

void CForceEngine::DrawBDgrmTimeHist(CDC *pDC)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	T_MIRE_K  mkey;

	int			i, nElem;
	T_ELEM_D	elem_d;
	CArray <int, int>				type_list;
	CArray <GRE_Atom, GRE_Atom&>		atom_list;
	BOOL bEscapePressed = FALSE;
	m_mapSFDBMDMax.RemoveAll();

	CDC	*pdc=gm->m_pMyView->GetDC();
	m_dUnitLength = fabs(gm->m_pGPSCtrl->GetWorldLength(((double) pdc->GetDeviceCaps(LOGPIXELSX))/5.0));

	gm->m_pMyView->ReleaseDC(pdc);

	//KYE-HONG-20020321
	m_arSfdBmdOutPut.RemoveAll();
	m_arSfdBmdOutPutM.RemoveAll();  

	// SFD/BMD 이외의 그림은 Hidden을 끄고 그린다.
	BOOL		fl_bak=gm->m_DOPT.DR.m_bFrameLine;
	gm->m_DOPT.DR.m_bFrameLine = TRUE;

	if(m_bDeformedShapeContour) 
	{
		if(gm->m_pDeformEngine == NULL) 
		{
			gm->m_DOPT.DR.m_bFrameLine = fl_bak;
			return;
		}
		type_list.Add(gm->m_MinOTID + OBJECT_TYPE_DEFORMED);

		// 변형된 모델에 Undeformed 모델을 같이 그릴 경우
		// Undeformed Shape이 Deformed Shape을 가려서 혼란스럽거나(Fill Mode일 경우)
		// 혹은 Deformed Shape에 가려져서 보이지 않게 되는 것을 피하기 위하여(Fill Mode가 아닐 경우)
		// Fill Mode가 아닐 경우에는 Undeformed Shape을 먼저 그리고
		// 그렇지 않을 경우엔 나중에 그린다.
		if(gm->m_DOPT.DR.m_bDrawInactive && m_bBSfdBmdLineOnly) 
		{
			int	rf_bak=gm->m_DOPT.DR.m_RenderFlag;
			gm->m_DOPT.DR.m_RenderFlag = 2;
			gm->GPSDrawOriginal(pDC, TRUE);
			gm->m_DOPT.DR.m_RenderFlag = rf_bak;
		}
	}
	else 
	{
		type_list.Add(gm->m_MinOTID + OBJECT_TYPE_ORIGINAL);
	}

	//----------------------------------------------------------------------
	// Beam Force 대화상자를 가지고 Wall도 함께 쓰기 때문에 Beam을 참고로 Wall도 아래와 같이 세팅 
	m_WSfdBmdAdjustFactor = m_BSfdBmdAdjustFactor;
	m_WSfdBmdScFactor = m_BSfdBmdScFactor;
	//----------------------------------------------------------------------

	gm->m_pGPSCtrl->GetZSortedList(type_list, gm->m_EKeyListVisible_Mirror, atom_list);
	nElem = atom_list.GetSize();
	for (i=0;i<nElem ;i++) 
	{
		if(gm->m_pGPSCtrl->WatchEscKeyPress()) return;
		if(gm->m_pGPSCtrl->IsZoomAllState() ||
			gm->m_pGPSCtrl->IsObjectInClientWindow(atom_list[i].m_OType, atom_list[i].m_OKey)) 
		{
			mkey.keymap = atom_list[i].m_OKey;
			if(!m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d))continue;
			if(gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey) && !bEscapePressed)
			{
				BOOL bBeam  = m_pDoc->m_pAttrCtrl->IsBeam(elem_d.eltyp);
				BOOL bTruss = m_pDoc->m_pAttrCtrl->IsTruss(elem_d.eltyp);
				BOOL bWall = m_pDoc->m_pAttrCtrl->IsWall(elem_d.eltyp);
				if(m_bDeformedShapeContour)
				{
					if(bBeam || bTruss || bWall) gm->m_pDeformEngine->DrawDeformedElement(pDC, atom_list[i].m_OKey);
					else						             gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, atom_list[i].m_OKey);
				}
				else
				{
					if(bBeam || bTruss || bWall) gm->GPSDrawElement(pDC, atom_list[i].m_OKey);
					else						             gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
				}
				if(bBeam || bTruss || bWall) DoBDgrmTimeHist(pDC, atom_list[i].m_OKey, elem_d.eltyp);
			}
			else
			{
				if(m_bDeformedShapeContour)
					gm->m_pDeformEngine->DrawInactiveDeformedElement(pDC, atom_list[i].m_OKey);
				else
					gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
			}
		}
	}

	//-----------------------------------------------------------------------------------
	// Link에 대한 결과 출력 
	//-----------------------------------------------------------------------------------
	BOOL bExit=FALSE;
	T_NLNK_D  NlnkD;
	CArray<T_NLNK_K,T_NLNK_K>arNllk;
	CDBDoc *pDoc = CDBDoc::GetDocPoint(); 
	pDoc->m_pAttrCtrl->GetNlnkKeyList(arNllk);

	for (i=0; i<arNllk.GetSize();i++) 
	{
		if(gm->m_pGPSCtrl->WatchEscKeyPress()){bExit=TRUE;  break; }

		pDoc->m_pAttrCtrl->GetNlnk(arNllk[i],NlnkD);
		if(!gm->m_pGPSCtrl->IsActiveNode(NlnkD.Node1))continue;
		if(!gm->m_pGPSCtrl->IsActiveNode(NlnkD.Node2))continue;

		T_STEK_D StekD;
		if(!m_mapNForcData.Lookup(arNllk[i],StekD))continue; 
		DrawNForcTimeHist(pDC,arNllk[i],NlnkD,StekD);
	}

	BOOL bOutNum=gm->m_DOPT.TX.m_bOutputNumber;

	if(bOutNum)
	{
		// Beam/Truss의 결과값 출력 
		BOOL bGrpFltMode=gm->m_pGPSCtrl->IsGroupFilterMode();
		for(i=0; i<m_arSfdBmdOutPut.GetSize(); i++)
		{
			if(bGrpFltMode)
			{
				if(!gm->m_pDispFilter->IsExistEKey(m_arSfdBmdOutPut[i].EKey))
					continue;
			}
			OutputSfdBmdNumber(pDC, m_arSfdBmdOutPut[i].EKey, m_arSfdBmdOutPut[i].StrbD, m_arSfdBmdOutPut[i].Pos, m_arSfdBmdOutPut[i].nComp, m_arSfdBmdOutPut[i].dMinMaxVal);
		}

		// General Link의 결과값 출력 
		OutputNForcNumbers4Hist(pDC);
	}

	m_arSfdBmdOutPut.RemoveAll();
	m_arSfdBmdOutPutM.RemoveAll(); 


	// 변형된 모델에 Undeformed 모델을 같이 그릴 경우
	if (m_bDeformedShapeContour && gm->m_DOPT.DR.m_bDrawInactive && !m_bBSfdBmdLineOnly && !bEscapePressed) 
	{
		int	rf_bak=gm->m_DOPT.DR.m_RenderFlag;
		gm->m_DOPT.DR.m_RenderFlag = 2;
		gm->GPSDrawOriginal(pDC, TRUE);
		gm->m_DOPT.DR.m_RenderFlag = rf_bak;
	}
	gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}

void CForceEngine::DoBDgrmTimeHist(CDC *pDC, unsigned int ekey, int ElemType)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	T_MIRE_K mkey;
	mkey.keymap = ekey;

	int		    poly_num;
	double		local_vector[3][3];
	T_STRB_D	bforc_d;
	T_STRW_D	wforc_d;
	T_WALL_D	winfo;
	double    dMnMxVal[2];

	POSITION	pos;
	C3DPoint	pnt[2], node_i, node_j, *txt_pnt;
	CArray<BOOL, BOOL>				ef_list;
	CArray<BOOL, BOOL>				rect_flag;
	CArray<double, double &>	val_list;
	CArray<C3DPoint,C3DPoint&>vtx_list;
	CArray<CList<C3DPoint,C3DPoint> *, CList <C3DPoint, C3DPoint> *>polygon_list;

	if((gm->m_pDeformEngine==NULL) || (m_pContourEngine==NULL))return;

	//DoBDgrmTimeHistWall(pDC,ekey,ElemType);

	if(ElemType == BEAM_EL)
	{
		if(!GetBeamForce(mkey.key.elem_k, bforc_d))return;
	}
	else if(ElemType == WALL_EL)
	{
		if(!GetWallData(mkey.key.elem_k, wforc_d)) return;
		if(!GetWallInfo(mkey.key.elem_k, winfo)) return;

		// Truss 처럼 Beam의 다이어그램 함수를 사용하기 위해, Beam force 데이터 형식으로 변환.
		bforc_d.Initialize();
		for(int i=0; i<4; i++)
		{
			// wforc_d는 [0]-top, [1]-bottom이라서 순서를 바꿔줌
			bforc_d.dblForce[i][0]  = wforc_d.dblForce[1][0] + (wforc_d.dblForce[0][0] - wforc_d.dblForce[1][0])*(i/4.0);
			bforc_d.dblForce[i][1]  = wforc_d.dblForce[1][1] + (wforc_d.dblForce[0][1] - wforc_d.dblForce[1][1])*(i/4.0);
			bforc_d.dblForce[i][2]  = wforc_d.dblForce[1][2] + (wforc_d.dblForce[0][2] - wforc_d.dblForce[1][2])*(i/4.0);
			bforc_d.dblForce[i][3]  = wforc_d.dblForce[1][3] + (wforc_d.dblForce[0][3] - wforc_d.dblForce[1][3])*(i/4.0);
			bforc_d.dblForce[i][4]  = wforc_d.dblForce[1][4] + (wforc_d.dblForce[0][4] - wforc_d.dblForce[1][4])*(i/4.0);
			bforc_d.dblForce[i][5]  = wforc_d.dblForce[1][5] + (wforc_d.dblForce[0][5] - wforc_d.dblForce[1][5])*(i/4.0);

			bforc_d.dblForce[i][ 6]  = wforc_d.dblForce[1][0] + (wforc_d.dblForce[0][0] - wforc_d.dblForce[1][0])*((i+1)/4.0);
			bforc_d.dblForce[i][ 7]  = wforc_d.dblForce[1][1] + (wforc_d.dblForce[0][1] - wforc_d.dblForce[1][1])*((i+1)/4.0);
			bforc_d.dblForce[i][ 8]  = wforc_d.dblForce[1][2] + (wforc_d.dblForce[0][2] - wforc_d.dblForce[1][2])*((i+1)/4.0);
			bforc_d.dblForce[i][ 9]  = wforc_d.dblForce[1][3] + (wforc_d.dblForce[0][3] - wforc_d.dblForce[1][3])*((i+1)/4.0);
			bforc_d.dblForce[i][10]  = wforc_d.dblForce[1][4] + (wforc_d.dblForce[0][4] - wforc_d.dblForce[1][4])*((i+1)/4.0);
			bforc_d.dblForce[i][11]  = wforc_d.dblForce[1][5] + (wforc_d.dblForce[0][5] - wforc_d.dblForce[1][5])*((i+1)/4.0);
		}
	}
	else if(ElemType == TRUSS_EL)
	{
		T_STRT_D strt_d;
		if(!GetTrussForce(mkey.key.elem_k,strt_d)) return;

		bforc_d.Initialize();

		for(int i=0; i<4; i++)
		{
			bforc_d.dblForce[i][0]  = strt_d.dblForce[0] + (strt_d.dblForce[1] - strt_d.dblForce[0])*(i/4.0);
			bforc_d.dblForce[i][6]  = strt_d.dblForce[0] + (strt_d.dblForce[1] - strt_d.dblForce[0])*((i+1)/4.0);
			bforc_d.dblStress[i][0] = strt_d.dblStress[0] + (strt_d.dblStress[1] - strt_d.dblStress[0])*((i+1)/4.0);
			bforc_d.dblStress[i][7] = strt_d.dblStress[0] + (strt_d.dblStress[1] - strt_d.dblStress[0])*((i+1)/4.0);
		}
	}
	else { ASSERT(0); return ; }

	m_pDoc->calcFrameLocalVector(mkey.key.elem_k, local_vector);


	if(m_bDeformedShapeContour)
	{
		gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, NULL, NULL);
	}
	else
	{
		gm->GetShapeElement(ekey, polygon_list, NULL, NULL, NULL);
	}

	poly_num = polygon_list.GetSize();
	if (ElemType == BEAM_EL || ElemType == TRUSS_EL)
	{
		if((poly_num!=1) || (polygon_list[0]->GetCount()!=2))return;
	}
	else if (ElemType == WALL_EL)
	{
		if((poly_num!=1) || (polygon_list[0]->GetCount()!=4))  { ASSERT(0);  return; }
	}
	else
	{
		ASSERT(0);  return;
	}

	if(gm->m_DOPT.TX.m_bOutputNumber) txt_pnt   = new C3DPoint[4];
	else                              txt_pnt   = NULL;

	pos = polygon_list[0]->GetHeadPosition();
	pnt[0] = polygon_list[0]->GetNext(pos);
	pnt[1] = polygon_list[0]->GetNext(pos);

	CArray<T_SFDBMD_OUTVAL_D,T_SFDBMD_OUTVAL_D&> arOutVal; 
	T_SFDBMD_OUTVAL_D OutVal;


	GetOffsetedPoint(mkey.key.elem_k,pnt[0],pnt[1],node_i,node_j,m_BForcComponent);

	if(ElemType == BEAM_EL)
	{
		BSfdBmdMakePolygon(bforc_d, m_BForcComponent, local_vector,node_i, node_j, vtx_list, val_list, ef_list, rect_flag, txt_pnt, mkey.key.elem_k, dMnMxVal , FALSE);
	}
	else if(ElemType == WALL_EL)
	{
		CArray<T_ELEM_K, T_ELEM_K> ElemKeyList;
		T_ELEM_K StartElemKey, EndElemKey;
		C3DPoint CenterP;

		CDBDoc::GetDocPoint()->m_pAttrCtrl->GetKeyListBy_WallID_ByStor(ElemKeyList,ekey);
		CDBDoc::GetDocPoint()->m_pAttrCtrl->GetWallIDFirstLastElem(ElemKeyList,StartElemKey,EndElemKey,FALSE);

		CArray<CList<C3DPoint,C3DPoint> *, CList <C3DPoint, C3DPoint> *>start_polygon_list;
		CArray<CList<C3DPoint,C3DPoint> *, CList <C3DPoint, C3DPoint> *>end_polygon_list;

		if(m_bDeformedShapeContour)
		{
			gm->m_pDeformEngine->GetDeformedShapeElement(StartElemKey, &start_polygon_list, NULL, NULL);
			gm->m_pDeformEngine->GetDeformedShapeElement(EndElemKey  , &end_polygon_list,   NULL, NULL);
		}
		else
		{
			gm->GetShapeElement(StartElemKey, start_polygon_list, NULL, NULL, NULL);
			gm->GetShapeElement(EndElemKey  , end_polygon_list,  NULL, NULL, NULL);
		}

		C3DPoint		start_bi_3D, start_bj_3D, start_ti_3D, start_tj_3D;
		C3DPoint		end_bi_3D, end_bj_3D, end_ti_3D, end_tj_3D;
		C3DPoint		bi_3D, bj_3D, ti_3D, tj_3D;

		pos = start_polygon_list[0]->GetHeadPosition();
		start_bi_3D = polygon_list[0]->GetNext(pos);
		start_bj_3D = polygon_list[0]->GetNext(pos);
		start_tj_3D = polygon_list[0]->GetNext(pos);
		start_ti_3D = polygon_list[0]->GetNext(pos);

		pos = end_polygon_list[0]->GetHeadPosition();
		end_bi_3D = polygon_list[0]->GetNext(pos);
		end_bj_3D = polygon_list[0]->GetNext(pos);
		end_tj_3D = polygon_list[0]->GetNext(pos);
		end_ti_3D = polygon_list[0]->GetNext(pos);

		bi_3D = start_bi_3D;
		ti_3D = start_ti_3D;
		bj_3D = end_bj_3D;
		tj_3D = end_tj_3D;

		// 		bi_3D.x = bi_3D.x / 2; bi_3D.y = bi_3D.y / 2; bi_3D.z = bi_3D.z / 2;
		// 		bj_3D.x = bj_3D.x / 2; bj_3D.y = bj_3D.y / 2; bj_3D.z = bj_3D.z / 2; 
		// 		ti_3D.x = ti_3D.x / 2; ti_3D.y = ti_3D.y / 2; ti_3D.z = ti_3D.z / 2;
		// 		tj_3D.x = tj_3D.x / 2; tj_3D.y = tj_3D.y / 2; tj_3D.z = tj_3D.z / 2;

		//     pos = polygon_list[0]->GetHeadPosition();
		//     bi_3D = polygon_list[0]->GetNext(pos);
		//     bj_3D = polygon_list[0]->GetNext(pos);
		//     tj_3D = polygon_list[0]->GetNext(pos);
		//     ti_3D = polygon_list[0]->GetNext(pos);

		node_i.x = (bi_3D.x + bj_3D.x)/2; //node_i 는 Bottom
		node_i.y = (bi_3D.y + bj_3D.y)/2; 

		node_j.x = (ti_3D.x + tj_3D.x)/2; //node_j 는 Top
		node_j.y = (ti_3D.y + tj_3D.y)/2;

		node_i.z = (bi_3D.z + bj_3D.z) * 0.5;
		node_j.z = (ti_3D.z + tj_3D.z) * 0.5;



		// 다이어그램을 면내방향으로 표현하기 위해 local-z를 90도 돌려줌.
		CMathFunc::mathRotateZ(90.0, local_vector[2][0], local_vector[2][1], local_vector[2][2]);

		BSfdBmdMakePolygon(bforc_d, m_BForcComponent, local_vector,
			node_i, node_j, vtx_list, val_list, ef_list, rect_flag, txt_pnt, mkey.key.elem_k, dMnMxVal , TRUE);
	}
	else
		BSfdBmdMakePolygon(bforc_d, m_BForcComponent, local_vector,
		node_i, node_j, vtx_list, val_list, ef_list, rect_flag, txt_pnt, mkey.key.elem_k, dMnMxVal , TRUE);

	if(txt_pnt)AddBSfdBmdOutputData(mkey.key.elem_k,txt_pnt,bforc_d,dMnMxVal,m_BForcComponent,0);

	gm->GPS_XGL_Begin_Diagram(mkey.key.elem_k);
	DoBSfdBmdContour(pDC, vtx_list, val_list, ef_list, rect_flag);
	gm->GPS_XGL_End_Elem();

	vtx_list.RemoveAll();
	val_list.RemoveAll();
	ef_list.RemoveAll();
	rect_flag.RemoveAll();

	FreeMemoryPolyList(&polygon_list); 

	if(txt_pnt) delete []txt_pnt;
}

void CForceEngine::DoBDgrmTimeHistWall(CDC *pDC, unsigned int ekey, int ElemType)
{
	if(ElemType != WALL_EL) return;

	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	T_MIRE_K mkey;
	mkey.keymap = ekey;

	int		    poly_num;
	double		local_vector[3][3];
	T_STRB_D	bforc_d;
	T_STRW_D	wforc_d;
	T_WALL_D	winfo;
	double    dMnMxVal[2];

	POSITION	pos;
	C3DPoint	pnt[2], node_i, node_j, *txt_pnt;
	CArray<BOOL, BOOL>				ef_list;
	CArray<BOOL, BOOL>				rect_flag;
	CArray<double, double &>	val_list;
	CArray<C3DPoint,C3DPoint&>vtx_list;
	CArray<CList<C3DPoint,C3DPoint> *, CList <C3DPoint, C3DPoint> *>polygon_list;
	if((gm->m_pDeformEngine==NULL) || (m_pContourEngine==NULL))return;

	CArray<T_ELEM_K,T_ELEM_K> aElemKeyList;
	T_ELEM_K RootKey, TempKey;

	m_pDoc->m_pAttrCtrl->GetKeyListBy_WallID_ByStor(aElemKeyList,ekey);
	m_pDoc->m_pAttrCtrl->GetRootWallElemKey(aElemKeyList, RootKey);
	if(ekey != RootKey) return;

	TempKey = ekey;
	ekey = RootKey;
	mkey.keymap = ekey;

	if(!GetWallData(mkey.key.elem_k, wforc_d))  { ASSERT(0);  return; }
	if(!GetWallInfo(mkey.key.elem_k, winfo))  { ASSERT(0);  return; }

	// Truss 처럼 Beam의 다이어그램 함수를 사용하기 위해, Beam force 데이터 형식으로 변환.
	bforc_d.Initialize();
	for(int i=0; i<4; i++)
	{
		// wforc_d는 [0]-top, [1]-bottom이라서 순서를 바꿔줌
		bforc_d.dblForce[i][0]  = wforc_d.dblForce[1][0] + (wforc_d.dblForce[0][0] - wforc_d.dblForce[1][0])*(i/4.0);
		bforc_d.dblForce[i][1]  = wforc_d.dblForce[1][1] + (wforc_d.dblForce[0][1] - wforc_d.dblForce[1][1])*(i/4.0);
		bforc_d.dblForce[i][2]  = wforc_d.dblForce[1][2] + (wforc_d.dblForce[0][2] - wforc_d.dblForce[1][2])*(i/4.0);
		bforc_d.dblForce[i][3]  = wforc_d.dblForce[1][3] + (wforc_d.dblForce[0][3] - wforc_d.dblForce[1][3])*(i/4.0);
		bforc_d.dblForce[i][4]  = wforc_d.dblForce[1][4] + (wforc_d.dblForce[0][4] - wforc_d.dblForce[1][4])*(i/4.0);
		bforc_d.dblForce[i][5]  = wforc_d.dblForce[1][5] + (wforc_d.dblForce[0][5] - wforc_d.dblForce[1][5])*(i/4.0);

		bforc_d.dblForce[i][ 6]  = wforc_d.dblForce[1][0] + (wforc_d.dblForce[0][0] - wforc_d.dblForce[1][0])*((i+1)/4.0);
		bforc_d.dblForce[i][ 7]  = wforc_d.dblForce[1][1] + (wforc_d.dblForce[0][1] - wforc_d.dblForce[1][1])*((i+1)/4.0);
		bforc_d.dblForce[i][ 8]  = wforc_d.dblForce[1][2] + (wforc_d.dblForce[0][2] - wforc_d.dblForce[1][2])*((i+1)/4.0);
		bforc_d.dblForce[i][ 9]  = wforc_d.dblForce[1][3] + (wforc_d.dblForce[0][3] - wforc_d.dblForce[1][3])*((i+1)/4.0);
		bforc_d.dblForce[i][10]  = wforc_d.dblForce[1][4] + (wforc_d.dblForce[0][4] - wforc_d.dblForce[1][4])*((i+1)/4.0);
		bforc_d.dblForce[i][11]  = wforc_d.dblForce[1][5] + (wforc_d.dblForce[0][5] - wforc_d.dblForce[1][5])*((i+1)/4.0);
	}

	m_pDoc->calcFrameLocalVector(mkey.key.elem_k, local_vector);

	if(m_bDeformedShapeContour)
		gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, NULL, NULL);
	else
		gm->GetShapeElement(ekey, polygon_list, NULL, NULL, NULL);

	poly_num = polygon_list.GetSize();
	if((poly_num!=1) || (polygon_list[0]->GetCount()!=4))  { ASSERT(0);  return; }

	if(gm->m_DOPT.TX.m_bOutputNumber) txt_pnt   = new C3DPoint[4];
	else                              txt_pnt   = NULL;

	pos = polygon_list[0]->GetHeadPosition();
	pnt[0] = polygon_list[0]->GetNext(pos);
	pnt[1] = polygon_list[0]->GetNext(pos);

	CArray<T_SFDBMD_OUTVAL_D,T_SFDBMD_OUTVAL_D&> arOutVal; 
	T_SFDBMD_OUTVAL_D OutVal;


	GetOffsetedPoint(mkey.key.elem_k,pnt[0],pnt[1],node_i,node_j,m_BForcComponent);

	CArray<T_ELEM_K, T_ELEM_K> ElemKeyList;
	T_ELEM_K StartElemKey, EndElemKey;
	C3DPoint CenterP;

	CDBDoc::GetDocPoint()->m_pAttrCtrl->GetKeyListBy_WallID_ByStor(ElemKeyList,ekey);
	CDBDoc::GetDocPoint()->m_pAttrCtrl->GetWallIDFirstLastElem(ElemKeyList,StartElemKey,EndElemKey);
	gm->GetWallIDElementListCenterPos(TRUE,StartElemKey,EndElemKey,&CenterP);

	C3DPoint		bi_3D, bj_3D, ti_3D, tj_3D;
	pos = polygon_list[0]->GetHeadPosition();
	bi_3D = polygon_list[0]->GetNext(pos);
	bj_3D = polygon_list[0]->GetNext(pos);
	tj_3D = polygon_list[0]->GetNext(pos);
	ti_3D = polygon_list[0]->GetNext(pos);

	node_i.x = (bi_3D.x + bj_3D.x)/2; //node_i 는 Bottom
	node_i.y = (bi_3D.y + bj_3D.y)/2; 

	node_j.x = (ti_3D.x + tj_3D.x)/2; //node_j 는 Top
	node_j.y = (ti_3D.y + tj_3D.y)/2;

	node_i.z = (bi_3D.z + bj_3D.z) * 0.5;
	node_j.z = (ti_3D.z + tj_3D.z) * 0.5;

	// 다이어그램을 면내방향으로 표현하기 위해 local-z를 90도 돌려줌.
	CMathFunc::mathRotateZ(90.0, local_vector[2][0], local_vector[2][1], local_vector[2][2]);

	BSfdBmdMakePolygon(bforc_d, m_BForcComponent, local_vector,
		node_i, node_j, vtx_list, val_list, ef_list, rect_flag, txt_pnt, mkey.key.elem_k, dMnMxVal , TRUE);

	if(txt_pnt)AddBSfdBmdOutputData(mkey.key.elem_k,txt_pnt,bforc_d,dMnMxVal,m_BForcComponent,0);

	gm->GPS_XGL_Begin_Diagram(mkey.key.elem_k);
	DoBSfdBmdContour(pDC, vtx_list, val_list, ef_list, rect_flag);
	gm->GPS_XGL_End_Elem();

	vtx_list.RemoveAll();
	val_list.RemoveAll();
	ef_list.RemoveAll();
	rect_flag.RemoveAll();

	FreeMemoryPolyList(&polygon_list); 

	if(txt_pnt) delete []txt_pnt;

}

void CForceEngine::OutputBForcTimeHist(CDC *pDC)
{
	OutputBForcNumbers(pDC);
	OutputTForcNumbers4Hist(pDC);
	OutputNForcNumbers4Hist(pDC);
	OutputWForcNumbers(pDC);
}

#if defined (__OLD_OUTPUT_VALUE)
void CForceEngine::OutputTForcNumbers4Hist(CDC* pDC)
{
	DECLARE_GPSMD();
	DECLARE_DPTDR();
	DECLARE_DPTTX();

	int					i, j, elem_num, slope;
	T_ELEM_K		ekey;
	T_ELEM_D		edata;
	T_STRT_D		tforc_d;
	C3DPoint		node3D_i, node3D_j, DrawPoint;
	CPoint			text_p, node_2d_i, node_2d_j;
	TCHAR				fmt_str[10], text_str[512];
	CFont				ft, * old_ft;
	BOOL				fl_bak, is_inverse;

	POSITION		pos;
	CArray<CList  <C3DPoint, C3DPoint>*, CList<C3DPoint, C3DPoint>*>		polygon_list;
	CArray<CArray <BOOL, BOOL>*, CArray <BOOL, BOOL>*>					edge_list;

	// 주의 
	if (!m_bBForcDataSet)return;

	if (pTX->m_bNumberOpaque) pDC->SetBkMode(OPAQUE);
	else		                 pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(pTX->m_NumberTextColorC);
	pDC->SetBkColor(pTX->m_NumberBackCol);
	pDC->SetTextAlign(TA_CENTER | TA_BOTTOM);

	if (pTX->m_bNumberExponent)_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else		                  _stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);

	fl_bak = pDR->m_bFrameLine;
	pDR->m_bFrameLine = TRUE;

	if (pTX->m_bNumberSelOnly)
	{
	}
	else
	{
		BOOL bGrpFltMode = gm->m_pGPSCtrl->IsGroupFilterMode();
		if (!bGrpFltMode)elem_num = gm->m_EKeyListActive.GetSize();
		else            elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize();

		for (i = 0; i < elem_num; i++)
		{
			if (!bGrpFltMode)ekey = gm->m_EKeyListActive[i];
			else            ekey = gm->m_pDispFilter->m_aGrpEKey[i];

			if (!gm->m_pGPSCtrl->IsActiveElem(ekey))
				continue;

			m_pDoc->m_pAttrCtrl->GetElem(ekey, edata);

			if (IsExcludeTruss(ekey))continue;
			if (!GetTrussForce(ekey, tforc_d))continue;

			if (m_bDeformedShapeContour)
				gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list);
			else
				gm->GetShapeElement(ekey, polygon_list, &edge_list);

			pos = polygon_list[0]->GetHeadPosition();

			node3D_i = polygon_list[0]->GetNext(pos);
			node3D_j = polygon_list[0]->GetNext(pos);

			if (gm->m_bVirtualMode)
			{
				node_2d_i = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_i);
				node_2d_j = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_j);
			}
			else {
				node_2d_i = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_i);
				node_2d_j = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_j);
			}

			if ((node_2d_i.x < 0 || node_2d_i.y < 0 || node_2d_j.x < 0 || node_2d_j.y < 0))continue;


			slope = (int)(atan2(node_2d_i.y - node_2d_j.y, node_2d_j.x - node_2d_i.x) * 1800.0 / 3.14159);
			slope = (slope + 3600) % 3600;
			if ((900 < slope) && (slope <= 2700))
			{
				slope = (slope + 1800) % 3600;
				is_inverse = TRUE;
			}
			else
			{
				is_inverse = FALSE;
			}

			gm->SetNumberFontOrientation(slope);
			ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
			old_ft = (CFont*)pDC->SelectObject(&ft);

			if (pTX->m_bOutputMinMaxValueOnly)
			{
				double dLimit = (m_dMaxValue - m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;
				double dTValue;

				for (int n = 0; n < 2; n++)
				{
					if (n == 0) // I단 또는 MAX
					{
						if (m_bBForcOutputI || m_bBForcOutputAll || m_bBForcOutputMinMax)
						{
							if (is_inverse)pDC->SetTextAlign(TA_RIGHT | TA_BOTTOM);
							else				  pDC->SetTextAlign(TA_LEFT | TA_BOTTOM);
							DrawPoint = node3D_i;
							dTValue = CalcTForcValue(tforc_d, I_NODE);
						}
						else if (m_bBForcOutputMax)
						{
							pDC->SetTextAlign(TA_CENTER | TA_BOTTOM);
							DrawPoint.x = (node3D_i.x + node3D_j.x) / 2.0;
							DrawPoint.y = (node3D_i.y + node3D_j.y) / 2.0;
							DrawPoint.z = (node3D_i.z + node3D_j.z) / 2.0;
							dTValue = (fabs(CalcTForcValue(tforc_d, I_NODE)) >= fabs(CalcTForcValue(tforc_d, J_NODE))) ? CalcTForcValue(tforc_d, I_NODE) : CalcTForcValue(tforc_d, J_NODE);
						}
					}
					else // J단
					{
						if (m_bBForcOutputI || m_bBForcOutputMax) continue;
						if (is_inverse) pDC->SetTextAlign(TA_LEFT | TA_BOTTOM);
						else				   pDC->SetTextAlign(TA_RIGHT | TA_BOTTOM);
						DrawPoint = node3D_j;
						dTValue = CalcTForcValue(tforc_d, J_NODE);
					}

					switch (pTX->m_nOutputMinMaxType)
					{
					case 0: // Min & Max
						if ((m_dMaxValue - dTValue) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, dTValue);
						else if ((dTValue - m_dMinValue) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, dTValue);
						break;
					case 1: // Abs Max
						if (fabs(m_dMaxValue) >= fabs(m_dMinValue))
						{
							if (fabs(m_dMaxValue) - fabs(dTValue) <= dLimit)
								DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, dTValue);
						}
						else
						{
							if (fabs(m_dMinValue) - fabs(dTValue) <= dLimit)
								DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 2, dTValue);
						}
						break;
					case 2: // Max
						if ((m_dMaxValue - dTValue) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 0, dTValue);
						break;
					case 3: // Min
						if ((dTValue - m_dMinValue) <= dLimit)
							DrawMinMaxOutputValue(pDC, DrawPoint, fmt_str, 1, dTValue);
						break;
					}
				}
				//////////////////////////////////////////////////////////////////////////////////////
			}
			else
			{
				if (m_bBForcOutputMax)
				{
					text_p.x = (int)((node_2d_i.x + node_2d_j.x) / 2.0);
					text_p.y = (int)((node_2d_i.y + node_2d_j.y) / 2.0);
					_stprintf(text_str, fmt_str, GetMaxElemTForc(tforc_d));
					pDC->TextOut(text_p.x, text_p.y, text_str);
				}
				else
				{
					if (m_bBForcOutputI || m_bBForcOutputMinMax) // Max/Min은 All과 같다 
					{
						pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorI);
						if (is_inverse)pDC->SetTextAlign(TA_RIGHT | TA_BOTTOM);
						else          pDC->SetTextAlign(TA_LEFT | TA_BOTTOM);
						text_p.x = (int)node_2d_i.x;
						text_p.y = (int)node_2d_i.y;
						_stprintf(text_str, fmt_str, tforc_d.dblForce[0]);
						pDC->TextOut(text_p.x, text_p.y, text_str);
					}
					if (m_bBForcOutputJ || m_bBForcOutputMinMax) // Max/Min은 All과 같다 
					{
						pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorJ);
						if (is_inverse)  pDC->SetTextAlign(TA_LEFT | TA_BOTTOM);
						else				    pDC->SetTextAlign(TA_RIGHT | TA_BOTTOM);
						text_p.x = (int)node_2d_j.x;
						text_p.y = (int)node_2d_j.y;
						_stprintf(text_str, fmt_str, tforc_d.dblForce[1]);
						pDC->TextOut(text_p.x, text_p.y, text_str);
					}
				}
			}
			pDC->SelectObject(old_ft);
			ft.DeleteObject();

			for (j = 0; j < polygon_list.GetSize(); j++)
			{
				polygon_list[j]->RemoveAll();
				delete polygon_list[j];
				edge_list[j]->RemoveAll();
				delete edge_list[j];
			}
			polygon_list.RemoveAll();
			edge_list.RemoveAll();
		}
	}
	gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}
#else
void CForceEngine::OutputTForcNumbers4Hist(CDC *pDC)
{
	DECLARE_GPSMD();
	DECLARE_DPTDR();
	DECLARE_DPTTX();

	int					i, j, elem_num, slope;
	T_ELEM_K		ekey;
	T_ELEM_D		edata;
	T_STRT_D		tforc_d;
	C3DPoint		node3D_i, node3D_j,DrawPoint;
	CPoint			text_p,node_2d_i, node_2d_j;
	TCHAR				fmt_str[10], text_str[512];
	CFont				ft, *old_ft;
	BOOL				fl_bak, is_inverse;

	POSITION		pos;
	CArray<CList  <C3DPoint,C3DPoint> *,CList<C3DPoint, C3DPoint> *>		polygon_list;
	CArray<CArray <BOOL,BOOL> *, CArray <BOOL, BOOL> *>					edge_list;

	// 주의 
	if(!m_bBForcDataSet)return;

	GPostTextOut TextOutModel;
	TextOutModel.SetDC(pDC);
	TextOutModel.StartTForc4HistVal();
	TextOutModel.SettingTForc4Hist(gm);

	if(pTX->m_bNumberExponent)_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else		                  _stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);

	fl_bak = pDR->m_bFrameLine;
	pDR->m_bFrameLine = TRUE;

	if(pTX->m_bNumberSelOnly) 
	{
	}
	else 
	{
		BOOL bGrpFltMode=gm->m_pGPSCtrl->IsGroupFilterMode();
		if(!bGrpFltMode)elem_num = gm->m_EKeyListActive.GetSize();
		else            elem_num = gm->m_pDispFilter->m_aGrpEKey.GetSize(); 

		for (i=0;i<elem_num;i++) 
		{
			if(!bGrpFltMode)ekey = gm->m_EKeyListActive[i];
			else            ekey = gm->m_pDispFilter->m_aGrpEKey[i]; 

			if(!gm->m_pGPSCtrl->IsActiveElem(ekey))
				continue;

			m_pDoc->m_pAttrCtrl->GetElem(ekey, edata);

			if(IsExcludeTruss(ekey))continue;
			if(!GetTrussForce(ekey, tforc_d))continue; 

			if(m_bDeformedShapeContour) 
				gm->m_pDeformEngine->GetDeformedShapeElement(ekey, &polygon_list, &edge_list);
			else
				gm->GetShapeElement(ekey, polygon_list, &edge_list);

			pos = polygon_list[0]->GetHeadPosition();

			node3D_i = polygon_list[0]->GetNext(pos);
			node3D_j = polygon_list[0]->GetNext(pos);

			if (gm->m_bVirtualMode) 
			{
				node_2d_i = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_i);
				node_2d_j = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_j);
			}
			else {
				node_2d_i = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_i);
				node_2d_j = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_j);
			}

			if((node_2d_i.x < 0 || node_2d_i.y < 0 || node_2d_j.x < 0 || node_2d_j.y < 0))continue; 


			slope = (int) (atan2(node_2d_i.y-node_2d_j.y, node_2d_j.x-node_2d_i.x)*1800.0/3.14159);
			slope = (slope+3600)%3600;
			if ((900<slope) && (slope<=2700)) 
			{
				slope = (slope+1800)%3600;
				is_inverse = TRUE;
			}
			else 
			{
				is_inverse = FALSE;
			}

			TextOutModel.Font4TForc4Hist(gm, slope);

			if(pTX->m_bOutputMinMaxValueOnly)
			{
				double dLimit = (m_dMaxValue-m_dMinValue) * gm->m_DOPT.TX.m_dOutputMinMaxLimit / 100.0;
				double dTValue;

				for(int n=0; n<2; n++)
				{
					if(n==0) // I단 또는 MAX
					{
						if(m_bBForcOutputI || m_bBForcOutputAll || m_bBForcOutputMinMax) 
						{
							if (is_inverse)
								TextOutModel.AlignTextBot(TA_RIGHT);
							else
								TextOutModel.AlignTextBot(TA_LEFT);
							DrawPoint = node3D_i;
							dTValue = CalcTForcValue(tforc_d, I_NODE);
						}
						else if(m_bBForcOutputMax) 
						{
							TextOutModel.AlignTextBot(TA_CENTER);
							DrawPoint.x = (node3D_i.x + node3D_j.x)/2.0;
							DrawPoint.y = (node3D_i.y + node3D_j.y)/2.0;
							DrawPoint.z = (node3D_i.z + node3D_j.z)/2.0;
							dTValue = (fabs(CalcTForcValue(tforc_d, I_NODE)) >= fabs(CalcTForcValue(tforc_d, J_NODE)))? CalcTForcValue(tforc_d, I_NODE) : CalcTForcValue(tforc_d, J_NODE);
						}
					}
					else // J단
					{			  
						if(m_bBForcOutputI || m_bBForcOutputMax ) continue;
						if(is_inverse) 
							TextOutModel.AlignTextBot(TA_LEFT);
						else
							TextOutModel.AlignTextBot(TA_RIGHT);
						DrawPoint = node3D_j;
						dTValue   = CalcTForcValue(tforc_d, J_NODE);
					}

					switch(pTX->m_nOutputMinMaxType)
					{
					case 0: // Min & Max
						if((m_dMaxValue-dTValue) <= dLimit)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,dTValue);
						else if((dTValue-m_dMinValue) <= dLimit)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,dTValue);
						break;
					case 1: // Abs Max
						if(fabs(m_dMaxValue) >= fabs(m_dMinValue))
						{
							if( fabs(m_dMaxValue)-fabs(dTValue) <= dLimit)
								DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dTValue);
						}
						else
						{
							if( fabs(m_dMinValue)-fabs(dTValue) <= dLimit)
								DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,2,dTValue);
						}
						break;
					case 2: // Max
						if((m_dMaxValue-dTValue) <= dLimit)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,0,dTValue);
						break;
					case 3: // Min
						if((dTValue-m_dMinValue) <= dLimit)
							DrawMinMaxOutputValue(pDC,DrawPoint,fmt_str,1,dTValue);
						break;
					}
				}
				//////////////////////////////////////////////////////////////////////////////////////
			}      
			else      
			{
				if(m_bBForcOutputMax) 
				{
					text_p.x = (int) ((node_2d_i.x+node_2d_j.x)/2.0);
					text_p.y = (int) ((node_2d_i.y+node_2d_j.y)/2.0);
					_stprintf(text_str, fmt_str, GetMaxElemTForc(tforc_d));
					TextOutModel.TextOutTForc4Hist(text_p.x, text_p.y, text_str);
				}
				else 
				{
					if(m_bBForcOutputI || m_bBForcOutputMinMax) // Max/Min은 All과 같다 
					{
						text_p.x = (int) node_2d_i.x;
						text_p.y = (int) node_2d_i.y;
						_stprintf(text_str, fmt_str, tforc_d.dblForce[0]);
						if (is_inverse)
							TextOutModel.TextOutTForc4Hist(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorI, TA_RIGHT);
						else
							TextOutModel.TextOutTForc4Hist(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorI, TA_LEFT);
					}
					if(m_bBForcOutputJ || m_bBForcOutputMinMax) // Max/Min은 All과 같다 
					{
						text_p.x = (int) node_2d_j.x;
						text_p.y = (int) node_2d_j.y;
						_stprintf(text_str, fmt_str, tforc_d.dblForce[1]);
						if (is_inverse)  
							TextOutModel.TextOutTForc4Hist(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorJ, TA_LEFT);
						else
							TextOutModel.TextOutTForc4Hist(text_p.x, text_p.y, text_str, gm->m_DOPT.TX.m_NumberTextColorJ, TA_RIGHT);
					}
				}
			}
			TextOutModel.DeleteFont();

			for(j=0;j<polygon_list.GetSize();j++) 
			{
				polygon_list[j]->RemoveAll();
				delete polygon_list[j];
				edge_list[j]->RemoveAll();
				delete edge_list[j];
			}
			polygon_list.RemoveAll();
			edge_list.RemoveAll();
		}
	}
	TextOutModel.EndTForc4HistVal();
	gm->m_DOPT.DR.m_bFrameLine = fl_bak;  
}
#endif

void CForceEngine::OutputNForcNumbers4Hist(CDC *pDC)
{
	DECLARE_DBDOC();
	DECLARE_GPSMD();
	DECLARE_DPTDR();
	DECLARE_DPTTX();

	T_NLNK_D NlnkD;
	CArray<T_NLNK_K,T_NLNK_K>arNllk;
	pDoc->m_pAttrCtrl->GetNlnkKeyList(arNllk);

	pTX->m_NumberDecimalPoint = gm->m_NumberDecimalPoint;
	pTX->m_NumberFont = gm->m_NumberFont;

	for (int i=0; i<arNllk.GetSize();i++) 
	{
		pDoc->m_pAttrCtrl->GetNlnk(arNllk[i],NlnkD);
		if(!gm->m_pGPSCtrl->IsActiveNode(NlnkD.Node1))continue;
		if(!gm->m_pGPSCtrl->IsActiveNode(NlnkD.Node2))continue;

		T_STEK_D StekD;
		if(!m_mapNForcData.Lookup(arNllk[i],StekD))continue; 
		OutputNForcNumbers4HistSub(pDC,arNllk[i],NlnkD,StekD);
	}

}
void CForceEngine::OutputNForcNumbers4HistSub(CDC *pDC,T_NLNK_K NlnkK,T_NLNK_D NlnkD,T_STEK_D &StekD)
{
	DECLARE_DBDOC();
	DECLARE_GPSMD();
	DECLARE_DPTDR();
	DECLARE_DPTTX();

	int i;
	GPS_3DPT_LIST PolyList;

	BOOL m_bDSCont = m_bDeformedShapeContour;

	T_NODE_D NodeD;
	C3DPoint Point1,Point2;
	pDoc->m_pAttrCtrl->GetNode(NlnkD.Node1,NodeD);
	Point1.Set(NodeD.x,NodeD.y,NodeD.z);
	pDoc->m_pAttrCtrl->GetNode(NlnkD.Node2,NodeD);
	Point2.Set(NodeD.x,NodeD.y,NodeD.z);

	if(m_bDeformedShapeContour) 
	{
		Point1 = gm->m_pDeformEngine->GetDisplacedPoint(NlnkD.Node1,Point1);
		Point2 = gm->m_pDeformEngine->GetDisplacedPoint(NlnkD.Node2,Point2);
	}

	PolyList.AddTail(Point1);
	PolyList.AddTail(Point2);

	CGPSBeamLabel BeamLabl;
	BeamLabl.SetDataByDispOptTX(pTX); 
	BeamLabl.SetDC(pDC); 

	int nSlope;
	BOOL      bInverse;
	CPoint    Node2D[2];
	C3DPoint  Node3D[2];

	POSITION nPos = PolyList.GetHeadPosition();
	Node3D[0] = PolyList.GetNext(nPos);
	Node3D[1] = PolyList.GetNext(nPos);
	Node2D[0] = gm->Get3DPtTo2DPt(&Node3D[0]);
	Node2D[1] = gm->Get3DPtTo2DPt(&Node3D[1]);

	bInverse = CUtilFuncs::GetSlope2Point(nSlope,Node2D[0].x,Node2D[0].y,Node2D[1].x,Node2D[1].y);

	if(Node2D[0].x < 0 || Node2D[0].y < 0 ||
		Node2D[1].x < 0 || Node2D[1].y < 0 )
		nSlope=0;

	BeamLabl.BeginLabel(&nSlope);

	UINT nAlign;
	CPoint   Ct2DPt;

	double    dValue[2];
	C3DPoint  IJPos[2];

	IJPos[0].x = Point1.x+(Point2.x-Point1.x)*0.1; 
	IJPos[0].y = Point1.y+(Point2.y-Point1.y)*0.1; 
	IJPos[0].z = Point1.z+(Point2.z-Point1.z)*0.1; 

	IJPos[1].x = Point1.x+(Point2.x-Point1.x)*0.9; 
	IJPos[1].y = Point1.y+(Point2.y-Point1.y)*0.9; 
	IJPos[1].z = Point1.z+(Point2.z-Point1.z)*0.9; 

	dValue[0] = this->CalcNForcValue(StekD,0);
	dValue[1] = this->CalcNForcValue(StekD,1);


	for(i=0; i<2; i++)
	{
		//if(fabs(dValue[i]) < 1.0E-13)continue; 

		nAlign = TA_CENTER|TA_BOTTOM;

		if(pTX->m_bOutputMinMaxValueOnly)
		{
			double dLimit = (m_dMaxValue-m_dMinValue) * pTX->m_dOutputMinMaxLimit / 100.0;

			switch(gm->m_DOPT.TX.m_nOutputMinMaxType)
			{
			case 0: // Min & Max
				if((m_dMaxValue-dValue[i]) <= dLimit)
					BeamLabl.TextMnMxOutput(gm,&IJPos[i],0,dValue[i],&nAlign);
				else if((dValue[i]-m_dMinValue) <= dLimit)
					BeamLabl.TextMnMxOutput(gm,&IJPos[i],1,dValue[i],&nAlign);
				break;
			case 1: // Abs Max
				if(fabs(m_dMaxValue) >= fabs(m_dMinValue))
				{
					if( fabs(m_dMaxValue)-fabs(dValue[i]) <= dLimit)
						BeamLabl.TextMnMxOutput(gm,&IJPos[i],2,dValue[i],&nAlign);
				}
				else
				{
					if( fabs(m_dMinValue)-fabs(dValue[i]) <= dLimit)
						BeamLabl.TextMnMxOutput(gm,&IJPos[i],2,dValue[i],&nAlign);
				}
				break;
			case 2: // Max
				if((m_dMaxValue-dValue[i]) <= dLimit)
					BeamLabl.TextMnMxOutput(gm,&IJPos[i],0,dValue[i],&nAlign);
				break;
			case 3: // Min
				if((dValue[i]-m_dMinValue) <= dLimit)
					BeamLabl.TextMnMxOutput(gm,&IJPos[i],1,dValue[i],&nAlign);
				break;
			}
		}
		else
		{
			Ct2DPt = gm->Get3DPtTo2DPt(&IJPos[i]);
			if(Ct2DPt.x < 0 ||  Ct2DPt.y < 0 )continue; 
			BeamLabl.TextOutputD(Ct2DPt.x,Ct2DPt.y,dValue[i],&nAlign); 
		}
	}
	BeamLabl.EndLabel();
}

BOOL CForceEngine::IsBForcWithTForc()
{
	return ( m_BForcComponent == BFORC_COMPONENT_FX && 
		m_bBForcWithTForc );
}

void CForceEngine::ConvertStrt2StrbForceOnly(T_STRT_D &StrtD,T_STRB_D &StrbD)
{
	StrbD.Initialize(); 
	for(int i=0; i<4; i++)
	{
		StrbD.dblForce[i][0] = StrtD.dblForce[0] + (StrtD.dblForce[1] - StrtD.dblForce[0])*((double)(i/4.0)) ;
		StrbD.dblForce[i][6] = StrtD.dblForce[0] + (StrtD.dblForce[1] - StrtD.dblForce[0])*((double)((i+1.)/4.0)) ;
	}
}

// 멤버 내의 Element키를 가지고 T_STRB_D를 만들어 대표요소 키로 삽입한다.
// 저장되는 구조체 : m_mapBForcDataByMember.dblForce
// [0-0]:I, [1]:Min, [2]:Max, [3-1]:J, [0-1]:Mid값
BOOL CForceEngine::MakeBForcDataListByMember()
{
	DECLARE_GPSMD();

	T_ELEM_K elem_key;
	T_MEMB_K MembK; T_MEMB_D MembD;
	CMembCtrl* pMembCtrl = CMembCtrl::GetMembCtrl();

	T_BFORC_ELEM_POS_D ElemPos[3]; // [0]:Min, [1]:Max, [2]:Mid
	m_mapBForcDataByMember.RemoveAll();
	for(int i=0; i<gm->m_EKeyListActive.GetSize(); i++)
	{
		elem_key = gm->m_EKeyListActive[i];
		if(!m_pDoc->m_pAttrCtrl->GetMembAssigned(elem_key, MembK)) 
		{
			// Member가 아닌 Element는 그 자리에 삽입
			T_STRB_D bforc_d;
			if(GetBeamForce(gm->m_EKeyListActive[i], bforc_d)) m_mapBForcDataByMember.SetAt(elem_key, bforc_d);
			continue;
		}

		// 대표 요소일 때만 동작
		m_pDoc->m_pAttrCtrl->GetMemb(MembK, MembD);
		if(MembD.aElemList[0] == elem_key)     
		{
			// 실제 좌표상의 순서대로 정렬된 요소 키
			CArray<T_ELEM_K,T_ELEM_K> aElemK_sequencial;
			if(!pMembCtrl->GetSortedElemKListInRealSequence(MembK,aElemK_sequencial)) { ASSERT(0); }
			MembD.aElemList.Copy(aElemK_sequencial);

			// 멤버 내의 모든 요소를 돌며 I,J,Max,Min,Mid값을 채워준다.
			double dBForcValue[5];
			dBForcValue[BFORC_MEMB_PART_MAX] = -DBL_MAX; 
			dBForcValue[BFORC_MEMB_PART_MIN] = DBL_MAX; 
			dBForcValue[BFORC_MEMB_PART_MID] = 0.;
			int nIndexMin, nIndexMax, nIndexMid;
			double dMin, dMax, dMid;

			T_STRB_D bforc_d, bforc_d_temp;
			bforc_d.Initialize();
			for(int j=0; j<MembD.aElemList.GetSize(); j++)
			{
				if(!GetBeamForce(MembD.aElemList[j], bforc_d_temp)) continue;
				dMin = GetMinElemBForc(bforc_d_temp, &nIndexMin);
				dMax = GetMaxElemBForc(bforc_d_temp, &nIndexMax);
				if(j==0)                                dMid = GetMidElemBForc(bforc_d_temp, FALSE, TRUE , &nIndexMid);
				else if(j==MembD.aElemList.GetSize()-1) dMid = GetMidElemBForc(bforc_d_temp, TRUE , FALSE, &nIndexMid);
				else                                    dMid = GetMidElemBForc(bforc_d_temp, TRUE , TRUE , &nIndexMid);

				if(0 == j) 
				{
					dBForcValue[BFORC_MEMB_PART_INODE] = bforc_d_temp.dblForce[0][m_BForcComponent];
				}
				if(dMin < dBForcValue[BFORC_MEMB_PART_MIN])
				{
					dBForcValue[BFORC_MEMB_PART_MIN] = dMin;
					GetElemIndexPos(MembD.aElemList[j], nIndexMin, ElemPos[0]);
				}
				if(dMax > dBForcValue[BFORC_MEMB_PART_MAX])
				{
					dBForcValue[BFORC_MEMB_PART_MAX] = dMax;
					GetElemIndexPos(MembD.aElemList[j], nIndexMax, ElemPos[1]);
				}
				if(MembD.aElemList.GetSize()-1 == j)
				{
					dBForcValue[BFORC_MEMB_PART_JNODE] = bforc_d_temp.dblForce[3][6+m_BForcComponent];
				}
				if(fabs(dBForcValue[BFORC_MEMB_PART_MID]) < fabs(dMid))
				{
					dBForcValue[BFORC_MEMB_PART_MID] = dMid;
					GetElemIndexPos(MembD.aElemList[j], nIndexMid, ElemPos[2]);
				}
			}

			bforc_d.dblForce[BFORC_MEMB_PART_INODE][m_BForcComponent]   = dBForcValue[BFORC_MEMB_PART_INODE];
			if(m_bBForcOutputC)
			{
				bforc_d.dblForce[BFORC_MEMB_PART_INODE][m_BForcComponent+6] = dBForcValue[BFORC_MEMB_PART_MID]; // 멤버별 출력시 Mid는 [0][J]에 저장하여 사용
			}
			else
			{
				bforc_d.dblForce[BFORC_MEMB_PART_INODE][m_BForcComponent+6] = dBForcValue[BFORC_MEMB_PART_INODE];
			}
			bforc_d.dblForce[BFORC_MEMB_PART_MIN  ][m_BForcComponent]   = dBForcValue[BFORC_MEMB_PART_MIN  ];
			bforc_d.dblForce[BFORC_MEMB_PART_MAX  ][m_BForcComponent]   = dBForcValue[BFORC_MEMB_PART_MAX  ];
			bforc_d.dblForce[BFORC_MEMB_PART_MIN  ][m_BForcComponent+6] = dBForcValue[BFORC_MEMB_PART_MIN  ];
			bforc_d.dblForce[BFORC_MEMB_PART_MAX  ][m_BForcComponent+6] = dBForcValue[BFORC_MEMB_PART_MAX  ];
			bforc_d.dblForce[BFORC_MEMB_PART_JNODE][m_BForcComponent]   = dBForcValue[BFORC_MEMB_PART_JNODE];
			bforc_d.dblForce[BFORC_MEMB_PART_JNODE][m_BForcComponent+6] = dBForcValue[BFORC_MEMB_PART_JNODE];

			m_mapBForcDataByMember  .SetAt(elem_key, bforc_d);
			m_mapBForcMinPosByMember.SetAt(elem_key, ElemPos[0]);
			m_mapBForcMaxPosByMember.SetAt(elem_key, ElemPos[1]);
			m_mapBForcMidPosByMember.SetAt(elem_key, ElemPos[2]);
		}
		else
		{
			continue;
		}
	}

	return TRUE;
}

// 요소 키, 요소 Polygon의 Index(0-4)를 받아 해당 점의 위치정보를 ElemPos에 기록
void CForceEngine::GetElemIndexPos(T_ELEM_K ElemK, int nIndex, T_BFORC_ELEM_POS_D &ElemPos)
{
	if(nIndex<0 || nIndex>4) { ASSERT(0); return; } 
	DECLARE_GPSMD();
	POSITION		pos;
	CArray<GPS_3DPT_LISTP, GPS_3DPT_LISTP>	polygon_list;
	CArray<GPS_BOOL_ARRYP, GPS_BOOL_ARRYP>  edge_list;
	C3DPoint		node3D_i, node3D_j,DrawPoint;

	if(m_bDeformedShapeContour) 
	{
		gm->m_pDeformEngine->GetDeformedShapeElement(ElemK, &polygon_list, &edge_list);
	}
	else 
	{
		gm->GetShapeElement(ElemK, polygon_list, &edge_list);
	}

	pos = polygon_list[0]->GetHeadPosition();
	node3D_i = polygon_list[0]->GetNext(pos);
	node3D_j = polygon_list[0]->GetNext(pos);

	int nSlope5Div[5];
	BOOL nInverse5Div[5];
	BOOL bCanDraw[5];
	CPoint DrawPt[5];
	CUtilFuncs::MakeBeamSlopeAt5Div(gm,node3D_i,node3D_j,nSlope5Div,nInverse5Div,bCanDraw,DrawPt);

	ElemPos.Initialize();
	ElemPos.nPosIndex    = nIndex;
	ElemPos.nSlope5Div   = nSlope5Div[nIndex];
	ElemPos.nInverse5Div = nInverse5Div[nIndex];
	ElemPos.bCanDraw     = bCanDraw[nIndex];
	ElemPos.DrawPt       = DrawPt[nIndex];
}

// 요소별로 저장된 arSfdBmdOutPut를 받아와서 멤버별 데이터로 갈아엎는다
// [0-0]:I, [1]:Min, [2]:Max, [3-1]:J, [0-1]:Mid값
BOOL CForceEngine::MakeSfdBmdDataListByMember(CArray<T_SFDBMD_OUTVAL_D,T_SFDBMD_OUTVAL_D &>& arSfdBmdOutPut, BOOL bMin)
{
	DECLARE_GPSMD();

	T_ELEM_K elem_key;
	T_MEMB_K MembK; T_MEMB_D MembD;
	CMembCtrl* pMembCtrl = CMembCtrl::GetMembCtrl();

	// Temp에 복사 후 필요한 데이터만 뽑아서 저장
	CArray<T_SFDBMD_OUTVAL_D,T_SFDBMD_OUTVAL_D &> aTempSrc; aTempSrc.RemoveAll();
	for(int i=0; i<arSfdBmdOutPut.GetSize(); i++) aTempSrc.Add(arSfdBmdOutPut[i]);

	C3DPoint PosMinMaxMid[3]; // [0]:Min, [1]:Max, [2]:Mid
	arSfdBmdOutPut.RemoveAll();
	for(int i=0; i<aTempSrc.GetSize(); i++)
	{
		elem_key = aTempSrc[i].EKey;
		if(!m_pDoc->m_pAttrCtrl->GetMembAssigned(elem_key, MembK)) 
		{
			// Member가 아닌 Element는 그 자리에 삽입
			arSfdBmdOutPut.Add(aTempSrc[i]);
			continue;
		}

		// 대표 요소일 때만 동작
		m_pDoc->m_pAttrCtrl->GetMemb(MembK, MembD);
		if(MembD.aElemList.GetSize() > 0 && MembD.aElemList[0] == elem_key)     
		{
			// 실제 좌표상의 순서대로 정렬된 요소 키
			CArray<T_ELEM_K,T_ELEM_K> aElemK_sequencial;
			if(!pMembCtrl->GetSortedElemKListInRealSequence(MembK,aElemK_sequencial)) { ASSERT(0); }
			MembD.aElemList.Copy(aElemK_sequencial);

			// 멤버 내의 모든 요소를 돌며 I,J,Max,Min,Mid값을 채워준다.
			double dBForcValue[5];
			dBForcValue[BFORC_MEMB_PART_MAX] = -DBL_MAX; 
			dBForcValue[BFORC_MEMB_PART_MIN] = DBL_MAX; 
			dBForcValue[BFORC_MEMB_PART_MID] = 0.;
			int nIndexMid;
			double dMin, dMax, dMid;
			T_STRB_D bforc_d, bforc_d_temp;
			bforc_d.Initialize();
			for(int j=0; j<MembD.aElemList.GetSize(); j++)
			{
				if(bMin)
				{
					if(!GetBeamForceMin(MembD.aElemList[j], bforc_d_temp)) continue;
				}
				else
				{
					if(!GetBeamForce(MembD.aElemList[j], bforc_d_temp)) continue;
				}

				if(IsPossibleExactSfdBmdMode())
				{
					double dMnMxVal[2];
					T_MIRE_K mkey;
					T_ELEM_K ElemK = MembD.aElemList[j];
					mkey.keymap = MembD.aElemList[j];

					//BeamDiagram에서 Member에 대한 Exact값을 계산
					if(!gm->m_pBeamDiagram)gm->m_pBeamDiagram = new CBeamDiagram;
					int nDiv = 0.7*(m_pDoc->calcLAVElem(mkey.key.elem_k)/m_dUnitLength); 
					if(nDiv<=4) nDiv = 4;if(nDiv>4 && nDiv<=8) nDiv = 8;// 4등분의 배수로 만들자.
					if(nDiv>280) nDiv = 280; if(!m_bVerticalLineFill) nDiv = 12;
					if (!gm->m_pBeamDiagram->MakeBeamSFBM(mkey.key.elem_k, gm->m_LoadCombi, nDiv))
					{
						ASSERT(0);
					}
					gm->SelectLoad();

					//위에 Exact계산한 값가지고 MinMax 구함
					GetBsfdBmdExactMinMaxVal(ElemK, dMnMxVal);

					dMin = dMnMxVal[0];
					dMax = dMnMxVal[1];
				}
				else
				{
					dMin = GetMinElemBForc(bforc_d_temp);
					dMax = GetMaxElemBForc(bforc_d_temp);
				}
				if(j==0)                                dMid = GetMidElemBForc(bforc_d_temp, FALSE, TRUE , &nIndexMid);
				else if(j==MembD.aElemList.GetSize()-1) dMid = GetMidElemBForc(bforc_d_temp, TRUE , FALSE, &nIndexMid);
				else                                    dMid = GetMidElemBForc(bforc_d_temp, TRUE , TRUE , &nIndexMid);

				if(0 == j) 
				{
					dBForcValue[BFORC_MEMB_PART_INODE] = bforc_d_temp.dblForce[0][m_BForcComponent];
				}
				int nIndexTempSrc = LookForIndexOfSfdBmdByElemK(MembD.aElemList[j] , aTempSrc);
				if(nIndexTempSrc == -1 || aTempSrc.GetSize()-1 < nIndexTempSrc) continue;

				if(dMin < dBForcValue[BFORC_MEMB_PART_MIN])
				{
					dBForcValue[BFORC_MEMB_PART_MIN] = dMin;
					PosMinMaxMid[0] = aTempSrc[nIndexTempSrc].Pos[0];
				}
				if(dMax > dBForcValue[BFORC_MEMB_PART_MAX])
				{
					dBForcValue[BFORC_MEMB_PART_MAX] = dMax;
					PosMinMaxMid[1] = aTempSrc[nIndexTempSrc].Pos[1];
				}
				if(MembD.aElemList.GetSize()-1 == j) 
				{
					dBForcValue[BFORC_MEMB_PART_JNODE] = bforc_d_temp.dblForce[3][6+m_BForcComponent];
				}
				if(fabs(dBForcValue[BFORC_MEMB_PART_MID]) < fabs(dMid))
				{
					// Mid값도 해당 위치에 출력
					dBForcValue[BFORC_MEMB_PART_MID] = dMid;
					switch(nIndexMid)
					{
					case 0:
						PosMinMaxMid[2] = aTempSrc[nIndexTempSrc].Pos[0]; break;
					case 1:
					case 2:
					case 3:
						PosMinMaxMid[2] = aTempSrc[nIndexTempSrc].Pos[1]; break;
					case 4:
						PosMinMaxMid[2] = aTempSrc[nIndexTempSrc].Pos[2]; break;
					default: 
						ASSERT(0); break;
					}
				}
			}

			// 값
			bforc_d.dblForce[BFORC_MEMB_PART_INODE][m_BForcComponent]   = dBForcValue[BFORC_MEMB_PART_INODE];
			if(m_bBForcOutputC)
			{
				bforc_d.dblForce[0][6+m_BForcComponent] = dBForcValue[BFORC_MEMB_PART_MID]; // 멤버별 출력시 Mid는 [0][J]에 저장하여 사용
			}
			else
			{
				bforc_d.dblForce[0][6+m_BForcComponent] = dBForcValue[BFORC_MEMB_PART_INODE]; 
			}
			bforc_d.dblForce[BFORC_MEMB_PART_MIN  ][m_BForcComponent]     = dBForcValue[BFORC_MEMB_PART_MIN  ];
			bforc_d.dblForce[BFORC_MEMB_PART_MIN  ][6+m_BForcComponent]   = dBForcValue[BFORC_MEMB_PART_MIN  ];
			bforc_d.dblForce[BFORC_MEMB_PART_MAX  ][m_BForcComponent]     = dBForcValue[BFORC_MEMB_PART_MAX  ];
			bforc_d.dblForce[BFORC_MEMB_PART_MAX  ][6+m_BForcComponent]   = dBForcValue[BFORC_MEMB_PART_MAX  ];
			bforc_d.dblForce[BFORC_MEMB_PART_JNODE][m_BForcComponent]     = dBForcValue[BFORC_MEMB_PART_JNODE];
			bforc_d.dblForce[BFORC_MEMB_PART_JNODE][6+m_BForcComponent]   = dBForcValue[BFORC_MEMB_PART_JNODE];

			aTempSrc[i].dMinMaxVal[0] = dBForcValue[BFORC_MEMB_PART_MIN];
			aTempSrc[i].dMinMaxVal[1] = dBForcValue[BFORC_MEMB_PART_MAX];

			// 출력 위치
			if(m_bBForcOutputMinMax || m_bBForcOutputMax)
			{
				// Min/Max 위치는 두개의 점으로 구성되어 있어서 따로 처리
				aTempSrc[i].Pos[0] = PosMinMaxMid[0];
				aTempSrc[i].Pos[1] = PosMinMaxMid[1];
			}
			else
			{
				BOOL bIsEven;
				T_ELEM_K ElemK_Mid  = CMembCtrl::GetMembCtrl()->GetMidElemKeyOfMemb(MembK, bIsEven);
				int nIndexMidElemOfMemb  = LookForIndexOfSfdBmdByElemK(ElemK_Mid , aTempSrc);
				if(m_bBForcOutputC)
				{
					// Mid값은 해당 위치에 출력
					aTempSrc[i].Pos[1] = PosMinMaxMid[2];
				}
				else
				{
					if(nIndexMidElemOfMemb==-1 || aTempSrc.GetSize()-1 < nIndexMidElemOfMemb) continue;
					if(bIsEven) aTempSrc[i].Pos[1] = aTempSrc[nIndexMidElemOfMemb].Pos[2]; // Center 위치는 가운데 요소의 J단이거나 Center(요소수에 따라 결정)
					else        aTempSrc[i].Pos[1] = aTempSrc[nIndexMidElemOfMemb].Pos[1]; 
				}
				T_ELEM_K ElemK_Last = MembD.aElemList[MembD.aElemList.GetSize()-1];
				int nIndexLastElemOfMemb = LookForIndexOfSfdBmdByElemK(ElemK_Last, aTempSrc);
				if(nIndexLastElemOfMemb==-1 || aTempSrc.GetSize()-1 < nIndexLastElemOfMemb) continue;
				aTempSrc[i].Pos[2] = aTempSrc[nIndexLastElemOfMemb].Pos[2]; // j단의 위치는 마지막 요소의 j단
			}

			aTempSrc[i].StrbD = bforc_d;
			arSfdBmdOutPut.Add(aTempSrc[i]);
		}
		else
		{
			continue;
		}
	}

	return TRUE;
}

// SfdBmd배열에서 해당 요소가 있는 Index 반환
int  CForceEngine::LookForIndexOfSfdBmdByElemK(T_ELEM_K ElemK, CArray<T_SFDBMD_OUTVAL_D,T_SFDBMD_OUTVAL_D &>& arSfdBmdOutPut)
{
	for(int i=0; i<arSfdBmdOutPut.GetSize(); i++)
	{
		if(arSfdBmdOutPut[i].EKey == ElemK) return i;
	}

	ASSERT(0);
	return -1;
}

// Strip Force 데이터를 만든다.
// 현재 Active Element List에 대해 Loop를 돌며
// 1. DB로 부터 해당 Element의 Beam Force 데이터를 얻고
// 2. Beam Force에 대한 최대/최소값을 갱신하고
// 3. Beam Force값 및 해당 Element번호를 CArray에 저장
BOOL CForceEngine::MakeStripForcDataList()
{
	DECLARE_GPSMD();

	double	max_bforc=-DBL_MAX, min_bforc=DBL_MAX;

	if(!gm->m_bLoadDataSet)return FALSE;
	int nGPSMode = (gm->m_GPSInstruction != -1)? gm->m_GPSInstruction:gm->m_GPSMode;

	gm->m_pMyView->BeginWaitCursor();

	CArray<T_MSTR_K,T_MSTR_K> aMstrK_DgnUse,aMstrK_Active,aMstrK;
	m_pDoc->m_pPostCtrl->GetDesignResult()->GetDesignedMstrKList(aMstrK_DgnUse);
	m_pDoc->m_pViewCtrl->GetAllActiveMstr(aMstrK_Active);
	CArrayUtil::IntersectUINT(aMstrK_DgnUse, aMstrK_Active, aMstrK);

	CArray<T_FORCSTRIP_D,T_FORCSTRIP_D> aForce, aForceMax, aForceMin;
	if(gm->m_LoadCaseKey==0) // All combination인 경우
	{
		gm->m_LoadMinMaxType=LOADTYPE_ALL;
		m_pDoc->m_pAttrCtrl2->GetStripForceAllComb(gm->m_LoadCaseType, aMstrK, aForce, aForceMax, aForceMin);
	}
	else
	{
		m_pDoc->m_pAttrCtrl2->GetStripForce(gm->m_LoadCaseType, gm->m_LoadCaseKey, 0, aMstrK, aForce);
	}

	for(int i=0; i<aForce.GetSize(); i++)
	{
		for(int j=0; j<5; j++)
		{
			double dStripForce = aForce[i].dLineForce[j][4];
			if(dStripForce < min_bforc) min_bforc = dStripForce;
			if(dStripForce > max_bforc) max_bforc = dStripForce;
		}
	}
	if(aForce.GetSize()<1) min_bforc = max_bforc = 0.0;

	if(fabs(max_bforc)<fabs(min_bforc))InitBSfdBmdAdjustFactor(min_bforc);
	else		                           InitBSfdBmdAdjustFactor(max_bforc);

	if (m_pContourEngine == NULL)m_pContourEngine = new CContourEngine(min_bforc, max_bforc);
	else		                     m_pContourEngine->MakeRankMap(min_bforc, max_bforc);

	gm->m_pMyView->EndWaitCursor();

	m_bBForcDataSet = TRUE;
	return TRUE;
}

// Strip 결과의 Bending moment diagram 그리는 함수
void CForceEngine::DrawStripBendingMementDiagram(CDC *pDC)
{
	m_bStripOutput = TRUE;
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	T_MIRE_K mkey;

	int			i, elem_num;
	BOOL		fl_bak=gm->m_DOPT.DR.m_bFrameLine;
	T_ELEM_D	elem_d;
	CArray <int, int>				type_list;
	CArray <GRE_Atom, GRE_Atom&>		atom_list;
	BOOL bEscapePressed = FALSE;
	m_mapSFDBMDMax.RemoveAll();

	CDC	*pdc=gm->m_pMyView->GetDC();
	m_dUnitLength = fabs(gm->m_pGPSCtrl->GetWorldLength(((double) pdc->GetDeviceCaps(LOGPIXELSX))/5.0));

	gm->m_pMyView->ReleaseDC(pdc);

	m_arStripOutPut.RemoveAll();
	m_arStripOutPutM.RemoveAll();  

	// strip 이외의 그림은 Hidden을 끄고 그린다.
	gm->m_DOPT.DR.m_bFrameLine = TRUE;

	type_list.Add(gm->m_MinOTID + OBJECT_TYPE_ORIGINAL);

	gm->m_pGPSCtrl->GetZSortedList(type_list, gm->m_EKeyListVisible_Mirror, atom_list);
	elem_num = atom_list.GetSize();
	for (i=0;i<elem_num;i++) 
	{
		if(gm->m_pGPSCtrl->WatchEscKeyPress()) { m_bStripOutput = FALSE; return; }

		if(gm->m_pGPSCtrl->IsZoomAllState() || gm->m_pGPSCtrl->IsObjectInClientWindow(atom_list[i].m_OType, atom_list[i].m_OKey)) 
		{
			mkey.keymap = atom_list[i].m_OKey;
			if(!m_pDoc->m_pAttrCtrl->GetElem(mkey.key.elem_k, elem_d))continue;
			BOOL bTruss = m_pDoc->m_pAttrCtrl->IsTruss(elem_d.eltyp) && this->IsBForcWithTForc();
			BOOL bBeam  = m_pDoc->m_pAttrCtrl->IsBeam(elem_d.eltyp) ;
			if(IsBForcWithTForc() && m_bBForcOnlyTForc)bBeam = FALSE; //Truss Only인경우 Beam은 출력하지 않음 
			if(gm->m_pGPSCtrl->IsActiveElem(atom_list[i].m_OKey) && !bEscapePressed)
			{
				if(bBeam || bTruss) gm->GPSDrawElement(pDC, atom_list[i].m_OKey);
				else						    gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
			}
			else
			{
				gm->GPSDrawInactiveElement(pDC, atom_list[i].m_OKey);
			}
		}
	}

	// Draw strip contour
	CArray<T_MSTR_K,T_MSTR_K> aMstrK_DgnUse,aMstrK_Active,aMstrK;
	m_pDoc->m_pPostCtrl->GetDesignResult()->GetDesignedMstrKList(aMstrK_DgnUse);
	m_pDoc->m_pViewCtrl->GetAllActiveMstr(aMstrK_Active);
	CArrayUtil::IntersectUINT(aMstrK_DgnUse, aMstrK_Active, aMstrK);

	CArray<T_FORCSTRIP_D,T_FORCSTRIP_D> aForce, aForceMax, aForceMin;
	if(gm->m_LoadCaseKey==0) // All combination인 경우
	{
		m_pDoc->m_pAttrCtrl2->GetStripForceAllComb(gm->m_LoadCaseType, aMstrK, aForce, aForceMax, aForceMin);
	}
	else
	{
		m_pDoc->m_pAttrCtrl2->GetStripForce(gm->m_LoadCaseType, gm->m_LoadCaseKey, 0, aMstrK, aForce);
	}

	for(i=0; i<aMstrK.GetSize(); i++)
	{
		if(IsMinMaxDiagram()) DoStripBendingMomentDiagram(pDC, aMstrK[i], aForceMax[i], aForceMin[i]);
		else                  DoStripBendingMomentDiagram(pDC, aMstrK[i], aForce[i], aForce[i]);
	}

	// 그림 그린 후 value 출력 
	BOOL bGrpFltMode=gm->m_pGPSCtrl->IsGroupFilterMode();
	for(i=0; i<m_arStripOutPut.GetSize(); i++)
	{
		if(bGrpFltMode)
		{
			if(!gm->m_pDispFilter->IsExistEKey(m_arStripOutPut[i].MKey))
				continue;
		}
		OutputStripNumber(pDC, m_arStripOutPut[i].MKey, m_arStripOutPut[i].StrbD, m_arStripOutPut[i].Pos, m_arStripOutPut[i].nComp, m_arStripOutPut[i].dMinMaxVal);
	}

	for(i=0; i<m_arStripOutPutM.GetSize(); i++)
	{
		if(bGrpFltMode)
		{
			if(!gm->m_pDispFilter->IsExistEKey(m_arStripOutPutM[i].MKey))
				continue;
		}
		OutputStripNumber(pDC, m_arStripOutPutM[i].MKey, m_arStripOutPutM[i].StrbD, m_arStripOutPutM[i].Pos, m_arStripOutPutM[i].nComp, m_arStripOutPutM[i].dMinMaxVal);
	}
	m_arStripOutPut.RemoveAll();
	m_arStripOutPutM.RemoveAll(); 

	gm->m_DOPT.DR.m_bFrameLine = fl_bak;
	m_bStripOutput = FALSE;
}

void CForceEngine::DoStripBendingMomentDiagram(CDC *pDC, T_MSTR_K MstrK, T_FORCSTRIP_D stripForce, T_FORCSTRIP_D stripForceM)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	T_MSTR_D MstrD;
	T_MEMB_D MembD;
	if(!m_pDoc->m_pAttrCtrl2->GetMstr(MstrK,MstrD)) { ASSERT(0); return; }
	if(!m_pDoc->m_pAttrCtrl->GetMemb(MstrD.MembK,MembD)) { ASSERT(0); return; }
	T_ELEM_K Memb1stElemK = MembD.aElemList[0];

	int		    poly_num;
	double		local_vector[3][3];
	T_STRB_D	bforc_d, bforc_dm;
	double    dMnMxVal[2];

	POSITION	pos;
	C3DPoint	pnt[2], node_i, node_j, *txt_pnts, *txt_pntms;
	CArray<BOOL, BOOL>				ef_list;
	CArray<BOOL, BOOL>				rect_flag;
	CArray<double, double &>	val_list;
	CArray<C3DPoint,C3DPoint&>vtx_list;
	CArray<CList<C3DPoint,C3DPoint> *, CList <C3DPoint, C3DPoint> *>polygon_list;

	if((gm->m_pDeformEngine==NULL) || (m_pContourEngine==NULL))return;

	memset(bforc_d.dblForce ,0,sizeof(double)*72);
	memset(bforc_dm.dblForce,0,sizeof(double)*72);
	const int IDX_MYI=4, IDX_MYJ=10;
	bforc_d.dblForce[0][IDX_MYI] = stripForce.dLineForce[0][4];
	bforc_d.dblForce[0][IDX_MYJ] = stripForce.dLineForce[1][4];
	bforc_d.dblForce[1][IDX_MYI] = stripForce.dLineForce[1][4];
	bforc_d.dblForce[1][IDX_MYJ] = stripForce.dLineForce[2][4];
	bforc_d.dblForce[2][IDX_MYI] = stripForce.dLineForce[2][4];
	bforc_d.dblForce[2][IDX_MYJ] = stripForce.dLineForce[3][4];
	bforc_d.dblForce[3][IDX_MYI] = stripForce.dLineForce[3][4];
	bforc_d.dblForce[3][IDX_MYJ] = stripForce.dLineForce[4][4];
	if(IsMinMaxDiagram())
	{
		bforc_dm.dblForce[0][IDX_MYI] = stripForceM.dLineForce[0][4];
		bforc_dm.dblForce[0][IDX_MYJ] = stripForceM.dLineForce[1][4];
		bforc_dm.dblForce[1][IDX_MYI] = stripForceM.dLineForce[1][4];
		bforc_dm.dblForce[1][IDX_MYJ] = stripForceM.dLineForce[2][4];
		bforc_dm.dblForce[2][IDX_MYI] = stripForceM.dLineForce[2][4];
		bforc_dm.dblForce[2][IDX_MYJ] = stripForceM.dLineForce[3][4];
		bforc_dm.dblForce[3][IDX_MYI] = stripForceM.dLineForce[3][4];
		bforc_dm.dblForce[3][IDX_MYJ] = stripForceM.dLineForce[4][4];
	}

	m_pDoc->calcFrameLocalVector(Memb1stElemK, local_vector);
	double dPtI[3], dPtJ[3], dPtCorner[4][3];
	if(!m_pDoc->m_pAttrCtrl2->GetStripPoint(MstrK, dPtI, dPtJ, dPtCorner, TRUE)) { return; }
	node_i.x = dPtI[0]; node_i.y = dPtI[1]; node_i.z = dPtI[2];
	node_j.x = dPtJ[0]; node_j.y = dPtJ[1]; node_j.z = dPtJ[2];

	AddStripToPolyList(MstrK, polygon_list);

	poly_num = polygon_list.GetSize();
	if((poly_num!=1) || (polygon_list[0]->GetCount()!=2))return;

	if(gm->m_DOPT.TX.m_bOutputNumber) 
	{
		txt_pnts   = new C3DPoint[5];
		txt_pntms  = new C3DPoint[5];
	}
	else 
	{
		txt_pnts   = NULL;
		txt_pntms  = NULL;
	}

	pos = polygon_list[0]->GetHeadPosition();
	pnt[0] = polygon_list[0]->GetNext(pos);
	pnt[1] = polygon_list[0]->GetNext(pos);

	CArray<T_SFDBMD_OUTVAL_D,T_SFDBMD_OUTVAL_D&> arOutVal; 
	T_SFDBMD_OUTVAL_D OutVal;

	//GetOffsetedPoint(mkey.key.elem_k,pnt[0],pnt[1],node_i,node_j,m_BForcComponent);
	T_ELEM_K DummyElemK = 0;
	BOOL bTruss=FALSE;
	BSfdBmdMakePolygon(bforc_d, m_BForcComponent, local_vector,
		node_i, node_j, vtx_list, val_list, ef_list, rect_flag, txt_pnts, DummyElemK, dMnMxVal, bTruss);
	if(txt_pnts) AddStripOutputData(MstrK,txt_pnts,bforc_d,dMnMxVal,m_BForcComponent,0);

	if(IsMinMaxDiagram())
	{
		BSfdBmdMakePolygon(bforc_dm, m_BForcComponent, local_vector,
			node_i, node_j, vtx_list, val_list, ef_list, rect_flag, txt_pntms, DummyElemK, dMnMxVal,bTruss);
		if(txt_pntms)AddStripOutputData(MstrK,txt_pntms,bforc_dm,dMnMxVal,m_BForcComponent,1);
	}

	DoBSfdBmdContour(pDC, vtx_list, val_list, ef_list, rect_flag);

	vtx_list.RemoveAll();
	val_list.RemoveAll();
	ef_list.RemoveAll();
	rect_flag.RemoveAll();

	FreeMemoryPolyList(&polygon_list); 

	if(txt_pnts) delete []txt_pnts;
	if(txt_pntms)delete []txt_pntms;
}

void CForceEngine::OutputStripNumber(CDC *pDC, T_MSTR_K MstrK, T_STRB_D bforc_d, 
																		 C3DPoint *txt_pnt,int nComp,double *pMnMxVal)
{
	DECLARE_GPSMD();
	DECLARE_DPTTX();
	DECLARE_DPTDR();

	int			  j, slope;
	TCHAR			fmt_str[10], text_str[512];
	BOOL			fl_bak, is_inverse;
	C3DPoint	node3D_i, node3D_j,DrawPoint;
	CPoint		text_p,node_2d_i, node_2d_j;
	CFont			ft, *old_ft;

	POSITION	pos;
	CArray<GPS_3DPT_LISTP, GPS_3DPT_LISTP>  polygon_list;

	BOOL bIsMemberAssigend = FALSE;

	if(pTX->m_bNumberOpaque)pDC->SetBkMode(OPAQUE);
	else		                pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(pTX->m_NumberTextColorC);
	pDC->SetBkColor(pTX->m_NumberBackCol);
	pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);

	if(pTX->m_bNumberExponent)_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else		                  _stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);

	fl_bak = pDR->m_bFrameLine;
	gm->m_DOPT.DR.m_bFrameLine = TRUE;

	polygon_list.RemoveAll();
	AddStripToPolyList(MstrK, polygon_list);

	pos = polygon_list[0]->GetHeadPosition();
	node3D_i = polygon_list[0]->GetNext(pos);
	node3D_j = polygon_list[0]->GetNext(pos);

	//XGLRenderer
	BOOL bSaveTextOutput = FALSE;
	if(gm->m_pGPSCtrl->IsGLRenderer() && 
		((gm->m_pGPSCtrl->IsXGRMode() && !gm->m_pGPSCtrl->IsMakeEMFMode()) ||
		(I_GPSModel::g_bViewStatePrinting && pTX->m_bOutputNumber) ) )
	{
		bSaveTextOutput = TRUE;
	}

	if(gm->m_bVirtualMode) 
	{
		node_2d_i = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_i);
		node_2d_j = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_j);
	}
	else 
	{
		node_2d_i = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_i);
		node_2d_j = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_j);
	}

	//XGLRenderer 
	if(bSaveTextOutput == FALSE) //저장 모드에서는 현재 화면 상태와 관계된 Filtering처리를 하지 않는다. 
	{
		if(node_2d_i.x < 0 ||node_2d_i.y < 0 ) return;
		if(node_2d_j.x < 0 ||node_2d_j.y < 0 ) return;
	}

	slope = (int) (atan2(node_2d_i.y-node_2d_j.y, node_2d_j.x-node_2d_i.x)*1800.0/3.14159);
	slope = (slope+3600)%3600;
	if ((900<slope) && (slope<=2700)) 
	{
		slope = (slope+1800)%3600;
		is_inverse = TRUE;
	}
	else 
	{
		is_inverse = FALSE;
	}

	gm->SetNumberFontOrientation(slope);
	ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
	old_ft = (CFont *) pDC->SelectObject(&ft);

	if(bSaveTextOutput) 
	{
		double Pos6[6];
		Pos6[0] = node3D_i.x;Pos6[1] = node3D_i.y;Pos6[2] = node3D_i.z;
		Pos6[3] = node3D_j.x;Pos6[4] = node3D_j.y;Pos6[5] = node3D_j.z;

		gm->m_pXGR_GPSDrawMgr->m_OutputStripNumber.Add_OutputStripNumber(&(txt_pnt[0]),Pos6, 6, CalcBForcValue(bforc_d, nComp, 0, I_NODE)); // I       
		gm->m_pXGR_GPSDrawMgr->m_OutputStripNumber.Add_OutputStripNumber(&(txt_pnt[1]),Pos6, 8, CalcBForcValue(bforc_d, nComp, 0, J_NODE)); // 1/4
		gm->m_pXGR_GPSDrawMgr->m_OutputStripNumber.Add_OutputStripNumber(&(txt_pnt[2]),Pos6, 8, CalcBForcValue(bforc_d, nComp, 1, J_NODE)); // C
		gm->m_pXGR_GPSDrawMgr->m_OutputStripNumber.Add_OutputStripNumber(&(txt_pnt[3]),Pos6, 8, CalcBForcValue(bforc_d, nComp, 2, J_NODE)); // 3/4
		gm->m_pXGR_GPSDrawMgr->m_OutputStripNumber.Add_OutputStripNumber(&(txt_pnt[4]),Pos6, 7, CalcBForcValue(bforc_d, nComp, 3, J_NODE)); // J

		if(I_GPSModel::g_bViewStatePrinting && pTX->m_bOutputNumber)
		{
			gm->m_pXGR_GPSDrawMgr->m_OutputStripNumber.Draw(pDC);
		}
	}
	else 
	{
		if(m_bBForcOutputI) 
		{
			pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorI);
			if(is_inverse)pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
			else				  pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
			if (gm->m_bVirtualMode) text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[0]);
			else                    text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[0]);
			_stprintf(text_str, fmt_str, CalcBForcValue(bforc_d, nComp, 0, I_NODE));
			if(text_p.x >= 0 && text_p.y>=0)pDC->TextOut(text_p.x, text_p.y, text_str);
		}
		if (m_bBForcOutputJ) 
		{
			pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorJ);
			if(is_inverse)pDC->SetTextAlign(TA_LEFT|TA_BOTTOM);
			else				  pDC->SetTextAlign(TA_RIGHT|TA_BOTTOM);
			if (gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[4]);
			else                   text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[4]);
			_stprintf(text_str, fmt_str, CalcBForcValue(bforc_d, nComp, 3, J_NODE));
			if(text_p.x >= 0 && text_p.y>=0) pDC->TextOut(text_p.x, text_p.y, text_str);
		}
		if(m_bBForcOutputC) 
		{
			double dCenterValue;
			dCenterValue= CalcBForcValue(bforc_d, nComp, 1, J_NODE);
			pDC->SetTextColor(gm->m_DOPT.TX.m_NumberTextColorC);
			pDC->SetTextAlign(TA_CENTER|TA_BOTTOM);
			if(gm->m_bVirtualMode)text_p = gm->m_pGPSCtrl->GetWorldToWindowP2D(txt_pnt[2]);
			else 				          text_p = gm->m_pGPSCtrl->GetWorldToMemDCP2D(txt_pnt[2]);

			_stprintf(text_str, fmt_str, dCenterValue);
			if(text_p.x >= 0 && text_p.y>=0) pDC->TextOut(text_p.x, text_p.y, text_str);
		}
	}

	pDC->SelectObject(old_ft);
	ft.DeleteObject();

	for(j=0;j<polygon_list.GetSize();j++) 
	{
		polygon_list[j]->RemoveAll();
		delete polygon_list[j];
	}
	polygon_list.RemoveAll();

	gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}

void CForceEngine::AddStripOutputData(T_MSTR_K MstrK,C3DPoint *pTxtPt,T_STRB_D &StrbD,double *pMnMxVal,int nComp,int nType)
{
	T_STRIP_OUTVAL_D OutVal;
	if(GetStripOutputData(OutVal,MstrK,pTxtPt,StrbD,pMnMxVal,nComp,nType))
	{
		if(nType==0)m_arStripOutPut.Add(OutVal);
		else        m_arStripOutPutM.Add(OutVal);
	}
}

BOOL CForceEngine::GetStripOutputData(T_STRIP_OUTVAL_D &OutVal,T_MSTR_K MstrK,C3DPoint *pTxtPt,T_STRB_D &StrbD,double *pMnMxVal,int nComp,int nType)
{
	I_GPSModel  *gm=(I_GPSModel *)m_pGPSModel;
	if(!gm->m_DOPT.TX.m_bOutputNumber)return FALSE; 
	OutVal.Pos[0] = pTxtPt[0];
	OutVal.Pos[1] = pTxtPt[1];
	OutVal.Pos[2] = pTxtPt[2];
	OutVal.Pos[3] = pTxtPt[3];
	OutVal.Pos[4] = pTxtPt[4];
	OutVal.MKey   = MstrK;
	OutVal.StrbD  = StrbD;
	OutVal.nComp  = nComp;
	OutVal.dMinMaxVal[0] = pMnMxVal[0];
	OutVal.dMinMaxVal[1] = pMnMxVal[1];
	return TRUE; 
}

void CForceEngine::AddStripToPolyList(T_MSTR_K MstrK, CArray<CList<C3DPoint,C3DPoint> *, CList <C3DPoint, C3DPoint> *>& polygon_list)
{
	double dPtI[3], dPtJ[3], dPtCorner[4][3];
	if(!m_pDoc->m_pAttrCtrl2->GetStripPoint(MstrK, dPtI, dPtJ, dPtCorner, TRUE)) { ASSERT(0); return; }
	C3DPoint pt3d_I(dPtI[0],dPtI[1],dPtI[2]);
	C3DPoint pt3d_J(dPtJ[0],dPtJ[1],dPtJ[2]);
	CList<C3DPoint,C3DPoint>* ptList = new CList <C3DPoint, C3DPoint>;
	ptList->RemoveAll();
	ptList->AddTail(pt3d_I);
	ptList->AddTail(pt3d_J);
	polygon_list.Add(ptList);
}

BOOL CForceEngine::MakeResultantForceDataList()
{
	I_GPSModel  *gm=(I_GPSModel *) m_pGPSModel;
	if(!gm->m_bLoadDataSet)	return FALSE;

	memset(m_dAbsMaxResultantForce, 0, sizeof(double)*6);
	m_mapResultantForceData.RemoveAll();
	m_mapResultantForceDataMxMn.RemoveAll();

	gm->m_pMyView->BeginWaitCursor();

	CArray<T_VBEM_K,T_VBEM_K> aVbemK;
	T_VBEM_D VbemD;
	T_VSEC_D VsecD1, VsecD2;
	T_SIMB_D SimbD, SimbD2;
	T_RESULTANT_FORCE_D RforcD;

	m_pDoc->m_pViewCtrl->GetAllActiveVbem(aVbemK);
	for(int i=0; i<aVbemK.GetSize(); i++)
	{
		if(!m_pDoc->m_pAttrCtrl2->GetVbem(aVbemK[i], VbemD)) { ASSERT(0); continue; }    
		if(!m_pDoc->m_pAttrCtrl2->GetVsec(VbemD.Vsec1, VsecD1)) { ASSERT(0); continue; }
		if(!m_pDoc->m_pAttrCtrl2->GetVsec(VbemD.Vsec2, VsecD2)) { ASSERT(0); continue; }

		SimbD.Initialize();
		SimbD2.Initialize();
		switch (gm->m_LoadMinMaxType) 
		{
		case LOADTYPE_NORMAL:
		case LOADTYPE_MAX:
			if(!m_pDoc->m_pPostCtrl ->GetSimbNew(aVbemK[i], &SimbD, NULL, NULL, TRUE)) { ASSERT(0); /*continue;*/ }
			break;
		case LOADTYPE_MIN:
			if(!m_pDoc->m_pPostCtrl ->GetSimbNew(aVbemK[i], NULL, &SimbD, NULL, TRUE)) { ASSERT(0); /*continue;*/ }
			break;
		case LOADTYPE_ALL:
			if(!m_pDoc->m_pPostCtrl ->GetSimbNew(aVbemK[i], &SimbD, &SimbD2, NULL, TRUE)) { ASSERT(0); /*continue;*/ }
			break;
		}

		RforcD.Initialize();
		RforcD.PosI.Set(VsecD1.dCentX, VsecD1.dCentY, GetTopZPointFromElemKList(VsecD1.arKeyElem));
		RforcD.PosJ.Set(VsecD2.dCentX, VsecD2.dCentY, GetTopZPointFromElemKList(VsecD2.arKeyElem));
		RforcD.SimbD = SimbD;
		RforcD.dVsecCentZ1 = VsecD1.dCentZ;
		RforcD.dVsecCentZ2 = VsecD2.dCentZ;
		m_mapResultantForceData.SetAt(aVbemK[i], RforcD);

		// All loadtype일 때는 max와 min 결과를 둘 다 출력
		if(gm->m_LoadMinMaxType == LOADTYPE_ALL)
		{
			RforcD.Initialize();
			RforcD.PosI.Set(VsecD1.dCentX, VsecD1.dCentY, GetTopZPointFromElemKList(VsecD1.arKeyElem));
			RforcD.PosJ.Set(VsecD2.dCentX, VsecD2.dCentY, GetTopZPointFromElemKList(VsecD2.arKeyElem));
			RforcD.SimbD = SimbD2;
			RforcD.dVsecCentZ1 = VsecD1.dCentZ;
			RforcD.dVsecCentZ2 = VsecD2.dCentZ;
			m_mapResultantForceDataMxMn.SetAt(aVbemK[i], RforcD);
		}

		for(int j=0; j<6; j++)
		{
			if(m_dAbsMaxResultantForce[j] < fabs(SimbD.dblForce[j]))   m_dAbsMaxResultantForce[j] = fabs(SimbD.dblForce[j]);
			if(m_dAbsMaxResultantForce[j] < fabs(SimbD.dblForce[j+6])) m_dAbsMaxResultantForce[j] = fabs(SimbD.dblForce[j+6]);

			if(m_dAbsMaxResultantForce[j] < fabs(SimbD2.dblForce[j]))    m_dAbsMaxResultantForce[j] = fabs(SimbD2.dblForce[j]);
			if(m_dAbsMaxResultantForce[j] < fabs(SimbD2.dblForce[j+6]))  m_dAbsMaxResultantForce[j] = fabs(SimbD2.dblForce[j+6]);
		}
	}

	gm->m_pMyView->EndWaitCursor();
	m_bResultantForcDataSet = TRUE;

	return TRUE; 
}

void	CForceEngine::DrawResultantForceContour(CDC *pDC)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	gm->GPSDrawOriginal(pDC);
	gm->m_pGPSCtrl->XGL_Begin_CuttingPLDiagram();

	CPen pen1, pen2, *old_pen;
	pen1.CreatePen(PS_SOLID, gm->m_nLineWidth*1.0, gm->m_CuttinLineColor);
	pen2.CreatePen(PS_SOLID, gm->m_nLineWidth*2.0, gm->m_CuttinLineColor);
	old_pen = (CPen *) pDC->SelectObject(&pen1);

	CArray<T_VBEM_K,T_VBEM_K> aVbemK;
	m_pDoc->m_pViewCtrl->GetAllActiveVbem(aVbemK);

	T_VBEM_K VbemK;
	T_RESULTANT_FORCE_D RforcD;

	for(int i=0; i<aVbemK.GetSize(); i++)
	{
		VbemK = aVbemK[i];
		if(m_mapResultantForceData.Lookup(VbemK, RforcD))
		{
			DrawResultantForceContour_Vbem(RforcD, pDC, pen1, pen2);
		}

		// All loadtype일 때는 max와 min 결과를 둘 다 출력
		if(m_mapResultantForceDataMxMn.Lookup(VbemK, RforcD) && gm->m_LoadMinMaxType == LOADTYPE_ALL)
		{
			DrawResultantForceContour_Vbem(RforcD, pDC, pen1, pen2);
		}
	}

	pDC->SelectObject(old_pen);
	pen1.DeleteObject();
	pen2.DeleteObject();

	gm->m_pGPSCtrl->XGL_End_CuttingPLDiagram();
}

void CForceEngine::DrawResultantForceContour_Vbem(const T_RESULTANT_FORCE_D& RforcD, CDC *pDC, CPen& pen1, CPen& pen2)
{
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;

	// ps,pe : Vsec1, Vsec2의 중점
	// pss, pee : ps,pe보다 z축으로 Resultant Force * factor만큼 떨어진 점
	C3DPoint ps, pss, pe, pee;
	double dVal1, dVal2;
	double dCutLineAdjustFactor; // 최대값을 구해서 높이 보정을 하기 위한 변수

	dVal1 = RforcD.SimbD.dblForce[m_ResultantForceComponent]  ;
	dVal2 = RforcD.SimbD.dblForce[m_ResultantForceComponent+6];

	InitCutLineAdjustFactor(m_dAbsMaxResultantForce[m_ResultantForceComponent],dCutLineAdjustFactor);
	if(gm->m_pBDT->PFUD.bRvrs) dCutLineAdjustFactor *= -1;
	dCutLineAdjustFactor *= gm->m_pBDT->PFUD.dScFc;

	ps = RforcD.PosI;
	pe = RforcD.PosJ;

	if(!m_bRFrcdTopAlignment)
	{
		ps.z = RforcD.dVsecCentZ1;
		pe.z = RforcD.dVsecCentZ2;
	}

	pss = ps; pss.z += dVal1 * dCutLineAdjustFactor;
	pee = pe; pee.z += dVal2 * dCutLineAdjustFactor;

	// 가로선은 굵은 선으로, 수직선은 가는선으로 그림
	pDC->SelectObject(&pen1);
	DrawLine3DByVMode(pDC, ps, pss, gm);
	DrawLine3DByVMode(pDC, pe, pee, gm);

	pDC->SelectObject(&pen2);
	DrawLine3DByVMode(pDC, ps, pe, gm);
	DrawLine3DByVMode(pDC, pss, pee, gm);

	if(gm->m_pBDT->PFUD.bValOutput)
	{
		if(m_nRfrcdOutputPos==0)
		{
			OutputCutLineNumber(pDC,&pss,dVal1);
		}
		else if(m_nRfrcdOutputPos==1)
		{
			OutputCutLineNumber(pDC,&pee,dVal2);
		}
		else
		{
			OutputCutLineNumber(pDC,&pss,dVal1);
			OutputCutLineNumber(pDC,&pee,dVal2);
		}    
	}
}

void CForceEngine::DrawLine3DByVMode(CDC* pDC, C3DPoint& P1, C3DPoint& P2, I_GPSModel* gm)
{
	if (gm->m_bVirtualMode)
	{
		gm->m_pGPSCtrl->DrawLine3DOnClientWindow(pDC, P1, P2);
	}
	else
	{ 
		gm->m_pGPSCtrl->DrawLine3D(pDC, P1, P2);

		// Cutting Line Diagram을 별도로 Rendering 하기 위한 처리 
		gm->m_pGPSCtrl->XGL_AddLine3D_CuttingPLDiagram(P1,P2 ,gm->m_nLineWidth*1.0,gm->m_CutPlaneColor);
	}
}

double CForceEngine::GetTopZPointFromElemKList(const CArray<T_ELEM_K, T_ELEM_K>&arKeyElem)
{
	double dTopZPoint = -DBL_MAX;
	T_NODE_D NodeD;
	T_ELEM_D ElemD;
	for(int i=0; i<arKeyElem.GetSize(); i++)
	{
		if(!m_pDoc->m_pAttrCtrl->GetElem(arKeyElem[i], ElemD)) continue;
		for(int j=0; j<D_ELEM_MAXNOD; j++)
		{
			if(ElemD.elnod[j] > 0)
			{
				if(!m_pDoc->m_pAttrCtrl->GetNode(ElemD.elnod[j], NodeD)) continue; 
				if(NodeD.z > dTopZPoint) dTopZPoint = NodeD.z;
			}
		}    
	}

	return dTopZPoint;
}

BOOL CForceEngine::IsSubDomainElem(T_ELEM_K Key)
{
	return m_pDoc->m_pPostCtrl->IsSubDomainElem(Key);
}

void CForceEngine::GetWoodArmerSlabForce(T_WAMT_D& WamtMax, T_WAMT_D& WamtMin, T_WAMT_D& WamtAbs, T_SLAB_FORCE_COMPACT& SlabForce)
{
	SlabForce.initialize();

	T_WAMT_D *pWamt;
	I_GPSModel	*gm=(I_GPSModel *) m_pGPSModel;
	switch (gm->m_LoadMinMaxType) 
	{
	case LOADTYPE_NORMAL:
	case LOADTYPE_MAX:
		pWamt = &WamtMax;
		break;
	case LOADTYPE_MIN:
		pWamt = &WamtMin;
		break;
	case LOADTYPE_ALL:
		pWamt = &WamtAbs;
		break;
	}

	// Center, Node1, Node2, Node3, Node4
	// [4] : Top Dir1, Top Dir2, Bot Dir1, Bot Dir2
	// [4] : Mxx. Myy. Mxy, Wood Armer Moment
	int nPosIdx;
	if(m_dWoodArmerAngle == 0.0) // Dir1
	{
		nPosIdx = 0;
	}
	else if(m_dWoodArmerAngle == 1.0) // Dir2
	{
		nPosIdx = 1;
	}
	else ASSERT(0);

	for (int j = 0; j < 2; j++)
	{
		// j = 0:Top, 1:Bot
		SlabForce.dForce[5 * j] = pWamt->dWAMoment[0][nPosIdx + 2 * j][3]; // Center값
		for (int k = 0; k < 4; k++) // 4는 Node개수.. Node가 4개라는 보장은 없지만.. 배열의 크기가 고정이므로 다 계산함..
		{
			SlabForce.dForce[k + 1 + 5 * j] = pWamt->dWAMoment[k + 1][nPosIdx + 2 * j][3]; // 첫번째에는 Center값이 들어가기 때문에 k + 1 같은 형태가 나오는 것임
			// pWamt->dWAMoment[][][3] 에서 3은 Wood Armer Moment를 의미함
		}
	}			
}

void CForceEngine::MakeIsolationForceDataList()
{
	//////////////////////////////////////////////////////////////////////////////////////////
	// Isolation GB 2022.5.31 - xuezc                                                       //
	// NLNK Force																			//
	//////////////////////////////////////////////////////////////////////////////////////////

	I_GPSModel	*gm = (I_GPSModel *)m_pGPSModel;
	int			node_num;
	double		max_force = -DBL_MAX, min_force = DBL_MAX, len;
	BOOL		has_content = FALSE;
	T_NLNK_K	nlnk_key;
	T_STEK_D	Stek;
	if (!gm->m_bLoadDataSet)return;
	gm->m_pMyView->BeginWaitCursor();
	//m_nLgdMaxValKey = 0;
	//m_nLgdMinValKey = 0;
	m_dMaxValue = -DBL_MAX;
	m_dMinValue = DBL_MAX;

	node_num = gm->m_NKeyListActive.GetSize();
	CMap<T_NODE_K, T_NODE_K, bool, bool> mapNodeExist;
	for (int i = 0; i < node_num; i++)
	{
		mapNodeExist[gm->m_NKeyListActive[i]] = true;
	}
	CArray<T_NLNK_K, T_NLNK_K> aNlnkK;
	T_NLNK_D NlnkD;
	m_pDoc->m_pAttrCtrl->GetNlnkKeyList(aNlnkK);

	for (int i = 0; i < aNlnkK.GetSize(); i++)
	{
		nlnk_key = aNlnkK[i];
		if (!m_pDoc->m_pAttrCtrl->GetNlnk(aNlnkK[i], NlnkD))
		{
			ASSERT(FALSE);
			continue;
		}
		if (!gm->m_pGPSCtrl->IsActiveNode(NlnkD.Node1))continue;
		if (!gm->m_pGPSCtrl->IsActiveNode(NlnkD.Node2))continue;
		if (!mapNodeExist.PLookup(NlnkD.Node1) && !mapNodeExist.PLookup(NlnkD.Node2))
			continue;
		if (gm->m_LoadMinMaxType == LOADTYPE_NORMAL || gm->m_LoadMinMaxType == LOADTYPE_MAX)
			m_pDoc->m_pPostCtrl->GetNlnkNew(aNlnkK[i], &Stek, 0, 0);
		else if (gm->m_LoadMinMaxType == LOADTYPE_MIN)
			m_pDoc->m_pPostCtrl->GetNlnkNew(aNlnkK[i], 0, &Stek, 0);
		else if (gm->m_LoadMinMaxType == LOADTYPE_ALL)
			m_pDoc->m_pPostCtrl->GetNlnkNew(aNlnkK[i], 0, 0, &Stek);
		else
		{
			ASSERT(FALSE);
			continue;
		}
		len = CalcIsolataionForceValue(Stek);
		if(len > DBL_MAX || len < -DBL_MAX)
			continue;
		if (len == 0.0)continue;

		if (len > max_force) { max_force = len; gm->m_nLgdMaxValKey = nlnk_key; }
		if (len < min_force) { min_force = len; gm->m_nLgdMinValKey = nlnk_key; }
		if (len > m_dMaxValue) { m_dMaxValue = len; gm->m_nLgdMaxValKey = nlnk_key; }
		if (len < m_dMinValue) { m_dMinValue = len; gm->m_nLgdMinValKey = nlnk_key; }

		has_content = TRUE;
		//m_IsolationNlnkKeyList.Add(nlnk_key);
		m_mapNForcData.SetAt(aNlnkK[i],Stek);
	}

	if (!has_content)
	{
		max_force = min_force = 0.0;
		gm->m_nLgdMaxValKey = 0;
		gm->m_nLgdMinValKey = 0;
	}

	if (!m_pContourEngine)m_pContourEngine = new CContourEngine(min_force, max_force);
	else m_pContourEngine->MakeRankMap(min_force, max_force);

	gm->m_pMyView->EndWaitCursor();

	//m_bIsolationDataSet = TRUE;
}

double CForceEngine::CalcIsolataionForceValue(T_STEK_D& stek_d)
{
	if (m_BForcComponent >= 0 && m_BForcComponent < 6)
		return (stek_d.dblForce[0][m_BForcComponent] + stek_d.dblForce[1][m_BForcComponent]) / 2.0;
	return 0.0;
}

#if defined(__OLD_OUTPUT_VALUE)
void CForceEngine::OutputNForcNumbers(CDC *pDC)
{
	DECLARE_GPSMD();
	DECLARE_DPTTX();
	DECLARE_DPTDR();

	int		node_num;
	double	dvalue;
	//fl_bak = gm->m_DOPT.DR.m_bFrameLine;
	//gm->m_DOPT.DR.m_bFrameLine = TRUE;
	TCHAR		fmt_str[10], text_str[512];
	CPoint		text_p, node_2d_i, node_2d_j;
	C3DPoint	node3D_i, node3D_j, DrawPoint;
	CFont	ft, *old_ft;
	if (gm->m_DOPT.TX.m_bNumberOpaque)
		pDC->SetBkMode(OPAQUE);
	else
		pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(pTX->m_NumberTextColorC);
	pDC->SetBkColor(pTX->m_NumberBackCol);
	pDC->SetTextAlign(TA_LEFT | TA_BOTTOM);
	gm->SetNumberFontNodeOrientation(0);
	ft.CreatePointFontIndirect(&gm->m_NumberFont, pDC);
	old_ft = (CFont *)pDC->SelectObject(&ft);
	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);
	node_num = gm->m_NKeyListActive.GetSize();
	CMap<T_NODE_K, T_NODE_K, bool, bool> mapNodeExist;
	CArray<T_NLNK_K, T_NLNK_K> aNlnkK;
	T_NLNK_D NlnkD;
	T_STEK_D StekD;
	for (int i = 0; i < node_num; i++)
	{
		mapNodeExist[gm->m_NKeyListActive[i]] = true;
	}
	m_pDoc->m_pAttrCtrl->GetNlnkKeyList(aNlnkK);
	for (int i = 0; i < aNlnkK.GetSize(); i++)
	{
		if (!m_pDoc->m_pAttrCtrl->GetNlnk(aNlnkK[i], NlnkD))
		{
			ASSERT(FALSE);
			continue;
		}
		if (!gm->m_pGPSCtrl->IsActiveNode(NlnkD.Node1))continue;
		if (!gm->m_pGPSCtrl->IsActiveNode(NlnkD.Node2))continue;
		gm->RE_GetLabelPosNodeByKey(NlnkD.Node1, &node3D_i);
		gm->RE_GetLabelPosNodeByKey(NlnkD.Node2, &node3D_j);
		if (gm->m_bVirtualMode) 
		{
			node_2d_i = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_i);
			node_2d_j = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_j);
		}
		else 
		{
			node_2d_i = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_i);
			node_2d_j = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_j);
		}
		text_p.x = (int)((node_2d_i.x + node_2d_j.x) / 2.0);
		text_p.y = (int)((node_2d_i.y + node_2d_j.y) / 2.0);
		if(!m_mapNForcData.Lookup(aNlnkK[i], StekD))
			continue;
		dvalue = (StekD.dblForce[0][m_BForcComponent] + StekD.dblForce[1][m_BForcComponent]) / 2.0;
		_stprintf(text_str, fmt_str, dvalue);
		pDC->TextOut(text_p.x, text_p.y, text_str);
	}
	pDC->SelectObject(old_ft);
	ft.DeleteObject();
	//gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}
#else
void CForceEngine::OutputNForcNumbers(CDC *pDC)
{
	DECLARE_GPSMD();
	DECLARE_DPTTX();
	DECLARE_DPTDR();

	int		node_num;
	double	dvalue;
	//fl_bak = gm->m_DOPT.DR.m_bFrameLine;
	//gm->m_DOPT.DR.m_bFrameLine = TRUE;
	TCHAR		fmt_str[10], text_str[512];
	CPoint		text_p, node_2d_i, node_2d_j;
	C3DPoint	node3D_i, node3D_j, DrawPoint;
	
	GPostTextOut TextOutModel;
	TextOutModel.StartNForceVal();
	TextOutModel.SetDC(pDC);
	TextOutModel.SettingNForce(gm);

	if (gm->m_DOPT.TX.m_bNumberExponent)
		_stprintf(fmt_str, _T(" %s%de "), _T("%."), gm->m_NumberDecimalPoint);
	else
		_stprintf(fmt_str, _T(" %s%df "), _T("%."), gm->m_NumberDecimalPoint);
	node_num = gm->m_NKeyListActive.GetSize();
	CMap<T_NODE_K, T_NODE_K, bool, bool> mapNodeExist;
	CArray<T_NLNK_K, T_NLNK_K> aNlnkK;
	T_NLNK_D NlnkD;
	T_STEK_D StekD;
	for (int i = 0; i < node_num; i++)
	{
		mapNodeExist[gm->m_NKeyListActive[i]] = true;
	}
	m_pDoc->m_pAttrCtrl->GetNlnkKeyList(aNlnkK);
	for (int i = 0; i < aNlnkK.GetSize(); i++)
	{
		if (!m_pDoc->m_pAttrCtrl->GetNlnk(aNlnkK[i], NlnkD))
		{
			ASSERT(FALSE);
			continue;
		}
		if (!gm->m_pGPSCtrl->IsActiveNode(NlnkD.Node1))continue;
		if (!gm->m_pGPSCtrl->IsActiveNode(NlnkD.Node2))continue;
		gm->RE_GetLabelPosNodeByKey(NlnkD.Node1, &node3D_i);
		gm->RE_GetLabelPosNodeByKey(NlnkD.Node2, &node3D_j);
		if (gm->m_bVirtualMode)
		{
			node_2d_i = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_i);
			node_2d_j = gm->m_pGPSCtrl->GetWorldToWindowP2D(node3D_j);
		}
		else
		{
			node_2d_i = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_i);
			node_2d_j = gm->m_pGPSCtrl->GetWorldToMemDCP2D(node3D_j);
		}
		text_p.x = (int)((node_2d_i.x + node_2d_j.x) / 2.0);
		text_p.y = (int)((node_2d_i.y + node_2d_j.y) / 2.0);
		if (!m_mapNForcData.Lookup(aNlnkK[i], StekD))
			continue;
		dvalue = (StekD.dblForce[0][m_BForcComponent] + StekD.dblForce[1][m_BForcComponent]) / 2.0;
		_stprintf(text_str, fmt_str, dvalue);
		TextOutModel.TextOutNForce(text_p.x, text_p.y, text_str);
	}
	TextOutModel.EndNForceVal();
	//gm->m_DOPT.DR.m_bFrameLine = fl_bak;
}
#endif